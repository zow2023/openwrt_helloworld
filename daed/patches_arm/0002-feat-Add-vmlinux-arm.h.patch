From 5fd47c8af9d93abdb7f5df7ce31150c9978ec580 Mon Sep 17 00:00:00 2001
From: sbwml <admin@cooluc.com>
Date: Mon, 2 Dec 2024 21:10:04 +0800
Subject: [PATCH 2/2] feat: Add vmlinux-arm.h

Signed-off-by: sbwml <admin@cooluc.com>
---
 vmlinux-arm.h | 84719 ++++++++++++++++++++++++++++++++++++++++++++++++
 vmlinux.h     |     2 +
 2 files changed, 84721 insertions(+)
 create mode 100644 vmlinux-arm.h

--- /dev/null
+++ b/dae-core/trace/kern/headers/vmlinux-arm.h
@@ -0,0 +1,84719 @@
+// Code generated by bpftool on Linux 6.12; DO NOT EDIT.
+
+#ifndef __VMLINUX_H__
+#define __VMLINUX_H__
+
+#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
+#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)
+#endif
+
+typedef signed char __s8;
+
+typedef unsigned char __u8;
+
+typedef short int __s16;
+
+typedef short unsigned int __u16;
+
+typedef int __s32;
+
+typedef unsigned int __u32;
+
+typedef long long int __s64;
+
+typedef long long unsigned int __u64;
+
+typedef __s8 s8;
+
+typedef __u8 u8;
+
+typedef __u16 u16;
+
+typedef __s32 s32;
+
+typedef __u32 u32;
+
+typedef __s64 s64;
+
+typedef __u64 u64;
+
+enum {
+	false = 0,
+	true = 1,
+};
+
+typedef long int __kernel_long_t;
+
+typedef long unsigned int __kernel_ulong_t;
+
+typedef int __kernel_pid_t;
+
+typedef unsigned int __kernel_uid32_t;
+
+typedef unsigned int __kernel_gid32_t;
+
+typedef unsigned int __kernel_size_t;
+
+typedef int __kernel_ssize_t;
+
+typedef long long int __kernel_loff_t;
+
+typedef long long int __kernel_time64_t;
+
+typedef __kernel_long_t __kernel_clock_t;
+
+typedef int __kernel_timer_t;
+
+typedef int __kernel_clockid_t;
+
+typedef unsigned int __poll_t;
+
+typedef u32 __kernel_dev_t;
+
+typedef __kernel_dev_t dev_t;
+
+typedef short unsigned int umode_t;
+
+typedef __kernel_pid_t pid_t;
+
+typedef __kernel_clockid_t clockid_t;
+
+typedef _Bool bool;
+
+typedef __kernel_uid32_t uid_t;
+
+typedef __kernel_gid32_t gid_t;
+
+typedef __kernel_loff_t loff_t;
+
+typedef __kernel_size_t size_t;
+
+typedef __kernel_ssize_t ssize_t;
+
+typedef s32 int32_t;
+
+typedef u32 uint32_t;
+
+typedef s64 ktime_t;
+
+typedef u64 sector_t;
+
+typedef u64 blkcnt_t;
+
+typedef unsigned int gfp_t;
+
+typedef unsigned int fmode_t;
+
+typedef u32 phys_addr_t;
+
+typedef struct {
+	int counter;
+} atomic_t;
+
+struct list_head {
+	struct list_head *next;
+	struct list_head *prev;
+};
+
+struct hlist_node;
+
+struct hlist_head {
+	struct hlist_node *first;
+};
+
+struct hlist_node {
+	struct hlist_node *next;
+	struct hlist_node **pprev;
+};
+
+struct callback_head {
+	struct callback_head *next;
+	void (*func)(struct callback_head *);
+};
+
+struct pt_regs {
+	long unsigned int uregs[18];
+};
+
+struct arch_hw_breakpoint_ctrl {
+	u32 __reserved: 9;
+	u32 mismatch: 1;
+	short: 6;
+	char: 3;
+	u32 len: 8;
+	u32 type: 2;
+	u32 privilege: 2;
+	u32 enabled: 1;
+};
+
+struct arch_hw_breakpoint {
+	u32 address;
+	u32 trigger;
+	struct arch_hw_breakpoint_ctrl step_ctrl;
+	struct arch_hw_breakpoint_ctrl ctrl;
+};
+
+struct perf_event;
+
+struct debug_info {
+	struct perf_event *hbp[32];
+};
+
+struct rb_node {
+	long unsigned int __rb_parent_color;
+	struct rb_node *rb_right;
+	struct rb_node *rb_left;
+};
+
+enum perf_event_state {
+	PERF_EVENT_STATE_DEAD = -4,
+	PERF_EVENT_STATE_EXIT = -3,
+	PERF_EVENT_STATE_ERROR = -2,
+	PERF_EVENT_STATE_OFF = -1,
+	PERF_EVENT_STATE_INACTIVE = 0,
+	PERF_EVENT_STATE_ACTIVE = 1,
+};
+
+typedef struct {
+	s64 counter;
+} atomic64_t;
+
+typedef struct {
+	atomic64_t a;
+} local64_t;
+
+struct perf_event_attr {
+	__u32 type;
+	__u32 size;
+	__u64 config;
+	union {
+		__u64 sample_period;
+		__u64 sample_freq;
+	};
+	__u64 sample_type;
+	__u64 read_format;
+	__u64 disabled: 1;
+	__u64 inherit: 1;
+	__u64 pinned: 1;
+	__u64 exclusive: 1;
+	__u64 exclude_user: 1;
+	__u64 exclude_kernel: 1;
+	__u64 exclude_hv: 1;
+	__u64 exclude_idle: 1;
+	__u64 mmap: 1;
+	__u64 comm: 1;
+	__u64 freq: 1;
+	__u64 inherit_stat: 1;
+	__u64 enable_on_exec: 1;
+	__u64 task: 1;
+	__u64 watermark: 1;
+	__u64 precise_ip: 2;
+	__u64 mmap_data: 1;
+	__u64 sample_id_all: 1;
+	__u64 exclude_host: 1;
+	__u64 exclude_guest: 1;
+	__u64 exclude_callchain_kernel: 1;
+	__u64 exclude_callchain_user: 1;
+	__u64 mmap2: 1;
+	__u64 comm_exec: 1;
+	__u64 use_clockid: 1;
+	__u64 context_switch: 1;
+	__u64 write_backward: 1;
+	__u64 namespaces: 1;
+	__u64 ksymbol: 1;
+	__u64 bpf_event: 1;
+	__u64 aux_output: 1;
+	__u64 cgroup: 1;
+	__u64 text_poke: 1;
+	__u64 build_id: 1;
+	__u64 inherit_thread: 1;
+	__u64 remove_on_exec: 1;
+	__u64 sigtrap: 1;
+	__u64 __reserved_1: 26;
+	union {
+		__u32 wakeup_events;
+		__u32 wakeup_watermark;
+	};
+	__u32 bp_type;
+	union {
+		__u64 bp_addr;
+		__u64 kprobe_func;
+		__u64 uprobe_path;
+		__u64 config1;
+	};
+	union {
+		__u64 bp_len;
+		__u64 kprobe_addr;
+		__u64 probe_offset;
+		__u64 config2;
+	};
+	__u64 branch_sample_type;
+	__u64 sample_regs_user;
+	__u32 sample_stack_user;
+	__s32 clockid;
+	__u64 sample_regs_intr;
+	__u32 aux_watermark;
+	__u16 sample_max_stack;
+	__u16 __reserved_2;
+	__u32 aux_sample_size;
+	__u32 __reserved_3;
+	__u64 sig_data;
+	__u64 config3;
+};
+
+struct hw_perf_event_extra {
+	u64 config;
+	unsigned int reg;
+	int alloc;
+	int idx;
+	long: 32;
+};
+
+struct timerqueue_node {
+	struct rb_node node;
+	long: 32;
+	ktime_t expires;
+};
+
+enum hrtimer_restart {
+	HRTIMER_NORESTART = 0,
+	HRTIMER_RESTART = 1,
+};
+
+struct hrtimer_clock_base;
+
+struct hrtimer {
+	struct timerqueue_node node;
+	ktime_t _softexpires;
+	enum hrtimer_restart (*function)(struct hrtimer *);
+	struct hrtimer_clock_base *base;
+	u8 state;
+	u8 is_rel;
+	u8 is_soft;
+	u8 is_hard;
+	long: 32;
+};
+
+struct rhash_head {
+	struct rhash_head *next;
+};
+
+struct rhlist_head {
+	struct rhash_head rhead;
+	struct rhlist_head *next;
+};
+
+struct task_struct;
+
+struct hw_perf_event {
+	union {
+		struct {
+			u64 config;
+			u64 last_tag;
+			long unsigned int config_base;
+			long unsigned int event_base;
+			int event_base_rdpmc;
+			int idx;
+			int last_cpu;
+			int flags;
+			struct hw_perf_event_extra extra_reg;
+			struct hw_perf_event_extra branch_reg;
+		};
+		struct {
+			u64 aux_config;
+		};
+		struct {
+			struct hrtimer hrtimer;
+		};
+		struct {
+			struct list_head tp_list;
+		};
+		struct {
+			u64 pwr_acc;
+			u64 ptsc;
+		};
+		struct {
+			struct arch_hw_breakpoint info;
+			struct rhlist_head bp_list;
+		};
+		struct {
+			u8 iommu_bank;
+			u8 iommu_cntr;
+			u16 padding;
+			long: 32;
+			u64 conf;
+			u64 conf1;
+		};
+	};
+	struct task_struct *target;
+	void *addr_filters;
+	long unsigned int addr_filters_gen;
+	int state;
+	local64_t prev_count;
+	u64 sample_period;
+	union {
+		struct {
+			u64 last_period;
+			local64_t period_left;
+		};
+		struct {
+			u64 saved_metric;
+			u64 saved_slots;
+		};
+	};
+	u64 interrupts_seq;
+	u64 interrupts;
+	u64 freq_time_stamp;
+	u64 freq_count_stamp;
+};
+
+typedef atomic_t atomic_long_t;
+
+struct __raw_tickets {
+	u16 owner;
+	u16 next;
+};
+
+typedef struct {
+	union {
+		u32 slock;
+		struct __raw_tickets tickets;
+	};
+} arch_spinlock_t;
+
+struct raw_spinlock {
+	arch_spinlock_t raw_lock;
+};
+
+typedef struct raw_spinlock raw_spinlock_t;
+
+struct optimistic_spin_queue {
+	atomic_t tail;
+};
+
+struct mutex {
+	atomic_long_t owner;
+	raw_spinlock_t wait_lock;
+	struct optimistic_spin_queue osq;
+	struct list_head wait_list;
+};
+
+struct spinlock {
+	union {
+		struct raw_spinlock rlock;
+	};
+};
+
+typedef struct spinlock spinlock_t;
+
+struct wait_queue_head {
+	spinlock_t lock;
+	struct list_head head;
+};
+
+typedef struct wait_queue_head wait_queue_head_t;
+
+struct llist_node {
+	struct llist_node *next;
+};
+
+struct __call_single_node {
+	struct llist_node llist;
+	union {
+		unsigned int u_flags;
+		atomic_t a_flags;
+	};
+};
+
+struct rcuwait {
+	struct task_struct *task;
+};
+
+struct irq_work {
+	struct __call_single_node node;
+	void (*func)(struct irq_work *);
+	struct rcuwait irqwait;
+};
+
+struct perf_addr_filters_head {
+	struct list_head list;
+	raw_spinlock_t lock;
+	unsigned int nr_file_filters;
+};
+
+struct perf_sample_data;
+
+typedef void (*perf_overflow_handler_t)(struct perf_event *, struct perf_sample_data *, struct pt_regs *);
+
+struct pmu;
+
+struct perf_event_context;
+
+struct perf_event_pmu_context;
+
+struct perf_buffer;
+
+struct fasync_struct;
+
+struct perf_addr_filter_range;
+
+struct pid_namespace;
+
+struct bpf_prog;
+
+struct trace_event_call;
+
+struct event_filter;
+
+struct perf_event {
+	struct list_head event_entry;
+	struct list_head sibling_list;
+	struct list_head active_list;
+	struct rb_node group_node;
+	long: 32;
+	u64 group_index;
+	struct list_head migrate_entry;
+	struct hlist_node hlist_entry;
+	struct list_head active_entry;
+	int nr_siblings;
+	int event_caps;
+	int group_caps;
+	unsigned int group_generation;
+	struct perf_event *group_leader;
+	struct pmu *pmu;
+	void *pmu_private;
+	enum perf_event_state state;
+	unsigned int attach_state;
+	long: 32;
+	local64_t count;
+	atomic64_t child_count;
+	u64 total_time_enabled;
+	u64 total_time_running;
+	u64 tstamp;
+	struct perf_event_attr attr;
+	u16 header_size;
+	u16 id_header_size;
+	u16 read_size;
+	struct hw_perf_event hw;
+	struct perf_event_context *ctx;
+	struct perf_event_pmu_context *pmu_ctx;
+	atomic_long_t refcount;
+	long: 32;
+	atomic64_t child_total_time_enabled;
+	atomic64_t child_total_time_running;
+	struct mutex child_mutex;
+	struct list_head child_list;
+	struct perf_event *parent;
+	int oncpu;
+	int cpu;
+	struct list_head owner_entry;
+	struct task_struct *owner;
+	struct mutex mmap_mutex;
+	atomic_t mmap_count;
+	struct perf_buffer *rb;
+	struct list_head rb_entry;
+	long unsigned int rcu_batches;
+	int rcu_pending;
+	wait_queue_head_t waitq;
+	struct fasync_struct *fasync;
+	unsigned int pending_wakeup;
+	unsigned int pending_kill;
+	unsigned int pending_disable;
+	long unsigned int pending_addr;
+	struct irq_work pending_irq;
+	struct irq_work pending_disable_irq;
+	struct callback_head pending_task;
+	unsigned int pending_work;
+	struct rcuwait pending_work_wait;
+	atomic_t event_limit;
+	struct perf_addr_filters_head addr_filters;
+	struct perf_addr_filter_range *addr_filter_ranges;
+	long unsigned int addr_filters_gen;
+	struct perf_event *aux_event;
+	void (*destroy)(struct perf_event *);
+	struct callback_head callback_head;
+	struct pid_namespace *ns;
+	u64 id;
+	atomic64_t lost_samples;
+	u64 (*clock)();
+	perf_overflow_handler_t overflow_handler;
+	void *overflow_handler_context;
+	struct bpf_prog *prog;
+	u64 bpf_cookie;
+	struct trace_event_call *tp_event;
+	struct event_filter *filter;
+	struct list_head sb_list;
+	__u32 orig_type;
+	long: 32;
+};
+
+struct thread_struct {
+	long unsigned int address;
+	long unsigned int trap_no;
+	long unsigned int error_code;
+	struct debug_info debug;
+};
+
+typedef int (*initcall_t)();
+
+struct lock_class_key {};
+
+struct fs_context;
+
+struct fs_parameter_spec;
+
+struct dentry;
+
+struct super_block;
+
+struct module;
+
+struct file_system_type {
+	const char *name;
+	int fs_flags;
+	int (*init_fs_context)(struct fs_context *);
+	const struct fs_parameter_spec *parameters;
+	struct dentry * (*mount)(struct file_system_type *, int, const char *, void *);
+	void (*kill_sb)(struct super_block *);
+	struct module *owner;
+	struct file_system_type *next;
+	struct hlist_head fs_supers;
+	struct lock_class_key s_lock_key;
+	struct lock_class_key s_umount_key;
+	struct lock_class_key s_vfs_rename_key;
+	struct lock_class_key s_writers_key[3];
+	struct lock_class_key i_lock_key;
+	struct lock_class_key i_mutex_key;
+	struct lock_class_key invalidate_lock_key;
+	struct lock_class_key i_mutex_dir_key;
+};
+
+struct obs_kernel_param {
+	const char *str;
+	int (*setup_func)(char *);
+	int early;
+};
+
+typedef struct {
+	u32 lock;
+} arch_rwlock_t;
+
+struct lockdep_map {};
+
+struct ratelimit_state {
+	raw_spinlock_t lock;
+	int interval;
+	int burst;
+	int printed;
+	int missed;
+	unsigned int flags;
+	long unsigned int begin;
+};
+
+typedef unsigned int fop_flags_t;
+
+typedef void *fl_owner_t;
+
+struct file;
+
+struct kiocb;
+
+struct iov_iter;
+
+struct io_comp_batch;
+
+struct dir_context;
+
+struct poll_table_struct;
+
+struct vm_area_struct;
+
+struct inode;
+
+struct file_lock;
+
+struct pipe_inode_info;
+
+struct file_lease;
+
+struct seq_file;
+
+struct io_uring_cmd;
+
+struct file_operations {
+	struct module *owner;
+	fop_flags_t fop_flags;
+	loff_t (*llseek)(struct file *, loff_t, int);
+	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
+	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
+	ssize_t (*read_iter)(struct kiocb *, struct iov_iter *);
+	ssize_t (*write_iter)(struct kiocb *, struct iov_iter *);
+	int (*iopoll)(struct kiocb *, struct io_comp_batch *, unsigned int);
+	int (*iterate_shared)(struct file *, struct dir_context *);
+	__poll_t (*poll)(struct file *, struct poll_table_struct *);
+	long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
+	long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
+	int (*mmap)(struct file *, struct vm_area_struct *);
+	int (*open)(struct inode *, struct file *);
+	int (*flush)(struct file *, fl_owner_t);
+	int (*release)(struct inode *, struct file *);
+	int (*fsync)(struct file *, loff_t, loff_t, int);
+	int (*fasync)(int, struct file *, int);
+	int (*lock)(struct file *, int, struct file_lock *);
+	long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
+	int (*check_flags)(int);
+	int (*flock)(struct file *, int, struct file_lock *);
+	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
+	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
+	void (*splice_eof)(struct file *);
+	int (*setlease)(struct file *, int, struct file_lease **, void **);
+	long int (*fallocate)(struct file *, int, loff_t, loff_t);
+	void (*show_fdinfo)(struct seq_file *, struct file *);
+	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
+	loff_t (*remap_file_range)(struct file *, loff_t, struct file *, loff_t, loff_t, unsigned int);
+	int (*fadvise)(struct file *, loff_t, loff_t, int);
+	int (*uring_cmd)(struct io_uring_cmd *, unsigned int);
+	int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *, unsigned int);
+};
+
+struct static_call_key {
+	void *func;
+};
+
+struct bug_entry {
+	long unsigned int bug_addr;
+	short unsigned int flags;
+};
+
+enum timespec_type {
+	TT_NONE = 0,
+	TT_NATIVE = 1,
+	TT_COMPAT = 2,
+};
+
+struct __kernel_timespec {
+	__kernel_time64_t tv_sec;
+	long long int tv_nsec;
+};
+
+typedef s32 old_time32_t;
+
+struct old_timespec32 {
+	old_time32_t tv_sec;
+	s32 tv_nsec;
+};
+
+struct pollfd {
+	int fd;
+	short int events;
+	short int revents;
+};
+
+struct restart_block {
+	long unsigned int arch_data;
+	long int (*fn)(struct restart_block *);
+	union {
+		struct {
+			u32 *uaddr;
+			u32 val;
+			u32 flags;
+			u32 bitset;
+			u64 time;
+			u32 *uaddr2;
+			long: 32;
+		} futex;
+		struct {
+			clockid_t clockid;
+			enum timespec_type type;
+			union {
+				struct __kernel_timespec *rmtp;
+				struct old_timespec32 *compat_rmtp;
+			};
+			long: 32;
+			u64 expires;
+		} nanosleep;
+		struct {
+			struct pollfd *ufds;
+			int nfds;
+			int has_timeout;
+			long unsigned int tv_sec;
+			long unsigned int tv_nsec;
+		} poll;
+	};
+};
+
+struct cpu_context_save {
+	__u32 r4;
+	__u32 r5;
+	__u32 r6;
+	__u32 r7;
+	__u32 r8;
+	__u32 r9;
+	__u32 sl;
+	__u32 fp;
+	__u32 sp;
+	__u32 pc;
+	__u32 extra[2];
+};
+
+struct fp_hard_struct {
+	unsigned int save[35];
+};
+
+struct fp_soft_struct {
+	unsigned int save[35];
+};
+
+union fp_state {
+	struct fp_hard_struct hard;
+	struct fp_soft_struct soft;
+};
+
+struct vfp_hard_struct {
+	__u64 fpregs[16];
+	__u32 fpexc;
+	__u32 fpscr;
+	__u32 fpinst;
+	__u32 fpinst2;
+	__u32 cpu;
+	long: 32;
+};
+
+union vfp_state {
+	struct vfp_hard_struct hard;
+};
+
+struct thread_info {
+	long unsigned int flags;
+	int preempt_count;
+	__u32 cpu;
+	__u32 cpu_domain;
+	struct cpu_context_save cpu_context;
+	__u32 abi_syscall;
+	long unsigned int tp_value[2];
+	long: 32;
+	union fp_state fpstate;
+	long: 32;
+	union vfp_state vfpstate;
+};
+
+struct refcount_struct {
+	atomic_t refs;
+};
+
+typedef struct refcount_struct refcount_t;
+
+struct load_weight {
+	long unsigned int weight;
+	u32 inv_weight;
+};
+
+struct sched_avg {
+	u64 last_update_time;
+	u64 load_sum;
+	u64 runnable_sum;
+	u32 util_sum;
+	u32 period_contrib;
+	long unsigned int load_avg;
+	long unsigned int runnable_avg;
+	long unsigned int util_avg;
+	unsigned int util_est;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct cfs_rq;
+
+struct sched_entity {
+	struct load_weight load;
+	struct rb_node run_node;
+	long: 32;
+	u64 deadline;
+	u64 min_vruntime;
+	u64 min_slice;
+	struct list_head group_node;
+	unsigned char on_rq;
+	unsigned char sched_delayed;
+	unsigned char rel_deadline;
+	unsigned char custom_slice;
+	long: 32;
+	u64 exec_start;
+	u64 sum_exec_runtime;
+	u64 prev_sum_exec_runtime;
+	u64 vruntime;
+	s64 vlag;
+	u64 slice;
+	u64 nr_migrations;
+	int depth;
+	struct sched_entity *parent;
+	struct cfs_rq *cfs_rq;
+	struct cfs_rq *my_q;
+	long unsigned int runnable_weight;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct sched_avg avg;
+};
+
+struct rt_rq;
+
+struct sched_rt_entity {
+	struct list_head run_list;
+	long unsigned int timeout;
+	long unsigned int watchdog_stamp;
+	unsigned int time_slice;
+	short unsigned int on_rq;
+	short unsigned int on_list;
+	struct sched_rt_entity *back;
+	struct sched_rt_entity *parent;
+	struct rt_rq *rt_rq;
+	struct rt_rq *my_q;
+};
+
+struct sched_dl_entity;
+
+typedef bool (*dl_server_has_tasks_f)(struct sched_dl_entity *);
+
+typedef struct task_struct * (*dl_server_pick_f)(struct sched_dl_entity *);
+
+struct rq;
+
+struct sched_dl_entity {
+	struct rb_node rb_node;
+	long: 32;
+	u64 dl_runtime;
+	u64 dl_deadline;
+	u64 dl_period;
+	u64 dl_bw;
+	u64 dl_density;
+	s64 runtime;
+	u64 deadline;
+	unsigned int flags;
+	unsigned int dl_throttled: 1;
+	unsigned int dl_yielded: 1;
+	unsigned int dl_non_contending: 1;
+	unsigned int dl_overrun: 1;
+	unsigned int dl_server: 1;
+	unsigned int dl_defer: 1;
+	unsigned int dl_defer_armed: 1;
+	unsigned int dl_defer_running: 1;
+	struct hrtimer dl_timer;
+	struct hrtimer inactive_timer;
+	struct rq *rq;
+	dl_server_has_tasks_f server_has_tasks;
+	dl_server_pick_f server_pick_task;
+	struct sched_dl_entity *pi_se;
+};
+
+struct sched_statistics {};
+
+struct cpumask {
+	long unsigned int bits[1];
+};
+
+typedef struct cpumask cpumask_t;
+
+union rcu_special {
+	struct {
+		u8 blocked;
+		u8 need_qs;
+		u8 exp_hint;
+		u8 need_mb;
+	} b;
+	u32 s;
+};
+
+struct sched_info {};
+
+struct plist_node {
+	int prio;
+	struct list_head prio_list;
+	struct list_head node_list;
+};
+
+struct prev_cputime {
+	u64 utime;
+	u64 stime;
+	raw_spinlock_t lock;
+	long: 32;
+};
+
+struct rb_root {
+	struct rb_node *rb_node;
+};
+
+struct rb_root_cached {
+	struct rb_root rb_root;
+	struct rb_node *rb_leftmost;
+};
+
+struct timerqueue_head {
+	struct rb_root_cached rb_root;
+};
+
+struct posix_cputimer_base {
+	u64 nextevt;
+	struct timerqueue_head tqhead;
+};
+
+struct posix_cputimers {
+	struct posix_cputimer_base bases[3];
+	unsigned int timers_active;
+	unsigned int expiry_active;
+};
+
+struct sem_undo_list;
+
+struct sysv_sem {
+	struct sem_undo_list *undo_list;
+};
+
+struct sysv_shm {
+	struct list_head shm_clist;
+};
+
+typedef struct {
+	long unsigned int sig[2];
+} sigset_t;
+
+struct sigpending {
+	struct list_head list;
+	sigset_t signal;
+};
+
+struct seccomp_filter;
+
+struct seccomp {
+	int mode;
+	atomic_t filter_count;
+	struct seccomp_filter *filter;
+};
+
+struct syscall_user_dispatch {};
+
+struct wake_q_node {
+	struct wake_q_node *next;
+};
+
+struct task_io_accounting {};
+
+typedef struct {
+	long unsigned int bits[1];
+} nodemask_t;
+
+struct seqcount {
+	unsigned int sequence;
+};
+
+typedef struct seqcount seqcount_t;
+
+struct seqcount_spinlock {
+	seqcount_t seqcount;
+};
+
+typedef struct seqcount_spinlock seqcount_spinlock_t;
+
+struct tlbflush_unmap_batch {};
+
+struct page;
+
+struct page_frag {
+	struct page *page;
+	__u16 offset;
+	__u16 size;
+};
+
+typedef u32 pteval_t;
+
+typedef pteval_t pte_t;
+
+struct kmap_ctrl {
+	int idx;
+	pte_t pteval[16];
+};
+
+struct timer_list {
+	struct hlist_node entry;
+	long unsigned int expires;
+	void (*function)(struct timer_list *);
+	u32 flags;
+};
+
+struct llist_head {
+	struct llist_node *first;
+};
+
+struct sched_class;
+
+struct task_group;
+
+struct mm_struct;
+
+struct address_space;
+
+struct pid;
+
+struct completion;
+
+struct cred;
+
+struct key;
+
+struct nameidata;
+
+struct fs_struct;
+
+struct files_struct;
+
+struct nsproxy;
+
+struct signal_struct;
+
+struct sighand_struct;
+
+struct rt_mutex_waiter;
+
+struct bio_list;
+
+struct blk_plug;
+
+struct reclaim_state;
+
+struct io_context;
+
+struct capture_control;
+
+struct kernel_siginfo;
+
+typedef struct kernel_siginfo kernel_siginfo_t;
+
+struct css_set;
+
+struct robust_list_head;
+
+struct futex_pi_state;
+
+struct mem_cgroup;
+
+struct obj_cgroup;
+
+struct gendisk;
+
+struct bpf_local_storage;
+
+struct bpf_run_ctx;
+
+struct bpf_net_context;
+
+struct task_struct {
+	struct thread_info thread_info;
+	unsigned int __state;
+	unsigned int saved_state;
+	void *stack;
+	refcount_t usage;
+	unsigned int flags;
+	unsigned int ptrace;
+	int on_cpu;
+	struct __call_single_node wake_entry;
+	unsigned int wakee_flips;
+	long unsigned int wakee_flip_decay_ts;
+	struct task_struct *last_wakee;
+	int recent_used_cpu;
+	int wake_cpu;
+	int on_rq;
+	int prio;
+	int static_prio;
+	int normal_prio;
+	unsigned int rt_priority;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct sched_entity se;
+	struct sched_rt_entity rt;
+	struct sched_dl_entity dl;
+	struct sched_dl_entity *dl_server;
+	const struct sched_class *sched_class;
+	struct task_group *sched_task_group;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct sched_statistics stats;
+	unsigned int policy;
+	long unsigned int max_allowed_capacity;
+	int nr_cpus_allowed;
+	const cpumask_t *cpus_ptr;
+	cpumask_t *user_cpus_ptr;
+	cpumask_t cpus_mask;
+	void *migration_pending;
+	short unsigned int migration_disabled;
+	short unsigned int migration_flags;
+	int trc_reader_nesting;
+	int trc_ipi_to_cpu;
+	union rcu_special trc_reader_special;
+	struct list_head trc_holdout_list;
+	struct list_head trc_blkd_node;
+	int trc_blkd_cpu;
+	struct sched_info sched_info;
+	struct list_head tasks;
+	struct plist_node pushable_tasks;
+	struct rb_node pushable_dl_tasks;
+	struct mm_struct *mm;
+	struct mm_struct *active_mm;
+	struct address_space *faults_disabled_mapping;
+	int exit_state;
+	int exit_code;
+	int exit_signal;
+	int pdeath_signal;
+	long unsigned int jobctl;
+	unsigned int personality;
+	unsigned int sched_reset_on_fork: 1;
+	unsigned int sched_contributes_to_load: 1;
+	unsigned int sched_migrated: 1;
+	long: 29;
+	unsigned int sched_remote_wakeup: 1;
+	unsigned int sched_rt_mutex: 1;
+	unsigned int in_execve: 1;
+	unsigned int in_iowait: 1;
+	unsigned int in_lru_fault: 1;
+	unsigned int no_cgroup_migration: 1;
+	unsigned int frozen: 1;
+	unsigned int use_memdelay: 1;
+	unsigned int in_eventfd: 1;
+	long unsigned int atomic_flags;
+	struct restart_block restart_block;
+	pid_t pid;
+	pid_t tgid;
+	long unsigned int stack_canary;
+	struct task_struct *real_parent;
+	struct task_struct *parent;
+	struct list_head children;
+	struct list_head sibling;
+	struct task_struct *group_leader;
+	struct list_head ptraced;
+	struct list_head ptrace_entry;
+	struct pid *thread_pid;
+	struct hlist_node pid_links[4];
+	struct list_head thread_node;
+	struct completion *vfork_done;
+	int *set_child_tid;
+	int *clear_child_tid;
+	void *worker_private;
+	long: 32;
+	u64 utime;
+	u64 stime;
+	u64 gtime;
+	struct prev_cputime prev_cputime;
+	long unsigned int nvcsw;
+	long unsigned int nivcsw;
+	u64 start_time;
+	u64 start_boottime;
+	long unsigned int min_flt;
+	long unsigned int maj_flt;
+	struct posix_cputimers posix_cputimers;
+	const struct cred *ptracer_cred;
+	const struct cred *real_cred;
+	const struct cred *cred;
+	struct key *cached_requested_key;
+	char comm[16];
+	struct nameidata *nameidata;
+	struct sysv_sem sysvsem;
+	struct sysv_shm sysvshm;
+	struct fs_struct *fs;
+	struct files_struct *files;
+	struct nsproxy *nsproxy;
+	struct signal_struct *signal;
+	struct sighand_struct *sighand;
+	sigset_t blocked;
+	sigset_t real_blocked;
+	sigset_t saved_sigmask;
+	struct sigpending pending;
+	long unsigned int sas_ss_sp;
+	size_t sas_ss_size;
+	unsigned int sas_ss_flags;
+	struct callback_head *task_works;
+	struct seccomp seccomp;
+	struct syscall_user_dispatch syscall_dispatch;
+	u64 parent_exec_id;
+	u64 self_exec_id;
+	spinlock_t alloc_lock;
+	raw_spinlock_t pi_lock;
+	struct wake_q_node wake_q;
+	struct rb_root_cached pi_waiters;
+	struct task_struct *pi_top_task;
+	struct rt_mutex_waiter *pi_blocked_on;
+	void *journal_info;
+	struct bio_list *bio_list;
+	struct blk_plug *plug;
+	struct reclaim_state *reclaim_state;
+	struct io_context *io_context;
+	struct capture_control *capture_control;
+	long unsigned int ptrace_message;
+	kernel_siginfo_t *last_siginfo;
+	struct task_io_accounting ioac;
+	nodemask_t mems_allowed;
+	seqcount_spinlock_t mems_allowed_seq;
+	int cpuset_mem_spread_rotor;
+	struct css_set *cgroups;
+	struct list_head cg_list;
+	struct robust_list_head *robust_list;
+	struct list_head pi_state_list;
+	struct futex_pi_state *pi_state_cache;
+	struct mutex futex_exit_mutex;
+	unsigned int futex_state;
+	u8 perf_recursion[4];
+	struct perf_event_context *perf_event_ctxp;
+	struct mutex perf_event_mutex;
+	struct list_head perf_event_list;
+	struct tlbflush_unmap_batch tlb_ubc;
+	struct pipe_inode_info *splice_pipe;
+	struct page_frag task_frag;
+	int nr_dirtied;
+	int nr_dirtied_pause;
+	long unsigned int dirty_paused_when;
+	u64 timer_slack_ns;
+	u64 default_timer_slack_ns;
+	long unsigned int trace_recursion;
+	unsigned int memcg_nr_pages_over_high;
+	struct mem_cgroup *active_memcg;
+	struct obj_cgroup *objcg;
+	struct gendisk *throttle_disk;
+	struct kmap_ctrl kmap_ctrl;
+	struct callback_head rcu;
+	refcount_t rcu_users;
+	int pagefault_disabled;
+	struct task_struct *oom_reaper_list;
+	struct timer_list oom_reaper_timer;
+	refcount_t stack_refcount;
+	struct bpf_local_storage *bpf_storage;
+	struct bpf_run_ctx *bpf_ctx;
+	struct bpf_net_context *bpf_net_context;
+	struct llist_head kretprobe_instances;
+	struct thread_struct thread;
+};
+
+struct page_pool;
+
+struct dev_pagemap;
+
+struct page {
+	long unsigned int flags;
+	union {
+		struct {
+			union {
+				struct list_head lru;
+				struct {
+					void *__filler;
+					unsigned int mlock_count;
+				};
+				struct list_head buddy_list;
+				struct list_head pcp_list;
+			};
+			struct address_space *mapping;
+			union {
+				long unsigned int index;
+				long unsigned int share;
+			};
+			long unsigned int private;
+		};
+		struct {
+			long unsigned int pp_magic;
+			struct page_pool *pp;
+			long unsigned int _pp_mapping_pad;
+			long unsigned int dma_addr;
+			atomic_long_t pp_ref_count;
+		};
+		struct {
+			long unsigned int compound_head;
+		};
+		struct {
+			struct dev_pagemap *pgmap;
+			void *zone_device_data;
+		};
+		struct callback_head callback_head;
+	};
+	union {
+		unsigned int page_type;
+		atomic_t _mapcount;
+	};
+	atomic_t _refcount;
+	long unsigned int memcg_data;
+};
+
+typedef pteval_t pgprot_t;
+
+typedef long unsigned int vm_flags_t;
+
+struct vm_userfaultfd_ctx {};
+
+struct vma_lock;
+
+struct anon_vma;
+
+struct vm_operations_struct;
+
+struct vm_area_struct {
+	union {
+		struct {
+			long unsigned int vm_start;
+			long unsigned int vm_end;
+		};
+		struct callback_head vm_rcu;
+	};
+	struct mm_struct *vm_mm;
+	pgprot_t vm_page_prot;
+	union {
+		const vm_flags_t vm_flags;
+		vm_flags_t __vm_flags;
+	};
+	bool detached;
+	int vm_lock_seq;
+	struct vma_lock *vm_lock;
+	struct {
+		struct rb_node rb;
+		long unsigned int rb_subtree_last;
+	} shared;
+	struct list_head anon_vma_chain;
+	struct anon_vma *anon_vma;
+	const struct vm_operations_struct *vm_ops;
+	long unsigned int vm_pgoff;
+	struct file *vm_file;
+	void *vm_private_data;
+	atomic_long_t swap_readahead_info;
+	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
+};
+
+typedef u32 pmdval_t;
+
+typedef pmdval_t pmd_t;
+
+typedef pmdval_t pgd_t[2];
+
+typedef struct page *pgtable_t;
+
+typedef struct cpumask cpumask_var_t[1];
+
+enum {
+	___GFP_DMA_BIT = 0,
+	___GFP_HIGHMEM_BIT = 1,
+	___GFP_DMA32_BIT = 2,
+	___GFP_MOVABLE_BIT = 3,
+	___GFP_RECLAIMABLE_BIT = 4,
+	___GFP_HIGH_BIT = 5,
+	___GFP_IO_BIT = 6,
+	___GFP_FS_BIT = 7,
+	___GFP_ZERO_BIT = 8,
+	___GFP_UNUSED_BIT = 9,
+	___GFP_DIRECT_RECLAIM_BIT = 10,
+	___GFP_KSWAPD_RECLAIM_BIT = 11,
+	___GFP_WRITE_BIT = 12,
+	___GFP_NOWARN_BIT = 13,
+	___GFP_RETRY_MAYFAIL_BIT = 14,
+	___GFP_NOFAIL_BIT = 15,
+	___GFP_NORETRY_BIT = 16,
+	___GFP_MEMALLOC_BIT = 17,
+	___GFP_COMP_BIT = 18,
+	___GFP_NOMEMALLOC_BIT = 19,
+	___GFP_HARDWALL_BIT = 20,
+	___GFP_THISNODE_BIT = 21,
+	___GFP_ACCOUNT_BIT = 22,
+	___GFP_ZEROTAGS_BIT = 23,
+	___GFP_NO_OBJ_EXT_BIT = 24,
+	___GFP_LAST_BIT = 25,
+};
+
+typedef struct {
+	arch_rwlock_t raw_lock;
+} rwlock_t;
+
+struct hlist_bl_node;
+
+struct hlist_bl_head {
+	struct hlist_bl_node *first;
+};
+
+struct hlist_bl_node {
+	struct hlist_bl_node *next;
+	struct hlist_bl_node **pprev;
+};
+
+struct cacheline_padding {
+	char x[0];
+};
+
+struct seqcount_raw_spinlock {
+	seqcount_t seqcount;
+};
+
+typedef struct seqcount_raw_spinlock seqcount_raw_spinlock_t;
+
+typedef struct {
+	seqcount_spinlock_t seqcount;
+	spinlock_t lock;
+} seqlock_t;
+
+struct lockref {
+	union {
+		__u64 lock_count;
+		struct {
+			spinlock_t lock;
+			int count;
+		};
+	};
+};
+
+struct qstr {
+	union {
+		struct {
+			u32 hash;
+			u32 len;
+		};
+		u64 hash_len;
+	};
+	const unsigned char *name;
+	long: 32;
+};
+
+struct dentry_operations;
+
+struct dentry {
+	unsigned int d_flags;
+	seqcount_spinlock_t d_seq;
+	struct hlist_bl_node d_hash;
+	struct dentry *d_parent;
+	long: 32;
+	struct qstr d_name;
+	struct inode *d_inode;
+	unsigned char d_iname[36];
+	const struct dentry_operations *d_op;
+	struct super_block *d_sb;
+	long unsigned int d_time;
+	void *d_fsdata;
+	struct lockref d_lockref;
+	union {
+		struct list_head d_lru;
+		wait_queue_head_t *d_wait;
+	};
+	struct hlist_node d_sib;
+	struct hlist_head d_children;
+	union {
+		struct hlist_node d_alias;
+		struct hlist_bl_node d_in_lookup_hash;
+		struct callback_head d_rcu;
+	} d_u;
+	long: 32;
+};
+
+typedef struct {
+	uid_t val;
+} kuid_t;
+
+typedef struct {
+	gid_t val;
+} kgid_t;
+
+typedef __s64 time64_t;
+
+enum rw_hint {
+	WRITE_LIFE_NOT_SET = 0,
+	WRITE_LIFE_NONE = 1,
+	WRITE_LIFE_SHORT = 2,
+	WRITE_LIFE_MEDIUM = 3,
+	WRITE_LIFE_LONG = 4,
+	WRITE_LIFE_EXTREME = 5,
+} __attribute__((mode(byte)));
+
+struct rw_semaphore {
+	atomic_long_t count;
+	atomic_long_t owner;
+	struct optimistic_spin_queue osq;
+	raw_spinlock_t wait_lock;
+	struct list_head wait_list;
+};
+
+struct xarray {
+	spinlock_t xa_lock;
+	gfp_t xa_flags;
+	void *xa_head;
+};
+
+typedef u32 errseq_t;
+
+struct address_space_operations;
+
+struct address_space {
+	struct inode *host;
+	struct xarray i_pages;
+	struct rw_semaphore invalidate_lock;
+	gfp_t gfp_mask;
+	atomic_t i_mmap_writable;
+	struct rb_root_cached i_mmap;
+	long unsigned int nrpages;
+	long unsigned int writeback_index;
+	const struct address_space_operations *a_ops;
+	long unsigned int flags;
+	errseq_t wb_err;
+	spinlock_t i_private_lock;
+	struct list_head i_private_list;
+	struct rw_semaphore i_mmap_rwsem;
+	void *i_private_data;
+};
+
+struct posix_acl;
+
+struct inode_operations;
+
+struct bdi_writeback;
+
+struct file_lock_context;
+
+struct cdev;
+
+struct fsnotify_mark_connector;
+
+struct inode {
+	umode_t i_mode;
+	short unsigned int i_opflags;
+	kuid_t i_uid;
+	kgid_t i_gid;
+	unsigned int i_flags;
+	struct posix_acl *i_acl;
+	struct posix_acl *i_default_acl;
+	const struct inode_operations *i_op;
+	struct super_block *i_sb;
+	struct address_space *i_mapping;
+	long unsigned int i_ino;
+	union {
+		const unsigned int i_nlink;
+		unsigned int __i_nlink;
+	};
+	dev_t i_rdev;
+	loff_t i_size;
+	time64_t i_atime_sec;
+	time64_t i_mtime_sec;
+	time64_t i_ctime_sec;
+	u32 i_atime_nsec;
+	u32 i_mtime_nsec;
+	u32 i_ctime_nsec;
+	u32 i_generation;
+	spinlock_t i_lock;
+	short unsigned int i_bytes;
+	u8 i_blkbits;
+	enum rw_hint i_write_hint;
+	blkcnt_t i_blocks;
+	seqcount_t i_size_seqcount;
+	u32 i_state;
+	struct rw_semaphore i_rwsem;
+	long unsigned int dirtied_when;
+	long unsigned int dirtied_time_when;
+	struct hlist_node i_hash;
+	struct list_head i_io_list;
+	struct bdi_writeback *i_wb;
+	int i_wb_frn_winner;
+	u16 i_wb_frn_avg_time;
+	u16 i_wb_frn_history;
+	struct list_head i_lru;
+	struct list_head i_sb_list;
+	struct list_head i_wb_list;
+	union {
+		struct hlist_head i_dentry;
+		struct callback_head i_rcu;
+	};
+	long: 32;
+	atomic64_t i_version;
+	atomic64_t i_sequence;
+	atomic_t i_count;
+	atomic_t i_dio_count;
+	atomic_t i_writecount;
+	atomic_t i_readcount;
+	union {
+		const struct file_operations *i_fop;
+		void (*free_inode)(struct inode *);
+	};
+	struct file_lock_context *i_flctx;
+	struct address_space i_data;
+	struct list_head i_devices;
+	union {
+		struct pipe_inode_info *i_pipe;
+		struct cdev *i_cdev;
+		char *i_link;
+		unsigned int i_dir_seq;
+	};
+	__u32 i_fsnotify_mask;
+	struct fsnotify_mark_connector *i_fsnotify_marks;
+	void *i_private;
+	long: 32;
+};
+
+enum d_real_type {
+	D_REAL_DATA = 0,
+	D_REAL_METADATA = 1,
+};
+
+struct vfsmount;
+
+struct path;
+
+struct dentry_operations {
+	int (*d_revalidate)(struct dentry *, unsigned int);
+	int (*d_weak_revalidate)(struct dentry *, unsigned int);
+	int (*d_hash)(const struct dentry *, struct qstr *);
+	int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);
+	int (*d_delete)(const struct dentry *);
+	int (*d_init)(struct dentry *);
+	void (*d_release)(struct dentry *);
+	void (*d_prune)(struct dentry *);
+	void (*d_iput)(struct dentry *, struct inode *);
+	char * (*d_dname)(struct dentry *, char *, int);
+	struct vfsmount * (*d_automount)(struct path *);
+	int (*d_manage)(const struct path *, bool);
+	struct dentry * (*d_real)(struct dentry *, enum d_real_type);
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+typedef long long int qsize_t;
+
+struct quota_format_type;
+
+struct mem_dqinfo {
+	struct quota_format_type *dqi_format;
+	int dqi_fmt_id;
+	struct list_head dqi_dirty_list;
+	long unsigned int dqi_flags;
+	unsigned int dqi_bgrace;
+	unsigned int dqi_igrace;
+	long: 32;
+	qsize_t dqi_max_spc_limit;
+	qsize_t dqi_max_ino_limit;
+	void *dqi_priv;
+	long: 32;
+};
+
+struct quota_format_ops;
+
+struct quota_info {
+	unsigned int flags;
+	struct rw_semaphore dqio_sem;
+	struct inode *files[3];
+	struct mem_dqinfo info[3];
+	const struct quota_format_ops *ops[3];
+	long: 32;
+};
+
+struct rcu_sync {
+	int gp_state;
+	int gp_count;
+	wait_queue_head_t gp_wait;
+	struct callback_head cb_head;
+};
+
+struct percpu_rw_semaphore {
+	struct rcu_sync rss;
+	unsigned int *read_count;
+	struct rcuwait writer;
+	wait_queue_head_t waiters;
+	atomic_t block;
+};
+
+struct sb_writers {
+	short unsigned int frozen;
+	int freeze_kcount;
+	int freeze_ucount;
+	struct percpu_rw_semaphore rw_sem[3];
+};
+
+typedef struct {
+	__u8 b[16];
+} uuid_t;
+
+struct list_lru_node;
+
+struct list_lru {
+	struct list_lru_node *node;
+	struct list_head list;
+	int shrinker_id;
+	bool memcg_aware;
+	struct xarray xa;
+};
+
+struct work_struct;
+
+typedef void (*work_func_t)(struct work_struct *);
+
+struct work_struct {
+	atomic_long_t data;
+	struct list_head entry;
+	work_func_t func;
+};
+
+struct super_operations;
+
+struct dquot_operations;
+
+struct quotactl_ops;
+
+struct export_operations;
+
+struct xattr_handler;
+
+struct block_device;
+
+struct backing_dev_info;
+
+struct mtd_info;
+
+struct fsnotify_sb_info;
+
+struct shrinker;
+
+struct workqueue_struct;
+
+struct user_namespace;
+
+struct super_block {
+	struct list_head s_list;
+	dev_t s_dev;
+	unsigned char s_blocksize_bits;
+	long unsigned int s_blocksize;
+	long: 32;
+	loff_t s_maxbytes;
+	struct file_system_type *s_type;
+	const struct super_operations *s_op;
+	const struct dquot_operations *dq_op;
+	const struct quotactl_ops *s_qcop;
+	const struct export_operations *s_export_op;
+	long unsigned int s_flags;
+	long unsigned int s_iflags;
+	long unsigned int s_magic;
+	struct dentry *s_root;
+	struct rw_semaphore s_umount;
+	int s_count;
+	atomic_t s_active;
+	const struct xattr_handler * const *s_xattr;
+	struct hlist_bl_head s_roots;
+	struct list_head s_mounts;
+	struct block_device *s_bdev;
+	struct file *s_bdev_file;
+	struct backing_dev_info *s_bdi;
+	struct mtd_info *s_mtd;
+	struct hlist_node s_instances;
+	unsigned int s_quota_types;
+	struct quota_info s_dquot;
+	struct sb_writers s_writers;
+	void *s_fs_info;
+	u32 s_time_gran;
+	time64_t s_time_min;
+	time64_t s_time_max;
+	u32 s_fsnotify_mask;
+	struct fsnotify_sb_info *s_fsnotify_info;
+	char s_id[32];
+	uuid_t s_uuid;
+	u8 s_uuid_len;
+	char s_sysfs_name[37];
+	unsigned int s_max_links;
+	struct mutex s_vfs_rename_mutex;
+	const char *s_subtype;
+	const struct dentry_operations *s_d_op;
+	struct shrinker *s_shrink;
+	atomic_long_t s_remove_count;
+	int s_readonly_remount;
+	errseq_t s_wb_err;
+	struct workqueue_struct *s_dio_done_wq;
+	struct hlist_head s_pins;
+	struct user_namespace *s_user_ns;
+	struct list_lru s_dentry_lru;
+	struct list_lru s_inode_lru;
+	struct callback_head rcu;
+	struct work_struct destroy_work;
+	struct mutex s_sync_lock;
+	int s_stack_depth;
+	long: 32;
+	spinlock_t s_inode_list_lock;
+	struct list_head s_inodes;
+	spinlock_t s_inode_wblist_lock;
+	struct list_head s_inodes_wb;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct mnt_idmap;
+
+struct vfsmount {
+	struct dentry *mnt_root;
+	struct super_block *mnt_sb;
+	int mnt_flags;
+	struct mnt_idmap *mnt_idmap;
+};
+
+struct path {
+	struct vfsmount *mnt;
+	struct dentry *dentry;
+};
+
+struct timespec64 {
+	time64_t tv_sec;
+	long int tv_nsec;
+	long: 32;
+};
+
+struct uid_gid_extent {
+	u32 first;
+	u32 lower_first;
+	u32 count;
+};
+
+struct uid_gid_map {
+	union {
+		struct {
+			struct uid_gid_extent extent[5];
+			u32 nr_extents;
+		};
+		struct {
+			struct uid_gid_extent *forward;
+			struct uid_gid_extent *reverse;
+		};
+	};
+};
+
+struct proc_ns_operations;
+
+struct ns_common {
+	struct dentry *stashed;
+	const struct proc_ns_operations *ops;
+	unsigned int inum;
+	refcount_t count;
+};
+
+struct ctl_table;
+
+struct ctl_table_root;
+
+struct ctl_table_set;
+
+struct ctl_dir;
+
+struct ctl_node;
+
+struct ctl_table_header {
+	union {
+		struct {
+			struct ctl_table *ctl_table;
+			int ctl_table_size;
+			int used;
+			int count;
+			int nreg;
+		};
+		struct callback_head rcu;
+	};
+	struct completion *unregistering;
+	const struct ctl_table *ctl_table_arg;
+	struct ctl_table_root *root;
+	struct ctl_table_set *set;
+	struct ctl_dir *parent;
+	struct ctl_node *node;
+	struct hlist_head inodes;
+	enum {
+		SYSCTL_TABLE_TYPE_DEFAULT = 0,
+		SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY = 1,
+	} type;
+};
+
+struct ctl_dir {
+	struct ctl_table_header header;
+	struct rb_root root;
+};
+
+struct ctl_table_set {
+	int (*is_seen)(struct ctl_table_set *);
+	struct ctl_dir dir;
+};
+
+struct ucounts;
+
+struct user_namespace {
+	struct uid_gid_map uid_map;
+	struct uid_gid_map gid_map;
+	struct uid_gid_map projid_map;
+	struct user_namespace *parent;
+	int level;
+	kuid_t owner;
+	kgid_t group;
+	struct ns_common ns;
+	long unsigned int flags;
+	bool parent_could_setfcap;
+	struct list_head keyring_name_list;
+	struct key *user_keyring_register;
+	struct rw_semaphore keyring_sem;
+	struct work_struct work;
+	struct ctl_table_set set;
+	struct ctl_table_header *sysctls;
+	struct ucounts *ucounts;
+	long int ucount_max[12];
+	long int rlimit_max[4];
+};
+
+struct kstat {
+	u32 result_mask;
+	umode_t mode;
+	unsigned int nlink;
+	uint32_t blksize;
+	u64 attributes;
+	u64 attributes_mask;
+	u64 ino;
+	dev_t dev;
+	dev_t rdev;
+	kuid_t uid;
+	kgid_t gid;
+	loff_t size;
+	struct timespec64 atime;
+	struct timespec64 mtime;
+	struct timespec64 ctime;
+	struct timespec64 btime;
+	u64 blocks;
+	u64 mnt_id;
+	u32 dio_mem_align;
+	u32 dio_offset_align;
+	u64 change_cookie;
+	u64 subvol;
+	u32 atomic_write_unit_min;
+	u32 atomic_write_unit_max;
+	u32 atomic_write_segments_max;
+	long: 32;
+};
+
+struct static_key {
+	atomic_t enabled;
+};
+
+struct swait_queue_head {
+	raw_spinlock_t lock;
+	struct list_head task_list;
+};
+
+struct completion {
+	unsigned int done;
+	struct swait_queue_head wait;
+};
+
+struct shrinker_info_unit {
+	atomic_long_t nr_deferred[32];
+	long unsigned int map[1];
+};
+
+struct shrinker_info {
+	struct callback_head rcu;
+	int map_nr_max;
+	struct shrinker_info_unit *unit[0];
+};
+
+struct shrink_control {
+	gfp_t gfp_mask;
+	int nid;
+	long unsigned int nr_to_scan;
+	long unsigned int nr_scanned;
+	struct mem_cgroup *memcg;
+};
+
+struct percpu_ref_data;
+
+struct percpu_ref {
+	long unsigned int percpu_count_ptr;
+	struct percpu_ref_data *data;
+};
+
+struct rcu_work {
+	struct work_struct work;
+	struct callback_head rcu;
+	struct workqueue_struct *wq;
+};
+
+struct cgroup;
+
+struct cgroup_subsys;
+
+struct cgroup_subsys_state {
+	struct cgroup *cgroup;
+	struct cgroup_subsys *ss;
+	struct percpu_ref refcnt;
+	struct list_head sibling;
+	struct list_head children;
+	struct list_head rstat_css_node;
+	int id;
+	unsigned int flags;
+	u64 serial_nr;
+	atomic_t online_cnt;
+	struct work_struct destroy_work;
+	struct rcu_work destroy_rwork;
+	struct cgroup_subsys_state *parent;
+	int nr_descendants;
+};
+
+struct mem_cgroup_id {
+	int id;
+	refcount_t ref;
+};
+
+struct page_counter {
+	atomic_long_t usage;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct cacheline_padding _pad1_;
+	long unsigned int emin;
+	atomic_long_t min_usage;
+	atomic_long_t children_min_usage;
+	long unsigned int elow;
+	atomic_long_t low_usage;
+	atomic_long_t children_low_usage;
+	long unsigned int watermark;
+	long unsigned int local_watermark;
+	long unsigned int failcnt;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct cacheline_padding _pad2_;
+	bool protection_support;
+	long unsigned int min;
+	long unsigned int low;
+	long unsigned int high;
+	long unsigned int max;
+	struct page_counter *parent;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct vmpressure {
+	long unsigned int scanned;
+	long unsigned int reclaimed;
+	long unsigned int tree_scanned;
+	long unsigned int tree_reclaimed;
+	spinlock_t sr_lock;
+	struct list_head events;
+	struct mutex events_lock;
+	struct work_struct work;
+};
+
+struct kernfs_node;
+
+struct cgroup_file {
+	struct kernfs_node *kn;
+	long unsigned int notified_at;
+	struct timer_list notify_timer;
+};
+
+struct percpu_counter {
+	raw_spinlock_t lock;
+	long: 32;
+	s64 count;
+	s32 *counters;
+	long: 32;
+};
+
+struct fprop_global {
+	struct percpu_counter events;
+	unsigned int period;
+	seqcount_t sequence;
+};
+
+struct wb_domain {
+	spinlock_t lock;
+	long: 32;
+	struct fprop_global completions;
+	struct timer_list period_timer;
+	long unsigned int period_time;
+	long unsigned int dirty_limit_tstamp;
+	long unsigned int dirty_limit;
+};
+
+struct wb_completion {
+	atomic_t cnt;
+	wait_queue_head_t *waitq;
+};
+
+struct memcg_cgwb_frn {
+	u64 bdi_id;
+	int memcg_id;
+	long: 32;
+	u64 at;
+	struct wb_completion done;
+};
+
+struct memcg_vmstats;
+
+struct memcg_vmstats_percpu;
+
+struct mem_cgroup_per_node;
+
+struct mem_cgroup {
+	struct cgroup_subsys_state css;
+	struct mem_cgroup_id id;
+	long: 32;
+	long: 32;
+	struct page_counter memory;
+	union {
+		struct page_counter swap;
+		struct page_counter memsw;
+	};
+	struct list_head memory_peaks;
+	struct list_head swap_peaks;
+	spinlock_t peaks_lock;
+	struct work_struct high_work;
+	struct vmpressure vmpressure;
+	bool oom_group;
+	int swappiness;
+	struct cgroup_file events_file;
+	struct cgroup_file events_local_file;
+	struct cgroup_file swap_events_file;
+	struct memcg_vmstats *vmstats;
+	atomic_long_t memory_events[9];
+	atomic_long_t memory_events_local[9];
+	long unsigned int socket_pressure;
+	int kmemcg_id;
+	struct obj_cgroup *objcg;
+	struct obj_cgroup *orig_objcg;
+	struct list_head objcg_list;
+	struct memcg_vmstats_percpu *vmstats_percpu;
+	struct list_head cgwb_list;
+	struct wb_domain cgwb_domain;
+	struct memcg_cgwb_frn cgwb_frn[4];
+	struct mem_cgroup_per_node *nodeinfo[0];
+	long: 32;
+	long: 32;
+};
+
+struct shrinker {
+	long unsigned int (*count_objects)(struct shrinker *, struct shrink_control *);
+	long unsigned int (*scan_objects)(struct shrinker *, struct shrink_control *);
+	long int batch;
+	int seeks;
+	unsigned int flags;
+	refcount_t refcount;
+	struct completion done;
+	struct callback_head rcu;
+	void *private_data;
+	struct list_head list;
+	int id;
+	atomic_long_t *nr_deferred;
+};
+
+struct hlist_nulls_node;
+
+struct hlist_nulls_head {
+	struct hlist_nulls_node *first;
+};
+
+struct hlist_nulls_node {
+	struct hlist_nulls_node *next;
+	struct hlist_nulls_node **pprev;
+};
+
+struct kref {
+	refcount_t refcount;
+};
+
+typedef struct {} lockdep_map_p;
+
+struct maple_tree {
+	union {
+		spinlock_t ma_lock;
+		lockdep_map_p ma_external_lock;
+	};
+	unsigned int ma_flags;
+	void *ma_root;
+};
+
+typedef struct {
+	atomic64_t id;
+	atomic_t vmalloc_seq;
+	long unsigned int sigpage;
+	long unsigned int vdso;
+	long: 32;
+} mm_context_t;
+
+struct uprobes_state {};
+
+struct linux_binfmt;
+
+struct kioctx_table;
+
+struct mm_struct {
+	struct {
+		struct {
+			atomic_t mm_count;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+		};
+		struct maple_tree mm_mt;
+		long unsigned int mmap_base;
+		long unsigned int mmap_legacy_base;
+		long unsigned int task_size;
+		pgd_t *pgd;
+		atomic_t membarrier_state;
+		atomic_t mm_users;
+		atomic_long_t pgtables_bytes;
+		int map_count;
+		spinlock_t page_table_lock;
+		struct rw_semaphore mmap_lock;
+		struct list_head mmlist;
+		int mm_lock_seq;
+		long unsigned int hiwater_rss;
+		long unsigned int hiwater_vm;
+		long unsigned int total_vm;
+		long unsigned int locked_vm;
+		long: 32;
+		atomic64_t pinned_vm;
+		long unsigned int data_vm;
+		long unsigned int exec_vm;
+		long unsigned int stack_vm;
+		long unsigned int def_flags;
+		seqcount_t write_protect_seq;
+		spinlock_t arg_lock;
+		long unsigned int start_code;
+		long unsigned int end_code;
+		long unsigned int start_data;
+		long unsigned int end_data;
+		long unsigned int start_brk;
+		long unsigned int brk;
+		long unsigned int start_stack;
+		long unsigned int arg_start;
+		long unsigned int arg_end;
+		long unsigned int env_start;
+		long unsigned int env_end;
+		long unsigned int saved_auxv[46];
+		long: 32;
+		struct percpu_counter rss_stat[4];
+		struct linux_binfmt *binfmt;
+		long: 32;
+		mm_context_t context;
+		long unsigned int flags;
+		spinlock_t ioctx_lock;
+		struct kioctx_table *ioctx_table;
+		struct task_struct *owner;
+		struct user_namespace *user_ns;
+		struct file *exe_file;
+		atomic_t tlb_flush_pending;
+		struct uprobes_state uprobes_state;
+		struct work_struct async_put_work;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+	};
+	long unsigned int cpu_bitmap[0];
+};
+
+struct delayed_work {
+	struct work_struct work;
+	struct timer_list timer;
+	struct workqueue_struct *wq;
+	int cpu;
+};
+
+enum pid_type {
+	PIDTYPE_PID = 0,
+	PIDTYPE_TGID = 1,
+	PIDTYPE_PGID = 2,
+	PIDTYPE_SID = 3,
+	PIDTYPE_MAX = 4,
+};
+
+struct idr {
+	struct xarray idr_rt;
+	unsigned int idr_base;
+	unsigned int idr_next;
+};
+
+struct kmem_cache;
+
+struct pid_namespace {
+	struct idr idr;
+	struct callback_head rcu;
+	unsigned int pid_allocated;
+	struct task_struct *child_reaper;
+	struct kmem_cache *pid_cachep;
+	unsigned int level;
+	struct pid_namespace *parent;
+	struct user_namespace *user_ns;
+	struct ucounts *ucounts;
+	int reboot;
+	struct ns_common ns;
+	int memfd_noexec_scope;
+};
+
+struct hrtimer_cpu_base;
+
+struct hrtimer_clock_base {
+	struct hrtimer_cpu_base *cpu_base;
+	unsigned int index;
+	clockid_t clockid;
+	seqcount_raw_spinlock_t seq;
+	struct hrtimer *running;
+	struct timerqueue_head active;
+	ktime_t (*get_time)();
+	ktime_t offset;
+};
+
+struct rlimit {
+	__kernel_ulong_t rlim_cur;
+	__kernel_ulong_t rlim_max;
+};
+
+struct task_cputime {
+	u64 stime;
+	u64 utime;
+	long long unsigned int sum_exec_runtime;
+};
+
+typedef void __signalfn_t(int);
+
+typedef __signalfn_t *__sighandler_t;
+
+typedef void __restorefn_t();
+
+typedef __restorefn_t *__sigrestore_t;
+
+union sigval {
+	int sival_int;
+	void *sival_ptr;
+};
+
+typedef union sigval sigval_t;
+
+union __sifields {
+	struct {
+		__kernel_pid_t _pid;
+		__kernel_uid32_t _uid;
+	} _kill;
+	struct {
+		__kernel_timer_t _tid;
+		int _overrun;
+		sigval_t _sigval;
+		int _sys_private;
+	} _timer;
+	struct {
+		__kernel_pid_t _pid;
+		__kernel_uid32_t _uid;
+		sigval_t _sigval;
+	} _rt;
+	struct {
+		__kernel_pid_t _pid;
+		__kernel_uid32_t _uid;
+		int _status;
+		__kernel_clock_t _utime;
+		__kernel_clock_t _stime;
+	} _sigchld;
+	struct {
+		void *_addr;
+		union {
+			int _trapno;
+			short int _addr_lsb;
+			struct {
+				char _dummy_bnd[4];
+				void *_lower;
+				void *_upper;
+			} _addr_bnd;
+			struct {
+				char _dummy_pkey[4];
+				__u32 _pkey;
+			} _addr_pkey;
+			struct {
+				long unsigned int _data;
+				__u32 _type;
+				__u32 _flags;
+			} _perf;
+		};
+	} _sigfault;
+	struct {
+		long int _band;
+		int _fd;
+	} _sigpoll;
+	struct {
+		void *_call_addr;
+		int _syscall;
+		unsigned int _arch;
+	} _sigsys;
+};
+
+struct kernel_siginfo {
+	struct {
+		int si_signo;
+		int si_errno;
+		int si_code;
+		union __sifields _sifields;
+	};
+};
+
+struct ucounts {
+	struct hlist_node node;
+	struct user_namespace *ns;
+	kuid_t uid;
+	atomic_t count;
+	atomic_long_t ucount[12];
+	atomic_long_t rlimit[4];
+};
+
+struct sigaction {
+	__sighandler_t sa_handler;
+	long unsigned int sa_flags;
+	__sigrestore_t sa_restorer;
+	sigset_t sa_mask;
+};
+
+struct k_sigaction {
+	struct sigaction sa;
+};
+
+struct rq_flags;
+
+struct affinity_context;
+
+struct sched_class {
+	void (*enqueue_task)(struct rq *, struct task_struct *, int);
+	bool (*dequeue_task)(struct rq *, struct task_struct *, int);
+	void (*yield_task)(struct rq *);
+	bool (*yield_to_task)(struct rq *, struct task_struct *);
+	void (*wakeup_preempt)(struct rq *, struct task_struct *, int);
+	int (*balance)(struct rq *, struct task_struct *, struct rq_flags *);
+	struct task_struct * (*pick_task)(struct rq *);
+	struct task_struct * (*pick_next_task)(struct rq *, struct task_struct *);
+	void (*put_prev_task)(struct rq *, struct task_struct *, struct task_struct *);
+	void (*set_next_task)(struct rq *, struct task_struct *, bool);
+	int (*select_task_rq)(struct task_struct *, int, int);
+	void (*migrate_task_rq)(struct task_struct *, int);
+	void (*task_woken)(struct rq *, struct task_struct *);
+	void (*set_cpus_allowed)(struct task_struct *, struct affinity_context *);
+	void (*rq_online)(struct rq *);
+	void (*rq_offline)(struct rq *);
+	struct rq * (*find_lock_rq)(struct task_struct *, struct rq *);
+	void (*task_tick)(struct rq *, struct task_struct *, int);
+	void (*task_fork)(struct task_struct *);
+	void (*task_dead)(struct task_struct *);
+	void (*switching_to)(struct rq *, struct task_struct *);
+	void (*switched_from)(struct rq *, struct task_struct *);
+	void (*switched_to)(struct rq *, struct task_struct *);
+	void (*reweight_task)(struct rq *, struct task_struct *, const struct load_weight *);
+	void (*prio_changed)(struct rq *, struct task_struct *, int);
+	unsigned int (*get_rr_interval)(struct rq *, struct task_struct *);
+	void (*update_curr)(struct rq *);
+	void (*task_change_group)(struct task_struct *);
+};
+
+struct upid {
+	int nr;
+	struct pid_namespace *ns;
+};
+
+struct pid {
+	refcount_t count;
+	unsigned int level;
+	spinlock_t lock;
+	struct dentry *stashed;
+	u64 ino;
+	struct hlist_head tasks[4];
+	struct hlist_head inodes;
+	wait_queue_head_t wait_pidfd;
+	struct callback_head rcu;
+	struct upid numbers[0];
+};
+
+typedef struct {
+	u64 val;
+} kernel_cap_t;
+
+struct user_struct;
+
+struct group_info;
+
+struct cred {
+	atomic_long_t usage;
+	kuid_t uid;
+	kgid_t gid;
+	kuid_t suid;
+	kgid_t sgid;
+	kuid_t euid;
+	kgid_t egid;
+	kuid_t fsuid;
+	kgid_t fsgid;
+	unsigned int securebits;
+	kernel_cap_t cap_inheritable;
+	kernel_cap_t cap_permitted;
+	kernel_cap_t cap_effective;
+	kernel_cap_t cap_bset;
+	kernel_cap_t cap_ambient;
+	unsigned char jit_keyring;
+	struct key *session_keyring;
+	struct key *process_keyring;
+	struct key *thread_keyring;
+	struct key *request_key_auth;
+	struct user_struct *user;
+	struct user_namespace *user_ns;
+	struct ucounts *ucounts;
+	struct group_info *group_info;
+	union {
+		int non_rcu;
+		struct callback_head rcu;
+	};
+	long: 32;
+};
+
+typedef int32_t key_serial_t;
+
+typedef uint32_t key_perm_t;
+
+struct key_type;
+
+struct key_tag;
+
+struct keyring_index_key {
+	long unsigned int hash;
+	union {
+		struct {
+			u16 desc_len;
+			char desc[2];
+		};
+		long unsigned int x;
+	};
+	struct key_type *type;
+	struct key_tag *domain_tag;
+	const char *description;
+};
+
+union key_payload {
+	void *rcu_data0;
+	void *data[4];
+};
+
+struct assoc_array_ptr;
+
+struct assoc_array {
+	struct assoc_array_ptr *root;
+	long unsigned int nr_leaves_on_tree;
+};
+
+struct key_user;
+
+struct key_restriction;
+
+struct key {
+	refcount_t usage;
+	key_serial_t serial;
+	union {
+		struct list_head graveyard_link;
+		struct rb_node serial_node;
+	};
+	struct rw_semaphore sem;
+	struct key_user *user;
+	void *security;
+	long: 32;
+	union {
+		time64_t expiry;
+		time64_t revoked_at;
+	};
+	time64_t last_used_at;
+	kuid_t uid;
+	kgid_t gid;
+	key_perm_t perm;
+	short unsigned int quotalen;
+	short unsigned int datalen;
+	short int state;
+	long unsigned int flags;
+	union {
+		struct keyring_index_key index_key;
+		struct {
+			long unsigned int hash;
+			long unsigned int len_desc;
+			struct key_type *type;
+			struct key_tag *domain_tag;
+			char *description;
+		};
+	};
+	union {
+		union key_payload payload;
+		struct {
+			struct list_head name_link;
+			struct assoc_array keys;
+		};
+	};
+	struct key_restriction *restrict_link;
+};
+
+struct uts_namespace;
+
+struct ipc_namespace;
+
+struct mnt_namespace;
+
+struct net;
+
+struct time_namespace;
+
+struct cgroup_namespace;
+
+struct nsproxy {
+	refcount_t count;
+	struct uts_namespace *uts_ns;
+	struct ipc_namespace *ipc_ns;
+	struct mnt_namespace *mnt_ns;
+	struct pid_namespace *pid_ns_for_children;
+	struct net *net_ns;
+	struct time_namespace *time_ns;
+	struct time_namespace *time_ns_for_children;
+	struct cgroup_namespace *cgroup_ns;
+};
+
+struct cpu_itimer {
+	u64 expires;
+	u64 incr;
+};
+
+struct task_cputime_atomic {
+	atomic64_t utime;
+	atomic64_t stime;
+	atomic64_t sum_exec_runtime;
+};
+
+struct thread_group_cputimer {
+	struct task_cputime_atomic cputime_atomic;
+};
+
+struct core_state;
+
+struct tty_struct;
+
+struct signal_struct {
+	refcount_t sigcnt;
+	atomic_t live;
+	int nr_threads;
+	int quick_threads;
+	struct list_head thread_head;
+	wait_queue_head_t wait_chldexit;
+	struct task_struct *curr_target;
+	struct sigpending shared_pending;
+	struct hlist_head multiprocess;
+	int group_exit_code;
+	int notify_count;
+	struct task_struct *group_exec_task;
+	int group_stop_count;
+	unsigned int flags;
+	struct core_state *core_state;
+	unsigned int is_child_subreaper: 1;
+	unsigned int has_child_subreaper: 1;
+	unsigned int next_posix_timer_id;
+	struct hlist_head posix_timers;
+	struct hrtimer real_timer;
+	ktime_t it_real_incr;
+	struct cpu_itimer it[2];
+	struct thread_group_cputimer cputimer;
+	struct posix_cputimers posix_cputimers;
+	struct pid *pids[4];
+	struct pid *tty_old_pgrp;
+	int leader;
+	struct tty_struct *tty;
+	seqlock_t stats_lock;
+	long: 32;
+	u64 utime;
+	u64 stime;
+	u64 cutime;
+	u64 cstime;
+	u64 gtime;
+	u64 cgtime;
+	struct prev_cputime prev_cputime;
+	long unsigned int nvcsw;
+	long unsigned int nivcsw;
+	long unsigned int cnvcsw;
+	long unsigned int cnivcsw;
+	long unsigned int min_flt;
+	long unsigned int maj_flt;
+	long unsigned int cmin_flt;
+	long unsigned int cmaj_flt;
+	long unsigned int inblock;
+	long unsigned int oublock;
+	long unsigned int cinblock;
+	long unsigned int coublock;
+	long unsigned int maxrss;
+	long unsigned int cmaxrss;
+	struct task_io_accounting ioac;
+	long long unsigned int sum_sched_runtime;
+	struct rlimit rlim[16];
+	bool oom_flag_origin;
+	short int oom_score_adj;
+	short int oom_score_adj_min;
+	struct mm_struct *oom_mm;
+	struct mutex cred_guard_mutex;
+	struct rw_semaphore exec_update_lock;
+};
+
+struct sighand_struct {
+	spinlock_t siglock;
+	refcount_t count;
+	wait_queue_head_t signalfd_wqh;
+	struct k_sigaction action[64];
+};
+
+struct bio;
+
+struct bio_list {
+	struct bio *head;
+	struct bio *tail;
+};
+
+struct request;
+
+struct blk_plug {
+	struct request *mq_list;
+	struct request *cached_rq;
+	u64 cur_ktime;
+	short unsigned int nr_ios;
+	short unsigned int rq_count;
+	bool multiple_queues;
+	bool has_elevator;
+	struct list_head cb_list;
+};
+
+struct io_cq;
+
+struct io_context {
+	atomic_long_t refcount;
+	atomic_t active_ref;
+	short unsigned int ioprio;
+	spinlock_t lock;
+	struct xarray icq_tree;
+	struct io_cq *icq_hint;
+	struct hlist_head icq_list;
+	struct work_struct release_work;
+};
+
+struct css_set {
+	struct cgroup_subsys_state *subsys[8];
+	refcount_t refcount;
+	struct css_set *dom_cset;
+	struct cgroup *dfl_cgrp;
+	int nr_tasks;
+	struct list_head tasks;
+	struct list_head mg_tasks;
+	struct list_head dying_tasks;
+	struct list_head task_iters;
+	struct list_head e_cset_node[8];
+	struct list_head threaded_csets;
+	struct list_head threaded_csets_node;
+	struct hlist_node hlist;
+	struct list_head cgrp_links;
+	struct list_head mg_src_preload_node;
+	struct list_head mg_dst_preload_node;
+	struct list_head mg_node;
+	struct cgroup *mg_src_cgrp;
+	struct cgroup *mg_dst_cgrp;
+	struct css_set *mg_dst_cset;
+	bool dead;
+	struct callback_head callback_head;
+};
+
+struct perf_event_groups {
+	struct rb_root tree;
+	long: 32;
+	u64 index;
+};
+
+typedef struct {
+	atomic_long_t a;
+} local_t;
+
+struct perf_event_context {
+	raw_spinlock_t lock;
+	struct mutex mutex;
+	struct list_head pmu_ctx_list;
+	struct perf_event_groups pinned_groups;
+	struct perf_event_groups flexible_groups;
+	struct list_head event_list;
+	int nr_events;
+	int nr_user;
+	int is_active;
+	int nr_task_data;
+	int nr_stat;
+	int nr_freq;
+	int rotate_disable;
+	refcount_t refcount;
+	struct task_struct *task;
+	long: 32;
+	u64 time;
+	u64 timestamp;
+	u64 timeoffset;
+	struct perf_event_context *parent_ctx;
+	long: 32;
+	u64 parent_gen;
+	u64 generation;
+	int pin_count;
+	struct callback_head callback_head;
+	local_t nr_no_switch_fast;
+};
+
+struct obj_cgroup {
+	struct percpu_ref refcnt;
+	struct mem_cgroup *memcg;
+	atomic_t nr_charged_bytes;
+	union {
+		struct list_head list;
+		struct callback_head rcu;
+	};
+};
+
+typedef void *mempool_alloc_t(gfp_t, void *);
+
+typedef void mempool_free_t(void *, void *);
+
+struct mempool_s {
+	spinlock_t lock;
+	int min_nr;
+	int curr_nr;
+	void **elements;
+	void *pool_data;
+	mempool_alloc_t *alloc;
+	mempool_free_t *free;
+	wait_queue_head_t wait;
+};
+
+typedef struct mempool_s mempool_t;
+
+struct bio_alloc_cache;
+
+struct bio_set {
+	struct kmem_cache *bio_slab;
+	unsigned int front_pad;
+	struct bio_alloc_cache *cache;
+	mempool_t bio_pool;
+	mempool_t bvec_pool;
+	unsigned int back_pad;
+	spinlock_t rescue_lock;
+	struct bio_list rescue_list;
+	struct work_struct rescue_work;
+	struct workqueue_struct *rescue_workqueue;
+	struct hlist_node cpuhp_dead;
+};
+
+struct kset;
+
+struct kobj_type;
+
+struct kobject {
+	const char *name;
+	struct list_head entry;
+	struct kobject *parent;
+	struct kset *kset;
+	const struct kobj_type *ktype;
+	struct kernfs_node *sd;
+	struct kref kref;
+	unsigned int state_initialized: 1;
+	unsigned int state_in_sysfs: 1;
+	unsigned int state_add_uevent_sent: 1;
+	unsigned int state_remove_uevent_sent: 1;
+	unsigned int uevent_suppress: 1;
+};
+
+struct timer_rand_state;
+
+struct cdrom_device_info;
+
+typedef unsigned int blk_mode_t;
+
+struct block_device_operations;
+
+struct request_queue;
+
+struct disk_events;
+
+struct badblocks;
+
+struct blk_independent_access_ranges;
+
+struct gendisk {
+	int major;
+	int first_minor;
+	int minors;
+	char disk_name[32];
+	short unsigned int events;
+	short unsigned int event_flags;
+	struct xarray part_tbl;
+	struct block_device *part0;
+	const struct block_device_operations *fops;
+	struct request_queue *queue;
+	void *private_data;
+	struct bio_set bio_split;
+	int flags;
+	long unsigned int state;
+	struct mutex open_mutex;
+	unsigned int open_partitions;
+	struct backing_dev_info *bdi;
+	struct kobject queue_kobj;
+	struct kobject *slave_dir;
+	struct list_head slave_bdevs;
+	struct timer_rand_state *random;
+	atomic_t sync_io;
+	struct disk_events *ev;
+	struct cdrom_device_info *cdi;
+	int node_id;
+	struct badblocks *bb;
+	struct lockdep_map lockdep_map;
+	u64 diskseq;
+	blk_mode_t open_mode;
+	struct blk_independent_access_ranges *ia_ranges;
+};
+
+struct bpf_run_ctx {};
+
+struct vmem_altmap {
+	long unsigned int base_pfn;
+	const long unsigned int end_pfn;
+	const long unsigned int reserve;
+	long unsigned int free;
+	long unsigned int align;
+	long unsigned int alloc;
+	bool inaccessible;
+};
+
+enum memory_type {
+	MEMORY_DEVICE_PRIVATE = 1,
+	MEMORY_DEVICE_COHERENT = 2,
+	MEMORY_DEVICE_FS_DAX = 3,
+	MEMORY_DEVICE_GENERIC = 4,
+	MEMORY_DEVICE_PCI_P2PDMA = 5,
+};
+
+struct range {
+	u64 start;
+	u64 end;
+};
+
+struct dev_pagemap_ops;
+
+struct dev_pagemap {
+	struct vmem_altmap altmap;
+	struct percpu_ref ref;
+	struct completion done;
+	enum memory_type type;
+	unsigned int flags;
+	long unsigned int vmemmap_shift;
+	const struct dev_pagemap_ops *ops;
+	void *owner;
+	int nr_range;
+	long: 32;
+	union {
+		struct range range;
+		struct {
+			struct {} __empty_ranges;
+			struct range ranges[0];
+		};
+	};
+};
+
+typedef struct {
+	long unsigned int val;
+} swp_entry_t;
+
+struct folio {
+	union {
+		struct {
+			long unsigned int flags;
+			union {
+				struct list_head lru;
+				struct {
+					void *__filler;
+					unsigned int mlock_count;
+				};
+			};
+			struct address_space *mapping;
+			long unsigned int index;
+			union {
+				void *private;
+				swp_entry_t swap;
+			};
+			atomic_t _mapcount;
+			atomic_t _refcount;
+			long unsigned int memcg_data;
+		};
+		struct page page;
+	};
+	union {
+		struct {
+			long unsigned int _flags_1;
+			long unsigned int _head_1;
+			atomic_t _large_mapcount;
+			atomic_t _entire_mapcount;
+			atomic_t _nr_pages_mapped;
+			atomic_t _pincount;
+		};
+		struct page __page_1;
+	};
+	union {
+		struct {
+			long unsigned int _flags_2;
+			long unsigned int _head_2;
+			void *_hugetlb_subpool;
+			void *_hugetlb_cgroup;
+			void *_hugetlb_cgroup_rsvd;
+			void *_hugetlb_hwpoison;
+		};
+		struct {
+			long unsigned int _flags_2a;
+			long unsigned int _head_2a;
+			struct list_head _deferred_list;
+		};
+		struct page __page_2;
+	};
+};
+
+struct file_ra_state {
+	long unsigned int start;
+	unsigned int size;
+	unsigned int async_size;
+	unsigned int ra_pages;
+	unsigned int mmap_miss;
+	long: 32;
+	loff_t prev_pos;
+};
+
+typedef struct {
+	long unsigned int v;
+} freeptr_t;
+
+struct fown_struct;
+
+struct file {
+	atomic_long_t f_count;
+	spinlock_t f_lock;
+	fmode_t f_mode;
+	const struct file_operations *f_op;
+	struct address_space *f_mapping;
+	void *private_data;
+	struct inode *f_inode;
+	unsigned int f_flags;
+	unsigned int f_iocb_flags;
+	const struct cred *f_cred;
+	struct path f_path;
+	union {
+		struct mutex f_pos_lock;
+		u64 f_pipe;
+	};
+	loff_t f_pos;
+	struct fown_struct *f_owner;
+	errseq_t f_wb_err;
+	errseq_t f_sb_err;
+	struct hlist_head *f_ep;
+	union {
+		struct callback_head f_task_work;
+		struct llist_node f_llist;
+		struct file_ra_state f_ra;
+		freeptr_t f_freeptr;
+	};
+};
+
+struct vma_lock {
+	struct rw_semaphore lock;
+};
+
+typedef unsigned int vm_fault_t;
+
+struct vm_fault;
+
+struct vm_operations_struct {
+	void (*open)(struct vm_area_struct *);
+	void (*close)(struct vm_area_struct *);
+	int (*may_split)(struct vm_area_struct *, long unsigned int);
+	int (*mremap)(struct vm_area_struct *);
+	int (*mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int);
+	vm_fault_t (*fault)(struct vm_fault *);
+	vm_fault_t (*huge_fault)(struct vm_fault *, unsigned int);
+	vm_fault_t (*map_pages)(struct vm_fault *, long unsigned int, long unsigned int);
+	long unsigned int (*pagesize)(struct vm_area_struct *);
+	vm_fault_t (*page_mkwrite)(struct vm_fault *);
+	vm_fault_t (*pfn_mkwrite)(struct vm_fault *);
+	int (*access)(struct vm_area_struct *, long unsigned int, void *, int, int);
+	const char * (*name)(struct vm_area_struct *);
+	struct page * (*find_special_page)(struct vm_area_struct *, long unsigned int);
+};
+
+enum fault_flag {
+	FAULT_FLAG_WRITE = 1,
+	FAULT_FLAG_MKWRITE = 2,
+	FAULT_FLAG_ALLOW_RETRY = 4,
+	FAULT_FLAG_RETRY_NOWAIT = 8,
+	FAULT_FLAG_KILLABLE = 16,
+	FAULT_FLAG_TRIED = 32,
+	FAULT_FLAG_USER = 64,
+	FAULT_FLAG_REMOTE = 128,
+	FAULT_FLAG_INSTRUCTION = 256,
+	FAULT_FLAG_INTERRUPTIBLE = 512,
+	FAULT_FLAG_UNSHARE = 1024,
+	FAULT_FLAG_ORIG_PTE_VALID = 2048,
+	FAULT_FLAG_VMA_LOCK = 4096,
+};
+
+typedef struct {
+	pgd_t pgd;
+} p4d_t;
+
+typedef struct {
+	p4d_t p4d;
+} pud_t;
+
+struct vm_fault {
+	const struct {
+		struct vm_area_struct *vma;
+		gfp_t gfp_mask;
+		long unsigned int pgoff;
+		long unsigned int address;
+		long unsigned int real_address;
+	};
+	enum fault_flag flags;
+	pmd_t *pmd;
+	pud_t *pud;
+	union {
+		pte_t orig_pte;
+		pmd_t orig_pmd;
+	};
+	struct page *cow_page;
+	struct page *page;
+	pte_t *pte;
+	spinlock_t *ptl;
+	pgtable_t prealloc_pte;
+};
+
+struct zswap_lruvec_state {};
+
+struct free_area {
+	struct list_head free_list[4];
+	long unsigned int nr_free;
+};
+
+struct lru_gen_folio {
+	long unsigned int max_seq;
+	long unsigned int min_seq[2];
+	long unsigned int timestamps[4];
+	struct list_head folios[24];
+	long int nr_pages[24];
+	long unsigned int avg_refaulted[8];
+	long unsigned int avg_total[8];
+	long unsigned int protected[6];
+	atomic_long_t evicted[8];
+	atomic_long_t refaulted[8];
+	bool enabled;
+	u8 gen;
+	u8 seg;
+	struct hlist_nulls_node list;
+};
+
+struct lruvec;
+
+struct lru_gen_mm_walk {
+	struct lruvec *lruvec;
+	long unsigned int seq;
+	long unsigned int next_addr;
+	int nr_pages[24];
+	int mm_stats[4];
+	int batched;
+	bool can_swap;
+	bool force_scan;
+};
+
+struct pglist_data;
+
+struct lruvec {
+	struct list_head lists[5];
+	spinlock_t lru_lock;
+	long unsigned int anon_cost;
+	long unsigned int file_cost;
+	atomic_long_t nonresident_age;
+	long unsigned int refaults[2];
+	long unsigned int flags;
+	struct lru_gen_folio lrugen;
+	struct pglist_data *pgdat;
+	struct zswap_lruvec_state zswap_lruvec_state;
+};
+
+struct lru_gen_memcg {
+	long unsigned int seq;
+	long unsigned int nr_memcgs[3];
+	struct hlist_nulls_head fifo[24];
+	spinlock_t lock;
+};
+
+struct per_cpu_pages;
+
+struct per_cpu_zonestat;
+
+struct zone {
+	long unsigned int _watermark[4];
+	long unsigned int watermark_boost;
+	long unsigned int nr_reserved_highatomic;
+	long unsigned int nr_free_highatomic;
+	long int lowmem_reserve[3];
+	struct pglist_data *zone_pgdat;
+	struct per_cpu_pages *per_cpu_pageset;
+	struct per_cpu_zonestat *per_cpu_zonestats;
+	int pageset_high_min;
+	int pageset_high_max;
+	int pageset_batch;
+	long unsigned int *pageblock_flags;
+	long unsigned int zone_start_pfn;
+	atomic_long_t managed_pages;
+	long unsigned int spanned_pages;
+	long unsigned int present_pages;
+	const char *name;
+	int initialized;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct cacheline_padding _pad1_;
+	struct free_area free_area[11];
+	long unsigned int flags;
+	spinlock_t lock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct cacheline_padding _pad2_;
+	long unsigned int percpu_drift_mark;
+	long unsigned int compact_cached_free_pfn;
+	long unsigned int compact_cached_migrate_pfn[2];
+	long unsigned int compact_init_migrate_pfn;
+	long unsigned int compact_init_free_pfn;
+	unsigned int compact_considered;
+	unsigned int compact_defer_shift;
+	int compact_order_failed;
+	bool compact_blockskip_flush;
+	bool contiguous;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct cacheline_padding _pad3_;
+	atomic_long_t vm_stat[11];
+	atomic_long_t vm_numa_event[0];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct zoneref {
+	struct zone *zone;
+	int zone_idx;
+};
+
+struct zonelist {
+	struct zoneref _zonerefs[4];
+};
+
+enum zone_type {
+	ZONE_NORMAL = 0,
+	ZONE_HIGHMEM = 1,
+	ZONE_MOVABLE = 2,
+	__MAX_NR_ZONES = 3,
+};
+
+struct per_cpu_nodestat;
+
+struct pglist_data {
+	struct zone node_zones[3];
+	struct zonelist node_zonelists[1];
+	int nr_zones;
+	struct page *node_mem_map;
+	long unsigned int node_start_pfn;
+	long unsigned int node_present_pages;
+	long unsigned int node_spanned_pages;
+	int node_id;
+	wait_queue_head_t kswapd_wait;
+	wait_queue_head_t pfmemalloc_wait;
+	wait_queue_head_t reclaim_wait[4];
+	atomic_t nr_writeback_throttled;
+	long unsigned int nr_reclaim_start;
+	struct task_struct *kswapd;
+	int kswapd_order;
+	enum zone_type kswapd_highest_zoneidx;
+	int kswapd_failures;
+	int kcompactd_max_order;
+	enum zone_type kcompactd_highest_zoneidx;
+	wait_queue_head_t kcompactd_wait;
+	struct task_struct *kcompactd;
+	bool proactive_compact_trigger;
+	long unsigned int totalreserve_pages;
+	long: 32;
+	long: 32;
+	struct cacheline_padding _pad1_;
+	struct lruvec __lruvec;
+	long unsigned int flags;
+	struct lru_gen_mm_walk mm_walk;
+	struct lru_gen_memcg memcg_lru;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct cacheline_padding _pad2_;
+	struct per_cpu_nodestat *per_cpu_nodestats;
+	atomic_long_t vm_stat[44];
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct per_cpu_pages {
+	spinlock_t lock;
+	int count;
+	int high;
+	int high_min;
+	int high_max;
+	int batch;
+	u8 flags;
+	u8 alloc_factor;
+	short int free_count;
+	struct list_head lists[12];
+	long: 32;
+};
+
+struct per_cpu_zonestat {
+	s8 vm_stat_diff[11];
+	s8 stat_threshold;
+};
+
+struct per_cpu_nodestat {
+	s8 stat_threshold;
+	s8 vm_node_stat_diff[44];
+};
+
+struct rcu_segcblist {
+	struct callback_head *head;
+	struct callback_head **tails[4];
+	long unsigned int gp_seq[4];
+	long int len;
+	long int seglen[4];
+	u8 flags;
+};
+
+struct srcu_node;
+
+struct srcu_struct;
+
+struct srcu_data {
+	atomic_long_t srcu_lock_count[2];
+	atomic_long_t srcu_unlock_count[2];
+	int srcu_nmi_safety;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	spinlock_t lock;
+	struct rcu_segcblist srcu_cblist;
+	long unsigned int srcu_gp_seq_needed;
+	long unsigned int srcu_gp_seq_needed_exp;
+	bool srcu_cblist_invoking;
+	struct timer_list delay_work;
+	struct work_struct work;
+	struct callback_head srcu_barrier_head;
+	struct srcu_node *mynode;
+	long unsigned int grpmask;
+	int cpu;
+	struct srcu_struct *ssp;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct srcu_node {
+	spinlock_t lock;
+	long unsigned int srcu_have_cbs[4];
+	long unsigned int srcu_data_have_cbs[4];
+	long unsigned int srcu_gp_seq_needed_exp;
+	struct srcu_node *srcu_parent;
+	int grplo;
+	int grphi;
+};
+
+struct srcu_usage;
+
+struct srcu_struct {
+	unsigned int srcu_idx;
+	struct srcu_data *sda;
+	struct lockdep_map dep_map;
+	struct srcu_usage *srcu_sup;
+};
+
+struct srcu_usage {
+	struct srcu_node *node;
+	struct srcu_node *level[2];
+	int srcu_size_state;
+	struct mutex srcu_cb_mutex;
+	spinlock_t lock;
+	struct mutex srcu_gp_mutex;
+	long unsigned int srcu_gp_seq;
+	long unsigned int srcu_gp_seq_needed;
+	long unsigned int srcu_gp_seq_needed_exp;
+	long unsigned int srcu_gp_start;
+	long unsigned int srcu_last_gp_end;
+	long unsigned int srcu_size_jiffies;
+	long unsigned int srcu_n_lock_retries;
+	long unsigned int srcu_n_exp_nodelay;
+	bool sda_is_static;
+	long unsigned int srcu_barrier_seq;
+	struct mutex srcu_barrier_mutex;
+	struct completion srcu_barrier_completion;
+	atomic_t srcu_barrier_cpu_cnt;
+	long unsigned int reschedule_jiffies;
+	long unsigned int reschedule_count;
+	struct delayed_work work;
+	struct srcu_struct *srcu_ssp;
+};
+
+struct list_lru_one {
+	struct list_head list;
+	long int nr_items;
+};
+
+struct list_lru_node {
+	spinlock_t lock;
+	struct list_lru_one lru;
+	long int nr_items;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+enum migrate_mode {
+	MIGRATE_ASYNC = 0,
+	MIGRATE_SYNC_LIGHT = 1,
+	MIGRATE_SYNC = 2,
+};
+
+struct exception_table_entry {
+	long unsigned int insn;
+	long unsigned int fixup;
+};
+
+struct cgroup_base_stat {
+	struct task_cputime cputime;
+};
+
+struct bpf_prog_array;
+
+struct cgroup_bpf {
+	struct bpf_prog_array *effective[28];
+	struct hlist_head progs[28];
+	u8 flags[28];
+	struct list_head storages;
+	struct bpf_prog_array *inactive;
+	struct percpu_ref refcnt;
+	struct work_struct release_work;
+};
+
+struct cgroup_freezer_state {
+	bool freeze;
+	int e_freeze;
+	int nr_frozen_descendants;
+	int nr_frozen_tasks;
+};
+
+struct cgroup_root;
+
+struct cgroup_rstat_cpu;
+
+struct psi_group;
+
+struct cgroup {
+	struct cgroup_subsys_state self;
+	long unsigned int flags;
+	int level;
+	int max_depth;
+	int nr_descendants;
+	int nr_dying_descendants;
+	int max_descendants;
+	int nr_populated_csets;
+	int nr_populated_domain_children;
+	int nr_populated_threaded_children;
+	int nr_threaded_children;
+	struct kernfs_node *kn;
+	struct cgroup_file procs_file;
+	struct cgroup_file events_file;
+	struct cgroup_file psi_files[0];
+	u16 subtree_control;
+	u16 subtree_ss_mask;
+	u16 old_subtree_control;
+	u16 old_subtree_ss_mask;
+	struct cgroup_subsys_state *subsys[8];
+	int nr_dying_subsys[8];
+	struct cgroup_root *root;
+	struct list_head cset_links;
+	struct list_head e_csets[8];
+	struct cgroup *dom_cgrp;
+	struct cgroup *old_dom_cgrp;
+	struct cgroup_rstat_cpu *rstat_cpu;
+	struct list_head rstat_css_list;
+	long: 32;
+	struct cacheline_padding _pad_;
+	struct cgroup *rstat_flush_next;
+	long: 32;
+	struct cgroup_base_stat last_bstat;
+	struct cgroup_base_stat bstat;
+	struct prev_cputime prev_cputime;
+	struct list_head pidlists;
+	struct mutex pidlist_mutex;
+	wait_queue_head_t offline_waitq;
+	struct work_struct release_agent_work;
+	struct psi_group *psi;
+	struct cgroup_bpf bpf;
+	struct cgroup_freezer_state freezer;
+	struct bpf_local_storage *bpf_cgrp_storage;
+	struct cgroup *ancestors[0];
+};
+
+typedef int proc_handler(const struct ctl_table *, int, void *, size_t *, loff_t *);
+
+struct ctl_table_poll;
+
+struct ctl_table {
+	const char *procname;
+	void *data;
+	int maxlen;
+	umode_t mode;
+	proc_handler *proc_handler;
+	struct ctl_table_poll *poll;
+	void *extra1;
+	void *extra2;
+};
+
+struct ctl_table_poll {
+	atomic_t event;
+	wait_queue_head_t wait;
+};
+
+struct ctl_node {
+	struct rb_node node;
+	struct ctl_table_header *header;
+};
+
+struct ctl_table_root {
+	struct ctl_table_set default_set;
+	struct ctl_table_set * (*lookup)(struct ctl_table_root *);
+	void (*set_ownership)(struct ctl_table_header *, kuid_t *, kgid_t *);
+	int (*permissions)(struct ctl_table_header *, const struct ctl_table *);
+};
+
+struct key_tag {
+	struct callback_head rcu;
+	refcount_t usage;
+	bool removed;
+};
+
+typedef int (*request_key_actor_t)(struct key *, void *);
+
+struct key_preparsed_payload;
+
+struct key_match_data;
+
+struct kernel_pkey_params;
+
+struct kernel_pkey_query;
+
+struct key_type {
+	const char *name;
+	size_t def_datalen;
+	unsigned int flags;
+	int (*vet_description)(const char *);
+	int (*preparse)(struct key_preparsed_payload *);
+	void (*free_preparse)(struct key_preparsed_payload *);
+	int (*instantiate)(struct key *, struct key_preparsed_payload *);
+	int (*update)(struct key *, struct key_preparsed_payload *);
+	int (*match_preparse)(struct key_match_data *);
+	void (*match_free)(struct key_match_data *);
+	void (*revoke)(struct key *);
+	void (*destroy)(struct key *);
+	void (*describe)(const struct key *, struct seq_file *);
+	long int (*read)(const struct key *, char *, size_t);
+	request_key_actor_t request_key;
+	struct key_restriction * (*lookup_restriction)(const char *);
+	int (*asym_query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
+	int (*asym_eds_op)(struct kernel_pkey_params *, const void *, void *);
+	int (*asym_verify_signature)(struct kernel_pkey_params *, const void *, const void *);
+	struct list_head link;
+	struct lock_class_key lock_class;
+};
+
+typedef int (*key_restrict_link_func_t)(struct key *, const struct key_type *, const union key_payload *, struct key *);
+
+struct key_restriction {
+	key_restrict_link_func_t check;
+	struct key *key;
+	struct key_type *keytype;
+};
+
+struct user_struct {
+	refcount_t __count;
+	long: 32;
+	struct percpu_counter epoll_watches;
+	long unsigned int unix_inflight;
+	atomic_long_t pipe_bufs;
+	struct hlist_node uidhash_node;
+	kuid_t uid;
+	atomic_long_t locked_vm;
+	struct ratelimit_state ratelimit;
+	long: 32;
+};
+
+struct group_info {
+	refcount_t usage;
+	int ngroups;
+	kgid_t gid[0];
+};
+
+struct hrtimer_cpu_base {
+	raw_spinlock_t lock;
+	unsigned int cpu;
+	unsigned int active_bases;
+	unsigned int clock_was_set_seq;
+	unsigned int hres_active: 1;
+	unsigned int in_hrtirq: 1;
+	unsigned int hang_detected: 1;
+	unsigned int softirq_activated: 1;
+	unsigned int online: 1;
+	unsigned int nr_events;
+	short unsigned int nr_retries;
+	short unsigned int nr_hangs;
+	unsigned int max_hang_time;
+	ktime_t expires_next;
+	struct hrtimer *next_timer;
+	long: 32;
+	ktime_t softirq_expires_next;
+	struct hrtimer *softirq_next_timer;
+	long: 32;
+	struct hrtimer_clock_base clock_base[8];
+};
+
+struct core_thread {
+	struct task_struct *task;
+	struct core_thread *next;
+};
+
+struct core_state {
+	atomic_t nr_threads;
+	struct core_thread dumper;
+	struct completion startup;
+};
+
+struct delayed_call {
+	void (*fn)(void *);
+	void *arg;
+};
+
+struct io_cq {
+	struct request_queue *q;
+	struct io_context *ioc;
+	union {
+		struct list_head q_node;
+		struct kmem_cache *__rcu_icq_cache;
+	};
+	union {
+		struct hlist_node ioc_node;
+		struct callback_head __rcu_head;
+	};
+	unsigned int flags;
+};
+
+typedef unsigned int blk_features_t;
+
+typedef unsigned int blk_flags_t;
+
+enum blk_integrity_checksum {
+	BLK_INTEGRITY_CSUM_NONE = 0,
+	BLK_INTEGRITY_CSUM_IP = 1,
+	BLK_INTEGRITY_CSUM_CRC = 2,
+	BLK_INTEGRITY_CSUM_CRC64 = 3,
+} __attribute__((mode(byte)));
+
+struct blk_integrity {
+	unsigned char flags;
+	enum blk_integrity_checksum csum_type;
+	unsigned char tuple_size;
+	unsigned char pi_offset;
+	unsigned char interval_exp;
+	unsigned char tag_size;
+};
+
+struct queue_limits {
+	blk_features_t features;
+	blk_flags_t flags;
+	long unsigned int seg_boundary_mask;
+	long unsigned int virt_boundary_mask;
+	unsigned int max_hw_sectors;
+	unsigned int max_dev_sectors;
+	unsigned int chunk_sectors;
+	unsigned int max_sectors;
+	unsigned int max_user_sectors;
+	unsigned int max_segment_size;
+	unsigned int physical_block_size;
+	unsigned int logical_block_size;
+	unsigned int alignment_offset;
+	unsigned int io_min;
+	unsigned int io_opt;
+	unsigned int max_discard_sectors;
+	unsigned int max_hw_discard_sectors;
+	unsigned int max_user_discard_sectors;
+	unsigned int max_secure_erase_sectors;
+	unsigned int max_write_zeroes_sectors;
+	unsigned int max_zone_append_sectors;
+	unsigned int discard_granularity;
+	unsigned int discard_alignment;
+	unsigned int zone_write_granularity;
+	unsigned int atomic_write_hw_max;
+	unsigned int atomic_write_max_sectors;
+	unsigned int atomic_write_hw_boundary;
+	unsigned int atomic_write_boundary_sectors;
+	unsigned int atomic_write_hw_unit_min;
+	unsigned int atomic_write_unit_min;
+	unsigned int atomic_write_hw_unit_max;
+	unsigned int atomic_write_unit_max;
+	short unsigned int max_segments;
+	short unsigned int max_integrity_segments;
+	short unsigned int max_discard_segments;
+	unsigned int max_open_zones;
+	unsigned int max_active_zones;
+	unsigned int dma_alignment;
+	unsigned int dma_pad_mask;
+	struct blk_integrity integrity;
+};
+
+struct elevator_queue;
+
+struct blk_mq_ops;
+
+struct blk_mq_ctx;
+
+struct blk_queue_stats;
+
+struct rq_qos;
+
+struct blk_mq_tags;
+
+struct blkcg_gq;
+
+struct blk_flush_queue;
+
+struct throtl_data;
+
+struct blk_mq_tag_set;
+
+struct request_queue {
+	void *queuedata;
+	struct elevator_queue *elevator;
+	const struct blk_mq_ops *mq_ops;
+	struct blk_mq_ctx *queue_ctx;
+	long unsigned int queue_flags;
+	unsigned int rq_timeout;
+	unsigned int queue_depth;
+	refcount_t refs;
+	unsigned int nr_hw_queues;
+	struct xarray hctx_table;
+	struct percpu_ref q_usage_counter;
+	struct request *last_merge;
+	spinlock_t queue_lock;
+	int quiesce_depth;
+	struct gendisk *disk;
+	struct kobject *mq_kobj;
+	struct queue_limits limits;
+	atomic_t pm_only;
+	struct blk_queue_stats *stats;
+	struct rq_qos *rq_qos;
+	struct mutex rq_qos_mutex;
+	int id;
+	long unsigned int nr_requests;
+	struct timer_list timeout;
+	struct work_struct timeout_work;
+	atomic_t nr_active_requests_shared_tags;
+	struct blk_mq_tags *sched_shared_tags;
+	struct list_head icq_list;
+	long unsigned int blkcg_pols[1];
+	struct blkcg_gq *root_blkg;
+	struct list_head blkg_list;
+	struct mutex blkcg_mutex;
+	int node;
+	spinlock_t requeue_lock;
+	struct list_head requeue_list;
+	struct delayed_work requeue_work;
+	struct blk_flush_queue *fq;
+	struct list_head flush_list;
+	struct mutex sysfs_lock;
+	struct mutex sysfs_dir_lock;
+	struct mutex limits_lock;
+	struct list_head unused_hctx_list;
+	spinlock_t unused_hctx_lock;
+	int mq_freeze_depth;
+	struct throtl_data *td;
+	struct callback_head callback_head;
+	wait_queue_head_t mq_freeze_wq;
+	struct mutex mq_freeze_lock;
+	struct blk_mq_tag_set *tag_set;
+	struct list_head tag_set_list;
+	struct dentry *debugfs_dir;
+	struct dentry *sched_debugfs_dir;
+	struct dentry *rqos_debugfs_dir;
+	struct mutex debugfs_mutex;
+	bool mq_sysfs_init_done;
+};
+
+typedef struct {
+	uid_t val;
+} vfsuid_t;
+
+typedef struct {
+	gid_t val;
+} vfsgid_t;
+
+typedef void percpu_ref_func_t(struct percpu_ref *);
+
+struct percpu_ref_data {
+	atomic_long_t count;
+	percpu_ref_func_t *release;
+	percpu_ref_func_t *confirm_switch;
+	bool force_atomic: 1;
+	bool allow_reinit: 1;
+	struct callback_head rcu;
+	struct percpu_ref *ref;
+};
+
+struct wait_page_queue;
+
+struct kiocb {
+	struct file *ki_filp;
+	long: 32;
+	loff_t ki_pos;
+	void (*ki_complete)(struct kiocb *, long int);
+	void *private;
+	int ki_flags;
+	u16 ki_ioprio;
+	union {
+		struct wait_page_queue *ki_waitq;
+		ssize_t (*dio_complete)(void *);
+	};
+	long: 32;
+};
+
+struct iattr {
+	unsigned int ia_valid;
+	umode_t ia_mode;
+	union {
+		kuid_t ia_uid;
+		vfsuid_t ia_vfsuid;
+	};
+	union {
+		kgid_t ia_gid;
+		vfsgid_t ia_vfsgid;
+	};
+	loff_t ia_size;
+	struct timespec64 ia_atime;
+	struct timespec64 ia_mtime;
+	struct timespec64 ia_ctime;
+	struct file *ia_file;
+	long: 32;
+};
+
+typedef __kernel_uid32_t projid_t;
+
+typedef struct {
+	projid_t val;
+} kprojid_t;
+
+enum quota_type {
+	USRQUOTA = 0,
+	GRPQUOTA = 1,
+	PRJQUOTA = 2,
+};
+
+struct kqid {
+	union {
+		kuid_t uid;
+		kgid_t gid;
+		kprojid_t projid;
+	};
+	enum quota_type type;
+};
+
+struct mem_dqblk {
+	qsize_t dqb_bhardlimit;
+	qsize_t dqb_bsoftlimit;
+	qsize_t dqb_curspace;
+	qsize_t dqb_rsvspace;
+	qsize_t dqb_ihardlimit;
+	qsize_t dqb_isoftlimit;
+	qsize_t dqb_curinodes;
+	time64_t dqb_btime;
+	time64_t dqb_itime;
+};
+
+struct dquot {
+	struct hlist_node dq_hash;
+	struct list_head dq_inuse;
+	struct list_head dq_free;
+	struct list_head dq_dirty;
+	struct mutex dq_lock;
+	spinlock_t dq_dqb_lock;
+	atomic_t dq_count;
+	struct super_block *dq_sb;
+	struct kqid dq_id;
+	loff_t dq_off;
+	long unsigned int dq_flags;
+	long: 32;
+	struct mem_dqblk dq_dqb;
+};
+
+struct quota_format_type {
+	int qf_fmt_id;
+	const struct quota_format_ops *qf_ops;
+	struct module *qf_owner;
+	struct quota_format_type *qf_next;
+};
+
+struct quota_format_ops {
+	int (*check_quota_file)(struct super_block *, int);
+	int (*read_file_info)(struct super_block *, int);
+	int (*write_file_info)(struct super_block *, int);
+	int (*free_file_info)(struct super_block *, int);
+	int (*read_dqblk)(struct dquot *);
+	int (*commit_dqblk)(struct dquot *);
+	int (*release_dqblk)(struct dquot *);
+	int (*get_next_id)(struct super_block *, struct kqid *);
+};
+
+struct dquot_operations {
+	int (*write_dquot)(struct dquot *);
+	struct dquot * (*alloc_dquot)(struct super_block *, int);
+	void (*destroy_dquot)(struct dquot *);
+	int (*acquire_dquot)(struct dquot *);
+	int (*release_dquot)(struct dquot *);
+	int (*mark_dirty)(struct dquot *);
+	int (*write_info)(struct super_block *, int);
+	qsize_t * (*get_reserved_space)(struct inode *);
+	int (*get_projid)(struct inode *, kprojid_t *);
+	int (*get_inode_usage)(struct inode *, qsize_t *);
+	int (*get_next_id)(struct super_block *, struct kqid *);
+};
+
+struct qc_dqblk {
+	int d_fieldmask;
+	long: 32;
+	u64 d_spc_hardlimit;
+	u64 d_spc_softlimit;
+	u64 d_ino_hardlimit;
+	u64 d_ino_softlimit;
+	u64 d_space;
+	u64 d_ino_count;
+	s64 d_ino_timer;
+	s64 d_spc_timer;
+	int d_ino_warns;
+	int d_spc_warns;
+	u64 d_rt_spc_hardlimit;
+	u64 d_rt_spc_softlimit;
+	u64 d_rt_space;
+	s64 d_rt_spc_timer;
+	int d_rt_spc_warns;
+	long: 32;
+};
+
+struct qc_type_state {
+	unsigned int flags;
+	unsigned int spc_timelimit;
+	unsigned int ino_timelimit;
+	unsigned int rt_spc_timelimit;
+	unsigned int spc_warnlimit;
+	unsigned int ino_warnlimit;
+	unsigned int rt_spc_warnlimit;
+	long: 32;
+	long long unsigned int ino;
+	blkcnt_t blocks;
+	blkcnt_t nextents;
+};
+
+struct qc_state {
+	unsigned int s_incoredqs;
+	long: 32;
+	struct qc_type_state s_state[3];
+};
+
+struct qc_info {
+	int i_fieldmask;
+	unsigned int i_flags;
+	unsigned int i_spc_timelimit;
+	unsigned int i_ino_timelimit;
+	unsigned int i_rt_spc_timelimit;
+	unsigned int i_spc_warnlimit;
+	unsigned int i_ino_warnlimit;
+	unsigned int i_rt_spc_warnlimit;
+};
+
+struct quotactl_ops {
+	int (*quota_on)(struct super_block *, int, int, const struct path *);
+	int (*quota_off)(struct super_block *, int);
+	int (*quota_enable)(struct super_block *, unsigned int);
+	int (*quota_disable)(struct super_block *, unsigned int);
+	int (*quota_sync)(struct super_block *, int);
+	int (*set_info)(struct super_block *, int, struct qc_info *);
+	int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
+	int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *);
+	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
+	int (*get_state)(struct super_block *, struct qc_state *);
+	int (*rm_xquota)(struct super_block *, unsigned int);
+};
+
+enum module_state {
+	MODULE_STATE_LIVE = 0,
+	MODULE_STATE_COMING = 1,
+	MODULE_STATE_GOING = 2,
+	MODULE_STATE_UNFORMED = 3,
+};
+
+struct module_param_attrs;
+
+struct module_kobject {
+	struct kobject kobj;
+	struct module *mod;
+	struct kobject *drivers_dir;
+	struct module_param_attrs *mp;
+	struct completion *kobj_completion;
+};
+
+struct latch_tree_node {
+	struct rb_node node[2];
+};
+
+struct mod_tree_node {
+	struct module *mod;
+	struct latch_tree_node node;
+};
+
+struct module_memory {
+	void *base;
+	unsigned int size;
+	struct mod_tree_node mtn;
+};
+
+struct unwind_table;
+
+struct mod_arch_specific {
+	struct list_head unwind_list;
+	struct unwind_table *init_table;
+};
+
+struct elf32_sym;
+
+typedef struct elf32_sym Elf32_Sym;
+
+struct mod_kallsyms {
+	Elf32_Sym *symtab;
+	unsigned int num_symtab;
+	char *strtab;
+	char *typetab;
+};
+
+struct module_attribute;
+
+struct kernel_symbol;
+
+struct kernel_param;
+
+struct module_sect_attrs;
+
+struct module_notes_attrs;
+
+struct tracepoint;
+
+typedef struct tracepoint * const tracepoint_ptr_t;
+
+struct bpf_raw_event_map;
+
+struct trace_eval_map;
+
+struct module {
+	enum module_state state;
+	struct list_head list;
+	char name[60];
+	struct module_kobject mkobj;
+	struct module_attribute *modinfo_attrs;
+	const char *version;
+	const char *srcversion;
+	struct kobject *holders_dir;
+	const struct kernel_symbol *syms;
+	const s32 *crcs;
+	unsigned int num_syms;
+	struct mutex param_lock;
+	struct kernel_param *kp;
+	unsigned int num_kp;
+	unsigned int num_gpl_syms;
+	const struct kernel_symbol *gpl_syms;
+	const s32 *gpl_crcs;
+	bool using_gplonly_symbols;
+	bool async_probe_requested;
+	unsigned int num_exentries;
+	struct exception_table_entry *extable;
+	int (*init)();
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct module_memory mem[7];
+	struct mod_arch_specific arch;
+	long unsigned int taints;
+	unsigned int num_bugs;
+	struct list_head bug_list;
+	struct bug_entry *bug_table;
+	struct mod_kallsyms *kallsyms;
+	struct mod_kallsyms core_kallsyms;
+	struct module_sect_attrs *sect_attrs;
+	struct module_notes_attrs *notes_attrs;
+	char *args;
+	void *percpu;
+	unsigned int percpu_size;
+	void *noinstr_text_start;
+	unsigned int noinstr_text_size;
+	unsigned int num_tracepoints;
+	tracepoint_ptr_t *tracepoints_ptrs;
+	unsigned int num_srcu_structs;
+	struct srcu_struct **srcu_struct_ptrs;
+	unsigned int num_bpf_raw_events;
+	struct bpf_raw_event_map *bpf_raw_events;
+	unsigned int btf_data_size;
+	unsigned int btf_base_data_size;
+	void *btf_data;
+	void *btf_base_data;
+	unsigned int num_trace_bprintk_fmt;
+	const char **trace_bprintk_fmt_start;
+	struct trace_event_call **trace_events;
+	unsigned int num_trace_events;
+	struct trace_eval_map **trace_evals;
+	unsigned int num_trace_evals;
+	void *kprobes_text_start;
+	unsigned int kprobes_text_size;
+	long unsigned int *kprobe_blacklist;
+	unsigned int num_kprobe_blacklist;
+	struct list_head source_list;
+	struct list_head target_list;
+	void (*exit)();
+	atomic_t refcnt;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct writeback_control;
+
+struct readahead_control;
+
+struct swap_info_struct;
+
+struct address_space_operations {
+	int (*writepage)(struct page *, struct writeback_control *);
+	int (*read_folio)(struct file *, struct folio *);
+	int (*writepages)(struct address_space *, struct writeback_control *);
+	bool (*dirty_folio)(struct address_space *, struct folio *);
+	void (*readahead)(struct readahead_control *);
+	int (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, struct folio **, void **);
+	int (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct folio *, void *);
+	sector_t (*bmap)(struct address_space *, sector_t);
+	void (*invalidate_folio)(struct folio *, size_t, size_t);
+	bool (*release_folio)(struct folio *, gfp_t);
+	void (*free_folio)(struct folio *);
+	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *);
+	int (*migrate_folio)(struct address_space *, struct folio *, struct folio *, enum migrate_mode);
+	int (*launder_folio)(struct folio *);
+	bool (*is_partially_uptodate)(struct folio *, size_t, size_t);
+	void (*is_dirty_writeback)(struct folio *, bool *, bool *);
+	int (*error_remove_folio)(struct address_space *, struct folio *);
+	int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);
+	void (*swap_deactivate)(struct file *);
+	int (*swap_rw)(struct kiocb *, struct iov_iter *);
+};
+
+enum writeback_sync_modes {
+	WB_SYNC_NONE = 0,
+	WB_SYNC_ALL = 1,
+};
+
+struct folio_batch {
+	unsigned char nr;
+	unsigned char i;
+	bool percpu_pvec_drained;
+	struct folio *folios[31];
+};
+
+struct swap_iocb;
+
+struct writeback_control {
+	long int nr_to_write;
+	long int pages_skipped;
+	loff_t range_start;
+	loff_t range_end;
+	enum writeback_sync_modes sync_mode;
+	unsigned int for_kupdate: 1;
+	unsigned int for_background: 1;
+	unsigned int tagged_writepages: 1;
+	unsigned int for_reclaim: 1;
+	unsigned int range_cyclic: 1;
+	unsigned int for_sync: 1;
+	unsigned int unpinned_netfs_wb: 1;
+	unsigned int no_cgroup_owner: 1;
+	struct swap_iocb **swap_plug;
+	struct list_head *list;
+	struct folio_batch fbatch;
+	long unsigned int index;
+	int saved_err;
+	struct bdi_writeback *wb;
+	struct inode *inode;
+	int wb_id;
+	int wb_lcand_id;
+	int wb_tcand_id;
+	size_t wb_bytes;
+	size_t wb_lcand_bytes;
+	size_t wb_tcand_bytes;
+};
+
+struct iovec {
+	void *iov_base;
+	__kernel_size_t iov_len;
+};
+
+struct kvec;
+
+struct bio_vec;
+
+struct folio_queue;
+
+struct iov_iter {
+	u8 iter_type;
+	bool nofault;
+	bool data_source;
+	size_t iov_offset;
+	union {
+		struct iovec __ubuf_iovec;
+		struct {
+			union {
+				const struct iovec *__iov;
+				const struct kvec *kvec;
+				const struct bio_vec *bvec;
+				const struct folio_queue *folioq;
+				struct xarray *xarray;
+				void *ubuf;
+			};
+			size_t count;
+		};
+	};
+	union {
+		long unsigned int nr_segs;
+		u8 folioq_slot;
+		loff_t xarray_start;
+	};
+};
+
+struct fiemap_extent_info;
+
+struct fileattr;
+
+struct offset_ctx;
+
+struct inode_operations {
+	struct dentry * (*lookup)(struct inode *, struct dentry *, unsigned int);
+	const char * (*get_link)(struct dentry *, struct inode *, struct delayed_call *);
+	int (*permission)(struct mnt_idmap *, struct inode *, int);
+	struct posix_acl * (*get_inode_acl)(struct inode *, int, bool);
+	int (*readlink)(struct dentry *, char *, int);
+	int (*create)(struct mnt_idmap *, struct inode *, struct dentry *, umode_t, bool);
+	int (*link)(struct dentry *, struct inode *, struct dentry *);
+	int (*unlink)(struct inode *, struct dentry *);
+	int (*symlink)(struct mnt_idmap *, struct inode *, struct dentry *, const char *);
+	int (*mkdir)(struct mnt_idmap *, struct inode *, struct dentry *, umode_t);
+	int (*rmdir)(struct inode *, struct dentry *);
+	int (*mknod)(struct mnt_idmap *, struct inode *, struct dentry *, umode_t, dev_t);
+	int (*rename)(struct mnt_idmap *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);
+	int (*setattr)(struct mnt_idmap *, struct dentry *, struct iattr *);
+	int (*getattr)(struct mnt_idmap *, const struct path *, struct kstat *, u32, unsigned int);
+	ssize_t (*listxattr)(struct dentry *, char *, size_t);
+	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);
+	int (*update_time)(struct inode *, int);
+	int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t);
+	int (*tmpfile)(struct mnt_idmap *, struct inode *, struct file *, umode_t);
+	struct posix_acl * (*get_acl)(struct mnt_idmap *, struct dentry *, int);
+	int (*set_acl)(struct mnt_idmap *, struct dentry *, struct posix_acl *, int);
+	int (*fileattr_set)(struct mnt_idmap *, struct dentry *, struct fileattr *);
+	int (*fileattr_get)(struct dentry *, struct fileattr *);
+	struct offset_ctx * (*get_offset_ctx)(struct inode *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct fprop_local_percpu {
+	struct percpu_counter events;
+	unsigned int period;
+	raw_spinlock_t lock;
+};
+
+enum wb_reason {
+	WB_REASON_BACKGROUND = 0,
+	WB_REASON_VMSCAN = 1,
+	WB_REASON_SYNC = 2,
+	WB_REASON_PERIODIC = 3,
+	WB_REASON_LAPTOP_TIMER = 4,
+	WB_REASON_FS_FREE_SPACE = 5,
+	WB_REASON_FORKER_THREAD = 6,
+	WB_REASON_FOREIGN_FLUSH = 7,
+	WB_REASON_MAX = 8,
+};
+
+struct bdi_writeback {
+	struct backing_dev_info *bdi;
+	long unsigned int state;
+	long unsigned int last_old_flush;
+	struct list_head b_dirty;
+	struct list_head b_io;
+	struct list_head b_more_io;
+	struct list_head b_dirty_time;
+	spinlock_t list_lock;
+	atomic_t writeback_inodes;
+	long: 32;
+	struct percpu_counter stat[4];
+	long unsigned int bw_time_stamp;
+	long unsigned int dirtied_stamp;
+	long unsigned int written_stamp;
+	long unsigned int write_bandwidth;
+	long unsigned int avg_write_bandwidth;
+	long unsigned int dirty_ratelimit;
+	long unsigned int balanced_dirty_ratelimit;
+	long: 32;
+	struct fprop_local_percpu completions;
+	int dirty_exceeded;
+	enum wb_reason start_all_reason;
+	spinlock_t work_lock;
+	struct list_head work_list;
+	struct delayed_work dwork;
+	struct delayed_work bw_dwork;
+	struct list_head bdi_node;
+	struct percpu_ref refcnt;
+	long: 32;
+	struct fprop_local_percpu memcg_completions;
+	struct cgroup_subsys_state *memcg_css;
+	struct cgroup_subsys_state *blkcg_css;
+	struct list_head memcg_node;
+	struct list_head blkcg_node;
+	struct list_head b_attached;
+	struct list_head offline_node;
+	union {
+		struct work_struct release_work;
+		struct callback_head rcu;
+	};
+};
+
+struct fown_struct {
+	struct file *file;
+	rwlock_t lock;
+	struct pid *pid;
+	enum pid_type pid_type;
+	kuid_t uid;
+	kuid_t euid;
+	int signum;
+};
+
+struct fasync_struct {
+	rwlock_t fa_lock;
+	int magic;
+	int fa_fd;
+	struct fasync_struct *fa_next;
+	struct file *fa_file;
+	struct callback_head fa_rcu;
+};
+
+enum freeze_holder {
+	FREEZE_HOLDER_KERNEL = 1,
+	FREEZE_HOLDER_USERSPACE = 2,
+	FREEZE_MAY_NEST = 4,
+};
+
+struct kstatfs;
+
+struct super_operations {
+	struct inode * (*alloc_inode)(struct super_block *);
+	void (*destroy_inode)(struct inode *);
+	void (*free_inode)(struct inode *);
+	void (*dirty_inode)(struct inode *, int);
+	int (*write_inode)(struct inode *, struct writeback_control *);
+	int (*drop_inode)(struct inode *);
+	void (*evict_inode)(struct inode *);
+	void (*put_super)(struct super_block *);
+	int (*sync_fs)(struct super_block *, int);
+	int (*freeze_super)(struct super_block *, enum freeze_holder);
+	int (*freeze_fs)(struct super_block *);
+	int (*thaw_super)(struct super_block *, enum freeze_holder);
+	int (*unfreeze_fs)(struct super_block *);
+	int (*statfs)(struct dentry *, struct kstatfs *);
+	int (*remount_fs)(struct super_block *, int *, char *);
+	void (*umount_begin)(struct super_block *);
+	int (*show_options)(struct seq_file *, struct dentry *);
+	int (*show_devname)(struct seq_file *, struct dentry *);
+	int (*show_path)(struct seq_file *, struct dentry *);
+	int (*show_stats)(struct seq_file *, struct dentry *);
+	long int (*nr_cached_objects)(struct super_block *, struct shrink_control *);
+	long int (*free_cached_objects)(struct super_block *, struct shrink_control *);
+	void (*shutdown)(struct super_block *);
+};
+
+struct fid;
+
+struct iomap;
+
+struct export_operations {
+	int (*encode_fh)(struct inode *, __u32 *, int *, struct inode *);
+	struct dentry * (*fh_to_dentry)(struct super_block *, struct fid *, int, int);
+	struct dentry * (*fh_to_parent)(struct super_block *, struct fid *, int, int);
+	int (*get_name)(struct dentry *, char *, struct dentry *);
+	struct dentry * (*get_parent)(struct dentry *);
+	int (*commit_metadata)(struct inode *);
+	int (*get_uuid)(struct super_block *, u8 *, u32 *, u64 *);
+	int (*map_blocks)(struct inode *, loff_t, u64, struct iomap *, bool, u32 *);
+	int (*commit_blocks)(struct inode *, struct iomap *, int, struct iattr *);
+	long unsigned int flags;
+};
+
+struct xattr_handler {
+	const char *name;
+	const char *prefix;
+	int flags;
+	bool (*list)(struct dentry *);
+	int (*get)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, void *, size_t);
+	int (*set)(const struct xattr_handler *, struct mnt_idmap *, struct dentry *, struct inode *, const char *, const void *, size_t, int);
+};
+
+enum dl_dev_state {
+	DL_DEV_NO_DRIVER = 0,
+	DL_DEV_PROBING = 1,
+	DL_DEV_DRIVER_BOUND = 2,
+	DL_DEV_UNBINDING = 3,
+};
+
+struct dev_links_info {
+	struct list_head suppliers;
+	struct list_head consumers;
+	struct list_head defer_sync;
+	enum dl_dev_state status;
+};
+
+struct pm_message {
+	int event;
+};
+
+typedef struct pm_message pm_message_t;
+
+struct pm_subsys_data;
+
+struct device;
+
+struct dev_pm_qos;
+
+struct dev_pm_info {
+	pm_message_t power_state;
+	bool can_wakeup: 1;
+	bool async_suspend: 1;
+	bool in_dpm_list: 1;
+	bool is_prepared: 1;
+	bool is_suspended: 1;
+	bool is_noirq_suspended: 1;
+	bool is_late_suspended: 1;
+	bool no_pm: 1;
+	bool early_init: 1;
+	bool direct_complete: 1;
+	u32 driver_flags;
+	spinlock_t lock;
+	bool should_wakeup: 1;
+	struct pm_subsys_data *subsys_data;
+	void (*set_latency_tolerance)(struct device *, s32);
+	struct dev_pm_qos *qos;
+};
+
+struct dev_msi_info {};
+
+struct dev_archdata {
+	unsigned int dma_ops_setup: 1;
+};
+
+enum device_removable {
+	DEVICE_REMOVABLE_NOT_SUPPORTED = 0,
+	DEVICE_REMOVABLE_UNKNOWN = 1,
+	DEVICE_FIXED = 2,
+	DEVICE_REMOVABLE = 3,
+};
+
+struct device_private;
+
+struct device_type;
+
+struct bus_type;
+
+struct device_driver;
+
+struct dev_pm_domain;
+
+struct dev_pin_info;
+
+struct dma_map_ops;
+
+struct bus_dma_region;
+
+struct device_dma_parameters;
+
+struct dma_coherent_mem;
+
+struct device_node;
+
+struct fwnode_handle;
+
+struct class;
+
+struct attribute_group;
+
+struct iommu_group;
+
+struct dev_iommu;
+
+struct device_physical_location;
+
+struct device {
+	struct kobject kobj;
+	struct device *parent;
+	struct device_private *p;
+	const char *init_name;
+	const struct device_type *type;
+	const struct bus_type *bus;
+	struct device_driver *driver;
+	void *platform_data;
+	void *driver_data;
+	struct mutex mutex;
+	struct dev_links_info links;
+	struct dev_pm_info power;
+	struct dev_pm_domain *pm_domain;
+	struct dev_pin_info *pins;
+	struct dev_msi_info msi;
+	const struct dma_map_ops *dma_ops;
+	u64 *dma_mask;
+	long: 32;
+	u64 coherent_dma_mask;
+	u64 bus_dma_limit;
+	const struct bus_dma_region *dma_range_map;
+	struct device_dma_parameters *dma_parms;
+	struct list_head dma_pools;
+	struct dma_coherent_mem *dma_mem;
+	struct dev_archdata archdata;
+	struct device_node *of_node;
+	struct fwnode_handle *fwnode;
+	dev_t devt;
+	u32 id;
+	spinlock_t devres_lock;
+	struct list_head devres_head;
+	const struct class *class;
+	const struct attribute_group **groups;
+	void (*release)(struct device *);
+	struct iommu_group *iommu_group;
+	struct dev_iommu *iommu;
+	struct device_physical_location *physical_location;
+	enum device_removable removable;
+	bool offline_disabled: 1;
+	bool offline: 1;
+	bool of_node_reused: 1;
+	bool state_synced: 1;
+	bool can_match: 1;
+	bool dma_coherent: 1;
+	bool dma_skip_sync: 1;
+	long: 32;
+};
+
+struct disk_stats;
+
+struct blk_holder_ops;
+
+struct partition_meta_info;
+
+struct block_device {
+	sector_t bd_start_sect;
+	sector_t bd_nr_sectors;
+	struct gendisk *bd_disk;
+	struct request_queue *bd_queue;
+	struct disk_stats *bd_stats;
+	long unsigned int bd_stamp;
+	atomic_t __bd_flags;
+	dev_t bd_dev;
+	struct address_space *bd_mapping;
+	atomic_t bd_openers;
+	spinlock_t bd_size_lock;
+	void *bd_claiming;
+	void *bd_holder;
+	const struct blk_holder_ops *bd_holder_ops;
+	struct mutex bd_holder_lock;
+	int bd_holders;
+	struct kobject *bd_holder_dir;
+	atomic_t bd_fsfreeze_count;
+	struct mutex bd_fsfreeze_mutex;
+	struct partition_meta_info *bd_meta_info;
+	int bd_writers;
+	long: 32;
+	struct device bd_device;
+};
+
+struct backing_dev_info {
+	u64 id;
+	struct rb_node rb_node;
+	struct list_head bdi_list;
+	long unsigned int ra_pages;
+	long unsigned int io_pages;
+	struct kref refcnt;
+	unsigned int capabilities;
+	unsigned int min_ratio;
+	unsigned int max_ratio;
+	unsigned int max_prop_frac;
+	atomic_long_t tot_write_bandwidth;
+	long unsigned int last_bdp_sleep;
+	struct bdi_writeback wb;
+	struct list_head wb_list;
+	struct xarray cgwb_tree;
+	struct mutex cgwb_release_mutex;
+	struct rw_semaphore wb_switch_rwsem;
+	wait_queue_head_t wb_waitq;
+	struct device *dev;
+	char dev_name[64];
+	struct device *owner;
+	struct timer_list laptop_mode_wb_timer;
+	struct dentry *debug_dir;
+	long: 32;
+};
+
+typedef bool (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64, unsigned int);
+
+struct dir_context {
+	filldir_t actor;
+	long: 32;
+	loff_t pos;
+};
+
+struct io_comp_batch {
+	struct request *req_list;
+	bool need_ts;
+	void (*complete)(struct io_comp_batch *);
+};
+
+typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);
+
+struct poll_table_struct {
+	poll_queue_proc _qproc;
+	__poll_t _key;
+};
+
+struct seq_operations;
+
+struct seq_file {
+	char *buf;
+	size_t size;
+	size_t from;
+	size_t count;
+	size_t pad_until;
+	long: 32;
+	loff_t index;
+	loff_t read_pos;
+	struct mutex lock;
+	const struct seq_operations *op;
+	int poll_event;
+	const struct file *file;
+	void *private;
+	long: 32;
+};
+
+struct offset_ctx {
+	struct maple_tree mt;
+	long unsigned int next_offset;
+};
+
+struct p_log;
+
+struct fs_parameter;
+
+struct fs_parse_result;
+
+typedef int fs_param_type(struct p_log *, const struct fs_parameter_spec *, struct fs_parameter *, struct fs_parse_result *);
+
+struct fs_parameter_spec {
+	const char *name;
+	fs_param_type *type;
+	u8 opt;
+	short unsigned int flags;
+	const void *data;
+};
+
+typedef __u32 blk_opf_t;
+
+typedef u8 blk_status_t;
+
+struct bvec_iter {
+	sector_t bi_sector;
+	unsigned int bi_size;
+	unsigned int bi_idx;
+	unsigned int bi_bvec_done;
+};
+
+typedef unsigned int blk_qc_t;
+
+typedef void bio_end_io_t(struct bio *);
+
+struct bio_issue {
+	u64 value;
+};
+
+struct bio_vec {
+	struct page *bv_page;
+	unsigned int bv_len;
+	unsigned int bv_offset;
+};
+
+struct bio {
+	struct bio *bi_next;
+	struct block_device *bi_bdev;
+	blk_opf_t bi_opf;
+	short unsigned int bi_flags;
+	short unsigned int bi_ioprio;
+	enum rw_hint bi_write_hint;
+	blk_status_t bi_status;
+	atomic_t __bi_remaining;
+	struct bvec_iter bi_iter;
+	union {
+		blk_qc_t bi_cookie;
+		unsigned int __bi_nr_segments;
+	};
+	bio_end_io_t *bi_end_io;
+	void *bi_private;
+	struct blkcg_gq *bi_blkg;
+	long: 32;
+	struct bio_issue bi_issue;
+	short unsigned int bi_vcnt;
+	short unsigned int bi_max_vecs;
+	atomic_t __bi_cnt;
+	struct bio_vec *bi_io_vec;
+	struct bio_set *bi_pool;
+	struct bio_vec bi_inline_vecs[0];
+};
+
+struct subprocess_info {
+	struct work_struct work;
+	struct completion *complete;
+	const char *path;
+	char **argv;
+	char **envp;
+	int wait;
+	int retval;
+	int (*init)(struct subprocess_info *, struct cred *);
+	void (*cleanup)(struct subprocess_info *);
+	void *data;
+};
+
+struct tracepoint_func {
+	void *func;
+	void *data;
+	int prio;
+};
+
+struct tracepoint {
+	const char *name;
+	struct static_key key;
+	struct static_call_key *static_call_key;
+	void *static_call_tramp;
+	void *iterator;
+	void *probestub;
+	int (*regfunc)();
+	void (*unregfunc)();
+	struct tracepoint_func *funcs;
+};
+
+struct bpf_raw_event_map {
+	struct tracepoint *tp;
+	void *bpf_func;
+	u32 num_args;
+	u32 writable_size;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct dev_pagemap_ops {
+	void (*page_free)(struct page *);
+	vm_fault_t (*migrate_to_ram)(struct vm_fault *);
+	int (*memory_failure)(struct dev_pagemap *, long unsigned int, long unsigned int, int);
+};
+
+struct kernfs_root;
+
+struct kernfs_elem_dir {
+	long unsigned int subdirs;
+	struct rb_root children;
+	struct kernfs_root *root;
+	long unsigned int rev;
+};
+
+struct kernfs_elem_symlink {
+	struct kernfs_node *target_kn;
+};
+
+struct kernfs_ops;
+
+struct kernfs_open_node;
+
+struct kernfs_elem_attr {
+	const struct kernfs_ops *ops;
+	struct kernfs_open_node *open;
+	loff_t size;
+	struct kernfs_node *notify_next;
+	long: 32;
+};
+
+struct kernfs_iattrs;
+
+struct kernfs_node {
+	atomic_t count;
+	atomic_t active;
+	struct kernfs_node *parent;
+	const char *name;
+	struct rb_node rb;
+	const void *ns;
+	unsigned int hash;
+	short unsigned int flags;
+	umode_t mode;
+	union {
+		struct kernfs_elem_dir dir;
+		struct kernfs_elem_symlink symlink;
+		struct kernfs_elem_attr attr;
+	};
+	u64 id;
+	void *priv;
+	struct kernfs_iattrs *iattr;
+	struct callback_head rcu;
+};
+
+struct kernfs_open_file;
+
+struct kernfs_ops {
+	int (*open)(struct kernfs_open_file *);
+	void (*release)(struct kernfs_open_file *);
+	int (*seq_show)(struct seq_file *, void *);
+	void * (*seq_start)(struct seq_file *, loff_t *);
+	void * (*seq_next)(struct seq_file *, void *, loff_t *);
+	void (*seq_stop)(struct seq_file *, void *);
+	ssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);
+	size_t atomic_write_len;
+	bool prealloc;
+	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
+	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
+	int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);
+	loff_t (*llseek)(struct kernfs_open_file *, loff_t, int);
+};
+
+struct kernfs_open_file {
+	struct kernfs_node *kn;
+	struct file *file;
+	struct seq_file *seq_file;
+	void *priv;
+	struct mutex mutex;
+	struct mutex prealloc_mutex;
+	int event;
+	struct list_head list;
+	char *prealloc_buf;
+	size_t atomic_write_len;
+	bool mmapped: 1;
+	bool released: 1;
+	const struct vm_operations_struct *vm_ops;
+};
+
+enum kobj_ns_type {
+	KOBJ_NS_TYPE_NONE = 0,
+	KOBJ_NS_TYPE_NET = 1,
+	KOBJ_NS_TYPES = 2,
+};
+
+struct sock;
+
+struct kobj_ns_type_operations {
+	enum kobj_ns_type type;
+	bool (*current_may_mount)();
+	void * (*grab_current_ns)();
+	const void * (*netlink_ns)(struct sock *);
+	const void * (*initial_ns)();
+	void (*drop_ns)(void *);
+};
+
+struct attribute {
+	const char *name;
+	umode_t mode;
+};
+
+struct bin_attribute;
+
+struct attribute_group {
+	const char *name;
+	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
+	umode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int);
+	struct attribute **attrs;
+	struct bin_attribute **bin_attrs;
+};
+
+struct bin_attribute {
+	struct attribute attr;
+	size_t size;
+	void *private;
+	struct address_space * (*f_mapping)();
+	ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
+	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
+	loff_t (*llseek)(struct file *, struct kobject *, struct bin_attribute *, loff_t, int);
+	int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *);
+};
+
+struct sysfs_ops {
+	ssize_t (*show)(struct kobject *, struct attribute *, char *);
+	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
+};
+
+struct kset_uevent_ops;
+
+struct kset {
+	struct list_head list;
+	spinlock_t list_lock;
+	struct kobject kobj;
+	const struct kset_uevent_ops *uevent_ops;
+};
+
+struct kobj_type {
+	void (*release)(struct kobject *);
+	const struct sysfs_ops *sysfs_ops;
+	const struct attribute_group **default_groups;
+	const struct kobj_ns_type_operations * (*child_ns_type)(const struct kobject *);
+	const void * (*namespace)(const struct kobject *);
+	void (*get_ownership)(const struct kobject *, kuid_t *, kgid_t *);
+};
+
+struct kobj_uevent_env {
+	char *argv[3];
+	char *envp[64];
+	int envp_idx;
+	char buf[2048];
+	int buflen;
+};
+
+struct kset_uevent_ops {
+	int (* const filter)(const struct kobject *);
+	const char * (* const name)(const struct kobject *);
+	int (* const uevent)(const struct kobject *, struct kobj_uevent_env *);
+};
+
+enum dev_dma_attr {
+	DEV_DMA_NOT_SUPPORTED = 0,
+	DEV_DMA_NON_COHERENT = 1,
+	DEV_DMA_COHERENT = 2,
+};
+
+struct fwnode_operations;
+
+struct fwnode_handle {
+	struct fwnode_handle *secondary;
+	const struct fwnode_operations *ops;
+	struct device *dev;
+	struct list_head suppliers;
+	struct list_head consumers;
+	u8 flags;
+};
+
+struct fwnode_reference_args;
+
+struct fwnode_endpoint;
+
+struct fwnode_operations {
+	struct fwnode_handle * (*get)(struct fwnode_handle *);
+	void (*put)(struct fwnode_handle *);
+	bool (*device_is_available)(const struct fwnode_handle *);
+	const void * (*device_get_match_data)(const struct fwnode_handle *, const struct device *);
+	bool (*device_dma_supported)(const struct fwnode_handle *);
+	enum dev_dma_attr (*device_get_dma_attr)(const struct fwnode_handle *);
+	bool (*property_present)(const struct fwnode_handle *, const char *);
+	int (*property_read_int_array)(const struct fwnode_handle *, const char *, unsigned int, void *, size_t);
+	int (*property_read_string_array)(const struct fwnode_handle *, const char *, const char **, size_t);
+	const char * (*get_name)(const struct fwnode_handle *);
+	const char * (*get_name_prefix)(const struct fwnode_handle *);
+	struct fwnode_handle * (*get_parent)(const struct fwnode_handle *);
+	struct fwnode_handle * (*get_next_child_node)(const struct fwnode_handle *, struct fwnode_handle *);
+	struct fwnode_handle * (*get_named_child_node)(const struct fwnode_handle *, const char *);
+	int (*get_reference_args)(const struct fwnode_handle *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args *);
+	struct fwnode_handle * (*graph_get_next_endpoint)(const struct fwnode_handle *, struct fwnode_handle *);
+	struct fwnode_handle * (*graph_get_remote_endpoint)(const struct fwnode_handle *);
+	struct fwnode_handle * (*graph_get_port_parent)(struct fwnode_handle *);
+	int (*graph_parse_endpoint)(const struct fwnode_handle *, struct fwnode_endpoint *);
+	void * (*iomap)(struct fwnode_handle *, int);
+	int (*irq_get)(const struct fwnode_handle *, unsigned int);
+	int (*add_links)(struct fwnode_handle *);
+};
+
+struct fwnode_endpoint {
+	unsigned int port;
+	unsigned int id;
+	const struct fwnode_handle *local_fwnode;
+};
+
+struct fwnode_reference_args {
+	struct fwnode_handle *fwnode;
+	unsigned int nargs;
+	u64 args[8];
+};
+
+enum fixed_addresses {
+	FIX_EARLYCON_MEM_BASE = 0,
+	__end_of_permanent_fixed_addresses = 1,
+	FIX_KMAP_BEGIN = 1,
+	FIX_KMAP_END = 32,
+	FIX_TEXT_POKE0 = 33,
+	FIX_TEXT_POKE1 = 34,
+	__end_of_fixmap_region = 35,
+	FIX_BTMAP_END = 1,
+	FIX_BTMAP_BEGIN = 224,
+	__end_of_early_ioremap_region = 225,
+};
+
+struct dev_pm_ops {
+	int (*prepare)(struct device *);
+	void (*complete)(struct device *);
+	int (*suspend)(struct device *);
+	int (*resume)(struct device *);
+	int (*freeze)(struct device *);
+	int (*thaw)(struct device *);
+	int (*poweroff)(struct device *);
+	int (*restore)(struct device *);
+	int (*suspend_late)(struct device *);
+	int (*resume_early)(struct device *);
+	int (*freeze_late)(struct device *);
+	int (*thaw_early)(struct device *);
+	int (*poweroff_late)(struct device *);
+	int (*restore_early)(struct device *);
+	int (*suspend_noirq)(struct device *);
+	int (*resume_noirq)(struct device *);
+	int (*freeze_noirq)(struct device *);
+	int (*thaw_noirq)(struct device *);
+	int (*poweroff_noirq)(struct device *);
+	int (*restore_noirq)(struct device *);
+	int (*runtime_suspend)(struct device *);
+	int (*runtime_resume)(struct device *);
+	int (*runtime_idle)(struct device *);
+};
+
+struct pm_subsys_data {
+	spinlock_t lock;
+	unsigned int refcount;
+};
+
+struct dev_pm_domain {
+	struct dev_pm_ops ops;
+	int (*start)(struct device *);
+	void (*detach)(struct device *, bool);
+	int (*activate)(struct device *);
+	void (*sync)(struct device *);
+	void (*dismiss)(struct device *);
+	int (*set_performance_state)(struct device *, unsigned int);
+};
+
+struct bus_type {
+	const char *name;
+	const char *dev_name;
+	const struct attribute_group **bus_groups;
+	const struct attribute_group **dev_groups;
+	const struct attribute_group **drv_groups;
+	int (*match)(struct device *, const struct device_driver *);
+	int (*uevent)(const struct device *, struct kobj_uevent_env *);
+	int (*probe)(struct device *);
+	void (*sync_state)(struct device *);
+	void (*remove)(struct device *);
+	void (*shutdown)(struct device *);
+	int (*online)(struct device *);
+	int (*offline)(struct device *);
+	int (*suspend)(struct device *, pm_message_t);
+	int (*resume)(struct device *);
+	int (*num_vf)(struct device *);
+	int (*dma_configure)(struct device *);
+	void (*dma_cleanup)(struct device *);
+	const struct dev_pm_ops *pm;
+	bool need_parent_lock;
+};
+
+enum probe_type {
+	PROBE_DEFAULT_STRATEGY = 0,
+	PROBE_PREFER_ASYNCHRONOUS = 1,
+	PROBE_FORCE_SYNCHRONOUS = 2,
+};
+
+struct of_device_id;
+
+struct acpi_device_id;
+
+struct driver_private;
+
+struct device_driver {
+	const char *name;
+	const struct bus_type *bus;
+	struct module *owner;
+	const char *mod_name;
+	bool suppress_bind_attrs;
+	enum probe_type probe_type;
+	const struct of_device_id *of_match_table;
+	const struct acpi_device_id *acpi_match_table;
+	int (*probe)(struct device *);
+	void (*sync_state)(struct device *);
+	int (*remove)(struct device *);
+	void (*shutdown)(struct device *);
+	int (*suspend)(struct device *, pm_message_t);
+	int (*resume)(struct device *);
+	const struct attribute_group **groups;
+	const struct attribute_group **dev_groups;
+	const struct dev_pm_ops *pm;
+	void (*coredump)(struct device *);
+	struct driver_private *p;
+};
+
+struct class {
+	const char *name;
+	const struct attribute_group **class_groups;
+	const struct attribute_group **dev_groups;
+	int (*dev_uevent)(const struct device *, struct kobj_uevent_env *);
+	char * (*devnode)(const struct device *, umode_t *);
+	void (*class_release)(const struct class *);
+	void (*dev_release)(struct device *);
+	int (*shutdown_pre)(struct device *);
+	const struct kobj_ns_type_operations *ns_type;
+	const void * (*namespace)(const struct device *);
+	void (*get_ownership)(const struct device *, kuid_t *, kgid_t *);
+	const struct dev_pm_ops *pm;
+};
+
+struct device_type {
+	const char *name;
+	const struct attribute_group **groups;
+	int (*uevent)(const struct device *, struct kobj_uevent_env *);
+	char * (*devnode)(const struct device *, umode_t *, kuid_t *, kgid_t *);
+	void (*release)(struct device *);
+	const struct dev_pm_ops *pm;
+};
+
+typedef __u32 Elf32_Addr;
+
+typedef __u16 Elf32_Half;
+
+typedef __u32 Elf32_Word;
+
+struct elf32_sym {
+	Elf32_Word st_name;
+	Elf32_Addr st_value;
+	Elf32_Word st_size;
+	unsigned char st_info;
+	unsigned char st_other;
+	Elf32_Half st_shndx;
+};
+
+struct kernel_param_ops {
+	unsigned int flags;
+	int (*set)(const char *, const struct kernel_param *);
+	int (*get)(char *, const struct kernel_param *);
+	void (*free)(void *);
+};
+
+struct kparam_string;
+
+struct kparam_array;
+
+struct kernel_param {
+	const char *name;
+	struct module *mod;
+	const struct kernel_param_ops *ops;
+	const u16 perm;
+	s8 level;
+	u8 flags;
+	union {
+		void *arg;
+		const struct kparam_string *str;
+		const struct kparam_array *arr;
+	};
+};
+
+struct kparam_string {
+	unsigned int maxlen;
+	char *string;
+};
+
+struct kparam_array {
+	unsigned int max;
+	unsigned int elemsize;
+	unsigned int *num;
+	const struct kernel_param_ops *ops;
+	void *elem;
+};
+
+struct unwind_idx {
+	long unsigned int addr_offset;
+	long unsigned int insn;
+};
+
+struct unwind_table {
+	struct list_head list;
+	struct list_head mod_list;
+	const struct unwind_idx *start;
+	const struct unwind_idx *origin;
+	const struct unwind_idx *stop;
+	long unsigned int begin_addr;
+	long unsigned int end_addr;
+};
+
+struct module_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *);
+	ssize_t (*store)(struct module_attribute *, struct module_kobject *, const char *, size_t);
+	void (*setup)(struct module *, const char *);
+	int (*test)(struct module *);
+	void (*free)(struct module *);
+};
+
+struct kernel_symbol {
+	long unsigned int value;
+	const char *name;
+	const char *namespace;
+};
+
+struct trace_event_functions;
+
+struct trace_event {
+	struct hlist_node node;
+	int type;
+	struct trace_event_functions *funcs;
+};
+
+struct trace_event_class;
+
+struct trace_event_call {
+	struct list_head list;
+	struct trace_event_class *class;
+	union {
+		char *name;
+		struct tracepoint *tp;
+	};
+	struct trace_event event;
+	char *print_fmt;
+	struct event_filter *filter;
+	union {
+		void *module;
+		atomic_t refcnt;
+	};
+	void *data;
+	int flags;
+	int perf_refcount;
+	struct hlist_head *perf_events;
+	struct bpf_prog_array *prog_array;
+	int (*perf_perm)(struct trace_event_call *, struct perf_event *);
+};
+
+struct trace_eval_map {
+	const char *system;
+	const char *eval_string;
+	long unsigned int eval_value;
+};
+
+struct of_device_id {
+	char name[32];
+	char type[32];
+	char compatible[128];
+	const void *data;
+};
+
+typedef long unsigned int kernel_ulong_t;
+
+struct acpi_device_id {
+	__u8 id[16];
+	kernel_ulong_t driver_data;
+	__u32 cls;
+	__u32 cls_msk;
+};
+
+struct device_dma_parameters {
+	unsigned int max_segment_size;
+	unsigned int min_align_mask;
+	long unsigned int segment_boundary_mask;
+};
+
+enum device_physical_location_panel {
+	DEVICE_PANEL_TOP = 0,
+	DEVICE_PANEL_BOTTOM = 1,
+	DEVICE_PANEL_LEFT = 2,
+	DEVICE_PANEL_RIGHT = 3,
+	DEVICE_PANEL_FRONT = 4,
+	DEVICE_PANEL_BACK = 5,
+	DEVICE_PANEL_UNKNOWN = 6,
+};
+
+enum device_physical_location_vertical_position {
+	DEVICE_VERT_POS_UPPER = 0,
+	DEVICE_VERT_POS_CENTER = 1,
+	DEVICE_VERT_POS_LOWER = 2,
+};
+
+enum device_physical_location_horizontal_position {
+	DEVICE_HORI_POS_LEFT = 0,
+	DEVICE_HORI_POS_CENTER = 1,
+	DEVICE_HORI_POS_RIGHT = 2,
+};
+
+struct device_physical_location {
+	enum device_physical_location_panel panel;
+	enum device_physical_location_vertical_position vertical_position;
+	enum device_physical_location_horizontal_position horizontal_position;
+	bool dock;
+	bool lid;
+};
+
+typedef u32 dma_addr_t;
+
+enum dma_data_direction {
+	DMA_BIDIRECTIONAL = 0,
+	DMA_TO_DEVICE = 1,
+	DMA_FROM_DEVICE = 2,
+	DMA_NONE = 3,
+};
+
+struct sg_table;
+
+struct scatterlist;
+
+struct dma_map_ops {
+	void * (*alloc)(struct device *, size_t, dma_addr_t *, gfp_t, long unsigned int);
+	void (*free)(struct device *, size_t, void *, dma_addr_t, long unsigned int);
+	struct page * (*alloc_pages_op)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
+	void (*free_pages)(struct device *, size_t, struct page *, dma_addr_t, enum dma_data_direction);
+	int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t, size_t, long unsigned int);
+	int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t, size_t, long unsigned int);
+	dma_addr_t (*map_page)(struct device *, struct page *, long unsigned int, size_t, enum dma_data_direction, long unsigned int);
+	void (*unmap_page)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
+	int (*map_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
+	void (*unmap_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
+	dma_addr_t (*map_resource)(struct device *, phys_addr_t, size_t, enum dma_data_direction, long unsigned int);
+	void (*unmap_resource)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
+	void (*sync_single_for_cpu)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
+	void (*sync_single_for_device)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
+	void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int, enum dma_data_direction);
+	void (*sync_sg_for_device)(struct device *, struct scatterlist *, int, enum dma_data_direction);
+	void (*cache_sync)(struct device *, void *, size_t, enum dma_data_direction);
+	int (*dma_supported)(struct device *, u64);
+	u64 (*get_required_mask)(struct device *);
+	size_t (*max_mapping_size)(struct device *);
+	size_t (*opt_mapping_size)();
+	long unsigned int (*get_merge_boundary)(struct device *);
+};
+
+struct bus_dma_region {
+	phys_addr_t cpu_start;
+	dma_addr_t dma_start;
+	u64 size;
+};
+
+struct blk_holder_ops {
+	void (*mark_dead)(struct block_device *, bool);
+	void (*sync)(struct block_device *);
+	int (*freeze)(struct block_device *);
+	int (*thaw)(struct block_device *);
+};
+
+struct partition_meta_info {
+	char uuid[37];
+	u8 volname[64];
+};
+
+struct kvec {
+	void *iov_base;
+	size_t iov_len;
+};
+
+struct folio_queue {
+	struct folio_batch vec;
+	u8 orders[31];
+	struct folio_queue *next;
+	struct folio_queue *prev;
+	long unsigned int marks;
+	long unsigned int marks2;
+	long unsigned int marks3;
+};
+
+struct blk_zone {
+	__u64 start;
+	__u64 len;
+	__u64 wp;
+	__u8 type;
+	__u8 cond;
+	__u8 non_seq;
+	__u8 reset;
+	__u8 resv[4];
+	__u64 capacity;
+	__u8 reserved[24];
+};
+
+typedef int (*report_zones_cb)(struct blk_zone *, unsigned int, void *);
+
+enum blk_unique_id {
+	BLK_UID_T10 = 1,
+	BLK_UID_EUI64 = 2,
+	BLK_UID_NAA = 3,
+};
+
+struct hd_geometry;
+
+struct pr_ops;
+
+struct block_device_operations {
+	void (*submit_bio)(struct bio *);
+	int (*poll_bio)(struct bio *, struct io_comp_batch *, unsigned int);
+	int (*open)(struct gendisk *, blk_mode_t);
+	void (*release)(struct gendisk *);
+	int (*ioctl)(struct block_device *, blk_mode_t, unsigned int, long unsigned int);
+	int (*compat_ioctl)(struct block_device *, blk_mode_t, unsigned int, long unsigned int);
+	unsigned int (*check_events)(struct gendisk *, unsigned int);
+	void (*unlock_native_capacity)(struct gendisk *);
+	int (*getgeo)(struct block_device *, struct hd_geometry *);
+	int (*set_read_only)(struct block_device *, bool);
+	void (*free_disk)(struct gendisk *);
+	void (*swap_slot_free_notify)(struct block_device *, long unsigned int);
+	int (*report_zones)(struct gendisk *, sector_t, unsigned int, report_zones_cb, void *);
+	char * (*devnode)(struct gendisk *, umode_t *);
+	int (*get_unique_id)(struct gendisk *, u8 *, enum blk_unique_id);
+	struct module *owner;
+	const struct pr_ops *pr_ops;
+	int (*alternative_gpt_sector)(struct gendisk *, sector_t *);
+};
+
+struct blk_independent_access_range {
+	struct kobject kobj;
+	long: 32;
+	sector_t sector;
+	sector_t nr_sectors;
+};
+
+struct blk_independent_access_ranges {
+	struct kobject kobj;
+	bool sysfs_registered;
+	unsigned int nr_ia_ranges;
+	long: 32;
+	struct blk_independent_access_range ia_range[0];
+};
+
+enum blk_eh_timer_return {
+	BLK_EH_DONE = 0,
+	BLK_EH_RESET_TIMER = 1,
+};
+
+struct blk_mq_hw_ctx;
+
+struct blk_mq_queue_data;
+
+struct blk_mq_ops {
+	blk_status_t (*queue_rq)(struct blk_mq_hw_ctx *, const struct blk_mq_queue_data *);
+	void (*commit_rqs)(struct blk_mq_hw_ctx *);
+	void (*queue_rqs)(struct request **);
+	int (*get_budget)(struct request_queue *);
+	void (*put_budget)(struct request_queue *, int);
+	void (*set_rq_budget_token)(struct request *, int);
+	int (*get_rq_budget_token)(struct request *);
+	enum blk_eh_timer_return (*timeout)(struct request *);
+	int (*poll)(struct blk_mq_hw_ctx *, struct io_comp_batch *);
+	void (*complete)(struct request *);
+	int (*init_hctx)(struct blk_mq_hw_ctx *, void *, unsigned int);
+	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
+	int (*init_request)(struct blk_mq_tag_set *, struct request *, unsigned int, unsigned int);
+	void (*exit_request)(struct blk_mq_tag_set *, struct request *, unsigned int);
+	void (*cleanup_rq)(struct request *);
+	bool (*busy)(struct request_queue *);
+	void (*map_queues)(struct blk_mq_tag_set *);
+};
+
+enum pr_type {
+	PR_WRITE_EXCLUSIVE = 1,
+	PR_EXCLUSIVE_ACCESS = 2,
+	PR_WRITE_EXCLUSIVE_REG_ONLY = 3,
+	PR_EXCLUSIVE_ACCESS_REG_ONLY = 4,
+	PR_WRITE_EXCLUSIVE_ALL_REGS = 5,
+	PR_EXCLUSIVE_ACCESS_ALL_REGS = 6,
+};
+
+struct pr_keys;
+
+struct pr_held_reservation;
+
+struct pr_ops {
+	int (*pr_register)(struct block_device *, u64, u64, u32);
+	int (*pr_reserve)(struct block_device *, u64, enum pr_type, u32);
+	int (*pr_release)(struct block_device *, u64, enum pr_type);
+	int (*pr_preempt)(struct block_device *, u64, u64, enum pr_type, bool);
+	int (*pr_clear)(struct block_device *, u64);
+	int (*pr_read_keys)(struct block_device *, struct pr_keys *);
+	int (*pr_read_reservation)(struct block_device *, struct pr_held_reservation *);
+};
+
+struct seq_operations {
+	void * (*start)(struct seq_file *, loff_t *);
+	void (*stop)(struct seq_file *, void *);
+	void * (*next)(struct seq_file *, void *, loff_t *);
+	int (*show)(struct seq_file *, void *);
+};
+
+struct seq_buf {
+	char *buffer;
+	size_t size;
+	size_t len;
+};
+
+struct trace_seq {
+	char buffer[8172];
+	struct seq_buf seq;
+	size_t readpos;
+	int full;
+};
+
+enum perf_sw_ids {
+	PERF_COUNT_SW_CPU_CLOCK = 0,
+	PERF_COUNT_SW_TASK_CLOCK = 1,
+	PERF_COUNT_SW_PAGE_FAULTS = 2,
+	PERF_COUNT_SW_CONTEXT_SWITCHES = 3,
+	PERF_COUNT_SW_CPU_MIGRATIONS = 4,
+	PERF_COUNT_SW_PAGE_FAULTS_MIN = 5,
+	PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,
+	PERF_COUNT_SW_ALIGNMENT_FAULTS = 7,
+	PERF_COUNT_SW_EMULATION_FAULTS = 8,
+	PERF_COUNT_SW_DUMMY = 9,
+	PERF_COUNT_SW_BPF_OUTPUT = 10,
+	PERF_COUNT_SW_CGROUP_SWITCHES = 11,
+	PERF_COUNT_SW_MAX = 12,
+};
+
+union perf_mem_data_src {
+	__u64 val;
+	struct {
+		__u64 mem_op: 5;
+		__u64 mem_lvl: 14;
+		__u64 mem_snoop: 5;
+		__u64 mem_lock: 2;
+		__u64 mem_dtlb: 7;
+		__u64 mem_lvl_num: 4;
+		__u64 mem_remote: 1;
+		__u64 mem_snoopx: 2;
+		__u64 mem_blk: 3;
+		__u64 mem_hops: 3;
+		__u64 mem_rsvd: 18;
+	};
+};
+
+struct perf_branch_entry {
+	__u64 from;
+	__u64 to;
+	__u64 mispred: 1;
+	__u64 predicted: 1;
+	__u64 in_tx: 1;
+	__u64 abort: 1;
+	__u64 cycles: 16;
+	__u64 type: 4;
+	__u64 spec: 2;
+	__u64 new_type: 4;
+	__u64 priv: 3;
+	__u64 reserved: 31;
+};
+
+union perf_sample_weight {
+	__u64 full;
+	struct {
+		__u32 var1_dw;
+		__u16 var2_w;
+		__u16 var3_w;
+	};
+};
+
+struct cgroup_namespace {
+	struct ns_common ns;
+	struct user_namespace *user_ns;
+	struct ucounts *ucounts;
+	struct css_set *root_cset;
+};
+
+struct nsset;
+
+struct proc_ns_operations {
+	const char *name;
+	const char *real_ns_name;
+	int type;
+	struct ns_common * (*get)(struct task_struct *);
+	void (*put)(struct ns_common *);
+	int (*install)(struct nsset *, struct ns_common *);
+	struct user_namespace * (*owner)(struct ns_common *);
+	struct ns_common * (*get_parent)(struct ns_common *);
+};
+
+struct perf_regs {
+	__u64 abi;
+	struct pt_regs *regs;
+	long: 32;
+};
+
+struct u64_stats_sync {
+	seqcount_t seq;
+};
+
+struct bpf_cgroup_storage;
+
+struct bpf_prog_array_item {
+	struct bpf_prog *prog;
+	long: 32;
+	union {
+		struct bpf_cgroup_storage *cgroup_storage[2];
+		u64 bpf_cookie;
+	};
+};
+
+struct bpf_prog_array {
+	struct callback_head rcu;
+	struct bpf_prog_array_item items[0];
+};
+
+struct psi_group {};
+
+struct cgroup_taskset;
+
+struct cftype;
+
+struct cgroup_subsys {
+	struct cgroup_subsys_state * (*css_alloc)(struct cgroup_subsys_state *);
+	int (*css_online)(struct cgroup_subsys_state *);
+	void (*css_offline)(struct cgroup_subsys_state *);
+	void (*css_released)(struct cgroup_subsys_state *);
+	void (*css_free)(struct cgroup_subsys_state *);
+	void (*css_reset)(struct cgroup_subsys_state *);
+	void (*css_rstat_flush)(struct cgroup_subsys_state *, int);
+	int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
+	int (*css_local_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
+	int (*can_attach)(struct cgroup_taskset *);
+	void (*cancel_attach)(struct cgroup_taskset *);
+	void (*attach)(struct cgroup_taskset *);
+	void (*post_attach)();
+	int (*can_fork)(struct task_struct *, struct css_set *);
+	void (*cancel_fork)(struct task_struct *, struct css_set *);
+	void (*fork)(struct task_struct *);
+	void (*exit)(struct task_struct *);
+	void (*release)(struct task_struct *);
+	void (*bind)(struct cgroup_subsys_state *);
+	bool early_init: 1;
+	bool implicit_on_dfl: 1;
+	bool threaded: 1;
+	int id;
+	const char *name;
+	const char *legacy_name;
+	struct cgroup_root *root;
+	struct idr css_idr;
+	struct list_head cfts;
+	struct cftype *dfl_cftypes;
+	struct cftype *legacy_cftypes;
+	unsigned int depends_on;
+};
+
+struct cgroup_rstat_cpu {
+	struct u64_stats_sync bsync;
+	long: 32;
+	struct cgroup_base_stat bstat;
+	struct cgroup_base_stat last_bstat;
+	struct cgroup_base_stat subtree_bstat;
+	struct cgroup_base_stat last_subtree_bstat;
+	struct cgroup *updated_children;
+	struct cgroup *updated_next;
+};
+
+struct cgroup_root {
+	struct kernfs_root *kf_root;
+	unsigned int subsys_mask;
+	int hierarchy_id;
+	struct list_head root_list;
+	struct callback_head rcu;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct cgroup cgrp;
+	struct cgroup *cgrp_ancestor_storage;
+	atomic_t nr_cgrps;
+	unsigned int flags;
+	char release_agent_path[4096];
+	char name[64];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct cftype {
+	char name[64];
+	long unsigned int private;
+	size_t max_write_len;
+	unsigned int flags;
+	unsigned int file_offset;
+	struct cgroup_subsys *ss;
+	struct list_head node;
+	struct kernfs_ops *kf_ops;
+	int (*open)(struct kernfs_open_file *);
+	void (*release)(struct kernfs_open_file *);
+	u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *);
+	s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *);
+	int (*seq_show)(struct seq_file *, void *);
+	void * (*seq_start)(struct seq_file *, loff_t *);
+	void * (*seq_next)(struct seq_file *, void *, loff_t *);
+	void (*seq_stop)(struct seq_file *, void *);
+	int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64);
+	int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64);
+	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
+	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
+	struct lock_class_key lockdep_key;
+};
+
+struct bpf_insn {
+	__u8 code;
+	__u8 dst_reg: 4;
+	__u8 src_reg: 4;
+	__s16 off;
+	__s32 imm;
+};
+
+enum bpf_cgroup_iter_order {
+	BPF_CGROUP_ITER_ORDER_UNSPEC = 0,
+	BPF_CGROUP_ITER_SELF_ONLY = 1,
+	BPF_CGROUP_ITER_DESCENDANTS_PRE = 2,
+	BPF_CGROUP_ITER_DESCENDANTS_POST = 3,
+	BPF_CGROUP_ITER_ANCESTORS_UP = 4,
+};
+
+enum bpf_map_type {
+	BPF_MAP_TYPE_UNSPEC = 0,
+	BPF_MAP_TYPE_HASH = 1,
+	BPF_MAP_TYPE_ARRAY = 2,
+	BPF_MAP_TYPE_PROG_ARRAY = 3,
+	BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
+	BPF_MAP_TYPE_PERCPU_HASH = 5,
+	BPF_MAP_TYPE_PERCPU_ARRAY = 6,
+	BPF_MAP_TYPE_STACK_TRACE = 7,
+	BPF_MAP_TYPE_CGROUP_ARRAY = 8,
+	BPF_MAP_TYPE_LRU_HASH = 9,
+	BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
+	BPF_MAP_TYPE_LPM_TRIE = 11,
+	BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
+	BPF_MAP_TYPE_HASH_OF_MAPS = 13,
+	BPF_MAP_TYPE_DEVMAP = 14,
+	BPF_MAP_TYPE_SOCKMAP = 15,
+	BPF_MAP_TYPE_CPUMAP = 16,
+	BPF_MAP_TYPE_XSKMAP = 17,
+	BPF_MAP_TYPE_SOCKHASH = 18,
+	BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED = 19,
+	BPF_MAP_TYPE_CGROUP_STORAGE = 19,
+	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
+	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE_DEPRECATED = 21,
+	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
+	BPF_MAP_TYPE_QUEUE = 22,
+	BPF_MAP_TYPE_STACK = 23,
+	BPF_MAP_TYPE_SK_STORAGE = 24,
+	BPF_MAP_TYPE_DEVMAP_HASH = 25,
+	BPF_MAP_TYPE_STRUCT_OPS = 26,
+	BPF_MAP_TYPE_RINGBUF = 27,
+	BPF_MAP_TYPE_INODE_STORAGE = 28,
+	BPF_MAP_TYPE_TASK_STORAGE = 29,
+	BPF_MAP_TYPE_BLOOM_FILTER = 30,
+	BPF_MAP_TYPE_USER_RINGBUF = 31,
+	BPF_MAP_TYPE_CGRP_STORAGE = 32,
+	BPF_MAP_TYPE_ARENA = 33,
+	__MAX_BPF_MAP_TYPE = 34,
+};
+
+enum bpf_prog_type {
+	BPF_PROG_TYPE_UNSPEC = 0,
+	BPF_PROG_TYPE_SOCKET_FILTER = 1,
+	BPF_PROG_TYPE_KPROBE = 2,
+	BPF_PROG_TYPE_SCHED_CLS = 3,
+	BPF_PROG_TYPE_SCHED_ACT = 4,
+	BPF_PROG_TYPE_TRACEPOINT = 5,
+	BPF_PROG_TYPE_XDP = 6,
+	BPF_PROG_TYPE_PERF_EVENT = 7,
+	BPF_PROG_TYPE_CGROUP_SKB = 8,
+	BPF_PROG_TYPE_CGROUP_SOCK = 9,
+	BPF_PROG_TYPE_LWT_IN = 10,
+	BPF_PROG_TYPE_LWT_OUT = 11,
+	BPF_PROG_TYPE_LWT_XMIT = 12,
+	BPF_PROG_TYPE_SOCK_OPS = 13,
+	BPF_PROG_TYPE_SK_SKB = 14,
+	BPF_PROG_TYPE_CGROUP_DEVICE = 15,
+	BPF_PROG_TYPE_SK_MSG = 16,
+	BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
+	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
+	BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
+	BPF_PROG_TYPE_LIRC_MODE2 = 20,
+	BPF_PROG_TYPE_SK_REUSEPORT = 21,
+	BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
+	BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
+	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
+	BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
+	BPF_PROG_TYPE_TRACING = 26,
+	BPF_PROG_TYPE_STRUCT_OPS = 27,
+	BPF_PROG_TYPE_EXT = 28,
+	BPF_PROG_TYPE_LSM = 29,
+	BPF_PROG_TYPE_SK_LOOKUP = 30,
+	BPF_PROG_TYPE_SYSCALL = 31,
+	BPF_PROG_TYPE_NETFILTER = 32,
+	__MAX_BPF_PROG_TYPE = 33,
+};
+
+enum bpf_attach_type {
+	BPF_CGROUP_INET_INGRESS = 0,
+	BPF_CGROUP_INET_EGRESS = 1,
+	BPF_CGROUP_INET_SOCK_CREATE = 2,
+	BPF_CGROUP_SOCK_OPS = 3,
+	BPF_SK_SKB_STREAM_PARSER = 4,
+	BPF_SK_SKB_STREAM_VERDICT = 5,
+	BPF_CGROUP_DEVICE = 6,
+	BPF_SK_MSG_VERDICT = 7,
+	BPF_CGROUP_INET4_BIND = 8,
+	BPF_CGROUP_INET6_BIND = 9,
+	BPF_CGROUP_INET4_CONNECT = 10,
+	BPF_CGROUP_INET6_CONNECT = 11,
+	BPF_CGROUP_INET4_POST_BIND = 12,
+	BPF_CGROUP_INET6_POST_BIND = 13,
+	BPF_CGROUP_UDP4_SENDMSG = 14,
+	BPF_CGROUP_UDP6_SENDMSG = 15,
+	BPF_LIRC_MODE2 = 16,
+	BPF_FLOW_DISSECTOR = 17,
+	BPF_CGROUP_SYSCTL = 18,
+	BPF_CGROUP_UDP4_RECVMSG = 19,
+	BPF_CGROUP_UDP6_RECVMSG = 20,
+	BPF_CGROUP_GETSOCKOPT = 21,
+	BPF_CGROUP_SETSOCKOPT = 22,
+	BPF_TRACE_RAW_TP = 23,
+	BPF_TRACE_FENTRY = 24,
+	BPF_TRACE_FEXIT = 25,
+	BPF_MODIFY_RETURN = 26,
+	BPF_LSM_MAC = 27,
+	BPF_TRACE_ITER = 28,
+	BPF_CGROUP_INET4_GETPEERNAME = 29,
+	BPF_CGROUP_INET6_GETPEERNAME = 30,
+	BPF_CGROUP_INET4_GETSOCKNAME = 31,
+	BPF_CGROUP_INET6_GETSOCKNAME = 32,
+	BPF_XDP_DEVMAP = 33,
+	BPF_CGROUP_INET_SOCK_RELEASE = 34,
+	BPF_XDP_CPUMAP = 35,
+	BPF_SK_LOOKUP = 36,
+	BPF_XDP = 37,
+	BPF_SK_SKB_VERDICT = 38,
+	BPF_SK_REUSEPORT_SELECT = 39,
+	BPF_SK_REUSEPORT_SELECT_OR_MIGRATE = 40,
+	BPF_PERF_EVENT = 41,
+	BPF_TRACE_KPROBE_MULTI = 42,
+	BPF_LSM_CGROUP = 43,
+	BPF_STRUCT_OPS = 44,
+	BPF_NETFILTER = 45,
+	BPF_TCX_INGRESS = 46,
+	BPF_TCX_EGRESS = 47,
+	BPF_TRACE_UPROBE_MULTI = 48,
+	BPF_CGROUP_UNIX_CONNECT = 49,
+	BPF_CGROUP_UNIX_SENDMSG = 50,
+	BPF_CGROUP_UNIX_RECVMSG = 51,
+	BPF_CGROUP_UNIX_GETPEERNAME = 52,
+	BPF_CGROUP_UNIX_GETSOCKNAME = 53,
+	BPF_NETKIT_PRIMARY = 54,
+	BPF_NETKIT_PEER = 55,
+	BPF_TRACE_KPROBE_SESSION = 56,
+	__MAX_BPF_ATTACH_TYPE = 57,
+};
+
+union bpf_attr {
+	struct {
+		__u32 map_type;
+		__u32 key_size;
+		__u32 value_size;
+		__u32 max_entries;
+		__u32 map_flags;
+		__u32 inner_map_fd;
+		__u32 numa_node;
+		char map_name[16];
+		__u32 map_ifindex;
+		__u32 btf_fd;
+		__u32 btf_key_type_id;
+		__u32 btf_value_type_id;
+		__u32 btf_vmlinux_value_type_id;
+		__u64 map_extra;
+		__s32 value_type_btf_obj_fd;
+		__s32 map_token_fd;
+	};
+	struct {
+		__u32 map_fd;
+		long: 32;
+		__u64 key;
+		union {
+			__u64 value;
+			__u64 next_key;
+		};
+		__u64 flags;
+	};
+	struct {
+		__u64 in_batch;
+		__u64 out_batch;
+		__u64 keys;
+		__u64 values;
+		__u32 count;
+		__u32 map_fd;
+		__u64 elem_flags;
+		__u64 flags;
+	} batch;
+	struct {
+		__u32 prog_type;
+		__u32 insn_cnt;
+		__u64 insns;
+		__u64 license;
+		__u32 log_level;
+		__u32 log_size;
+		__u64 log_buf;
+		__u32 kern_version;
+		__u32 prog_flags;
+		char prog_name[16];
+		__u32 prog_ifindex;
+		__u32 expected_attach_type;
+		__u32 prog_btf_fd;
+		__u32 func_info_rec_size;
+		__u64 func_info;
+		__u32 func_info_cnt;
+		__u32 line_info_rec_size;
+		__u64 line_info;
+		__u32 line_info_cnt;
+		__u32 attach_btf_id;
+		union {
+			__u32 attach_prog_fd;
+			__u32 attach_btf_obj_fd;
+		};
+		__u32 core_relo_cnt;
+		__u64 fd_array;
+		__u64 core_relos;
+		__u32 core_relo_rec_size;
+		__u32 log_true_size;
+		__s32 prog_token_fd;
+		long: 32;
+	};
+	struct {
+		__u64 pathname;
+		__u32 bpf_fd;
+		__u32 file_flags;
+		__s32 path_fd;
+		long: 32;
+	};
+	struct {
+		union {
+			__u32 target_fd;
+			__u32 target_ifindex;
+		};
+		__u32 attach_bpf_fd;
+		__u32 attach_type;
+		__u32 attach_flags;
+		__u32 replace_bpf_fd;
+		union {
+			__u32 relative_fd;
+			__u32 relative_id;
+		};
+		__u64 expected_revision;
+	};
+	struct {
+		__u32 prog_fd;
+		__u32 retval;
+		__u32 data_size_in;
+		__u32 data_size_out;
+		__u64 data_in;
+		__u64 data_out;
+		__u32 repeat;
+		__u32 duration;
+		__u32 ctx_size_in;
+		__u32 ctx_size_out;
+		__u64 ctx_in;
+		__u64 ctx_out;
+		__u32 flags;
+		__u32 cpu;
+		__u32 batch_size;
+		long: 32;
+	} test;
+	struct {
+		union {
+			__u32 start_id;
+			__u32 prog_id;
+			__u32 map_id;
+			__u32 btf_id;
+			__u32 link_id;
+		};
+		__u32 next_id;
+		__u32 open_flags;
+	};
+	struct {
+		__u32 bpf_fd;
+		__u32 info_len;
+		__u64 info;
+	} info;
+	struct {
+		union {
+			__u32 target_fd;
+			__u32 target_ifindex;
+		};
+		__u32 attach_type;
+		__u32 query_flags;
+		__u32 attach_flags;
+		__u64 prog_ids;
+		union {
+			__u32 prog_cnt;
+			__u32 count;
+		};
+		long: 32;
+		__u64 prog_attach_flags;
+		__u64 link_ids;
+		__u64 link_attach_flags;
+		__u64 revision;
+	} query;
+	struct {
+		__u64 name;
+		__u32 prog_fd;
+		long: 32;
+		__u64 cookie;
+	} raw_tracepoint;
+	struct {
+		__u64 btf;
+		__u64 btf_log_buf;
+		__u32 btf_size;
+		__u32 btf_log_size;
+		__u32 btf_log_level;
+		__u32 btf_log_true_size;
+		__u32 btf_flags;
+		__s32 btf_token_fd;
+	};
+	struct {
+		__u32 pid;
+		__u32 fd;
+		__u32 flags;
+		__u32 buf_len;
+		__u64 buf;
+		__u32 prog_id;
+		__u32 fd_type;
+		__u64 probe_offset;
+		__u64 probe_addr;
+	} task_fd_query;
+	struct {
+		union {
+			__u32 prog_fd;
+			__u32 map_fd;
+		};
+		union {
+			__u32 target_fd;
+			__u32 target_ifindex;
+		};
+		__u32 attach_type;
+		__u32 flags;
+		union {
+			__u32 target_btf_id;
+			struct {
+				__u64 iter_info;
+				__u32 iter_info_len;
+				long: 32;
+			};
+			struct {
+				__u64 bpf_cookie;
+			} perf_event;
+			struct {
+				__u32 flags;
+				__u32 cnt;
+				__u64 syms;
+				__u64 addrs;
+				__u64 cookies;
+			} kprobe_multi;
+			struct {
+				__u32 target_btf_id;
+				long: 32;
+				__u64 cookie;
+			} tracing;
+			struct {
+				__u32 pf;
+				__u32 hooknum;
+				__s32 priority;
+				__u32 flags;
+			} netfilter;
+			struct {
+				union {
+					__u32 relative_fd;
+					__u32 relative_id;
+				};
+				long: 32;
+				__u64 expected_revision;
+			} tcx;
+			struct {
+				__u64 path;
+				__u64 offsets;
+				__u64 ref_ctr_offsets;
+				__u64 cookies;
+				__u32 cnt;
+				__u32 flags;
+				__u32 pid;
+				long: 32;
+			} uprobe_multi;
+			struct {
+				union {
+					__u32 relative_fd;
+					__u32 relative_id;
+				};
+				long: 32;
+				__u64 expected_revision;
+			} netkit;
+		};
+	} link_create;
+	struct {
+		__u32 link_fd;
+		union {
+			__u32 new_prog_fd;
+			__u32 new_map_fd;
+		};
+		__u32 flags;
+		union {
+			__u32 old_prog_fd;
+			__u32 old_map_fd;
+		};
+	} link_update;
+	struct {
+		__u32 link_fd;
+	} link_detach;
+	struct {
+		__u32 type;
+	} enable_stats;
+	struct {
+		__u32 link_fd;
+		__u32 flags;
+	} iter_create;
+	struct {
+		__u32 prog_fd;
+		__u32 map_fd;
+		__u32 flags;
+	} prog_bind_map;
+	struct {
+		__u32 flags;
+		__u32 bpffs_fd;
+	} token_create;
+};
+
+struct bpf_func_info {
+	__u32 insn_off;
+	__u32 type_id;
+};
+
+struct bpf_line_info {
+	__u32 insn_off;
+	__u32 file_name_off;
+	__u32 line_off;
+	__u32 line_col;
+};
+
+struct sock_filter {
+	__u16 code;
+	__u8 jt;
+	__u8 jf;
+	__u32 k;
+};
+
+struct btf_type {
+	__u32 name_off;
+	__u32 info;
+	union {
+		__u32 size;
+		__u32 type;
+	};
+};
+
+struct bpf_prog_stats;
+
+struct bpf_prog_aux;
+
+struct sock_fprog_kern;
+
+struct bpf_prog {
+	u16 pages;
+	u16 jited: 1;
+	u16 jit_requested: 1;
+	u16 gpl_compatible: 1;
+	u16 cb_access: 1;
+	u16 dst_needed: 1;
+	u16 blinding_requested: 1;
+	u16 blinded: 1;
+	u16 is_func: 1;
+	u16 kprobe_override: 1;
+	u16 has_callchain_buf: 1;
+	u16 enforce_expected_attach_type: 1;
+	u16 call_get_stack: 1;
+	u16 call_get_func_ip: 1;
+	u16 tstamp_type_access: 1;
+	u16 sleepable: 1;
+	enum bpf_prog_type type;
+	enum bpf_attach_type expected_attach_type;
+	u32 len;
+	u32 jited_len;
+	u8 tag[8];
+	struct bpf_prog_stats *stats;
+	int *active;
+	unsigned int (*bpf_func)(const void *, const struct bpf_insn *);
+	struct bpf_prog_aux *aux;
+	struct sock_fprog_kern *orig_prog;
+	union {
+		struct {
+			struct {} __empty_insns;
+			struct sock_filter insns[0];
+		};
+		struct {
+			struct {} __empty_insnsi;
+			struct bpf_insn insnsi[0];
+		};
+	};
+};
+
+enum btf_field_type {
+	BPF_SPIN_LOCK = 1,
+	BPF_TIMER = 2,
+	BPF_KPTR_UNREF = 4,
+	BPF_KPTR_REF = 8,
+	BPF_KPTR_PERCPU = 16,
+	BPF_KPTR = 28,
+	BPF_LIST_HEAD = 32,
+	BPF_LIST_NODE = 64,
+	BPF_RB_ROOT = 128,
+	BPF_RB_NODE = 256,
+	BPF_GRAPH_NODE = 320,
+	BPF_GRAPH_ROOT = 160,
+	BPF_REFCOUNT = 512,
+	BPF_WORKQUEUE = 1024,
+};
+
+typedef void (*btf_dtor_kfunc_t)(void *);
+
+struct btf;
+
+struct btf_field_kptr {
+	struct btf *btf;
+	struct module *module;
+	btf_dtor_kfunc_t dtor;
+	u32 btf_id;
+};
+
+struct btf_record;
+
+struct btf_field_graph_root {
+	struct btf *btf;
+	u32 value_btf_id;
+	u32 node_offset;
+	struct btf_record *value_rec;
+};
+
+struct btf_field {
+	u32 offset;
+	u32 size;
+	enum btf_field_type type;
+	union {
+		struct btf_field_kptr kptr;
+		struct btf_field_graph_root graph_root;
+	};
+};
+
+struct btf_record {
+	u32 cnt;
+	u32 field_mask;
+	int spin_lock_off;
+	int timer_off;
+	int wq_off;
+	int refcount_off;
+	struct btf_field fields[0];
+};
+
+struct mem_cgroup_reclaim_iter {
+	struct mem_cgroup *position;
+	atomic_t generation;
+};
+
+struct lruvec_stats_percpu;
+
+struct lruvec_stats;
+
+struct mem_cgroup_per_node {
+	struct mem_cgroup *memcg;
+	struct lruvec_stats_percpu *lruvec_stats_percpu;
+	struct lruvec_stats *lruvec_stats;
+	struct shrinker_info *shrinker_info;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct cacheline_padding _pad1_;
+	struct lruvec lruvec;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct cacheline_padding _pad2_;
+	long unsigned int lru_zone_size[15];
+	struct mem_cgroup_reclaim_iter iter;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+typedef u64 (*bpf_callback_t)(u64, u64, u64, u64, u64);
+
+struct bpf_iter_aux_info;
+
+typedef int (*bpf_iter_init_seq_priv_t)(void *, struct bpf_iter_aux_info *);
+
+enum bpf_iter_task_type {
+	BPF_TASK_ITER_ALL = 0,
+	BPF_TASK_ITER_TID = 1,
+	BPF_TASK_ITER_TGID = 2,
+};
+
+struct bpf_map;
+
+struct bpf_iter_aux_info {
+	struct bpf_map *map;
+	struct {
+		struct cgroup *start;
+		enum bpf_cgroup_iter_order order;
+	} cgroup;
+	struct {
+		enum bpf_iter_task_type type;
+		u32 pid;
+	} task;
+};
+
+typedef void (*bpf_iter_fini_seq_priv_t)(void *);
+
+struct bpf_iter_seq_info {
+	const struct seq_operations *seq_ops;
+	bpf_iter_init_seq_priv_t init_seq_private;
+	bpf_iter_fini_seq_priv_t fini_seq_private;
+	u32 seq_priv_size;
+};
+
+struct bpf_local_storage_map;
+
+struct bpf_verifier_env;
+
+struct bpf_func_state;
+
+struct bpf_map_ops {
+	int (*map_alloc_check)(union bpf_attr *);
+	struct bpf_map * (*map_alloc)(union bpf_attr *);
+	void (*map_release)(struct bpf_map *, struct file *);
+	void (*map_free)(struct bpf_map *);
+	int (*map_get_next_key)(struct bpf_map *, void *, void *);
+	void (*map_release_uref)(struct bpf_map *);
+	void * (*map_lookup_elem_sys_only)(struct bpf_map *, void *);
+	int (*map_lookup_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
+	int (*map_lookup_and_delete_elem)(struct bpf_map *, void *, void *, u64);
+	int (*map_lookup_and_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
+	int (*map_update_batch)(struct bpf_map *, struct file *, const union bpf_attr *, union bpf_attr *);
+	int (*map_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
+	void * (*map_lookup_elem)(struct bpf_map *, void *);
+	long int (*map_update_elem)(struct bpf_map *, void *, void *, u64);
+	long int (*map_delete_elem)(struct bpf_map *, void *);
+	long int (*map_push_elem)(struct bpf_map *, void *, u64);
+	long int (*map_pop_elem)(struct bpf_map *, void *);
+	long int (*map_peek_elem)(struct bpf_map *, void *);
+	void * (*map_lookup_percpu_elem)(struct bpf_map *, void *, u32);
+	void * (*map_fd_get_ptr)(struct bpf_map *, struct file *, int);
+	void (*map_fd_put_ptr)(struct bpf_map *, void *, bool);
+	int (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *);
+	u32 (*map_fd_sys_lookup_elem)(void *);
+	void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *);
+	int (*map_check_btf)(const struct bpf_map *, const struct btf *, const struct btf_type *, const struct btf_type *);
+	int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *);
+	void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *);
+	void (*map_poke_run)(struct bpf_map *, u32, struct bpf_prog *, struct bpf_prog *);
+	int (*map_direct_value_addr)(const struct bpf_map *, u64 *, u32);
+	int (*map_direct_value_meta)(const struct bpf_map *, u64, u32 *);
+	int (*map_mmap)(struct bpf_map *, struct vm_area_struct *);
+	__poll_t (*map_poll)(struct bpf_map *, struct file *, struct poll_table_struct *);
+	long unsigned int (*map_get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
+	int (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);
+	void (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);
+	struct bpf_local_storage ** (*map_owner_storage_ptr)(void *);
+	long int (*map_redirect)(struct bpf_map *, u64, u64);
+	bool (*map_meta_equal)(const struct bpf_map *, const struct bpf_map *);
+	int (*map_set_for_each_callback_args)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *);
+	long int (*map_for_each_callback)(struct bpf_map *, bpf_callback_t, void *, u64);
+	u64 (*map_mem_usage)(const struct bpf_map *);
+	int *map_btf_id;
+	const struct bpf_iter_seq_info *iter_seq_info;
+};
+
+struct bpf_map {
+	const struct bpf_map_ops *ops;
+	struct bpf_map *inner_map_meta;
+	enum bpf_map_type map_type;
+	u32 key_size;
+	u32 value_size;
+	u32 max_entries;
+	u64 map_extra;
+	u32 map_flags;
+	u32 id;
+	struct btf_record *record;
+	int numa_node;
+	u32 btf_key_type_id;
+	u32 btf_value_type_id;
+	u32 btf_vmlinux_value_type_id;
+	struct btf *btf;
+	struct obj_cgroup *objcg;
+	char name[16];
+	struct mutex freeze_mutex;
+	atomic64_t refcnt;
+	atomic64_t usercnt;
+	union {
+		struct work_struct work;
+		struct callback_head rcu;
+	};
+	atomic64_t writecnt;
+	struct {
+		const struct btf_type *attach_func_proto;
+		spinlock_t lock;
+		enum bpf_prog_type type;
+		bool jited;
+		bool xdp_has_frags;
+	} owner;
+	bool bypass_spec_v1;
+	bool frozen;
+	bool free_after_mult_rcu_gp;
+	bool free_after_rcu_gp;
+	long: 32;
+	atomic64_t sleepable_refcnt;
+	s64 *elem_count;
+	long: 32;
+};
+
+struct btf_header {
+	__u16 magic;
+	__u8 version;
+	__u8 flags;
+	__u32 hdr_len;
+	__u32 type_off;
+	__u32 type_len;
+	__u32 str_off;
+	__u32 str_len;
+};
+
+struct btf_kfunc_set_tab;
+
+struct btf_id_dtor_kfunc_tab;
+
+struct btf_struct_metas;
+
+struct btf_struct_ops_tab;
+
+struct btf {
+	void *data;
+	struct btf_type **types;
+	u32 *resolved_ids;
+	u32 *resolved_sizes;
+	const char *strings;
+	void *nohdr_data;
+	struct btf_header hdr;
+	u32 nr_types;
+	u32 types_size;
+	u32 data_size;
+	refcount_t refcnt;
+	u32 id;
+	struct callback_head rcu;
+	struct btf_kfunc_set_tab *kfunc_set_tab;
+	struct btf_id_dtor_kfunc_tab *dtor_kfunc_tab;
+	struct btf_struct_metas *struct_meta_tab;
+	struct btf_struct_ops_tab *struct_ops_tab;
+	struct btf *base_btf;
+	u32 start_id;
+	u32 start_str_off;
+	char name[60];
+	bool kernel_btf;
+	__u32 *base_id_map;
+};
+
+struct bpf_arena;
+
+struct bpf_ksym {
+	long unsigned int start;
+	long unsigned int end;
+	char name[512];
+	struct list_head lnode;
+	struct latch_tree_node tnode;
+	bool prog;
+};
+
+struct bpf_ctx_arg_aux;
+
+struct bpf_trampoline;
+
+struct bpf_jit_poke_descriptor;
+
+struct bpf_kfunc_desc_tab;
+
+struct bpf_kfunc_btf_tab;
+
+struct bpf_prog_ops;
+
+struct btf_mod_pair;
+
+struct bpf_token;
+
+struct bpf_prog_offload;
+
+struct bpf_func_info_aux;
+
+struct bpf_prog_aux {
+	atomic64_t refcnt;
+	u32 used_map_cnt;
+	u32 used_btf_cnt;
+	u32 max_ctx_offset;
+	u32 max_pkt_offset;
+	u32 max_tp_access;
+	u32 stack_depth;
+	u32 id;
+	u32 func_cnt;
+	u32 real_func_cnt;
+	u32 func_idx;
+	u32 attach_btf_id;
+	u32 ctx_arg_info_size;
+	u32 max_rdonly_access;
+	u32 max_rdwr_access;
+	struct btf *attach_btf;
+	const struct bpf_ctx_arg_aux *ctx_arg_info;
+	struct mutex dst_mutex;
+	struct bpf_prog *dst_prog;
+	struct bpf_trampoline *dst_trampoline;
+	enum bpf_prog_type saved_dst_prog_type;
+	enum bpf_attach_type saved_dst_attach_type;
+	bool verifier_zext;
+	bool dev_bound;
+	bool offload_requested;
+	bool attach_btf_trace;
+	bool attach_tracing_prog;
+	bool func_proto_unreliable;
+	bool tail_call_reachable;
+	bool xdp_has_frags;
+	bool exception_cb;
+	bool exception_boundary;
+	struct bpf_arena *arena;
+	const struct btf_type *attach_func_proto;
+	const char *attach_func_name;
+	struct bpf_prog **func;
+	void *jit_data;
+	struct bpf_jit_poke_descriptor *poke_tab;
+	struct bpf_kfunc_desc_tab *kfunc_tab;
+	struct bpf_kfunc_btf_tab *kfunc_btf_tab;
+	u32 size_poke_tab;
+	struct bpf_ksym ksym;
+	const struct bpf_prog_ops *ops;
+	struct bpf_map **used_maps;
+	struct mutex used_maps_mutex;
+	struct btf_mod_pair *used_btfs;
+	struct bpf_prog *prog;
+	struct user_struct *user;
+	u64 load_time;
+	u32 verified_insns;
+	int cgroup_atype;
+	struct bpf_map *cgroup_storage[2];
+	char name[16];
+	u64 (*bpf_exception_cb)(u64, u64, u64, u64, u64);
+	struct bpf_token *token;
+	struct bpf_prog_offload *offload;
+	struct btf *btf;
+	struct bpf_func_info *func_info;
+	struct bpf_func_info_aux *func_info_aux;
+	struct bpf_line_info *linfo;
+	void **jited_linfo;
+	u32 func_info_cnt;
+	u32 nr_linfo;
+	u32 linfo_idx;
+	struct module *mod;
+	u32 num_exentries;
+	struct exception_table_entry *extable;
+	union {
+		struct work_struct work;
+		struct callback_head rcu;
+	};
+};
+
+enum bpf_reg_type {
+	NOT_INIT = 0,
+	SCALAR_VALUE = 1,
+	PTR_TO_CTX = 2,
+	CONST_PTR_TO_MAP = 3,
+	PTR_TO_MAP_VALUE = 4,
+	PTR_TO_MAP_KEY = 5,
+	PTR_TO_STACK = 6,
+	PTR_TO_PACKET_META = 7,
+	PTR_TO_PACKET = 8,
+	PTR_TO_PACKET_END = 9,
+	PTR_TO_FLOW_KEYS = 10,
+	PTR_TO_SOCKET = 11,
+	PTR_TO_SOCK_COMMON = 12,
+	PTR_TO_TCP_SOCK = 13,
+	PTR_TO_TP_BUFFER = 14,
+	PTR_TO_XDP_SOCK = 15,
+	PTR_TO_BTF_ID = 16,
+	PTR_TO_MEM = 17,
+	PTR_TO_ARENA = 18,
+	PTR_TO_BUF = 19,
+	PTR_TO_FUNC = 20,
+	CONST_PTR_TO_DYNPTR = 21,
+	__BPF_REG_TYPE_MAX = 22,
+	PTR_TO_MAP_VALUE_OR_NULL = 260,
+	PTR_TO_SOCKET_OR_NULL = 267,
+	PTR_TO_SOCK_COMMON_OR_NULL = 268,
+	PTR_TO_TCP_SOCK_OR_NULL = 269,
+	PTR_TO_BTF_ID_OR_NULL = 272,
+	__BPF_REG_TYPE_LIMIT = 134217727,
+};
+
+struct bpf_prog_ops {
+	int (*test_run)(struct bpf_prog *, const union bpf_attr *, union bpf_attr *);
+};
+
+struct net_device;
+
+struct bpf_offload_dev;
+
+struct bpf_prog_offload {
+	struct bpf_prog *prog;
+	struct net_device *netdev;
+	struct bpf_offload_dev *offdev;
+	void *dev_priv;
+	struct list_head offloads;
+	bool dev_state;
+	bool opt_failed;
+	void *jited_image;
+	u32 jited_len;
+};
+
+struct btf_func_model {
+	u8 ret_size;
+	u8 ret_flags;
+	u8 nr_args;
+	u8 arg_size[12];
+	u8 arg_flags[12];
+};
+
+struct bpf_tramp_image {
+	void *image;
+	int size;
+	struct bpf_ksym ksym;
+	struct percpu_ref pcref;
+	void *ip_after_call;
+	void *ip_epilogue;
+	union {
+		struct callback_head rcu;
+		struct work_struct work;
+	};
+};
+
+struct ftrace_ops;
+
+struct bpf_trampoline {
+	struct hlist_node hlist;
+	struct ftrace_ops *fops;
+	struct mutex mutex;
+	refcount_t refcnt;
+	u32 flags;
+	u64 key;
+	struct {
+		struct btf_func_model model;
+		void *addr;
+		bool ftrace_managed;
+	} func;
+	struct bpf_prog *extension_prog;
+	struct hlist_head progs_hlist[3];
+	int progs_cnt[3];
+	struct bpf_tramp_image *cur_image;
+	long: 32;
+};
+
+struct bpf_func_info_aux {
+	u16 linkage;
+	bool unreliable;
+	bool called: 1;
+	bool verified: 1;
+};
+
+struct bpf_jit_poke_descriptor {
+	void *tailcall_target;
+	void *tailcall_bypass;
+	void *bypass_addr;
+	void *aux;
+	union {
+		struct {
+			struct bpf_map *map;
+			u32 key;
+		} tail_call;
+	};
+	bool tailcall_target_stable;
+	u8 adj_off;
+	u16 reason;
+	u32 insn_idx;
+};
+
+struct bpf_ctx_arg_aux {
+	u32 offset;
+	enum bpf_reg_type reg_type;
+	struct btf *btf;
+	u32 btf_id;
+};
+
+struct btf_mod_pair {
+	struct btf *btf;
+	struct module *module;
+};
+
+struct bpf_token {
+	struct work_struct work;
+	atomic64_t refcnt;
+	struct user_namespace *userns;
+	long: 32;
+	u64 allowed_cmds;
+	u64 allowed_maps;
+	u64 allowed_progs;
+	u64 allowed_attachs;
+};
+
+struct perf_callchain_entry {
+	__u64 nr;
+	__u64 ip[0];
+};
+
+typedef long unsigned int (*perf_copy_f)(void *, const void *, long unsigned int, long unsigned int);
+
+struct perf_raw_frag {
+	union {
+		struct perf_raw_frag *next;
+		long unsigned int pad;
+	};
+	perf_copy_f copy;
+	void *data;
+	u32 size;
+};
+
+struct perf_raw_record {
+	struct perf_raw_frag frag;
+	u32 size;
+};
+
+struct perf_branch_stack {
+	__u64 nr;
+	__u64 hw_idx;
+	struct perf_branch_entry entries[0];
+};
+
+struct perf_cpu_pmu_context;
+
+struct perf_output_handle;
+
+struct pmu {
+	struct list_head entry;
+	struct module *module;
+	struct device *dev;
+	struct device *parent;
+	const struct attribute_group **attr_groups;
+	const struct attribute_group **attr_update;
+	const char *name;
+	int type;
+	int capabilities;
+	unsigned int scope;
+	int *pmu_disable_count;
+	struct perf_cpu_pmu_context *cpu_pmu_context;
+	atomic_t exclusive_cnt;
+	int task_ctx_nr;
+	int hrtimer_interval_ms;
+	unsigned int nr_addr_filters;
+	void (*pmu_enable)(struct pmu *);
+	void (*pmu_disable)(struct pmu *);
+	int (*event_init)(struct perf_event *);
+	void (*event_mapped)(struct perf_event *, struct mm_struct *);
+	void (*event_unmapped)(struct perf_event *, struct mm_struct *);
+	int (*add)(struct perf_event *, int);
+	void (*del)(struct perf_event *, int);
+	void (*start)(struct perf_event *, int);
+	void (*stop)(struct perf_event *, int);
+	void (*read)(struct perf_event *);
+	void (*start_txn)(struct pmu *, unsigned int);
+	int (*commit_txn)(struct pmu *);
+	void (*cancel_txn)(struct pmu *);
+	int (*event_idx)(struct perf_event *);
+	void (*sched_task)(struct perf_event_pmu_context *, bool);
+	struct kmem_cache *task_ctx_cache;
+	void (*swap_task_ctx)(struct perf_event_pmu_context *, struct perf_event_pmu_context *);
+	void * (*setup_aux)(struct perf_event *, void **, int, bool);
+	void (*free_aux)(void *);
+	long int (*snapshot_aux)(struct perf_event *, struct perf_output_handle *, long unsigned int);
+	int (*addr_filters_validate)(struct list_head *);
+	void (*addr_filters_sync)(struct perf_event *);
+	int (*aux_output_match)(struct perf_event *);
+	bool (*filter)(struct pmu *, int);
+	int (*check_period)(struct perf_event *, u64);
+};
+
+struct perf_event_pmu_context {
+	struct pmu *pmu;
+	struct perf_event_context *ctx;
+	struct list_head pmu_ctx_entry;
+	struct list_head pinned_active;
+	struct list_head flexible_active;
+	unsigned int embedded: 1;
+	unsigned int nr_events;
+	unsigned int nr_cgroups;
+	unsigned int nr_freq;
+	atomic_t refcount;
+	struct callback_head callback_head;
+	void *task_ctx_data;
+	int rotate_necessary;
+};
+
+struct perf_cpu_pmu_context {
+	struct perf_event_pmu_context epc;
+	struct perf_event_pmu_context *task_epc;
+	struct list_head sched_cb_entry;
+	int sched_cb_usage;
+	int active_oncpu;
+	int exclusive;
+	raw_spinlock_t hrtimer_lock;
+	struct hrtimer hrtimer;
+	ktime_t hrtimer_interval;
+	unsigned int hrtimer_active;
+	long: 32;
+};
+
+struct perf_output_handle {
+	struct perf_event *event;
+	struct perf_buffer *rb;
+	long unsigned int wakeup;
+	long unsigned int size;
+	u64 aux_flags;
+	union {
+		void *addr;
+		long unsigned int head;
+	};
+	int page;
+};
+
+struct perf_addr_filter_range {
+	long unsigned int start;
+	long unsigned int size;
+};
+
+struct perf_sample_data {
+	u64 sample_flags;
+	u64 period;
+	u64 dyn_size;
+	u64 type;
+	struct {
+		u32 pid;
+		u32 tid;
+	} tid_entry;
+	u64 time;
+	u64 id;
+	struct {
+		u32 cpu;
+		u32 reserved;
+	} cpu_entry;
+	u64 ip;
+	struct perf_callchain_entry *callchain;
+	struct perf_raw_record *raw;
+	struct perf_branch_stack *br_stack;
+	u64 *br_stack_cntr;
+	union perf_sample_weight weight;
+	union perf_mem_data_src data_src;
+	u64 txn;
+	struct perf_regs regs_user;
+	struct perf_regs regs_intr;
+	u64 stack_user_size;
+	u64 stream_id;
+	u64 cgroup;
+	u64 addr;
+	u64 phys_addr;
+	u64 data_page_size;
+	u64 code_page_size;
+	u64 aux_size;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct trace_entry {
+	short unsigned int type;
+	unsigned char flags;
+	unsigned char preempt_count;
+	int pid;
+};
+
+struct trace_array;
+
+struct tracer;
+
+struct array_buffer;
+
+struct ring_buffer_iter;
+
+struct trace_iterator {
+	struct trace_array *tr;
+	struct tracer *trace;
+	struct array_buffer *array_buffer;
+	void *private;
+	int cpu_file;
+	struct mutex mutex;
+	struct ring_buffer_iter **buffer_iter;
+	long unsigned int iter_flags;
+	void *temp;
+	unsigned int temp_size;
+	char *fmt;
+	unsigned int fmt_size;
+	atomic_t wait_index;
+	struct trace_seq tmp_seq;
+	cpumask_var_t started;
+	bool closed;
+	bool snapshot;
+	struct trace_seq seq;
+	struct trace_entry *ent;
+	long unsigned int lost_events;
+	int leftover;
+	int ent_size;
+	int cpu;
+	u64 ts;
+	loff_t pos;
+	long int idx;
+	long: 32;
+};
+
+enum print_line_t {
+	TRACE_TYPE_PARTIAL_LINE = 0,
+	TRACE_TYPE_HANDLED = 1,
+	TRACE_TYPE_UNHANDLED = 2,
+	TRACE_TYPE_NO_CONSUME = 3,
+};
+
+typedef enum print_line_t (*trace_print_func)(struct trace_iterator *, int, struct trace_event *);
+
+struct trace_event_functions {
+	trace_print_func trace;
+	trace_print_func raw;
+	trace_print_func hex;
+	trace_print_func binary;
+};
+
+enum trace_reg {
+	TRACE_REG_REGISTER = 0,
+	TRACE_REG_UNREGISTER = 1,
+	TRACE_REG_PERF_REGISTER = 2,
+	TRACE_REG_PERF_UNREGISTER = 3,
+	TRACE_REG_PERF_OPEN = 4,
+	TRACE_REG_PERF_CLOSE = 5,
+	TRACE_REG_PERF_ADD = 6,
+	TRACE_REG_PERF_DEL = 7,
+};
+
+struct trace_event_fields {
+	const char *type;
+	union {
+		struct {
+			const char *name;
+			const int size;
+			const int align;
+			const int is_signed;
+			const int filter_type;
+			const int len;
+		};
+		int (*define_fields)(struct trace_event_call *);
+	};
+};
+
+struct trace_event_class {
+	const char *system;
+	void *probe;
+	void *perf_probe;
+	int (*reg)(struct trace_event_call *, enum trace_reg, void *);
+	struct trace_event_fields *fields_array;
+	struct list_head * (*get_fields)(struct trace_event_call *);
+	struct list_head fields;
+	int (*raw_init)(struct trace_event_call *);
+};
+
+enum {
+	TRACE_EVENT_FL_FILTERED_BIT = 0,
+	TRACE_EVENT_FL_CAP_ANY_BIT = 1,
+	TRACE_EVENT_FL_NO_SET_FILTER_BIT = 2,
+	TRACE_EVENT_FL_IGNORE_ENABLE_BIT = 3,
+	TRACE_EVENT_FL_TRACEPOINT_BIT = 4,
+	TRACE_EVENT_FL_DYNAMIC_BIT = 5,
+	TRACE_EVENT_FL_KPROBE_BIT = 6,
+	TRACE_EVENT_FL_UPROBE_BIT = 7,
+	TRACE_EVENT_FL_EPROBE_BIT = 8,
+	TRACE_EVENT_FL_FPROBE_BIT = 9,
+	TRACE_EVENT_FL_CUSTOM_BIT = 10,
+};
+
+enum {
+	EVENT_FILE_FL_ENABLED_BIT = 0,
+	EVENT_FILE_FL_RECORDED_CMD_BIT = 1,
+	EVENT_FILE_FL_RECORDED_TGID_BIT = 2,
+	EVENT_FILE_FL_FILTERED_BIT = 3,
+	EVENT_FILE_FL_NO_SET_FILTER_BIT = 4,
+	EVENT_FILE_FL_SOFT_MODE_BIT = 5,
+	EVENT_FILE_FL_SOFT_DISABLED_BIT = 6,
+	EVENT_FILE_FL_TRIGGER_MODE_BIT = 7,
+	EVENT_FILE_FL_TRIGGER_COND_BIT = 8,
+	EVENT_FILE_FL_PID_FILTER_BIT = 9,
+	EVENT_FILE_FL_WAS_ENABLED_BIT = 10,
+	EVENT_FILE_FL_FREED_BIT = 11,
+};
+
+enum {
+	Root_NFS = 255,
+	Root_CIFS = 254,
+	Root_Generic = 253,
+	Root_RAM0 = 1048576,
+};
+
+typedef long unsigned int uintptr_t;
+
+enum fortify_func {
+	FORTIFY_FUNC_strncpy = 0,
+	FORTIFY_FUNC_strnlen = 1,
+	FORTIFY_FUNC_strlen = 2,
+	FORTIFY_FUNC_strscpy = 3,
+	FORTIFY_FUNC_strlcat = 4,
+	FORTIFY_FUNC_strcat = 5,
+	FORTIFY_FUNC_strncat = 6,
+	FORTIFY_FUNC_memset = 7,
+	FORTIFY_FUNC_memcpy = 8,
+	FORTIFY_FUNC_memmove = 9,
+	FORTIFY_FUNC_memscan = 10,
+	FORTIFY_FUNC_memcmp = 11,
+	FORTIFY_FUNC_memchr = 12,
+	FORTIFY_FUNC_memchr_inv = 13,
+	FORTIFY_FUNC_kmemdup = 14,
+	FORTIFY_FUNC_strcpy = 15,
+	FORTIFY_FUNC_UNKNOWN = 16,
+};
+
+struct codetag {
+	unsigned int flags;
+	unsigned int lineno;
+	const char *modname;
+	const char *function;
+	const char *filename;
+	long: 32;
+};
+
+struct alloc_tag_counters {
+	u64 bytes;
+	u64 calls;
+};
+
+struct alloc_tag {
+	struct codetag ct;
+	struct alloc_tag_counters *counters;
+	long: 32;
+};
+
+enum umh_disable_depth {
+	UMH_ENABLED = 0,
+	UMH_FREEZING = 1,
+	UMH_DISABLED = 2,
+};
+
+typedef u64 async_cookie_t;
+
+typedef void (*async_func_t)(void *, async_cookie_t);
+
+struct async_domain {
+	struct list_head pending;
+	unsigned int registered: 1;
+};
+
+enum kmalloc_cache_type {
+	KMALLOC_NORMAL = 0,
+	KMALLOC_DMA = 0,
+	KMALLOC_RANDOM_START = 0,
+	KMALLOC_RANDOM_END = 0,
+	KMALLOC_RECLAIM = 1,
+	KMALLOC_CGROUP = 2,
+	NR_KMALLOC_TYPES = 3,
+};
+
+struct hash {
+	int ino;
+	int minor;
+	int major;
+	umode_t mode;
+	struct hash *next;
+	char name[4098];
+};
+
+enum state {
+	Start = 0,
+	Collect = 1,
+	GotHeader = 2,
+	SkipIt = 3,
+	GotName = 4,
+	CopyFile = 5,
+	GotSymlink = 6,
+	Reset = 7,
+};
+
+typedef int (*decompress_fn)(unsigned char *, long int, long int (*)(void *, long unsigned int), long int (*)(void *, long unsigned int), unsigned char *, long int *, void (*)(char *));
+
+enum key_being_used_for {
+	VERIFYING_MODULE_SIGNATURE = 0,
+	VERIFYING_FIRMWARE_SIGNATURE = 1,
+	VERIFYING_KEXEC_PE_SIGNATURE = 2,
+	VERIFYING_KEY_SIGNATURE = 3,
+	VERIFYING_KEY_SELF_SIGNATURE = 4,
+	VERIFYING_UNSPECIFIED_SIGNATURE = 5,
+	NR__KEY_BEING_USED_FOR = 6,
+};
+
+enum rseq_cs_flags_bit {
+	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,
+	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,
+	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,
+};
+
+enum {
+	TASK_COMM_LEN = 16,
+};
+
+typedef struct {
+	raw_spinlock_t *lock;
+} class_raw_spinlock_t;
+
+typedef struct {
+	raw_spinlock_t *lock;
+} class_raw_spinlock_irq_t;
+
+typedef struct {
+	raw_spinlock_t *lock;
+	long unsigned int flags;
+} class_raw_spinlock_irqsave_t;
+
+typedef struct {
+	spinlock_t *lock;
+} class_spinlock_t;
+
+typedef struct {
+	spinlock_t *lock;
+} class_spinlock_irq_t;
+
+typedef struct {
+	spinlock_t *lock;
+	long unsigned int flags;
+} class_spinlock_irqsave_t;
+
+struct arm_delay_ops {
+	void (*delay)(long unsigned int);
+	void (*const_udelay)(long unsigned int);
+	void (*udelay)(long unsigned int);
+	long unsigned int ticks_per_jiffy;
+};
+
+enum pcpu_fc {
+	PCPU_FC_AUTO = 0,
+	PCPU_FC_EMBED = 1,
+	PCPU_FC_PAGE = 2,
+	PCPU_FC_NR = 3,
+};
+
+typedef __u16 __be16;
+
+typedef __u32 __be32;
+
+typedef __u32 __wsum;
+
+struct new_utsname {
+	char sysname[65];
+	char nodename[65];
+	char release[65];
+	char version[65];
+	char machine[65];
+	char domainname[65];
+};
+
+struct uts_namespace {
+	struct new_utsname name;
+	struct user_namespace *user_ns;
+	struct ucounts *ucounts;
+	struct ns_common ns;
+};
+
+struct ref_tracker_dir {};
+
+struct notifier_block;
+
+struct raw_notifier_head {
+	struct notifier_block *head;
+};
+
+struct prot_inuse;
+
+struct netns_core {
+	struct ctl_table_header *sysctl_hdr;
+	int sysctl_somaxconn;
+	int sysctl_optmem_max;
+	u8 sysctl_txrehash;
+	struct prot_inuse *prot_inuse;
+	struct cpumask *rps_default_mask;
+};
+
+struct ipstats_mib;
+
+struct tcp_mib;
+
+struct linux_mib;
+
+struct udp_mib;
+
+struct linux_tls_mib;
+
+struct mptcp_mib;
+
+struct icmp_mib;
+
+struct icmpmsg_mib;
+
+struct icmpv6_mib;
+
+struct icmpv6msg_mib;
+
+struct proc_dir_entry;
+
+struct netns_mib {
+	struct ipstats_mib *ip_statistics;
+	struct ipstats_mib *ipv6_statistics;
+	struct tcp_mib *tcp_statistics;
+	struct linux_mib *net_statistics;
+	struct udp_mib *udp_statistics;
+	struct udp_mib *udp_stats_in6;
+	struct linux_tls_mib *tls_statistics;
+	struct mptcp_mib *mptcp_statistics;
+	struct udp_mib *udplite_statistics;
+	struct udp_mib *udplite_stats_in6;
+	struct icmp_mib *icmp_statistics;
+	struct icmpmsg_mib *icmpmsg_statistics;
+	struct icmpv6_mib *icmpv6_statistics;
+	struct icmpv6msg_mib *icmpv6msg_statistics;
+	struct proc_dir_entry *proc_net_devsnmp6;
+};
+
+struct netns_packet {
+	struct mutex sklist_lock;
+	struct hlist_head sklist;
+};
+
+struct unix_table {
+	spinlock_t *locks;
+	struct hlist_head *buckets;
+};
+
+struct netns_unix {
+	struct unix_table table;
+	int sysctl_max_dgram_qlen;
+	struct ctl_table_header *ctl;
+};
+
+struct blocking_notifier_head {
+	struct rw_semaphore rwsem;
+	struct notifier_block *head;
+};
+
+struct netns_nexthop {
+	struct rb_root rb_root;
+	struct hlist_head *devhash;
+	unsigned int seq;
+	u32 last_id_allocated;
+	struct blocking_notifier_head notifier_chain;
+};
+
+struct inet_hashinfo;
+
+struct inet_timewait_death_row {
+	refcount_t tw_refcount;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct inet_hashinfo *hashinfo;
+	int sysctl_max_tw_buckets;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct local_ports {
+	u32 range;
+	bool warned;
+};
+
+struct ping_group_range {
+	seqlock_t lock;
+	kgid_t range[2];
+};
+
+struct sysctl_fib_multipath_hash_seed {
+	u32 user_seed;
+	u32 mp_seed;
+};
+
+typedef struct {
+	u64 key[2];
+} siphash_key_t;
+
+struct udp_table;
+
+struct ipv4_devconf;
+
+struct ip_ra_chain;
+
+struct fib_rules_ops;
+
+struct fib_table;
+
+struct inet_peer_base;
+
+struct fqdir;
+
+struct tcp_congestion_ops;
+
+struct tcp_fastopen_context;
+
+struct fib_notifier_ops;
+
+struct netns_ipv4 {
+	__u8 __cacheline_group_begin__netns_ipv4_read_tx[0];
+	u8 sysctl_tcp_early_retrans;
+	u8 sysctl_tcp_tso_win_divisor;
+	u8 sysctl_tcp_tso_rtt_log;
+	u8 sysctl_tcp_autocorking;
+	int sysctl_tcp_min_snd_mss;
+	unsigned int sysctl_tcp_notsent_lowat;
+	int sysctl_tcp_limit_output_bytes;
+	int sysctl_tcp_min_rtt_wlen;
+	int sysctl_tcp_wmem[3];
+	u8 sysctl_ip_fwd_use_pmtu;
+	__u8 __cacheline_group_end__netns_ipv4_read_tx[0];
+	__u8 __cacheline_group_begin__netns_ipv4_read_txrx[0];
+	u8 sysctl_tcp_moderate_rcvbuf;
+	__u8 __cacheline_group_end__netns_ipv4_read_txrx[0];
+	__u8 __cacheline_group_begin__netns_ipv4_read_rx[0];
+	u8 sysctl_ip_early_demux;
+	u8 sysctl_tcp_early_demux;
+	int sysctl_tcp_reordering;
+	int sysctl_tcp_rmem[3];
+	__u8 __cacheline_group_end__netns_ipv4_read_rx[0];
+	long: 32;
+	long: 32;
+	long: 32;
+	struct inet_timewait_death_row tcp_death_row;
+	struct udp_table *udp_table;
+	struct ctl_table_header *forw_hdr;
+	struct ctl_table_header *frags_hdr;
+	struct ctl_table_header *ipv4_hdr;
+	struct ctl_table_header *route_hdr;
+	struct ctl_table_header *xfrm4_hdr;
+	struct ipv4_devconf *devconf_all;
+	struct ipv4_devconf *devconf_dflt;
+	struct ip_ra_chain *ra_chain;
+	struct mutex ra_mutex;
+	struct fib_rules_ops *rules_ops;
+	struct fib_table *fib_main;
+	struct fib_table *fib_default;
+	unsigned int fib_rules_require_fldissect;
+	bool fib_has_custom_rules;
+	bool fib_has_custom_local_routes;
+	bool fib_offload_disabled;
+	u8 sysctl_tcp_shrink_window;
+	atomic_t fib_num_tclassid_users;
+	struct hlist_head *fib_table_hash;
+	struct sock *fibnl;
+	struct sock *mc_autojoin_sk;
+	struct inet_peer_base *peers;
+	struct fqdir *fqdir;
+	u8 sysctl_icmp_echo_ignore_all;
+	u8 sysctl_icmp_echo_enable_probe;
+	u8 sysctl_icmp_echo_ignore_broadcasts;
+	u8 sysctl_icmp_ignore_bogus_error_responses;
+	u8 sysctl_icmp_errors_use_inbound_ifaddr;
+	int sysctl_icmp_ratelimit;
+	int sysctl_icmp_ratemask;
+	int sysctl_icmp_msgs_per_sec;
+	int sysctl_icmp_msgs_burst;
+	atomic_t icmp_global_credit;
+	u32 icmp_global_stamp;
+	u32 ip_rt_min_pmtu;
+	int ip_rt_mtu_expires;
+	int ip_rt_min_advmss;
+	struct local_ports ip_local_ports;
+	u8 sysctl_tcp_ecn;
+	u8 sysctl_tcp_ecn_fallback;
+	u8 sysctl_ip_default_ttl;
+	u8 sysctl_ip_no_pmtu_disc;
+	u8 sysctl_ip_fwd_update_priority;
+	u8 sysctl_ip_nonlocal_bind;
+	u8 sysctl_ip_autobind_reuse;
+	u8 sysctl_ip_dynaddr;
+	u8 sysctl_raw_l3mdev_accept;
+	u8 sysctl_udp_early_demux;
+	u8 sysctl_nexthop_compat_mode;
+	u8 sysctl_fwmark_reflect;
+	u8 sysctl_tcp_fwmark_accept;
+	u8 sysctl_tcp_l3mdev_accept;
+	u8 sysctl_tcp_mtu_probing;
+	int sysctl_tcp_mtu_probe_floor;
+	int sysctl_tcp_base_mss;
+	int sysctl_tcp_probe_threshold;
+	u32 sysctl_tcp_probe_interval;
+	int sysctl_tcp_keepalive_time;
+	int sysctl_tcp_keepalive_intvl;
+	u8 sysctl_tcp_keepalive_probes;
+	u8 sysctl_tcp_syn_retries;
+	u8 sysctl_tcp_synack_retries;
+	u8 sysctl_tcp_syncookies;
+	u8 sysctl_tcp_migrate_req;
+	u8 sysctl_tcp_comp_sack_nr;
+	u8 sysctl_tcp_backlog_ack_defer;
+	u8 sysctl_tcp_pingpong_thresh;
+	u8 sysctl_tcp_retries1;
+	u8 sysctl_tcp_retries2;
+	u8 sysctl_tcp_orphan_retries;
+	u8 sysctl_tcp_tw_reuse;
+	int sysctl_tcp_fin_timeout;
+	u8 sysctl_tcp_sack;
+	u8 sysctl_tcp_window_scaling;
+	u8 sysctl_tcp_timestamps;
+	int sysctl_tcp_rto_min_us;
+	u8 sysctl_tcp_recovery;
+	u8 sysctl_tcp_thin_linear_timeouts;
+	u8 sysctl_tcp_slow_start_after_idle;
+	u8 sysctl_tcp_retrans_collapse;
+	u8 sysctl_tcp_stdurg;
+	u8 sysctl_tcp_rfc1337;
+	u8 sysctl_tcp_abort_on_overflow;
+	u8 sysctl_tcp_fack;
+	int sysctl_tcp_max_reordering;
+	int sysctl_tcp_adv_win_scale;
+	u8 sysctl_tcp_dsack;
+	u8 sysctl_tcp_app_win;
+	u8 sysctl_tcp_frto;
+	u8 sysctl_tcp_nometrics_save;
+	u8 sysctl_tcp_no_ssthresh_metrics_save;
+	u8 sysctl_tcp_workaround_signed_windows;
+	int sysctl_tcp_challenge_ack_limit;
+	u8 sysctl_tcp_min_tso_segs;
+	u8 sysctl_tcp_reflect_tos;
+	int sysctl_tcp_invalid_ratelimit;
+	int sysctl_tcp_pacing_ss_ratio;
+	int sysctl_tcp_pacing_ca_ratio;
+	unsigned int sysctl_tcp_child_ehash_entries;
+	long unsigned int sysctl_tcp_comp_sack_delay_ns;
+	long unsigned int sysctl_tcp_comp_sack_slack_ns;
+	int sysctl_max_syn_backlog;
+	int sysctl_tcp_fastopen;
+	const struct tcp_congestion_ops *tcp_congestion_control;
+	struct tcp_fastopen_context *tcp_fastopen_ctx;
+	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
+	atomic_t tfo_active_disable_times;
+	long unsigned int tfo_active_disable_stamp;
+	u32 tcp_challenge_timestamp;
+	u32 tcp_challenge_count;
+	u8 sysctl_tcp_plb_enabled;
+	u8 sysctl_tcp_plb_idle_rehash_rounds;
+	u8 sysctl_tcp_plb_rehash_rounds;
+	u8 sysctl_tcp_plb_suspend_rto_sec;
+	int sysctl_tcp_plb_cong_thresh;
+	int sysctl_udp_wmem_min;
+	int sysctl_udp_rmem_min;
+	u8 sysctl_fib_notify_on_flag_change;
+	u8 sysctl_tcp_syn_linear_timeouts;
+	u8 sysctl_udp_l3mdev_accept;
+	u8 sysctl_igmp_llm_reports;
+	int sysctl_igmp_max_memberships;
+	int sysctl_igmp_max_msf;
+	int sysctl_igmp_qrv;
+	struct ping_group_range ping_group_range;
+	atomic_t dev_addr_genid;
+	unsigned int sysctl_udp_child_hash_entries;
+	long unsigned int *sysctl_local_reserved_ports;
+	int sysctl_ip_prot_sock;
+	struct list_head mr_tables;
+	struct fib_rules_ops *mr_rules_ops;
+	struct sysctl_fib_multipath_hash_seed sysctl_fib_multipath_hash_seed;
+	u32 sysctl_fib_multipath_hash_fields;
+	u8 sysctl_fib_multipath_use_neigh;
+	u8 sysctl_fib_multipath_hash_policy;
+	struct fib_notifier_ops *notifier_ops;
+	unsigned int fib_seq;
+	struct fib_notifier_ops *ipmr_notifier_ops;
+	unsigned int ipmr_seq;
+	atomic_t rt_genid;
+	long: 32;
+	siphash_key_t ip_id_key;
+	long: 32;
+	long: 32;
+};
+
+struct dst_entry;
+
+struct sk_buff;
+
+struct neighbour;
+
+struct dst_ops {
+	short unsigned int family;
+	unsigned int gc_thresh;
+	void (*gc)(struct dst_ops *);
+	struct dst_entry * (*check)(struct dst_entry *, __u32);
+	unsigned int (*default_advmss)(const struct dst_entry *);
+	unsigned int (*mtu)(const struct dst_entry *);
+	u32 * (*cow_metrics)(struct dst_entry *, long unsigned int);
+	void (*destroy)(struct dst_entry *);
+	void (*ifdown)(struct dst_entry *, struct net_device *);
+	void (*negative_advice)(struct sock *, struct dst_entry *);
+	void (*link_failure)(struct sk_buff *);
+	void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32, bool);
+	void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *);
+	int (*local_out)(struct net *, struct sock *, struct sk_buff *);
+	struct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff *, const void *);
+	void (*confirm_neigh)(const struct dst_entry *, const void *);
+	struct kmem_cache *kmem_cachep;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct percpu_counter pcpuc_entries;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct netns_sysctl_ipv6 {
+	struct ctl_table_header *hdr;
+	struct ctl_table_header *route_hdr;
+	struct ctl_table_header *icmp_hdr;
+	struct ctl_table_header *frags_hdr;
+	struct ctl_table_header *xfrm6_hdr;
+	int flush_delay;
+	int ip6_rt_max_size;
+	int ip6_rt_gc_min_interval;
+	int ip6_rt_gc_timeout;
+	int ip6_rt_gc_interval;
+	int ip6_rt_gc_elasticity;
+	int ip6_rt_mtu_expires;
+	int ip6_rt_min_advmss;
+	u32 multipath_hash_fields;
+	u8 multipath_hash_policy;
+	u8 bindv6only;
+	u8 flowlabel_consistency;
+	u8 auto_flowlabels;
+	int icmpv6_time;
+	u8 icmpv6_echo_ignore_all;
+	u8 icmpv6_echo_ignore_multicast;
+	u8 icmpv6_echo_ignore_anycast;
+	long unsigned int icmpv6_ratemask[8];
+	long unsigned int *icmpv6_ratemask_ptr;
+	u8 anycast_src_echo_reply;
+	u8 ip_nonlocal_bind;
+	u8 fwmark_reflect;
+	u8 flowlabel_state_ranges;
+	int idgen_retries;
+	int idgen_delay;
+	int flowlabel_reflect;
+	int max_dst_opts_cnt;
+	int max_hbh_opts_cnt;
+	int max_dst_opts_len;
+	int max_hbh_opts_len;
+	int seg6_flowlabel;
+	u32 ioam6_id;
+	u64 ioam6_id_wide;
+	u8 skip_notify_on_dev_down;
+	u8 fib_notify_on_flag_change;
+	u8 icmpv6_error_anycast_as_unicast;
+	long: 32;
+};
+
+struct ipv6_devconf;
+
+struct fib6_info;
+
+struct rt6_info;
+
+struct rt6_statistics;
+
+struct fib6_table;
+
+struct seg6_pernet_data;
+
+struct ioam6_pernet_data;
+
+struct netns_ipv6 {
+	struct dst_ops ip6_dst_ops;
+	struct netns_sysctl_ipv6 sysctl;
+	struct ipv6_devconf *devconf_all;
+	struct ipv6_devconf *devconf_dflt;
+	struct inet_peer_base *peers;
+	struct fqdir *fqdir;
+	struct fib6_info *fib6_null_entry;
+	struct rt6_info *ip6_null_entry;
+	struct rt6_statistics *rt6_stats;
+	struct timer_list ip6_fib_timer;
+	struct hlist_head *fib_table_hash;
+	struct fib6_table *fib6_main_tbl;
+	struct list_head fib6_walkers;
+	rwlock_t fib6_walker_lock;
+	spinlock_t fib6_gc_lock;
+	atomic_t ip6_rt_gc_expire;
+	long unsigned int ip6_rt_last_gc;
+	unsigned char flowlabel_has_excl;
+	bool fib6_has_custom_rules;
+	unsigned int fib6_rules_require_fldissect;
+	unsigned int fib6_routes_require_src;
+	struct rt6_info *ip6_prohibit_entry;
+	struct rt6_info *ip6_policy_failed_entry;
+	struct rt6_info *ip6_blk_hole_entry;
+	struct fib6_table *fib6_local_tbl;
+	struct fib_rules_ops *fib6_rules_ops;
+	struct sock *ndisc_sk;
+	struct sock *tcp_sk;
+	struct sock *igmp_sk;
+	struct sock *mc_autojoin_sk;
+	struct hlist_head *inet6_addr_lst;
+	spinlock_t addrconf_hash_lock;
+	struct delayed_work addr_chk_work;
+	struct list_head mr6_tables;
+	struct fib_rules_ops *mr6_rules_ops;
+	atomic_t dev_addr_genid;
+	atomic_t fib6_sernum;
+	struct seg6_pernet_data *seg6_data;
+	struct fib_notifier_ops *notifier_ops;
+	struct fib_notifier_ops *ip6mr_notifier_ops;
+	unsigned int ipmr_seq;
+	struct {
+		struct hlist_head head;
+		spinlock_t lock;
+		u32 seq;
+	} ip6addrlbl_table;
+	struct ioam6_pernet_data *ioam6_data;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct netns_sysctl_lowpan {
+	struct ctl_table_header *frags_hdr;
+};
+
+struct netns_ieee802154_lowpan {
+	struct netns_sysctl_lowpan sysctl;
+	struct fqdir *fqdir;
+};
+
+struct sctp_mib;
+
+struct netns_sctp {
+	struct sctp_mib *sctp_statistics;
+	struct proc_dir_entry *proc_net_sctp;
+	struct ctl_table_header *sysctl_header;
+	struct sock *ctl_sock;
+	struct sock *udp4_sock;
+	struct sock *udp6_sock;
+	int udp_port;
+	int encap_port;
+	struct list_head local_addr_list;
+	struct list_head addr_waitq;
+	struct timer_list addr_wq_timer;
+	struct list_head auto_asconf_splist;
+	spinlock_t addr_wq_lock;
+	spinlock_t local_addr_lock;
+	unsigned int rto_initial;
+	unsigned int rto_min;
+	unsigned int rto_max;
+	int rto_alpha;
+	int rto_beta;
+	int max_burst;
+	int cookie_preserve_enable;
+	char *sctp_hmac_alg;
+	unsigned int valid_cookie_life;
+	unsigned int sack_timeout;
+	unsigned int hb_interval;
+	unsigned int probe_interval;
+	int max_retrans_association;
+	int max_retrans_path;
+	int max_retrans_init;
+	int pf_retrans;
+	int ps_retrans;
+	int pf_enable;
+	int pf_expose;
+	int sndbuf_policy;
+	int rcvbuf_policy;
+	int default_auto_asconf;
+	int addip_enable;
+	int addip_noauth;
+	int prsctp_enable;
+	int reconf_enable;
+	int auth_enable;
+	int intl_enable;
+	int ecn_enable;
+	int scope_policy;
+	int rwnd_upd_shift;
+	long unsigned int max_autoclose;
+	int l3mdev_accept;
+};
+
+struct nf_logger;
+
+struct nf_hook_entries;
+
+struct netns_nf {
+	struct proc_dir_entry *proc_netfilter;
+	const struct nf_logger *nf_loggers[11];
+	struct ctl_table_header *nf_log_dir_header;
+	struct ctl_table_header *nf_lwtnl_dir_header;
+	struct nf_hook_entries *hooks_ipv4[5];
+	struct nf_hook_entries *hooks_ipv6[5];
+	struct nf_hook_entries *hooks_arp[3];
+	struct nf_hook_entries *hooks_bridge[5];
+	unsigned int defrag_ipv4_users;
+	unsigned int defrag_ipv6_users;
+};
+
+struct atomic_notifier_head {
+	spinlock_t lock;
+	struct notifier_block *head;
+};
+
+struct nf_generic_net {
+	unsigned int timeout;
+};
+
+struct nf_tcp_net {
+	unsigned int timeouts[14];
+	u8 tcp_loose;
+	u8 tcp_be_liberal;
+	u8 tcp_max_retrans;
+	u8 tcp_ignore_invalid_rst;
+	unsigned int offload_timeout;
+};
+
+struct nf_udp_net {
+	unsigned int timeouts[2];
+	unsigned int offload_timeout;
+};
+
+struct nf_icmp_net {
+	unsigned int timeout;
+};
+
+struct nf_gre_net {
+	struct list_head keymap_list;
+	unsigned int timeouts[2];
+};
+
+struct nf_ip_net {
+	struct nf_generic_net generic;
+	struct nf_tcp_net tcp;
+	struct nf_udp_net udp;
+	struct nf_icmp_net icmp;
+	struct nf_icmp_net icmpv6;
+	struct nf_gre_net gre;
+};
+
+struct ip_conntrack_stat;
+
+struct nf_ct_event_notifier;
+
+struct netns_ct {
+	bool ecache_dwork_pending;
+	u8 sysctl_log_invalid;
+	u8 sysctl_events;
+	u8 sysctl_acct;
+	u8 sysctl_tstamp;
+	u8 sysctl_checksum;
+	struct ip_conntrack_stat *stat;
+	struct atomic_notifier_head nf_conntrack_chain;
+	struct nf_ct_event_notifier *nf_conntrack_event_cb;
+	struct nf_ip_net nf_ct_proto;
+	atomic_t labels_used;
+};
+
+struct netns_nftables {
+	u8 gencursor;
+};
+
+struct nf_flow_table_stat;
+
+struct netns_ft {
+	struct nf_flow_table_stat *stat;
+};
+
+struct netns_bpf {
+	struct bpf_prog_array *run_array[2];
+	struct bpf_prog *progs[2];
+	struct list_head links[2];
+};
+
+struct xfrm_policy_hash {
+	struct hlist_head *table;
+	unsigned int hmask;
+	u8 dbits4;
+	u8 sbits4;
+	u8 dbits6;
+	u8 sbits6;
+};
+
+struct xfrm_policy_hthresh {
+	struct work_struct work;
+	seqlock_t lock;
+	u8 lbits4;
+	u8 rbits4;
+	u8 lbits6;
+	u8 rbits6;
+};
+
+struct netns_xfrm {
+	struct list_head state_all;
+	struct hlist_head *state_bydst;
+	struct hlist_head *state_bysrc;
+	struct hlist_head *state_byspi;
+	struct hlist_head *state_byseq;
+	unsigned int state_hmask;
+	unsigned int state_num;
+	struct work_struct state_hash_work;
+	struct list_head policy_all;
+	struct hlist_head *policy_byidx;
+	unsigned int policy_idx_hmask;
+	unsigned int idx_generator;
+	struct xfrm_policy_hash policy_bydst[3];
+	unsigned int policy_count[6];
+	struct work_struct policy_hash_work;
+	struct xfrm_policy_hthresh policy_hthresh;
+	struct list_head inexact_bins;
+	struct sock *nlsk;
+	struct sock *nlsk_stash;
+	u32 sysctl_aevent_etime;
+	u32 sysctl_aevent_rseqth;
+	int sysctl_larval_drop;
+	u32 sysctl_acq_expires;
+	u8 policy_default[3];
+	struct ctl_table_header *sysctl_hdr;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct dst_ops xfrm4_dst_ops;
+	struct dst_ops xfrm6_dst_ops;
+	spinlock_t xfrm_state_lock;
+	seqcount_spinlock_t xfrm_state_hash_generation;
+	seqcount_spinlock_t xfrm_policy_hash_generation;
+	spinlock_t xfrm_policy_lock;
+	struct mutex xfrm_cfg_mutex;
+	struct delayed_work nat_keepalive_work;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct netns_ipvs;
+
+struct mpls_route;
+
+struct netns_mpls {
+	int ip_ttl_propagate;
+	int default_ttl;
+	size_t platform_labels;
+	struct mpls_route **platform_label;
+	struct ctl_table_header *ctl;
+};
+
+struct can_dev_rcv_lists;
+
+struct can_pkg_stats;
+
+struct can_rcv_lists_stats;
+
+struct netns_can {
+	struct proc_dir_entry *proc_dir;
+	struct proc_dir_entry *pde_stats;
+	struct proc_dir_entry *pde_reset_stats;
+	struct proc_dir_entry *pde_rcvlist_all;
+	struct proc_dir_entry *pde_rcvlist_fil;
+	struct proc_dir_entry *pde_rcvlist_inv;
+	struct proc_dir_entry *pde_rcvlist_sff;
+	struct proc_dir_entry *pde_rcvlist_eff;
+	struct proc_dir_entry *pde_rcvlist_err;
+	struct proc_dir_entry *bcmproc_dir;
+	struct can_dev_rcv_lists *rx_alldev_list;
+	spinlock_t rcvlists_lock;
+	struct timer_list stattimer;
+	struct can_pkg_stats *pkg_stats;
+	struct can_rcv_lists_stats *rcv_lists_stats;
+	struct hlist_head cgw_list;
+};
+
+struct netns_xdp {
+	struct mutex lock;
+	struct hlist_head list;
+};
+
+struct uevent_sock;
+
+struct net_generic;
+
+struct net {
+	refcount_t passive;
+	spinlock_t rules_mod_lock;
+	unsigned int dev_base_seq;
+	u32 ifindex;
+	spinlock_t nsid_lock;
+	atomic_t fnhe_genid;
+	struct list_head list;
+	struct list_head exit_list;
+	struct llist_node cleanup_list;
+	struct key_tag *key_domain;
+	struct user_namespace *user_ns;
+	struct ucounts *ucounts;
+	struct idr netns_ids;
+	struct ns_common ns;
+	struct ref_tracker_dir refcnt_tracker;
+	struct ref_tracker_dir notrefcnt_tracker;
+	struct list_head dev_base_head;
+	struct proc_dir_entry *proc_net;
+	struct proc_dir_entry *proc_net_stat;
+	struct ctl_table_set sysctls;
+	struct sock *rtnl;
+	struct sock *genl_sock;
+	struct uevent_sock *uevent_sock;
+	struct hlist_head *dev_name_head;
+	struct hlist_head *dev_index_head;
+	struct xarray dev_by_index;
+	struct raw_notifier_head netdev_chain;
+	u32 hash_mix;
+	struct net_device *loopback_dev;
+	struct list_head rules_ops;
+	struct netns_core core;
+	struct netns_mib mib;
+	struct netns_packet packet;
+	struct netns_unix unx;
+	struct netns_nexthop nexthop;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct netns_ipv4 ipv4;
+	struct netns_ipv6 ipv6;
+	struct netns_ieee802154_lowpan ieee802154_lowpan;
+	struct netns_sctp sctp;
+	struct netns_nf nf;
+	struct netns_ct ct;
+	struct netns_nftables nft;
+	struct netns_ft ft;
+	struct net_generic *gen;
+	struct netns_bpf bpf;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct netns_xfrm xfrm;
+	u64 net_cookie;
+	struct netns_ipvs *ipvs;
+	struct netns_mpls mpls;
+	struct netns_can can;
+	struct netns_xdp xdp;
+	struct sock *crypto_nlsk;
+	struct sock *diag_nlsk;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+typedef int (*notifier_fn_t)(struct notifier_block *, long unsigned int, void *);
+
+struct notifier_block {
+	notifier_fn_t notifier_call;
+	struct notifier_block *next;
+	int priority;
+};
+
+struct rhashtable;
+
+struct rhashtable_compare_arg {
+	struct rhashtable *ht;
+	const void *key;
+};
+
+typedef u32 (*rht_hashfn_t)(const void *, u32, u32);
+
+typedef u32 (*rht_obj_hashfn_t)(const void *, u32, u32);
+
+typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *, const void *);
+
+struct rhashtable_params {
+	u16 nelem_hint;
+	u16 key_len;
+	u16 key_offset;
+	u16 head_offset;
+	unsigned int max_size;
+	u16 min_size;
+	bool automatic_shrinking;
+	rht_hashfn_t hashfn;
+	rht_obj_hashfn_t obj_hashfn;
+	rht_obj_cmpfn_t obj_cmpfn;
+};
+
+struct bucket_table;
+
+struct rhashtable {
+	struct bucket_table *tbl;
+	unsigned int key_len;
+	unsigned int max_elems;
+	struct rhashtable_params p;
+	bool rhlist;
+	struct work_struct run_work;
+	struct mutex mutex;
+	spinlock_t lock;
+	atomic_t nelems;
+};
+
+struct in6_addr {
+	union {
+		__u8 u6_addr8[16];
+		__be16 u6_addr16[8];
+		__be32 u6_addr32[4];
+	} in6_u;
+};
+
+struct ipstats_mib {
+	u64 mibs[38];
+	struct u64_stats_sync syncp;
+	long: 32;
+};
+
+struct icmp_mib {
+	long unsigned int mibs[30];
+};
+
+struct icmpmsg_mib {
+	atomic_long_t mibs[512];
+};
+
+struct icmpv6_mib {
+	long unsigned int mibs[7];
+};
+
+struct icmpv6msg_mib {
+	atomic_long_t mibs[512];
+};
+
+struct tcp_mib {
+	long unsigned int mibs[16];
+};
+
+struct udp_mib {
+	long unsigned int mibs[10];
+};
+
+struct linux_mib {
+	long unsigned int mibs[132];
+};
+
+struct linux_tls_mib {
+	long unsigned int mibs[13];
+};
+
+struct inet_frags;
+
+struct fqdir {
+	long int high_thresh;
+	long int low_thresh;
+	int timeout;
+	int max_dist;
+	struct inet_frags *f;
+	struct net *net;
+	bool dead;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct rhashtable rhashtable;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	atomic_long_t mem;
+	struct work_struct destroy_work;
+	struct llist_node free_list;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct inet_frag_queue;
+
+struct inet_frags {
+	unsigned int qsize;
+	void (*constructor)(struct inet_frag_queue *, const void *);
+	void (*destructor)(struct inet_frag_queue *);
+	void (*frag_expire)(struct timer_list *);
+	struct kmem_cache *frags_cachep;
+	const char *frags_cache_name;
+	struct rhashtable_params rhash_params;
+	refcount_t refcnt;
+	struct completion completion;
+};
+
+struct frag_v4_compare_key {
+	__be32 saddr;
+	__be32 daddr;
+	u32 user;
+	u32 vif;
+	__be16 id;
+	u16 protocol;
+};
+
+struct frag_v6_compare_key {
+	struct in6_addr saddr;
+	struct in6_addr daddr;
+	u32 user;
+	__be32 id;
+	u32 iif;
+};
+
+struct inet_frag_queue {
+	struct rhash_head node;
+	union {
+		struct frag_v4_compare_key v4;
+		struct frag_v6_compare_key v6;
+	} key;
+	struct timer_list timer;
+	spinlock_t lock;
+	refcount_t refcnt;
+	struct rb_root rb_fragments;
+	struct sk_buff *fragments_tail;
+	struct sk_buff *last_run_head;
+	ktime_t stamp;
+	int len;
+	int meat;
+	u8 tstamp_type;
+	__u8 flags;
+	u16 max_size;
+	struct fqdir *fqdir;
+	struct callback_head rcu;
+};
+
+typedef unsigned char *sk_buff_data_t;
+
+struct skb_ext;
+
+struct sk_buff {
+	union {
+		struct {
+			struct sk_buff *next;
+			struct sk_buff *prev;
+			union {
+				struct net_device *dev;
+				long unsigned int dev_scratch;
+			};
+		};
+		struct rb_node rbnode;
+		struct list_head list;
+		struct llist_node ll_node;
+	};
+	struct sock *sk;
+	union {
+		ktime_t tstamp;
+		u64 skb_mstamp_ns;
+	};
+	char cb[48];
+	union {
+		struct {
+			long unsigned int _skb_refdst;
+			void (*destructor)(struct sk_buff *);
+		};
+		struct list_head tcp_tsorted_anchor;
+		long unsigned int _sk_redir;
+	};
+	long unsigned int _nfct;
+	unsigned int len;
+	unsigned int data_len;
+	__u16 mac_len;
+	__u16 hdr_len;
+	__u16 queue_mapping;
+	__u8 __cloned_offset[0];
+	__u8 cloned: 1;
+	__u8 nohdr: 1;
+	__u8 fclone: 2;
+	__u8 peeked: 1;
+	__u8 head_frag: 1;
+	__u8 pfmemalloc: 1;
+	__u8 pp_recycle: 1;
+	__u8 active_extensions;
+	union {
+		struct {
+			__u8 __pkt_type_offset[0];
+			__u8 pkt_type: 3;
+			__u8 ignore_df: 1;
+			__u8 dst_pending_confirm: 1;
+			__u8 ip_summed: 2;
+			__u8 ooo_okay: 1;
+			__u8 __mono_tc_offset[0];
+			__u8 tstamp_type: 2;
+			__u8 tc_at_ingress: 1;
+			__u8 tc_skip_classify: 1;
+			__u8 remcsum_offload: 1;
+			__u8 csum_complete_sw: 1;
+			__u8 csum_level: 2;
+			__u8 inner_protocol_type: 1;
+			__u8 l4_hash: 1;
+			__u8 sw_hash: 1;
+			__u8 wifi_acked_valid: 1;
+			__u8 wifi_acked: 1;
+			__u8 no_fcs: 1;
+			__u8 encapsulation: 1;
+			__u8 encap_hdr_csum: 1;
+			__u8 csum_valid: 1;
+			__u8 ndisc_nodetype: 2;
+			__u8 ipvs_property: 1;
+			__u8 nf_trace: 1;
+			__u8 offload_fwd_mark: 1;
+			__u8 offload_l3_fwd_mark: 1;
+			__u8 redirected: 1;
+			__u8 from_ingress: 1;
+			__u8 nf_skip_egress: 1;
+			__u8 decrypted: 1;
+			__u8 slow_gro: 1;
+			__u8 csum_not_inet: 1;
+			__u8 unreadable: 1;
+			__u8 fast_forwarded: 1;
+			__u16 tc_index;
+			u16 alloc_cpu;
+			union {
+				__wsum csum;
+				struct {
+					__u16 csum_start;
+					__u16 csum_offset;
+				};
+			};
+			__u32 priority;
+			int skb_iif;
+			__u32 hash;
+			union {
+				u32 vlan_all;
+				struct {
+					__be16 vlan_proto;
+					__u16 vlan_tci;
+				};
+			};
+			union {
+				unsigned int napi_id;
+				unsigned int sender_cpu;
+			};
+			union {
+				__u32 mark;
+				__u32 reserved_tailroom;
+			};
+			union {
+				__be16 inner_protocol;
+				__u8 inner_ipproto;
+			};
+			__u16 inner_transport_header;
+			__u16 inner_network_header;
+			__u16 inner_mac_header;
+			__be16 protocol;
+			__u16 transport_header;
+			__u16 network_header;
+			__u16 mac_header;
+		};
+		struct {
+			__u8 __pkt_type_offset[0];
+			__u8 pkt_type: 3;
+			__u8 ignore_df: 1;
+			__u8 dst_pending_confirm: 1;
+			__u8 ip_summed: 2;
+			__u8 ooo_okay: 1;
+			__u8 __mono_tc_offset[0];
+			__u8 tstamp_type: 2;
+			__u8 tc_at_ingress: 1;
+			__u8 tc_skip_classify: 1;
+			__u8 remcsum_offload: 1;
+			__u8 csum_complete_sw: 1;
+			__u8 csum_level: 2;
+			__u8 inner_protocol_type: 1;
+			__u8 l4_hash: 1;
+			__u8 sw_hash: 1;
+			__u8 wifi_acked_valid: 1;
+			__u8 wifi_acked: 1;
+			__u8 no_fcs: 1;
+			__u8 encapsulation: 1;
+			__u8 encap_hdr_csum: 1;
+			__u8 csum_valid: 1;
+			__u8 ndisc_nodetype: 2;
+			__u8 ipvs_property: 1;
+			__u8 nf_trace: 1;
+			__u8 offload_fwd_mark: 1;
+			__u8 offload_l3_fwd_mark: 1;
+			__u8 redirected: 1;
+			__u8 from_ingress: 1;
+			__u8 nf_skip_egress: 1;
+			__u8 decrypted: 1;
+			__u8 slow_gro: 1;
+			__u8 csum_not_inet: 1;
+			__u8 unreadable: 1;
+			__u8 fast_forwarded: 1;
+			__u16 tc_index;
+			u16 alloc_cpu;
+			union {
+				__wsum csum;
+				struct {
+					__u16 csum_start;
+					__u16 csum_offset;
+				};
+			};
+			__u32 priority;
+			int skb_iif;
+			__u32 hash;
+			union {
+				u32 vlan_all;
+				struct {
+					__be16 vlan_proto;
+					__u16 vlan_tci;
+				};
+			};
+			union {
+				unsigned int napi_id;
+				unsigned int sender_cpu;
+			};
+			union {
+				__u32 mark;
+				__u32 reserved_tailroom;
+			};
+			union {
+				__be16 inner_protocol;
+				__u8 inner_ipproto;
+			};
+			__u16 inner_transport_header;
+			__u16 inner_network_header;
+			__u16 inner_mac_header;
+			__be16 protocol;
+			__u16 transport_header;
+			__u16 network_header;
+			__u16 mac_header;
+		} headers;
+	};
+	sk_buff_data_t tail;
+	sk_buff_data_t end;
+	unsigned char *head;
+	unsigned char *data;
+	unsigned int truesize;
+	refcount_t users;
+	struct skb_ext *extensions;
+};
+
+enum tcp_ca_event {
+	CA_EVENT_TX_START = 0,
+	CA_EVENT_CWND_RESTART = 1,
+	CA_EVENT_COMPLETE_CWR = 2,
+	CA_EVENT_LOSS = 3,
+	CA_EVENT_ECN_NO_CE = 4,
+	CA_EVENT_ECN_IS_CE = 5,
+	CA_EVENT_TLP_RECOVERY = 6,
+};
+
+struct ack_sample;
+
+struct rate_sample;
+
+union tcp_cc_info;
+
+struct tcp_congestion_ops {
+	u32 (*ssthresh)(struct sock *);
+	void (*cong_avoid)(struct sock *, u32, u32);
+	void (*set_state)(struct sock *, u8);
+	void (*cwnd_event)(struct sock *, enum tcp_ca_event);
+	void (*in_ack_event)(struct sock *, u32);
+	void (*pkts_acked)(struct sock *, const struct ack_sample *);
+	u32 (*tso_segs)(struct sock *, unsigned int);
+	void (*skb_marked_lost)(struct sock *, const struct sk_buff *);
+	void (*cong_control)(struct sock *, u32, int, const struct rate_sample *);
+	u32 (*undo_cwnd)(struct sock *);
+	u32 (*sndbuf_expand)(struct sock *);
+	size_t (*get_info)(struct sock *, u32, int *, union tcp_cc_info *);
+	char name[16];
+	struct module *owner;
+	struct list_head list;
+	u32 key;
+	u32 flags;
+	void (*init)(struct sock *);
+	void (*release)(struct sock *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+typedef struct {
+	atomic_t refcnt;
+} rcuref_t;
+
+typedef struct {} netdevice_tracker;
+
+struct xfrm_state;
+
+struct lwtunnel_state;
+
+struct uncached_list;
+
+struct dst_entry {
+	struct net_device *dev;
+	struct dst_ops *ops;
+	long unsigned int _metrics;
+	long unsigned int expires;
+	struct xfrm_state *xfrm;
+	int (*input)(struct sk_buff *);
+	int (*output)(struct net *, struct sock *, struct sk_buff *);
+	short unsigned int flags;
+	short int obsolete;
+	short unsigned int header_len;
+	short unsigned int trailer_len;
+	int __use;
+	long unsigned int lastuse;
+	struct callback_head callback_head;
+	short int error;
+	short int __pad;
+	__u32 tclassid;
+	struct lwtunnel_state *lwtstate;
+	rcuref_t __rcuref;
+	netdevice_tracker dev_tracker;
+	struct list_head rt_uncached;
+	struct uncached_list *rt_uncached_list;
+};
+
+enum nf_log_type {
+	NF_LOG_TYPE_LOG = 0,
+	NF_LOG_TYPE_ULOG = 1,
+	NF_LOG_TYPE_MAX = 2,
+};
+
+typedef u8 u_int8_t;
+
+struct nf_loginfo;
+
+typedef void nf_logfn(struct net *, u_int8_t, unsigned int, const struct sk_buff *, const struct net_device *, const struct net_device *, const struct nf_loginfo *, const char *);
+
+struct nf_logger {
+	char *name;
+	enum nf_log_type type;
+	nf_logfn *logfn;
+	struct module *me;
+};
+
+struct ip_conntrack_stat {
+	unsigned int found;
+	unsigned int invalid;
+	unsigned int insert;
+	unsigned int insert_failed;
+	unsigned int clash_resolve;
+	unsigned int drop;
+	unsigned int early_drop;
+	unsigned int error;
+	unsigned int expect_new;
+	unsigned int expect_create;
+	unsigned int expect_delete;
+	unsigned int search_restart;
+	unsigned int chaintoolong;
+};
+
+struct nf_flow_table_stat {
+	unsigned int count_wq_add;
+	unsigned int count_wq_del;
+	unsigned int count_wq_stats;
+};
+
+enum {
+	__SD_BALANCE_NEWIDLE = 0,
+	__SD_BALANCE_EXEC = 1,
+	__SD_BALANCE_FORK = 2,
+	__SD_BALANCE_WAKE = 3,
+	__SD_WAKE_AFFINE = 4,
+	__SD_ASYM_CPUCAPACITY = 5,
+	__SD_ASYM_CPUCAPACITY_FULL = 6,
+	__SD_SHARE_CPUCAPACITY = 7,
+	__SD_CLUSTER = 8,
+	__SD_SHARE_LLC = 9,
+	__SD_SERIALIZE = 10,
+	__SD_ASYM_PACKING = 11,
+	__SD_PREFER_SIBLING = 12,
+	__SD_OVERLAP = 13,
+	__SD_NUMA = 14,
+	__SD_FLAG_CNT = 15,
+};
+
+enum {
+	TCA_FLOWER_KEY_FLAGS_IS_FRAGMENT = 1,
+	TCA_FLOWER_KEY_FLAGS_FRAG_IS_FIRST = 2,
+	TCA_FLOWER_KEY_FLAGS_TUNNEL_CSUM = 4,
+	TCA_FLOWER_KEY_FLAGS_TUNNEL_DONT_FRAGMENT = 8,
+	TCA_FLOWER_KEY_FLAGS_TUNNEL_OAM = 16,
+	TCA_FLOWER_KEY_FLAGS_TUNNEL_CRIT_OPT = 32,
+	__TCA_FLOWER_KEY_FLAGS_MAX = 33,
+};
+
+enum flow_dissector_key_id {
+	FLOW_DISSECTOR_KEY_CONTROL = 0,
+	FLOW_DISSECTOR_KEY_BASIC = 1,
+	FLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,
+	FLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,
+	FLOW_DISSECTOR_KEY_PORTS = 4,
+	FLOW_DISSECTOR_KEY_PORTS_RANGE = 5,
+	FLOW_DISSECTOR_KEY_ICMP = 6,
+	FLOW_DISSECTOR_KEY_ETH_ADDRS = 7,
+	FLOW_DISSECTOR_KEY_TIPC = 8,
+	FLOW_DISSECTOR_KEY_ARP = 9,
+	FLOW_DISSECTOR_KEY_VLAN = 10,
+	FLOW_DISSECTOR_KEY_FLOW_LABEL = 11,
+	FLOW_DISSECTOR_KEY_GRE_KEYID = 12,
+	FLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,
+	FLOW_DISSECTOR_KEY_ENC_KEYID = 14,
+	FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,
+	FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,
+	FLOW_DISSECTOR_KEY_ENC_CONTROL = 17,
+	FLOW_DISSECTOR_KEY_ENC_PORTS = 18,
+	FLOW_DISSECTOR_KEY_MPLS = 19,
+	FLOW_DISSECTOR_KEY_TCP = 20,
+	FLOW_DISSECTOR_KEY_IP = 21,
+	FLOW_DISSECTOR_KEY_CVLAN = 22,
+	FLOW_DISSECTOR_KEY_ENC_IP = 23,
+	FLOW_DISSECTOR_KEY_ENC_OPTS = 24,
+	FLOW_DISSECTOR_KEY_META = 25,
+	FLOW_DISSECTOR_KEY_CT = 26,
+	FLOW_DISSECTOR_KEY_HASH = 27,
+	FLOW_DISSECTOR_KEY_NUM_OF_VLANS = 28,
+	FLOW_DISSECTOR_KEY_PPPOE = 29,
+	FLOW_DISSECTOR_KEY_L2TPV3 = 30,
+	FLOW_DISSECTOR_KEY_CFM = 31,
+	FLOW_DISSECTOR_KEY_IPSEC = 32,
+	FLOW_DISSECTOR_KEY_MAX = 33,
+};
+
+struct skb_ext {
+	refcount_t refcnt;
+	u8 offset[3];
+	u8 chunks;
+	char data[0];
+};
+
+enum skb_ext_id {
+	SKB_EXT_BRIDGE_NF = 0,
+	SKB_EXT_SEC_PATH = 1,
+	SKB_EXT_MPTCP = 2,
+	SKB_EXT_NUM = 3,
+};
+
+enum {
+	UNAME26 = 131072,
+	ADDR_NO_RANDOMIZE = 262144,
+	FDPIC_FUNCPTRS = 524288,
+	MMAP_PAGE_ZERO = 1048576,
+	ADDR_COMPAT_LAYOUT = 2097152,
+	READ_IMPLIES_EXEC = 4194304,
+	ADDR_LIMIT_32BIT = 8388608,
+	SHORT_INODE = 16777216,
+	WHOLE_SECONDS = 33554432,
+	STICKY_TIMEOUTS = 67108864,
+	ADDR_LIMIT_3GB = 134217728,
+};
+
+enum {
+	PER_LINUX = 0,
+	PER_LINUX_32BIT = 8388608,
+	PER_LINUX_FDPIC = 524288,
+	PER_SVR4 = 68157441,
+	PER_SVR3 = 83886082,
+	PER_SCOSVR3 = 117440515,
+	PER_OSR5 = 100663299,
+	PER_WYSEV386 = 83886084,
+	PER_ISCR4 = 67108869,
+	PER_BSD = 6,
+	PER_SUNOS = 67108870,
+	PER_XENIX = 83886087,
+	PER_LINUX32 = 8,
+	PER_LINUX32_3GB = 134217736,
+	PER_IRIX32 = 67108873,
+	PER_IRIXN32 = 67108874,
+	PER_IRIX64 = 67108875,
+	PER_RISCOS = 12,
+	PER_SOLARIS = 67108877,
+	PER_UW7 = 68157454,
+	PER_OSF4 = 15,
+	PER_HPUX = 16,
+	PER_MASK = 255,
+};
+
+typedef __u32 Elf32_Off;
+
+struct elf32_hdr {
+	unsigned char e_ident[16];
+	Elf32_Half e_type;
+	Elf32_Half e_machine;
+	Elf32_Word e_version;
+	Elf32_Addr e_entry;
+	Elf32_Off e_phoff;
+	Elf32_Off e_shoff;
+	Elf32_Word e_flags;
+	Elf32_Half e_ehsize;
+	Elf32_Half e_phentsize;
+	Elf32_Half e_phnum;
+	Elf32_Half e_shentsize;
+	Elf32_Half e_shnum;
+	Elf32_Half e_shstrndx;
+};
+
+enum node_states {
+	N_POSSIBLE = 0,
+	N_ONLINE = 1,
+	N_NORMAL_MEMORY = 2,
+	N_HIGH_MEMORY = 3,
+	N_MEMORY = 4,
+	N_CPU = 5,
+	N_GENERIC_INITIATOR = 6,
+	NR_NODE_STATES = 7,
+};
+
+enum {
+	MM_FILEPAGES = 0,
+	MM_ANONPAGES = 1,
+	MM_SWAPENTS = 2,
+	MM_SHMEMPAGES = 3,
+	NR_MM_COUNTERS = 4,
+};
+
+enum work_bits {
+	WORK_STRUCT_PENDING_BIT = 0,
+	WORK_STRUCT_INACTIVE_BIT = 1,
+	WORK_STRUCT_PWQ_BIT = 2,
+	WORK_STRUCT_LINKED_BIT = 3,
+	WORK_STRUCT_FLAG_BITS = 4,
+	WORK_STRUCT_COLOR_SHIFT = 4,
+	WORK_STRUCT_COLOR_BITS = 4,
+	WORK_STRUCT_PWQ_SHIFT = 8,
+	WORK_OFFQ_FLAG_SHIFT = 4,
+	WORK_OFFQ_BH_BIT = 4,
+	WORK_OFFQ_FLAG_END = 5,
+	WORK_OFFQ_FLAG_BITS = 1,
+	WORK_OFFQ_DISABLE_SHIFT = 5,
+	WORK_OFFQ_DISABLE_BITS = 16,
+	WORK_OFFQ_POOL_SHIFT = 21,
+	WORK_OFFQ_LEFT = 11,
+	WORK_OFFQ_POOL_BITS = 11,
+};
+
+enum migratetype {
+	MIGRATE_UNMOVABLE = 0,
+	MIGRATE_MOVABLE = 1,
+	MIGRATE_RECLAIMABLE = 2,
+	MIGRATE_PCPTYPES = 3,
+	MIGRATE_HIGHATOMIC = 3,
+	MIGRATE_TYPES = 4,
+};
+
+enum zone_stat_item {
+	NR_FREE_PAGES = 0,
+	NR_ZONE_LRU_BASE = 1,
+	NR_ZONE_INACTIVE_ANON = 1,
+	NR_ZONE_ACTIVE_ANON = 2,
+	NR_ZONE_INACTIVE_FILE = 3,
+	NR_ZONE_ACTIVE_FILE = 4,
+	NR_ZONE_UNEVICTABLE = 5,
+	NR_ZONE_WRITE_PENDING = 6,
+	NR_MLOCK = 7,
+	NR_BOUNCE = 8,
+	NR_ZSPAGES = 9,
+	NR_FREE_CMA_PAGES = 10,
+	NR_VM_ZONE_STAT_ITEMS = 11,
+};
+
+enum node_stat_item {
+	NR_LRU_BASE = 0,
+	NR_INACTIVE_ANON = 0,
+	NR_ACTIVE_ANON = 1,
+	NR_INACTIVE_FILE = 2,
+	NR_ACTIVE_FILE = 3,
+	NR_UNEVICTABLE = 4,
+	NR_SLAB_RECLAIMABLE_B = 5,
+	NR_SLAB_UNRECLAIMABLE_B = 6,
+	NR_ISOLATED_ANON = 7,
+	NR_ISOLATED_FILE = 8,
+	WORKINGSET_NODES = 9,
+	WORKINGSET_REFAULT_BASE = 10,
+	WORKINGSET_REFAULT_ANON = 10,
+	WORKINGSET_REFAULT_FILE = 11,
+	WORKINGSET_ACTIVATE_BASE = 12,
+	WORKINGSET_ACTIVATE_ANON = 12,
+	WORKINGSET_ACTIVATE_FILE = 13,
+	WORKINGSET_RESTORE_BASE = 14,
+	WORKINGSET_RESTORE_ANON = 14,
+	WORKINGSET_RESTORE_FILE = 15,
+	WORKINGSET_NODERECLAIM = 16,
+	NR_ANON_MAPPED = 17,
+	NR_FILE_MAPPED = 18,
+	NR_FILE_PAGES = 19,
+	NR_FILE_DIRTY = 20,
+	NR_WRITEBACK = 21,
+	NR_WRITEBACK_TEMP = 22,
+	NR_SHMEM = 23,
+	NR_SHMEM_THPS = 24,
+	NR_SHMEM_PMDMAPPED = 25,
+	NR_FILE_THPS = 26,
+	NR_FILE_PMDMAPPED = 27,
+	NR_ANON_THPS = 28,
+	NR_VMSCAN_WRITE = 29,
+	NR_VMSCAN_IMMEDIATE = 30,
+	NR_DIRTIED = 31,
+	NR_WRITTEN = 32,
+	NR_THROTTLED_WRITTEN = 33,
+	NR_KERNEL_MISC_RECLAIMABLE = 34,
+	NR_FOLL_PIN_ACQUIRED = 35,
+	NR_FOLL_PIN_RELEASED = 36,
+	NR_KERNEL_STACK_KB = 37,
+	NR_PAGETABLE = 38,
+	NR_SECONDARY_PAGETABLE = 39,
+	NR_SWAPCACHE = 40,
+	PGDEMOTE_KSWAPD = 41,
+	PGDEMOTE_DIRECT = 42,
+	PGDEMOTE_KHUGEPAGED = 43,
+	NR_VM_NODE_STAT_ITEMS = 44,
+};
+
+enum lru_list {
+	LRU_INACTIVE_ANON = 0,
+	LRU_ACTIVE_ANON = 1,
+	LRU_INACTIVE_FILE = 2,
+	LRU_ACTIVE_FILE = 3,
+	LRU_UNEVICTABLE = 4,
+	NR_LRU_LISTS = 5,
+};
+
+enum vmscan_throttle_state {
+	VMSCAN_THROTTLE_WRITEBACK = 0,
+	VMSCAN_THROTTLE_ISOLATED = 1,
+	VMSCAN_THROTTLE_NOPROGRESS = 2,
+	VMSCAN_THROTTLE_CONGESTED = 3,
+	NR_VMSCAN_THROTTLE = 4,
+};
+
+enum {
+	MM_LEAF_TOTAL = 0,
+	MM_LEAF_YOUNG = 1,
+	MM_NONLEAF_FOUND = 2,
+	MM_NONLEAF_ADDED = 3,
+	NR_MM_STATS = 4,
+};
+
+enum zone_watermarks {
+	WMARK_MIN = 0,
+	WMARK_LOW = 1,
+	WMARK_HIGH = 2,
+	WMARK_PROMO = 3,
+	NR_WMARK = 4,
+};
+
+enum {
+	ZONELIST_FALLBACK = 0,
+	MAX_ZONELISTS = 1,
+};
+
+enum mod_mem_type {
+	MOD_TEXT = 0,
+	MOD_DATA = 1,
+	MOD_RODATA = 2,
+	MOD_RO_AFTER_INIT = 3,
+	MOD_INIT_TEXT = 4,
+	MOD_INIT_DATA = 5,
+	MOD_INIT_RODATA = 6,
+	MOD_MEM_NUM_TYPES = 7,
+	MOD_INVALID = -1,
+};
+
+struct undef_hook {
+	struct list_head node;
+	u32 instr_mask;
+	u32 instr_val;
+	u32 cpsr_mask;
+	u32 cpsr_val;
+	int (*fn)(struct pt_regs *, unsigned int);
+};
+
+struct seccomp_data {
+	int nr;
+	__u32 arch;
+	__u64 instruction_pointer;
+	__u64 args[6];
+};
+
+enum bpf_link_type {
+	BPF_LINK_TYPE_UNSPEC = 0,
+	BPF_LINK_TYPE_RAW_TRACEPOINT = 1,
+	BPF_LINK_TYPE_TRACING = 2,
+	BPF_LINK_TYPE_CGROUP = 3,
+	BPF_LINK_TYPE_ITER = 4,
+	BPF_LINK_TYPE_NETNS = 5,
+	BPF_LINK_TYPE_XDP = 6,
+	BPF_LINK_TYPE_PERF_EVENT = 7,
+	BPF_LINK_TYPE_KPROBE_MULTI = 8,
+	BPF_LINK_TYPE_STRUCT_OPS = 9,
+	BPF_LINK_TYPE_NETFILTER = 10,
+	BPF_LINK_TYPE_TCX = 11,
+	BPF_LINK_TYPE_UPROBE_MULTI = 12,
+	BPF_LINK_TYPE_NETKIT = 13,
+	BPF_LINK_TYPE_SOCKMAP = 14,
+	__MAX_BPF_LINK_TYPE = 15,
+};
+
+struct bpf_link_info {
+	__u32 type;
+	__u32 id;
+	__u32 prog_id;
+	long: 32;
+	union {
+		struct {
+			__u64 tp_name;
+			__u32 tp_name_len;
+			long: 32;
+		} raw_tracepoint;
+		struct {
+			__u32 attach_type;
+			__u32 target_obj_id;
+			__u32 target_btf_id;
+		} tracing;
+		struct {
+			__u64 cgroup_id;
+			__u32 attach_type;
+			long: 32;
+		} cgroup;
+		struct {
+			__u64 target_name;
+			__u32 target_name_len;
+			union {
+				struct {
+					__u32 map_id;
+				} map;
+			};
+			union {
+				struct {
+					__u64 cgroup_id;
+					__u32 order;
+					long: 32;
+				} cgroup;
+				struct {
+					__u32 tid;
+					__u32 pid;
+				} task;
+			};
+		} iter;
+		struct {
+			__u32 netns_ino;
+			__u32 attach_type;
+		} netns;
+		struct {
+			__u32 ifindex;
+		} xdp;
+		struct {
+			__u32 map_id;
+		} struct_ops;
+		struct {
+			__u32 pf;
+			__u32 hooknum;
+			__s32 priority;
+			__u32 flags;
+		} netfilter;
+		struct {
+			__u64 addrs;
+			__u32 count;
+			__u32 flags;
+			__u64 missed;
+			__u64 cookies;
+		} kprobe_multi;
+		struct {
+			__u64 path;
+			__u64 offsets;
+			__u64 ref_ctr_offsets;
+			__u64 cookies;
+			__u32 path_size;
+			__u32 count;
+			__u32 flags;
+			__u32 pid;
+		} uprobe_multi;
+		struct {
+			__u32 type;
+			long: 32;
+			union {
+				struct {
+					__u64 file_name;
+					__u32 name_len;
+					__u32 offset;
+					__u64 cookie;
+				} uprobe;
+				struct {
+					__u64 func_name;
+					__u32 name_len;
+					__u32 offset;
+					__u64 addr;
+					__u64 missed;
+					__u64 cookie;
+				} kprobe;
+				struct {
+					__u64 tp_name;
+					__u32 name_len;
+					long: 32;
+					__u64 cookie;
+				} tracepoint;
+				struct {
+					__u64 config;
+					__u32 type;
+					long: 32;
+					__u64 cookie;
+				} event;
+			};
+		} perf_event;
+		struct {
+			__u32 ifindex;
+			__u32 attach_type;
+		} tcx;
+		struct {
+			__u32 ifindex;
+			__u32 attach_type;
+		} netkit;
+		struct {
+			__u32 map_id;
+			__u32 attach_type;
+		} sockmap;
+	};
+};
+
+struct bpf_link_ops;
+
+struct bpf_link {
+	atomic64_t refcnt;
+	u32 id;
+	enum bpf_link_type type;
+	const struct bpf_link_ops *ops;
+	struct bpf_prog *prog;
+	union {
+		struct callback_head rcu;
+		struct work_struct work;
+	};
+};
+
+struct bpf_link_ops {
+	void (*release)(struct bpf_link *);
+	void (*dealloc)(struct bpf_link *);
+	void (*dealloc_deferred)(struct bpf_link *);
+	int (*detach)(struct bpf_link *);
+	int (*update_prog)(struct bpf_link *, struct bpf_prog *, struct bpf_prog *);
+	void (*show_fdinfo)(const struct bpf_link *, struct seq_file *);
+	int (*fill_link_info)(const struct bpf_link *, struct bpf_link_info *);
+	int (*update_map)(struct bpf_link *, struct bpf_map *, struct bpf_map *);
+	__poll_t (*poll)(struct file *, struct poll_table_struct *);
+};
+
+struct bpf_raw_tp_link {
+	struct bpf_link link;
+	struct bpf_raw_event_map *btp;
+	long: 32;
+	u64 cookie;
+};
+
+enum perf_type_id {
+	PERF_TYPE_HARDWARE = 0,
+	PERF_TYPE_SOFTWARE = 1,
+	PERF_TYPE_TRACEPOINT = 2,
+	PERF_TYPE_HW_CACHE = 3,
+	PERF_TYPE_RAW = 4,
+	PERF_TYPE_BREAKPOINT = 5,
+	PERF_TYPE_MAX = 6,
+};
+
+enum perf_branch_sample_type_shift {
+	PERF_SAMPLE_BRANCH_USER_SHIFT = 0,
+	PERF_SAMPLE_BRANCH_KERNEL_SHIFT = 1,
+	PERF_SAMPLE_BRANCH_HV_SHIFT = 2,
+	PERF_SAMPLE_BRANCH_ANY_SHIFT = 3,
+	PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT = 4,
+	PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 5,
+	PERF_SAMPLE_BRANCH_IND_CALL_SHIFT = 6,
+	PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT = 7,
+	PERF_SAMPLE_BRANCH_IN_TX_SHIFT = 8,
+	PERF_SAMPLE_BRANCH_NO_TX_SHIFT = 9,
+	PERF_SAMPLE_BRANCH_COND_SHIFT = 10,
+	PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 11,
+	PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT = 12,
+	PERF_SAMPLE_BRANCH_CALL_SHIFT = 13,
+	PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT = 14,
+	PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT = 15,
+	PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT = 16,
+	PERF_SAMPLE_BRANCH_HW_INDEX_SHIFT = 17,
+	PERF_SAMPLE_BRANCH_PRIV_SAVE_SHIFT = 18,
+	PERF_SAMPLE_BRANCH_COUNTERS_SHIFT = 19,
+	PERF_SAMPLE_BRANCH_MAX_SHIFT = 20,
+};
+
+enum {
+	HW_BREAKPOINT_LEN_1 = 1,
+	HW_BREAKPOINT_LEN_2 = 2,
+	HW_BREAKPOINT_LEN_3 = 3,
+	HW_BREAKPOINT_LEN_4 = 4,
+	HW_BREAKPOINT_LEN_5 = 5,
+	HW_BREAKPOINT_LEN_6 = 6,
+	HW_BREAKPOINT_LEN_7 = 7,
+	HW_BREAKPOINT_LEN_8 = 8,
+};
+
+enum {
+	HW_BREAKPOINT_EMPTY = 0,
+	HW_BREAKPOINT_R = 1,
+	HW_BREAKPOINT_W = 2,
+	HW_BREAKPOINT_RW = 3,
+	HW_BREAKPOINT_X = 4,
+	HW_BREAKPOINT_INVALID = 7,
+};
+
+enum bp_type_idx {
+	TYPE_INST = 0,
+	TYPE_DATA = 1,
+	TYPE_MAX = 2,
+};
+
+struct membuf {
+	void *p;
+	size_t left;
+};
+
+struct user_regset;
+
+typedef int user_regset_active_fn(struct task_struct *, const struct user_regset *);
+
+typedef int user_regset_get2_fn(struct task_struct *, const struct user_regset *, struct membuf);
+
+typedef int user_regset_set_fn(struct task_struct *, const struct user_regset *, unsigned int, unsigned int, const void *, const void *);
+
+typedef int user_regset_writeback_fn(struct task_struct *, const struct user_regset *, int);
+
+struct user_regset {
+	user_regset_get2_fn *regset_get;
+	user_regset_set_fn *set;
+	user_regset_active_fn *active;
+	user_regset_writeback_fn *writeback;
+	unsigned int n;
+	unsigned int size;
+	unsigned int align;
+	unsigned int bias;
+	unsigned int core_note_type;
+};
+
+struct user_regset_view {
+	const char *name;
+	const struct user_regset *regsets;
+	unsigned int n;
+	u32 e_flags;
+	u16 e_machine;
+	u8 ei_osabi;
+};
+
+struct ring_buffer_event {
+	u32 type_len: 5;
+	u32 time_delta: 27;
+	u32 array[0];
+};
+
+struct trace_buffer;
+
+struct trace_event_file;
+
+struct trace_event_buffer {
+	struct trace_buffer *buffer;
+	struct ring_buffer_event *event;
+	struct trace_event_file *trace_file;
+	void *entry;
+	unsigned int trace_ctx;
+	struct pt_regs *regs;
+};
+
+struct eventfs_inode;
+
+struct trace_subsystem_dir;
+
+struct trace_event_file {
+	struct list_head list;
+	struct trace_event_call *event_call;
+	struct event_filter *filter;
+	struct eventfs_inode *ei;
+	struct trace_array *tr;
+	struct trace_subsystem_dir *system;
+	struct list_head triggers;
+	long unsigned int flags;
+	refcount_t ref;
+	atomic_t sm_ref;
+	atomic_t tm_ref;
+};
+
+enum {
+	TRACE_EVENT_FL_FILTERED = 1,
+	TRACE_EVENT_FL_CAP_ANY = 2,
+	TRACE_EVENT_FL_NO_SET_FILTER = 4,
+	TRACE_EVENT_FL_IGNORE_ENABLE = 8,
+	TRACE_EVENT_FL_TRACEPOINT = 16,
+	TRACE_EVENT_FL_DYNAMIC = 32,
+	TRACE_EVENT_FL_KPROBE = 64,
+	TRACE_EVENT_FL_UPROBE = 128,
+	TRACE_EVENT_FL_EPROBE = 256,
+	TRACE_EVENT_FL_FPROBE = 512,
+	TRACE_EVENT_FL_CUSTOM = 1024,
+};
+
+enum {
+	EVENT_FILE_FL_ENABLED = 1,
+	EVENT_FILE_FL_RECORDED_CMD = 2,
+	EVENT_FILE_FL_RECORDED_TGID = 4,
+	EVENT_FILE_FL_FILTERED = 8,
+	EVENT_FILE_FL_NO_SET_FILTER = 16,
+	EVENT_FILE_FL_SOFT_MODE = 32,
+	EVENT_FILE_FL_SOFT_DISABLED = 64,
+	EVENT_FILE_FL_TRIGGER_MODE = 128,
+	EVENT_FILE_FL_TRIGGER_COND = 256,
+	EVENT_FILE_FL_PID_FILTER = 512,
+	EVENT_FILE_FL_WAS_ENABLED = 1024,
+	EVENT_FILE_FL_FREED = 2048,
+};
+
+enum {
+	FILTER_OTHER = 0,
+	FILTER_STATIC_STRING = 1,
+	FILTER_DYN_STRING = 2,
+	FILTER_RDYN_STRING = 3,
+	FILTER_PTR_STRING = 4,
+	FILTER_TRACE_FN = 5,
+	FILTER_CPUMASK = 6,
+	FILTER_COMM = 7,
+	FILTER_CPU = 8,
+	FILTER_STACKTRACE = 9,
+};
+
+struct trace_event_raw_sys_enter {
+	struct trace_entry ent;
+	long int id;
+	long unsigned int args[6];
+	char __data[0];
+};
+
+struct trace_event_raw_sys_exit {
+	struct trace_entry ent;
+	long int id;
+	long int ret;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_sys_enter {};
+
+struct trace_event_data_offsets_sys_exit {};
+
+typedef void (*btf_trace_sys_enter)(void *, struct pt_regs *, long int);
+
+typedef void (*btf_trace_sys_exit)(void *, struct pt_regs *, long int);
+
+struct pt_regs_offset {
+	const char *name;
+	int offset;
+};
+
+enum arm_regset {
+	REGSET_GPR = 0,
+	REGSET_FPR = 1,
+};
+
+enum ptrace_syscall_dir {
+	PTRACE_SYSCALL_ENTER = 0,
+	PTRACE_SYSCALL_EXIT = 1,
+};
+
+struct smp_operations {
+	void (*smp_init_cpus)();
+	void (*smp_prepare_cpus)(unsigned int);
+	void (*smp_secondary_init)(unsigned int);
+	int (*smp_boot_secondary)(unsigned int, struct task_struct *);
+};
+
+enum hrtimer_base_type {
+	HRTIMER_BASE_MONOTONIC = 0,
+	HRTIMER_BASE_REALTIME = 1,
+	HRTIMER_BASE_BOOTTIME = 2,
+	HRTIMER_BASE_TAI = 3,
+	HRTIMER_BASE_MONOTONIC_SOFT = 4,
+	HRTIMER_BASE_REALTIME_SOFT = 5,
+	HRTIMER_BASE_BOOTTIME_SOFT = 6,
+	HRTIMER_BASE_TAI_SOFT = 7,
+	HRTIMER_MAX_CLOCK_BASES = 8,
+};
+
+enum {
+	HI_SOFTIRQ = 0,
+	TIMER_SOFTIRQ = 1,
+	NET_TX_SOFTIRQ = 2,
+	NET_RX_SOFTIRQ = 3,
+	BLOCK_SOFTIRQ = 4,
+	IRQ_POLL_SOFTIRQ = 5,
+	TASKLET_SOFTIRQ = 6,
+	SCHED_SOFTIRQ = 7,
+	HRTIMER_SOFTIRQ = 8,
+	RCU_SOFTIRQ = 9,
+	NR_SOFTIRQS = 10,
+};
+
+enum reboot_mode {
+	REBOOT_UNDEFINED = -1,
+	REBOOT_COLD = 0,
+	REBOOT_WARM = 1,
+	REBOOT_HARD = 2,
+	REBOOT_SOFT = 3,
+	REBOOT_GPIO = 4,
+};
+
+struct tag;
+
+struct machine_desc {
+	unsigned int nr;
+	const char *name;
+	long unsigned int atag_offset;
+	const char * const *dt_compat;
+	unsigned int nr_irqs;
+	unsigned int video_start;
+	unsigned int video_end;
+	unsigned char reserve_lp0: 1;
+	unsigned char reserve_lp1: 1;
+	unsigned char reserve_lp2: 1;
+	enum reboot_mode reboot_mode;
+	unsigned int l2c_aux_val;
+	unsigned int l2c_aux_mask;
+	void (*l2c_write_sec)(long unsigned int, unsigned int);
+	const struct smp_operations *smp;
+	bool (*smp_init)();
+	void (*fixup)(struct tag *, char **);
+	void (*dt_fixup)();
+	long long int (*pv_fixup)();
+	void (*reserve)();
+	void (*map_io)();
+	void (*init_early)();
+	void (*init_irq)();
+	void (*init_time)();
+	void (*init_machine)();
+	void (*init_late)();
+	void (*restart)(enum reboot_mode, const char *);
+};
+
+typedef void (*clock_access_fn)(struct timespec64 *);
+
+struct stackframe {
+	long unsigned int fp;
+	long unsigned int sp;
+	long unsigned int lr;
+	long unsigned int pc;
+	long unsigned int *lr_addr;
+	struct llist_node *kr_cur;
+	struct task_struct *tsk;
+};
+
+enum {
+	DQF_ROOT_SQUASH_B = 0,
+	DQF_SYS_FILE_B = 16,
+	DQF_PRIVATE = 17,
+};
+
+enum {
+	DQST_LOOKUPS = 0,
+	DQST_DROPS = 1,
+	DQST_READS = 2,
+	DQST_WRITES = 3,
+	DQST_CACHE_HITS = 4,
+	DQST_ALLOC_DQUOTS = 5,
+	DQST_FREE_DQUOTS = 6,
+	DQST_SYNCS = 7,
+	_DQST_DQSTAT_LAST = 8,
+};
+
+enum {
+	SB_UNFROZEN = 0,
+	SB_FREEZE_WRITE = 1,
+	SB_FREEZE_PAGEFAULT = 2,
+	SB_FREEZE_FS = 3,
+	SB_FREEZE_COMPLETE = 4,
+};
+
+struct tag_header {
+	__u32 size;
+	__u32 tag;
+};
+
+struct tag_core {
+	__u32 flags;
+	__u32 pagesize;
+	__u32 rootdev;
+};
+
+struct tag_mem32 {
+	__u32 size;
+	__u32 start;
+};
+
+struct tag_videotext {
+	__u8 x;
+	__u8 y;
+	__u16 video_page;
+	__u8 video_mode;
+	__u8 video_cols;
+	__u16 video_ega_bx;
+	__u8 video_lines;
+	__u8 video_isvga;
+	__u16 video_points;
+};
+
+struct tag_ramdisk {
+	__u32 flags;
+	__u32 size;
+	__u32 start;
+};
+
+struct tag_initrd {
+	__u32 start;
+	__u32 size;
+};
+
+struct tag_serialnr {
+	__u32 low;
+	__u32 high;
+};
+
+struct tag_revision {
+	__u32 rev;
+};
+
+struct tag_videolfb {
+	__u16 lfb_width;
+	__u16 lfb_height;
+	__u16 lfb_depth;
+	__u16 lfb_linelength;
+	__u32 lfb_base;
+	__u32 lfb_size;
+	__u8 red_size;
+	__u8 red_pos;
+	__u8 green_size;
+	__u8 green_pos;
+	__u8 blue_size;
+	__u8 blue_pos;
+	__u8 rsvd_size;
+	__u8 rsvd_pos;
+};
+
+struct tag_cmdline {
+	char cmdline[1];
+};
+
+struct tag_acorn {
+	__u32 memc_control_reg;
+	__u32 vram_pages;
+	__u8 sounddefault;
+	__u8 adfsdrives;
+};
+
+struct tag_memclk {
+	__u32 fmemclk;
+};
+
+struct tag {
+	struct tag_header hdr;
+	union {
+		struct tag_core core;
+		struct tag_mem32 mem;
+		struct tag_videotext videotext;
+		struct tag_ramdisk ramdisk;
+		struct tag_initrd initrd;
+		struct tag_serialnr serialnr;
+		struct tag_revision revision;
+		struct tag_videolfb videolfb;
+		struct tag_cmdline cmdline;
+		struct tag_acorn acorn;
+		struct tag_memclk memclk;
+	} u;
+};
+
+struct tagtable {
+	__u32 tag;
+	int (*parse)(const struct tag *);
+};
+
+typedef unsigned int u_int;
+
+typedef phys_addr_t resource_size_t;
+
+struct pci_device_id {
+	__u32 vendor;
+	__u32 device;
+	__u32 subvendor;
+	__u32 subdevice;
+	__u32 class;
+	__u32 class_mask;
+	kernel_ulong_t driver_data;
+	__u32 override_only;
+};
+
+struct resource {
+	resource_size_t start;
+	resource_size_t end;
+	const char *name;
+	long unsigned int flags;
+	long unsigned int desc;
+	struct resource *parent;
+	struct resource *sibling;
+	struct resource *child;
+};
+
+struct resource_entry {
+	struct list_head node;
+	struct resource *res;
+	resource_size_t offset;
+	struct resource __res;
+};
+
+struct pci_bus;
+
+struct hotplug_slot;
+
+struct pci_slot {
+	struct pci_bus *bus;
+	struct list_head list;
+	struct hotplug_slot *hotplug;
+	unsigned char number;
+	struct kobject kobj;
+};
+
+typedef short unsigned int pci_bus_flags_t;
+
+struct pci_dev;
+
+struct pci_ops;
+
+struct pci_bus {
+	struct list_head node;
+	struct pci_bus *parent;
+	struct list_head children;
+	struct list_head devices;
+	struct pci_dev *self;
+	struct list_head slots;
+	struct resource *resource[4];
+	struct list_head resources;
+	struct resource busn_res;
+	struct pci_ops *ops;
+	void *sysdata;
+	struct proc_dir_entry *procdir;
+	unsigned char number;
+	unsigned char primary;
+	unsigned char max_bus_speed;
+	unsigned char cur_bus_speed;
+	int domain_nr;
+	char name[48];
+	short unsigned int bridge_ctl;
+	pci_bus_flags_t bus_flags;
+	struct device *bridge;
+	long: 32;
+	struct device dev;
+	struct bin_attribute *legacy_io;
+	struct bin_attribute *legacy_mem;
+	unsigned int is_added: 1;
+	unsigned int unsafe_warn: 1;
+	long: 32;
+};
+
+enum {
+	PCI_STD_RESOURCES = 0,
+	PCI_STD_RESOURCE_END = 5,
+	PCI_ROM_RESOURCE = 6,
+	PCI_BRIDGE_RESOURCES = 7,
+	PCI_BRIDGE_RESOURCE_END = 10,
+	PCI_NUM_RESOURCES = 11,
+	DEVICE_COUNT_RESOURCE = 11,
+};
+
+typedef int pci_power_t;
+
+typedef unsigned int pci_channel_state_t;
+
+typedef unsigned int pcie_reset_state_t;
+
+typedef short unsigned int pci_dev_flags_t;
+
+struct pci_vpd {
+	struct mutex lock;
+	unsigned int len;
+	u8 cap;
+};
+
+struct pci_driver;
+
+struct pci_dev {
+	struct list_head bus_list;
+	struct pci_bus *bus;
+	struct pci_bus *subordinate;
+	void *sysdata;
+	struct proc_dir_entry *procent;
+	struct pci_slot *slot;
+	unsigned int devfn;
+	short unsigned int vendor;
+	short unsigned int device;
+	short unsigned int subsystem_vendor;
+	short unsigned int subsystem_device;
+	unsigned int class;
+	u8 revision;
+	u8 hdr_type;
+	u32 devcap;
+	u8 pcie_cap;
+	u8 msi_cap;
+	u8 msix_cap;
+	u8 pcie_mpss: 3;
+	u8 rom_base_reg;
+	u8 pin;
+	u16 pcie_flags_reg;
+	long unsigned int *dma_alias_mask;
+	struct pci_driver *driver;
+	long: 32;
+	u64 dma_mask;
+	struct device_dma_parameters dma_parms;
+	pci_power_t current_state;
+	u8 pm_cap;
+	unsigned int pme_support: 5;
+	unsigned int pme_poll: 1;
+	unsigned int pinned: 1;
+	unsigned int config_rrs_sv: 1;
+	unsigned int imm_ready: 1;
+	unsigned int d1_support: 1;
+	unsigned int d2_support: 1;
+	unsigned int no_d1d2: 1;
+	unsigned int no_d3cold: 1;
+	unsigned int bridge_d3: 1;
+	unsigned int d3cold_allowed: 1;
+	unsigned int mmio_always_on: 1;
+	unsigned int wakeup_prepared: 1;
+	unsigned int skip_bus_pm: 1;
+	unsigned int ignore_hotplug: 1;
+	unsigned int hotplug_user_indicators: 1;
+	unsigned int clear_retrain_link: 1;
+	unsigned int d3hot_delay;
+	unsigned int d3cold_delay;
+	u16 l1ss;
+	unsigned int pasid_no_tlp: 1;
+	unsigned int eetlp_prefix_path: 1;
+	pci_channel_state_t error_state;
+	long: 32;
+	struct device dev;
+	int cfg_size;
+	unsigned int irq;
+	struct resource resource[11];
+	struct resource driver_exclusive_resource;
+	bool match_driver;
+	unsigned int transparent: 1;
+	unsigned int io_window: 1;
+	unsigned int pref_window: 1;
+	unsigned int pref_64_window: 1;
+	unsigned int multifunction: 1;
+	unsigned int is_busmaster: 1;
+	unsigned int no_msi: 1;
+	unsigned int no_64bit_msi: 1;
+	unsigned int block_cfg_access: 1;
+	unsigned int broken_parity_status: 1;
+	unsigned int irq_reroute_variant: 2;
+	unsigned int msi_enabled: 1;
+	unsigned int msix_enabled: 1;
+	unsigned int ari_enabled: 1;
+	unsigned int ats_enabled: 1;
+	unsigned int pasid_enabled: 1;
+	unsigned int pri_enabled: 1;
+	unsigned int is_managed: 1;
+	unsigned int is_msi_managed: 1;
+	unsigned int needs_freset: 1;
+	unsigned int state_saved: 1;
+	unsigned int is_physfn: 1;
+	unsigned int is_virtfn: 1;
+	unsigned int is_hotplug_bridge: 1;
+	unsigned int shpc_managed: 1;
+	unsigned int is_thunderbolt: 1;
+	unsigned int untrusted: 1;
+	unsigned int external_facing: 1;
+	unsigned int broken_intx_masking: 1;
+	unsigned int io_window_1k: 1;
+	unsigned int irq_managed: 1;
+	unsigned int non_compliant_bars: 1;
+	unsigned int is_probed: 1;
+	unsigned int link_active_reporting: 1;
+	unsigned int no_vf_scan: 1;
+	unsigned int no_command_memory: 1;
+	unsigned int rom_bar_overlap: 1;
+	unsigned int rom_attr_enabled: 1;
+	pci_dev_flags_t dev_flags;
+	atomic_t enable_cnt;
+	spinlock_t pcie_cap_lock;
+	u32 saved_config_space[16];
+	struct hlist_head saved_cap_space;
+	struct bin_attribute *res_attr[11];
+	struct bin_attribute *res_attr_wc[11];
+	struct pci_vpd vpd;
+	u16 acs_cap;
+	phys_addr_t rom;
+	size_t romlen;
+	const char *driver_override;
+	long unsigned int priv_flags;
+	u8 reset_methods[8];
+	long: 32;
+};
+
+struct pci_dynids {
+	spinlock_t lock;
+	struct list_head list;
+};
+
+struct pci_error_handlers;
+
+struct pci_driver {
+	const char *name;
+	const struct pci_device_id *id_table;
+	int (*probe)(struct pci_dev *, const struct pci_device_id *);
+	void (*remove)(struct pci_dev *);
+	int (*suspend)(struct pci_dev *, pm_message_t);
+	int (*resume)(struct pci_dev *);
+	void (*shutdown)(struct pci_dev *);
+	int (*sriov_configure)(struct pci_dev *, int);
+	int (*sriov_set_msix_vec_count)(struct pci_dev *, int);
+	u32 (*sriov_get_vf_total_msix)(struct pci_dev *);
+	const struct pci_error_handlers *err_handler;
+	const struct attribute_group **groups;
+	const struct attribute_group **dev_groups;
+	struct device_driver driver;
+	struct pci_dynids dynids;
+	bool driver_managed_dma;
+};
+
+struct pci_host_bridge {
+	struct device dev;
+	struct pci_bus *bus;
+	struct pci_ops *ops;
+	struct pci_ops *child_ops;
+	void *sysdata;
+	int busnr;
+	int domain_nr;
+	struct list_head windows;
+	struct list_head dma_ranges;
+	u8 (*swizzle_irq)(struct pci_dev *, u8 *);
+	int (*map_irq)(const struct pci_dev *, u8, u8);
+	void (*release_fn)(struct pci_host_bridge *);
+	void *release_data;
+	unsigned int ignore_reset_delay: 1;
+	unsigned int no_ext_tags: 1;
+	unsigned int no_inc_mrrs: 1;
+	unsigned int native_aer: 1;
+	unsigned int native_pcie_hotplug: 1;
+	unsigned int native_shpc_hotplug: 1;
+	unsigned int native_pme: 1;
+	unsigned int native_ltr: 1;
+	unsigned int native_dpc: 1;
+	unsigned int native_cxl_error: 1;
+	unsigned int preserve_config: 1;
+	unsigned int size_windows: 1;
+	unsigned int msi_domain: 1;
+	resource_size_t (*align_resource)(struct pci_dev *, const struct resource *, resource_size_t, resource_size_t, resource_size_t);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long unsigned int private[0];
+};
+
+struct pci_ops {
+	int (*add_bus)(struct pci_bus *);
+	void (*remove_bus)(struct pci_bus *);
+	void * (*map_bus)(struct pci_bus *, unsigned int, int);
+	int (*read)(struct pci_bus *, unsigned int, int, int, u32 *);
+	int (*write)(struct pci_bus *, unsigned int, int, int, u32);
+};
+
+typedef unsigned int pci_ers_result_t;
+
+struct pci_error_handlers {
+	pci_ers_result_t (*error_detected)(struct pci_dev *, pci_channel_state_t);
+	pci_ers_result_t (*mmio_enabled)(struct pci_dev *);
+	pci_ers_result_t (*slot_reset)(struct pci_dev *);
+	void (*reset_prepare)(struct pci_dev *);
+	void (*reset_done)(struct pci_dev *);
+	void (*resume)(struct pci_dev *);
+	void (*cor_error_detected)(struct pci_dev *);
+};
+
+enum {
+	PCI_REASSIGN_ALL_RSRC = 1,
+	PCI_REASSIGN_ALL_BUS = 2,
+	PCI_PROBE_ONLY = 4,
+	PCI_CAN_SKIP_ISA_ALIGN = 8,
+	PCI_ENABLE_PROC_DOMAINS = 16,
+	PCI_COMPAT_DOMAIN_0 = 32,
+	PCI_SCAN_ALL_PCIE_DEVS = 64,
+};
+
+struct pci_sys_data;
+
+struct hw_pci {
+	struct pci_ops *ops;
+	int nr_controllers;
+	void **private_data;
+	int (*setup)(int, struct pci_sys_data *);
+	int (*scan)(int, struct pci_host_bridge *);
+	void (*preinit)();
+	void (*postinit)();
+	u8 (*swizzle)(struct pci_dev *, u8 *);
+	int (*map_irq)(const struct pci_dev *, u8, u8);
+};
+
+struct pci_sys_data {
+	struct list_head node;
+	int busnr;
+	long: 32;
+	u64 mem_offset;
+	long unsigned int io_offset;
+	struct pci_bus *bus;
+	struct list_head resources;
+	struct resource io_res;
+	char io_res_name[12];
+	u8 (*swizzle)(struct pci_dev *, u8 *);
+	int (*map_irq)(const struct pci_dev *, u8, u8);
+	void *private_data;
+};
+
+struct pci_fixup {
+	u16 vendor;
+	u16 device;
+	u32 class;
+	unsigned int class_shift;
+	void (*hook)(struct pci_dev *);
+};
+
+struct map_desc {
+	long unsigned int virtual;
+	long unsigned int pfn;
+	long unsigned int length;
+	unsigned int type;
+};
+
+struct delay_timer {
+	long unsigned int (*read_current_timer)();
+	long unsigned int freq;
+};
+
+typedef int (*cpu_stop_fn_t)(void *);
+
+struct patch {
+	void *addr;
+	unsigned int insn;
+};
+
+enum perf_sample_regs_abi {
+	PERF_SAMPLE_REGS_ABI_NONE = 0,
+	PERF_SAMPLE_REGS_ABI_32 = 1,
+	PERF_SAMPLE_REGS_ABI_64 = 2,
+};
+
+enum perf_event_arm_regs {
+	PERF_REG_ARM_R0 = 0,
+	PERF_REG_ARM_R1 = 1,
+	PERF_REG_ARM_R2 = 2,
+	PERF_REG_ARM_R3 = 3,
+	PERF_REG_ARM_R4 = 4,
+	PERF_REG_ARM_R5 = 5,
+	PERF_REG_ARM_R6 = 6,
+	PERF_REG_ARM_R7 = 7,
+	PERF_REG_ARM_R8 = 8,
+	PERF_REG_ARM_R9 = 9,
+	PERF_REG_ARM_R10 = 10,
+	PERF_REG_ARM_FP = 11,
+	PERF_REG_ARM_IP = 12,
+	PERF_REG_ARM_SP = 13,
+	PERF_REG_ARM_LR = 14,
+	PERF_REG_ARM_PC = 15,
+	PERF_REG_ARM_MAX = 16,
+};
+
+typedef struct elf32_hdr Elf32_Ehdr;
+
+struct elf32_shdr {
+	Elf32_Word sh_name;
+	Elf32_Word sh_type;
+	Elf32_Word sh_flags;
+	Elf32_Addr sh_addr;
+	Elf32_Off sh_offset;
+	Elf32_Word sh_size;
+	Elf32_Word sh_link;
+	Elf32_Word sh_info;
+	Elf32_Word sh_addralign;
+	Elf32_Word sh_entsize;
+};
+
+typedef struct elf32_shdr Elf32_Shdr;
+
+struct timens_offset {
+	s64 sec;
+	u64 nsec;
+};
+
+struct vm_special_mapping {
+	const char *name;
+	struct page **pages;
+	vm_fault_t (*fault)(const struct vm_special_mapping *, struct vm_area_struct *, struct vm_fault *);
+	int (*mremap)(const struct vm_special_mapping *, struct vm_area_struct *);
+	void (*close)(const struct vm_special_mapping *, struct vm_area_struct *);
+};
+
+typedef u32 phandle;
+
+struct property {
+	char *name;
+	int length;
+	void *value;
+	struct property *next;
+	struct bin_attribute attr;
+};
+
+struct device_node {
+	const char *name;
+	phandle phandle;
+	const char *full_name;
+	struct fwnode_handle fwnode;
+	struct property *properties;
+	struct property *deadprops;
+	struct device_node *parent;
+	struct device_node *child;
+	struct device_node *sibling;
+	struct kobject kobj;
+	long unsigned int _flags;
+	void *data;
+};
+
+struct arch_vdso_data {};
+
+struct vdso_timestamp {
+	u64 sec;
+	u64 nsec;
+};
+
+struct vdso_data {
+	u32 seq;
+	s32 clock_mode;
+	u64 cycle_last;
+	u64 mask;
+	u32 mult;
+	u32 shift;
+	union {
+		struct vdso_timestamp basetime[12];
+		struct timens_offset offset[12];
+	};
+	s32 tz_minuteswest;
+	s32 tz_dsttime;
+	u32 hrtimer_res;
+	u32 __unused;
+	struct arch_vdso_data arch_data;
+};
+
+union vdso_data_store {
+	struct vdso_data data[2];
+	u8 page[4096];
+};
+
+struct elfinfo {
+	Elf32_Ehdr *hdr;
+	Elf32_Sym *dynsym;
+	long unsigned int dynsymsize;
+	char *dynstr;
+};
+
+struct wait_queue_entry;
+
+typedef int (*wait_queue_func_t)(struct wait_queue_entry *, unsigned int, int, void *);
+
+struct wait_queue_entry {
+	unsigned int flags;
+	void *private;
+	wait_queue_func_t func;
+	struct list_head entry;
+};
+
+typedef struct wait_queue_entry wait_queue_entry_t;
+
+struct wait_page_queue {
+	struct folio *folio;
+	int bit_nr;
+	wait_queue_entry_t wait;
+};
+
+struct readahead_control {
+	struct file *file;
+	struct address_space *mapping;
+	struct file_ra_state *ra;
+	long unsigned int _index;
+	unsigned int _nr_pages;
+	unsigned int _batch_count;
+	bool _workingset;
+	long unsigned int _pflags;
+};
+
+struct vm_struct {
+	struct vm_struct *next;
+	void *addr;
+	long unsigned int size;
+	long unsigned int flags;
+	struct page **pages;
+	unsigned int nr_pages;
+	phys_addr_t phys_addr;
+	const void *caller;
+};
+
+enum {
+	MT_UNCACHED = 4,
+	MT_CACHECLEAN = 5,
+	MT_MINICLEAN = 6,
+	MT_LOW_VECTORS = 7,
+	MT_HIGH_VECTORS = 8,
+	MT_MEMORY_RWX = 9,
+	MT_MEMORY_RW = 10,
+	MT_MEMORY_RO = 11,
+	MT_ROM = 12,
+	MT_MEMORY_RWX_NONCACHED = 13,
+	MT_MEMORY_RW_DTCM = 14,
+	MT_MEMORY_RWX_ITCM = 15,
+	MT_MEMORY_RW_SO = 16,
+	MT_MEMORY_DMA_READY = 17,
+};
+
+struct mem_type {
+	pteval_t prot_pte;
+	pteval_t prot_pte_s2;
+	pmdval_t prot_l1;
+	pmdval_t prot_sect;
+	unsigned int domain;
+};
+
+struct static_vm {
+	struct vm_struct vm;
+	struct list_head list;
+};
+
+struct processor {
+	void (*_data_abort)(long unsigned int);
+	long unsigned int (*_prefetch_abort)(long unsigned int);
+	void (*_proc_init)();
+	void (*check_bugs)();
+	void (*_proc_fin)();
+	void (*reset)(long unsigned int, bool);
+	int (*_do_idle)();
+	void (*dcache_clean_area)(void *, int);
+	void (*switch_mm)(phys_addr_t, struct mm_struct *);
+	void (*set_pte_ext)(pte_t *, pte_t, unsigned int);
+	unsigned int suspend_size;
+	void (*do_suspend)(void *);
+	void (*do_resume)(void *);
+};
+
+typedef int (*pte_fn_t)(pte_t *, long unsigned int, void *);
+
+struct page_change_data {
+	pgprot_t set_mask;
+	pgprot_t clear_mask;
+};
+
+struct cpu_tlb_fns {
+	void (*flush_user_range)(long unsigned int, long unsigned int, struct vm_area_struct *);
+	void (*flush_kern_range)(long unsigned int, long unsigned int);
+	long unsigned int tlb_flags;
+};
+
+typedef u32 kprobe_opcode_t;
+
+typedef u32 probes_opcode_t;
+
+struct arch_probes_insn;
+
+typedef void probes_insn_handler_t(probes_opcode_t, struct arch_probes_insn *, struct pt_regs *);
+
+typedef long unsigned int probes_check_cc(long unsigned int);
+
+typedef void probes_insn_singlestep_t(probes_opcode_t, struct arch_probes_insn *, struct pt_regs *);
+
+typedef void probes_insn_fn_t();
+
+struct arch_probes_insn {
+	probes_opcode_t *insn;
+	probes_insn_handler_t *insn_handler;
+	probes_check_cc *insn_check_cc;
+	probes_insn_singlestep_t *insn_singlestep;
+	probes_insn_fn_t *insn_fn;
+	int stack_space;
+	long unsigned int register_usage_flags;
+	bool kprobe_direct_exec;
+};
+
+union decode_item {
+	u32 bits;
+	const union decode_item *table;
+	int action;
+};
+
+enum probes_insn {
+	INSN_REJECTED = 0,
+	INSN_GOOD = 1,
+	INSN_GOOD_NO_SLOT = 2,
+};
+
+struct decode_header;
+
+typedef enum probes_insn probes_custom_decode_t(probes_opcode_t, struct arch_probes_insn *, const struct decode_header *);
+
+struct decode_header {
+	union decode_item type_regs;
+	union decode_item mask;
+	union decode_item value;
+};
+
+union decode_action {
+	probes_insn_handler_t *handler;
+	probes_custom_decode_t *decoder;
+};
+
+typedef enum probes_insn probes_check_t(probes_opcode_t, struct arch_probes_insn *, const struct decode_header *);
+
+struct decode_checker {
+	probes_check_t *checker;
+};
+
+enum probes_arm_action {
+	PROBES_PRELOAD_IMM = 0,
+	PROBES_PRELOAD_REG = 1,
+	PROBES_BRANCH_IMM = 2,
+	PROBES_BRANCH_REG = 3,
+	PROBES_MRS = 4,
+	PROBES_CLZ = 5,
+	PROBES_SATURATING_ARITHMETIC = 6,
+	PROBES_MUL1 = 7,
+	PROBES_MUL2 = 8,
+	PROBES_SWP = 9,
+	PROBES_LDRSTRD = 10,
+	PROBES_LOAD = 11,
+	PROBES_STORE = 12,
+	PROBES_LOAD_EXTRA = 13,
+	PROBES_STORE_EXTRA = 14,
+	PROBES_MOV_IP_SP = 15,
+	PROBES_DATA_PROCESSING_REG = 16,
+	PROBES_DATA_PROCESSING_IMM = 17,
+	PROBES_MOV_HALFWORD = 18,
+	PROBES_SEV = 19,
+	PROBES_WFE = 20,
+	PROBES_SATURATE = 21,
+	PROBES_REV = 22,
+	PROBES_MMI = 23,
+	PROBES_PACK = 24,
+	PROBES_EXTEND = 25,
+	PROBES_EXTEND_ADD = 26,
+	PROBES_MUL_ADD_LONG = 27,
+	PROBES_MUL_ADD = 28,
+	PROBES_BITFIELD = 29,
+	PROBES_BRANCH = 30,
+	PROBES_LDMSTM = 31,
+	NUM_PROBES_ARM_ACTIONS = 32,
+};
+
+struct kprobe;
+
+struct prev_kprobe {
+	struct kprobe *kp;
+	unsigned int status;
+};
+
+typedef int (*kprobe_pre_handler_t)(struct kprobe *, struct pt_regs *);
+
+typedef void (*kprobe_post_handler_t)(struct kprobe *, struct pt_regs *, long unsigned int);
+
+struct kprobe {
+	struct hlist_node hlist;
+	struct list_head list;
+	long unsigned int nmissed;
+	kprobe_opcode_t *addr;
+	const char *symbol_name;
+	unsigned int offset;
+	kprobe_pre_handler_t pre_handler;
+	kprobe_post_handler_t post_handler;
+	kprobe_opcode_t opcode;
+	struct arch_probes_insn ainsn;
+	u32 flags;
+};
+
+struct kprobe_ctlblk {
+	unsigned int kprobe_status;
+	struct prev_kprobe prev_kprobe;
+};
+
+struct arch_optimized_insn {
+	kprobe_opcode_t copied_insn[1];
+	kprobe_opcode_t *insn;
+};
+
+struct kprobe_insn_cache {
+	struct mutex mutex;
+	void * (*alloc)();
+	void (*free)(void *);
+	const char *sym;
+	struct list_head pages;
+	size_t insn_size;
+	int nr_garbage;
+};
+
+struct optimized_kprobe {
+	struct kprobe kp;
+	struct list_head list;
+	struct arch_optimized_insn optinsn;
+};
+
+typedef __u32 __le32;
+
+struct of_cpu_method {
+	const char *method;
+	const struct smp_operations *ops;
+};
+
+struct plist_head {
+	struct list_head node_list;
+};
+
+struct reclaim_state {
+	long unsigned int reclaimed;
+	struct lru_gen_mm_walk *mm_walk;
+};
+
+struct swap_cluster_info;
+
+struct percpu_cluster;
+
+struct swap_info_struct {
+	struct percpu_ref users;
+	long unsigned int flags;
+	short int prio;
+	struct plist_node list;
+	signed char type;
+	unsigned int max;
+	unsigned char *swap_map;
+	long unsigned int *zeromap;
+	struct swap_cluster_info *cluster_info;
+	struct list_head free_clusters;
+	struct list_head full_clusters;
+	struct list_head nonfull_clusters[1];
+	struct list_head frag_clusters[1];
+	unsigned int frag_cluster_nr[1];
+	unsigned int lowest_bit;
+	unsigned int highest_bit;
+	unsigned int pages;
+	unsigned int inuse_pages;
+	unsigned int cluster_next;
+	unsigned int cluster_nr;
+	unsigned int *cluster_next_cpu;
+	struct percpu_cluster *percpu_cluster;
+	struct rb_root swap_extent_root;
+	struct block_device *bdev;
+	struct file *swap_file;
+	struct completion comp;
+	spinlock_t lock;
+	spinlock_t cont_lock;
+	struct work_struct discard_work;
+	struct work_struct reclaim_work;
+	struct list_head discard_clusters;
+	struct plist_node avail_lists[0];
+};
+
+enum pm_qos_type {
+	PM_QOS_UNITIALIZED = 0,
+	PM_QOS_MAX = 1,
+	PM_QOS_MIN = 2,
+};
+
+struct pm_qos_constraints {
+	struct plist_head list;
+	s32 target_value;
+	s32 default_value;
+	s32 no_constraint_value;
+	enum pm_qos_type type;
+	struct blocking_notifier_head *notifiers;
+};
+
+struct freq_constraints {
+	struct pm_qos_constraints min_freq;
+	struct blocking_notifier_head min_freq_notifiers;
+	struct pm_qos_constraints max_freq;
+	struct blocking_notifier_head max_freq_notifiers;
+};
+
+struct pm_qos_flags {
+	struct list_head list;
+	s32 effective_flags;
+};
+
+struct dev_pm_qos_request;
+
+struct dev_pm_qos {
+	struct pm_qos_constraints resume_latency;
+	struct pm_qos_constraints latency_tolerance;
+	struct freq_constraints freq;
+	struct pm_qos_flags flags;
+	struct dev_pm_qos_request *resume_latency_req;
+	struct dev_pm_qos_request *latency_tolerance_req;
+	struct dev_pm_qos_request *flags_req;
+};
+
+enum cpuhp_state {
+	CPUHP_INVALID = -1,
+	CPUHP_OFFLINE = 0,
+	CPUHP_CREATE_THREADS = 1,
+	CPUHP_PERF_PREPARE = 2,
+	CPUHP_PERF_X86_PREPARE = 3,
+	CPUHP_PERF_X86_AMD_UNCORE_PREP = 4,
+	CPUHP_PERF_POWER = 5,
+	CPUHP_PERF_SUPERH = 6,
+	CPUHP_X86_HPET_DEAD = 7,
+	CPUHP_X86_MCE_DEAD = 8,
+	CPUHP_VIRT_NET_DEAD = 9,
+	CPUHP_IBMVNIC_DEAD = 10,
+	CPUHP_SLUB_DEAD = 11,
+	CPUHP_DEBUG_OBJ_DEAD = 12,
+	CPUHP_MM_WRITEBACK_DEAD = 13,
+	CPUHP_MM_VMSTAT_DEAD = 14,
+	CPUHP_SOFTIRQ_DEAD = 15,
+	CPUHP_NET_MVNETA_DEAD = 16,
+	CPUHP_CPUIDLE_DEAD = 17,
+	CPUHP_ARM64_FPSIMD_DEAD = 18,
+	CPUHP_ARM_OMAP_WAKE_DEAD = 19,
+	CPUHP_IRQ_POLL_DEAD = 20,
+	CPUHP_BLOCK_SOFTIRQ_DEAD = 21,
+	CPUHP_BIO_DEAD = 22,
+	CPUHP_ACPI_CPUDRV_DEAD = 23,
+	CPUHP_S390_PFAULT_DEAD = 24,
+	CPUHP_BLK_MQ_DEAD = 25,
+	CPUHP_FS_BUFF_DEAD = 26,
+	CPUHP_PRINTK_DEAD = 27,
+	CPUHP_MM_MEMCQ_DEAD = 28,
+	CPUHP_PERCPU_CNT_DEAD = 29,
+	CPUHP_RADIX_DEAD = 30,
+	CPUHP_PAGE_ALLOC = 31,
+	CPUHP_NET_DEV_DEAD = 32,
+	CPUHP_PCI_XGENE_DEAD = 33,
+	CPUHP_IOMMU_IOVA_DEAD = 34,
+	CPUHP_AP_ARM_CACHE_B15_RAC_DEAD = 35,
+	CPUHP_PADATA_DEAD = 36,
+	CPUHP_AP_DTPM_CPU_DEAD = 37,
+	CPUHP_RANDOM_PREPARE = 38,
+	CPUHP_WORKQUEUE_PREP = 39,
+	CPUHP_POWER_NUMA_PREPARE = 40,
+	CPUHP_HRTIMERS_PREPARE = 41,
+	CPUHP_X2APIC_PREPARE = 42,
+	CPUHP_SMPCFD_PREPARE = 43,
+	CPUHP_RELAY_PREPARE = 44,
+	CPUHP_MD_RAID5_PREPARE = 45,
+	CPUHP_RCUTREE_PREP = 46,
+	CPUHP_CPUIDLE_COUPLED_PREPARE = 47,
+	CPUHP_POWERPC_PMAC_PREPARE = 48,
+	CPUHP_POWERPC_MMU_CTX_PREPARE = 49,
+	CPUHP_XEN_PREPARE = 50,
+	CPUHP_XEN_EVTCHN_PREPARE = 51,
+	CPUHP_ARM_SHMOBILE_SCU_PREPARE = 52,
+	CPUHP_SH_SH3X_PREPARE = 53,
+	CPUHP_TOPOLOGY_PREPARE = 54,
+	CPUHP_NET_IUCV_PREPARE = 55,
+	CPUHP_ARM_BL_PREPARE = 56,
+	CPUHP_TRACE_RB_PREPARE = 57,
+	CPUHP_MM_ZS_PREPARE = 58,
+	CPUHP_MM_ZSWP_POOL_PREPARE = 59,
+	CPUHP_KVM_PPC_BOOK3S_PREPARE = 60,
+	CPUHP_ZCOMP_PREPARE = 61,
+	CPUHP_TIMERS_PREPARE = 62,
+	CPUHP_TMIGR_PREPARE = 63,
+	CPUHP_MIPS_SOC_PREPARE = 64,
+	CPUHP_BP_PREPARE_DYN = 65,
+	CPUHP_BP_PREPARE_DYN_END = 85,
+	CPUHP_BP_KICK_AP = 86,
+	CPUHP_BRINGUP_CPU = 87,
+	CPUHP_AP_IDLE_DEAD = 88,
+	CPUHP_AP_OFFLINE = 89,
+	CPUHP_AP_CACHECTRL_STARTING = 90,
+	CPUHP_AP_SCHED_STARTING = 91,
+	CPUHP_AP_RCUTREE_DYING = 92,
+	CPUHP_AP_CPU_PM_STARTING = 93,
+	CPUHP_AP_IRQ_GIC_STARTING = 94,
+	CPUHP_AP_IRQ_HIP04_STARTING = 95,
+	CPUHP_AP_IRQ_APPLE_AIC_STARTING = 96,
+	CPUHP_AP_IRQ_ARMADA_XP_STARTING = 97,
+	CPUHP_AP_IRQ_BCM2836_STARTING = 98,
+	CPUHP_AP_IRQ_MIPS_GIC_STARTING = 99,
+	CPUHP_AP_IRQ_EIOINTC_STARTING = 100,
+	CPUHP_AP_IRQ_AVECINTC_STARTING = 101,
+	CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING = 102,
+	CPUHP_AP_IRQ_RISCV_IMSIC_STARTING = 103,
+	CPUHP_AP_IRQ_RISCV_SBI_IPI_STARTING = 104,
+	CPUHP_AP_ARM_MVEBU_COHERENCY = 105,
+	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING = 106,
+	CPUHP_AP_PERF_X86_STARTING = 107,
+	CPUHP_AP_PERF_X86_AMD_IBS_STARTING = 108,
+	CPUHP_AP_PERF_XTENSA_STARTING = 109,
+	CPUHP_AP_ARM_VFP_STARTING = 110,
+	CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING = 111,
+	CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING = 112,
+	CPUHP_AP_PERF_ARM_ACPI_STARTING = 113,
+	CPUHP_AP_PERF_ARM_STARTING = 114,
+	CPUHP_AP_PERF_RISCV_STARTING = 115,
+	CPUHP_AP_ARM_L2X0_STARTING = 116,
+	CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING = 117,
+	CPUHP_AP_ARM_ARCH_TIMER_STARTING = 118,
+	CPUHP_AP_ARM_ARCH_TIMER_EVTSTRM_STARTING = 119,
+	CPUHP_AP_ARM_GLOBAL_TIMER_STARTING = 120,
+	CPUHP_AP_JCORE_TIMER_STARTING = 121,
+	CPUHP_AP_ARM_TWD_STARTING = 122,
+	CPUHP_AP_QCOM_TIMER_STARTING = 123,
+	CPUHP_AP_TEGRA_TIMER_STARTING = 124,
+	CPUHP_AP_ARMADA_TIMER_STARTING = 125,
+	CPUHP_AP_MIPS_GIC_TIMER_STARTING = 126,
+	CPUHP_AP_ARC_TIMER_STARTING = 127,
+	CPUHP_AP_REALTEK_TIMER_STARTING = 128,
+	CPUHP_AP_RISCV_TIMER_STARTING = 129,
+	CPUHP_AP_CLINT_TIMER_STARTING = 130,
+	CPUHP_AP_CSKY_TIMER_STARTING = 131,
+	CPUHP_AP_TI_GP_TIMER_STARTING = 132,
+	CPUHP_AP_HYPERV_TIMER_STARTING = 133,
+	CPUHP_AP_DUMMY_TIMER_STARTING = 134,
+	CPUHP_AP_ARM_XEN_STARTING = 135,
+	CPUHP_AP_ARM_XEN_RUNSTATE_STARTING = 136,
+	CPUHP_AP_ARM_CORESIGHT_STARTING = 137,
+	CPUHP_AP_ARM_CORESIGHT_CTI_STARTING = 138,
+	CPUHP_AP_ARM64_ISNDEP_STARTING = 139,
+	CPUHP_AP_SMPCFD_DYING = 140,
+	CPUHP_AP_HRTIMERS_DYING = 141,
+	CPUHP_AP_TICK_DYING = 142,
+	CPUHP_AP_X86_TBOOT_DYING = 143,
+	CPUHP_AP_ARM_CACHE_B15_RAC_DYING = 144,
+	CPUHP_AP_ONLINE = 145,
+	CPUHP_TEARDOWN_CPU = 146,
+	CPUHP_AP_ONLINE_IDLE = 147,
+	CPUHP_AP_HYPERV_ONLINE = 148,
+	CPUHP_AP_KVM_ONLINE = 149,
+	CPUHP_AP_SCHED_WAIT_EMPTY = 150,
+	CPUHP_AP_SMPBOOT_THREADS = 151,
+	CPUHP_AP_IRQ_AFFINITY_ONLINE = 152,
+	CPUHP_AP_BLK_MQ_ONLINE = 153,
+	CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS = 154,
+	CPUHP_AP_X86_INTEL_EPB_ONLINE = 155,
+	CPUHP_AP_PERF_ONLINE = 156,
+	CPUHP_AP_PERF_X86_ONLINE = 157,
+	CPUHP_AP_PERF_X86_UNCORE_ONLINE = 158,
+	CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE = 159,
+	CPUHP_AP_PERF_X86_AMD_POWER_ONLINE = 160,
+	CPUHP_AP_PERF_X86_RAPL_ONLINE = 161,
+	CPUHP_AP_PERF_S390_CF_ONLINE = 162,
+	CPUHP_AP_PERF_S390_SF_ONLINE = 163,
+	CPUHP_AP_PERF_ARM_CCI_ONLINE = 164,
+	CPUHP_AP_PERF_ARM_CCN_ONLINE = 165,
+	CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE = 166,
+	CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE = 167,
+	CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE = 168,
+	CPUHP_AP_PERF_ARM_HISI_L3_ONLINE = 169,
+	CPUHP_AP_PERF_ARM_HISI_PA_ONLINE = 170,
+	CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE = 171,
+	CPUHP_AP_PERF_ARM_HISI_PCIE_PMU_ONLINE = 172,
+	CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE = 173,
+	CPUHP_AP_PERF_ARM_L2X0_ONLINE = 174,
+	CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE = 175,
+	CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE = 176,
+	CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE = 177,
+	CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE = 178,
+	CPUHP_AP_PERF_ARM_MARVELL_CN10K_DDR_ONLINE = 179,
+	CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE = 180,
+	CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE = 181,
+	CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE = 182,
+	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE = 183,
+	CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE = 184,
+	CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE = 185,
+	CPUHP_AP_PERF_CSKY_ONLINE = 186,
+	CPUHP_AP_TMIGR_ONLINE = 187,
+	CPUHP_AP_WATCHDOG_ONLINE = 188,
+	CPUHP_AP_WORKQUEUE_ONLINE = 189,
+	CPUHP_AP_RANDOM_ONLINE = 190,
+	CPUHP_AP_RCUTREE_ONLINE = 191,
+	CPUHP_AP_BASE_CACHEINFO_ONLINE = 192,
+	CPUHP_AP_ONLINE_DYN = 193,
+	CPUHP_AP_ONLINE_DYN_END = 233,
+	CPUHP_AP_X86_HPET_ONLINE = 234,
+	CPUHP_AP_X86_KVM_CLK_ONLINE = 235,
+	CPUHP_AP_ACTIVE = 236,
+	CPUHP_ONLINE = 237,
+};
+
+struct swap_cluster_info {
+	spinlock_t lock;
+	u16 count;
+	u8 flags;
+	u8 order;
+	struct list_head list;
+};
+
+struct percpu_cluster {
+	unsigned int next[1];
+};
+
+struct smp_hotplug_thread {
+	struct task_struct **store;
+	struct list_head list;
+	int (*thread_should_run)(unsigned int);
+	void (*thread_fn)(unsigned int);
+	void (*create)(unsigned int);
+	void (*setup)(unsigned int);
+	void (*cleanup)(unsigned int, bool);
+	void (*park)(unsigned int);
+	void (*unpark)(unsigned int);
+	bool selfparking;
+	const char *thread_comm;
+};
+
+struct pm_qos_flags_request {
+	struct list_head node;
+	s32 flags;
+};
+
+enum freq_qos_req_type {
+	FREQ_QOS_MIN = 1,
+	FREQ_QOS_MAX = 2,
+};
+
+struct freq_qos_request {
+	enum freq_qos_req_type type;
+	struct plist_node pnode;
+	struct freq_constraints *qos;
+};
+
+enum dev_pm_qos_req_type {
+	DEV_PM_QOS_RESUME_LATENCY = 1,
+	DEV_PM_QOS_LATENCY_TOLERANCE = 2,
+	DEV_PM_QOS_MIN_FREQUENCY = 3,
+	DEV_PM_QOS_MAX_FREQUENCY = 4,
+	DEV_PM_QOS_FLAGS = 5,
+};
+
+struct dev_pm_qos_request {
+	enum dev_pm_qos_req_type type;
+	union {
+		struct plist_node pnode;
+		struct pm_qos_flags_request flr;
+		struct freq_qos_request freq;
+	} data;
+	struct device *dev;
+};
+
+struct trace_event_raw_cpuhp_enter {
+	struct trace_entry ent;
+	unsigned int cpu;
+	int target;
+	int idx;
+	void *fun;
+	char __data[0];
+};
+
+struct trace_event_raw_cpuhp_multi_enter {
+	struct trace_entry ent;
+	unsigned int cpu;
+	int target;
+	int idx;
+	void *fun;
+	char __data[0];
+};
+
+struct trace_event_raw_cpuhp_exit {
+	struct trace_entry ent;
+	unsigned int cpu;
+	int state;
+	int idx;
+	int ret;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_cpuhp_enter {};
+
+struct trace_event_data_offsets_cpuhp_multi_enter {};
+
+struct trace_event_data_offsets_cpuhp_exit {};
+
+typedef void (*btf_trace_cpuhp_enter)(void *, unsigned int, int, int, int (*)(unsigned int));
+
+typedef void (*btf_trace_cpuhp_multi_enter)(void *, unsigned int, int, int, int (*)(unsigned int, struct hlist_node *), struct hlist_node *);
+
+typedef void (*btf_trace_cpuhp_exit)(void *, unsigned int, int, int, int);
+
+struct cpuhp_cpu_state {
+	enum cpuhp_state state;
+	enum cpuhp_state target;
+	enum cpuhp_state fail;
+	struct task_struct *thread;
+	bool should_run;
+	bool rollback;
+	bool single;
+	bool bringup;
+	struct hlist_node *node;
+	struct hlist_node *last;
+	enum cpuhp_state cb_state;
+	int result;
+	atomic_t ap_sync_state;
+	struct completion done_up;
+	struct completion done_down;
+};
+
+struct cpuhp_step {
+	const char *name;
+	union {
+		int (*single)(unsigned int);
+		int (*multi)(unsigned int, struct hlist_node *);
+	} startup;
+	union {
+		int (*single)(unsigned int);
+		int (*multi)(unsigned int, struct hlist_node *);
+	} teardown;
+	struct hlist_head list;
+	bool cant_stop;
+	bool multi_instance;
+};
+
+enum cpuhp_sync_state {
+	SYNC_STATE_DEAD = 0,
+	SYNC_STATE_KICKED = 1,
+	SYNC_STATE_SHOULD_DIE = 2,
+	SYNC_STATE_ALIVE = 3,
+	SYNC_STATE_SHOULD_ONLINE = 4,
+	SYNC_STATE_ONLINE = 5,
+};
+
+enum cpu_mitigations {
+	CPU_MITIGATIONS_OFF = 0,
+	CPU_MITIGATIONS_AUTO = 1,
+	CPU_MITIGATIONS_AUTO_NOSMT = 2,
+};
+
+typedef __s16 s16;
+
+typedef __u64 __be64;
+
+typedef __kernel_clock_t clock_t;
+
+typedef unsigned int slab_flags_t;
+
+enum lockdep_ok {
+	LOCKDEP_STILL_OK = 0,
+	LOCKDEP_NOW_UNRELIABLE = 1,
+};
+
+struct bpf_nh_params {
+	u32 nh_family;
+	union {
+		u32 ipv4_nh;
+		struct in6_addr ipv6_nh;
+	};
+};
+
+struct bpf_redirect_info {
+	u64 tgt_index;
+	void *tgt_value;
+	struct bpf_map *map;
+	u32 flags;
+	u32 map_id;
+	enum bpf_map_type map_type;
+	struct bpf_nh_params nh;
+	u32 kern_flags;
+	long: 32;
+};
+
+struct bpf_net_context {
+	struct bpf_redirect_info ri;
+	struct list_head cpu_map_flush_list;
+	struct list_head dev_map_flush_list;
+	struct list_head xskmap_map_flush_list;
+};
+
+struct linux_binprm;
+
+struct coredump_params;
+
+struct linux_binfmt {
+	struct list_head lh;
+	struct module *module;
+	int (*load_binary)(struct linux_binprm *);
+	int (*load_shlib)(struct file *);
+	int (*core_dump)(struct coredump_params *);
+	long unsigned int min_coredump;
+};
+
+typedef __u64 __addrpair;
+
+typedef __u32 __portpair;
+
+typedef struct {
+	struct net *net;
+} possible_net_t;
+
+struct proto;
+
+struct sock_common {
+	union {
+		__addrpair skc_addrpair;
+		struct {
+			__be32 skc_daddr;
+			__be32 skc_rcv_saddr;
+		};
+	};
+	union {
+		unsigned int skc_hash;
+		__u16 skc_u16hashes[2];
+	};
+	union {
+		__portpair skc_portpair;
+		struct {
+			__be16 skc_dport;
+			__u16 skc_num;
+		};
+	};
+	short unsigned int skc_family;
+	volatile unsigned char skc_state;
+	unsigned char skc_reuse: 4;
+	unsigned char skc_reuseport: 1;
+	unsigned char skc_ipv6only: 1;
+	unsigned char skc_net_refcnt: 1;
+	int skc_bound_dev_if;
+	union {
+		struct hlist_node skc_bind_node;
+		struct hlist_node skc_portaddr_node;
+	};
+	struct proto *skc_prot;
+	possible_net_t skc_net;
+	struct in6_addr skc_v6_daddr;
+	struct in6_addr skc_v6_rcv_saddr;
+	atomic64_t skc_cookie;
+	union {
+		long unsigned int skc_flags;
+		struct sock *skc_listener;
+		struct inet_timewait_death_row *skc_tw_dr;
+	};
+	int skc_dontcopy_begin[0];
+	union {
+		struct hlist_node skc_node;
+		struct hlist_nulls_node skc_nulls_node;
+	};
+	short unsigned int skc_tx_queue_mapping;
+	short unsigned int skc_rx_queue_mapping;
+	union {
+		int skc_incoming_cpu;
+		u32 skc_rcv_wnd;
+		u32 skc_tw_rcv_nxt;
+	};
+	refcount_t skc_refcnt;
+	int skc_dontcopy_end[0];
+	union {
+		u32 skc_rxhash;
+		u32 skc_window_clamp;
+		u32 skc_tw_snd_nxt;
+	};
+	long: 32;
+};
+
+struct sk_buff_list {
+	struct sk_buff *next;
+	struct sk_buff *prev;
+};
+
+struct sk_buff_head {
+	union {
+		struct {
+			struct sk_buff *next;
+			struct sk_buff *prev;
+		};
+		struct sk_buff_list list;
+	};
+	__u32 qlen;
+	spinlock_t lock;
+};
+
+typedef struct {
+	spinlock_t slock;
+	int owned;
+	wait_queue_head_t wq;
+} socket_lock_t;
+
+typedef u64 netdev_features_t;
+
+struct sock_cgroup_data {
+	struct cgroup *cgroup;
+	u32 classid;
+};
+
+typedef struct {} netns_tracker;
+
+struct sk_filter;
+
+struct socket_wq;
+
+struct socket;
+
+struct xfrm_policy;
+
+struct sock_reuseport;
+
+struct sock {
+	struct sock_common __sk_common;
+	__u8 __cacheline_group_begin__sock_write_rx[0];
+	atomic_t sk_drops;
+	__s32 sk_peek_off;
+	struct sk_buff_head sk_error_queue;
+	struct sk_buff_head sk_receive_queue;
+	struct {
+		atomic_t rmem_alloc;
+		int len;
+		struct sk_buff *head;
+		struct sk_buff *tail;
+	} sk_backlog;
+	__u8 __cacheline_group_end__sock_write_rx[0];
+	__u8 __cacheline_group_begin__sock_read_rx[0];
+	struct dst_entry *sk_rx_dst;
+	int sk_rx_dst_ifindex;
+	u32 sk_rx_dst_cookie;
+	unsigned int sk_ll_usec;
+	unsigned int sk_napi_id;
+	u16 sk_busy_poll_budget;
+	u8 sk_prefer_busy_poll;
+	u8 sk_userlocks;
+	int sk_rcvbuf;
+	struct sk_filter *sk_filter;
+	union {
+		struct socket_wq *sk_wq;
+		struct socket_wq *sk_wq_raw;
+	};
+	void (*sk_data_ready)(struct sock *);
+	long int sk_rcvtimeo;
+	int sk_rcvlowat;
+	__u8 __cacheline_group_end__sock_read_rx[0];
+	__u8 __cacheline_group_begin__sock_read_rxtx[0];
+	int sk_err;
+	struct socket *sk_socket;
+	struct mem_cgroup *sk_memcg;
+	struct xfrm_policy *sk_policy[2];
+	__u8 __cacheline_group_end__sock_read_rxtx[0];
+	__u8 __cacheline_group_begin__sock_write_rxtx[0];
+	socket_lock_t sk_lock;
+	u32 sk_reserved_mem;
+	int sk_forward_alloc;
+	u32 sk_tsflags;
+	__u8 __cacheline_group_end__sock_write_rxtx[0];
+	__u8 __cacheline_group_begin__sock_write_tx[0];
+	int sk_write_pending;
+	atomic_t sk_omem_alloc;
+	int sk_sndbuf;
+	int sk_wmem_queued;
+	refcount_t sk_wmem_alloc;
+	long unsigned int sk_tsq_flags;
+	union {
+		struct sk_buff *sk_send_head;
+		struct rb_root tcp_rtx_queue;
+	};
+	struct sk_buff_head sk_write_queue;
+	u32 sk_dst_pending_confirm;
+	u32 sk_pacing_status;
+	struct page_frag sk_frag;
+	struct timer_list sk_timer;
+	long unsigned int sk_pacing_rate;
+	atomic_t sk_zckey;
+	atomic_t sk_tskey;
+	__u8 __cacheline_group_end__sock_write_tx[0];
+	__u8 __cacheline_group_begin__sock_read_tx[0];
+	long unsigned int sk_max_pacing_rate;
+	long int sk_sndtimeo;
+	u32 sk_priority;
+	u32 sk_mark;
+	struct dst_entry *sk_dst_cache;
+	long: 32;
+	netdev_features_t sk_route_caps;
+	struct sk_buff * (*sk_validate_xmit_skb)(struct sock *, struct net_device *, struct sk_buff *);
+	u16 sk_gso_type;
+	u16 sk_gso_max_segs;
+	unsigned int sk_gso_max_size;
+	gfp_t sk_allocation;
+	u32 sk_txhash;
+	u8 sk_pacing_shift;
+	bool sk_use_task_frag;
+	__u8 __cacheline_group_end__sock_read_tx[0];
+	u8 sk_gso_disabled: 1;
+	u8 sk_kern_sock: 1;
+	u8 sk_no_check_tx: 1;
+	u8 sk_no_check_rx: 1;
+	u8 sk_shutdown;
+	u16 sk_type;
+	u16 sk_protocol;
+	long unsigned int sk_lingertime;
+	struct proto *sk_prot_creator;
+	rwlock_t sk_callback_lock;
+	int sk_err_soft;
+	u32 sk_ack_backlog;
+	u32 sk_max_ack_backlog;
+	kuid_t sk_uid;
+	spinlock_t sk_peer_lock;
+	int sk_bind_phc;
+	struct pid *sk_peer_pid;
+	const struct cred *sk_peer_cred;
+	ktime_t sk_stamp;
+	seqlock_t sk_stamp_seq;
+	int sk_disconnects;
+	u8 sk_txrehash;
+	u8 sk_clockid;
+	u8 sk_txtime_deadline_mode: 1;
+	u8 sk_txtime_report_errors: 1;
+	u8 sk_txtime_unused: 6;
+	void *sk_user_data;
+	struct sock_cgroup_data sk_cgrp_data;
+	void (*sk_state_change)(struct sock *);
+	void (*sk_write_space)(struct sock *);
+	void (*sk_error_report)(struct sock *);
+	int (*sk_backlog_rcv)(struct sock *, struct sk_buff *);
+	void (*sk_destruct)(struct sock *);
+	struct sock_reuseport *sk_reuseport_cb;
+	struct bpf_local_storage *sk_bpf_storage;
+	struct callback_head sk_rcu;
+	netns_tracker ns_tracker;
+	struct xarray sk_user_frags;
+	long: 32;
+};
+
+struct posix_acl_entry {
+	short int e_tag;
+	short unsigned int e_perm;
+	union {
+		kuid_t e_uid;
+		kgid_t e_gid;
+	};
+};
+
+struct posix_acl {
+	refcount_t a_refcount;
+	struct callback_head a_rcu;
+	unsigned int a_count;
+	struct posix_acl_entry a_entries[0];
+};
+
+typedef struct {
+	u64 v;
+} u64_stats_t;
+
+typedef struct {
+	union {
+		void *kernel;
+		void *user;
+	};
+	bool is_kernel: 1;
+} sockptr_t;
+
+struct bpf_offloaded_map;
+
+struct bpf_map_dev_ops {
+	int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *);
+	int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *);
+	int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64);
+	int (*map_delete_elem)(struct bpf_offloaded_map *, void *);
+};
+
+struct bpf_offloaded_map {
+	struct bpf_map map;
+	struct net_device *netdev;
+	const struct bpf_map_dev_ops *dev_ops;
+	void *dev_priv;
+	struct list_head offloads;
+	long: 32;
+};
+
+struct netdev_tc_txq {
+	u16 count;
+	u16 offset;
+};
+
+enum rx_handler_result {
+	RX_HANDLER_CONSUMED = 0,
+	RX_HANDLER_ANOTHER = 1,
+	RX_HANDLER_EXACT = 2,
+	RX_HANDLER_PASS = 3,
+};
+
+typedef enum rx_handler_result rx_handler_result_t;
+
+typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);
+
+typedef u32 xdp_features_t;
+
+struct net_device_stats {
+	union {
+		long unsigned int rx_packets;
+		atomic_long_t __rx_packets;
+	};
+	union {
+		long unsigned int tx_packets;
+		atomic_long_t __tx_packets;
+	};
+	union {
+		long unsigned int rx_bytes;
+		atomic_long_t __rx_bytes;
+	};
+	union {
+		long unsigned int tx_bytes;
+		atomic_long_t __tx_bytes;
+	};
+	union {
+		long unsigned int rx_errors;
+		atomic_long_t __rx_errors;
+	};
+	union {
+		long unsigned int tx_errors;
+		atomic_long_t __tx_errors;
+	};
+	union {
+		long unsigned int rx_dropped;
+		atomic_long_t __rx_dropped;
+	};
+	union {
+		long unsigned int tx_dropped;
+		atomic_long_t __tx_dropped;
+	};
+	union {
+		long unsigned int multicast;
+		atomic_long_t __multicast;
+	};
+	union {
+		long unsigned int collisions;
+		atomic_long_t __collisions;
+	};
+	union {
+		long unsigned int rx_length_errors;
+		atomic_long_t __rx_length_errors;
+	};
+	union {
+		long unsigned int rx_over_errors;
+		atomic_long_t __rx_over_errors;
+	};
+	union {
+		long unsigned int rx_crc_errors;
+		atomic_long_t __rx_crc_errors;
+	};
+	union {
+		long unsigned int rx_frame_errors;
+		atomic_long_t __rx_frame_errors;
+	};
+	union {
+		long unsigned int rx_fifo_errors;
+		atomic_long_t __rx_fifo_errors;
+	};
+	union {
+		long unsigned int rx_missed_errors;
+		atomic_long_t __rx_missed_errors;
+	};
+	union {
+		long unsigned int tx_aborted_errors;
+		atomic_long_t __tx_aborted_errors;
+	};
+	union {
+		long unsigned int tx_carrier_errors;
+		atomic_long_t __tx_carrier_errors;
+	};
+	union {
+		long unsigned int tx_fifo_errors;
+		atomic_long_t __tx_fifo_errors;
+	};
+	union {
+		long unsigned int tx_heartbeat_errors;
+		atomic_long_t __tx_heartbeat_errors;
+	};
+	union {
+		long unsigned int tx_window_errors;
+		atomic_long_t __tx_window_errors;
+	};
+	union {
+		long unsigned int rx_compressed;
+		atomic_long_t __rx_compressed;
+	};
+	union {
+		long unsigned int tx_compressed;
+		atomic_long_t __tx_compressed;
+	};
+};
+
+struct netdev_hw_addr_list {
+	struct list_head list;
+	int count;
+	struct rb_root tree;
+};
+
+struct wireless_dev;
+
+struct mpls_dev;
+
+enum netdev_ml_priv_type {
+	ML_PRIV_NONE = 0,
+	ML_PRIV_CAN = 1,
+};
+
+enum netdev_stat_type {
+	NETDEV_PCPU_STAT_NONE = 0,
+	NETDEV_PCPU_STAT_LSTATS = 1,
+	NETDEV_PCPU_STAT_TSTATS = 2,
+	NETDEV_PCPU_STAT_DSTATS = 3,
+};
+
+struct udp_tunnel_nic;
+
+struct bpf_xdp_link;
+
+struct bpf_xdp_entity {
+	struct bpf_prog *prog;
+	struct bpf_xdp_link *link;
+};
+
+struct net_device_ops;
+
+struct header_ops;
+
+struct netdev_queue;
+
+struct xps_dev_maps;
+
+struct bpf_mprog_entry;
+
+struct pcpu_lstats;
+
+struct pcpu_sw_netstats;
+
+struct pcpu_dstats;
+
+struct inet6_dev;
+
+struct netdev_rx_queue;
+
+struct netpoll_info;
+
+struct netdev_name_node;
+
+struct dev_ifalias;
+
+struct xdp_metadata_ops;
+
+struct xsk_tx_metadata_ops;
+
+struct net_device_core_stats;
+
+struct ethtool_ops;
+
+struct l3mdev_ops;
+
+struct ndisc_ops;
+
+struct tlsdev_ops;
+
+struct in_device;
+
+struct vlan_info;
+
+struct dsa_port;
+
+struct wpan_dev;
+
+struct cpu_rmap;
+
+struct Qdisc;
+
+struct xdp_dev_bulk_queue;
+
+struct rtnl_link_ops;
+
+struct netdev_stat_ops;
+
+struct netdev_queue_mgmt_ops;
+
+struct dcbnl_rtnl_ops;
+
+struct phy_link_topology;
+
+struct phy_device;
+
+struct sfp_bus;
+
+struct macsec_ops;
+
+struct udp_tunnel_nic_info;
+
+struct ethtool_netdev_state;
+
+struct rtnl_hw_stats64;
+
+struct devlink_port;
+
+struct dim_irq_moder;
+
+struct net_device {
+	__u8 __cacheline_group_begin__net_device_read_tx[0];
+	union {
+		struct {
+			long unsigned int priv_flags: 32;
+			long unsigned int lltx: 1;
+		};
+		struct {
+			long unsigned int priv_flags: 32;
+			long unsigned int lltx: 1;
+		} priv_flags_fast;
+	};
+	const struct net_device_ops *netdev_ops;
+	const struct header_ops *header_ops;
+	struct netdev_queue *_tx;
+	long: 32;
+	netdev_features_t gso_partial_features;
+	unsigned int real_num_tx_queues;
+	unsigned int gso_max_size;
+	unsigned int gso_ipv4_max_size;
+	u16 gso_max_segs;
+	s16 num_tc;
+	unsigned int mtu;
+	short unsigned int needed_headroom;
+	struct netdev_tc_txq tc_to_txq[16];
+	struct xps_dev_maps *xps_maps[2];
+	struct nf_hook_entries *nf_hooks_egress;
+	struct bpf_mprog_entry *tcx_egress;
+	__u8 __cacheline_group_end__net_device_read_tx[0];
+	__u8 __cacheline_group_begin__net_device_read_txrx[0];
+	union {
+		struct pcpu_lstats *lstats;
+		struct pcpu_sw_netstats *tstats;
+		struct pcpu_dstats *dstats;
+	};
+	long unsigned int state;
+	unsigned int flags;
+	short unsigned int hard_header_len;
+	netdev_features_t features;
+	struct inet6_dev *ip6_ptr;
+	__u8 __cacheline_group_end__net_device_read_txrx[0];
+	__u8 __cacheline_group_begin__net_device_read_rx[0];
+	struct bpf_prog *xdp_prog;
+	struct list_head ptype_specific;
+	int ifindex;
+	unsigned int real_num_rx_queues;
+	struct netdev_rx_queue *_rx;
+	long unsigned int gro_flush_timeout;
+	u32 napi_defer_hard_irqs;
+	unsigned int gro_max_size;
+	unsigned int gro_ipv4_max_size;
+	rx_handler_func_t *rx_handler;
+	void *rx_handler_data;
+	possible_net_t nd_net;
+	struct netpoll_info *npinfo;
+	struct bpf_mprog_entry *tcx_ingress;
+	__u8 __cacheline_group_end__net_device_read_rx[0];
+	char name[16];
+	struct netdev_name_node *name_node;
+	struct dev_ifalias *ifalias;
+	long unsigned int mem_end;
+	long unsigned int mem_start;
+	long unsigned int base_addr;
+	struct list_head dev_list;
+	struct list_head napi_list;
+	struct list_head unreg_list;
+	struct list_head close_list;
+	struct list_head ptype_all;
+	struct {
+		struct list_head upper;
+		struct list_head lower;
+	} adj_list;
+	xdp_features_t xdp_features;
+	const struct xdp_metadata_ops *xdp_metadata_ops;
+	const struct xsk_tx_metadata_ops *xsk_tx_metadata_ops;
+	short unsigned int gflags;
+	short unsigned int needed_tailroom;
+	long: 32;
+	netdev_features_t hw_features;
+	netdev_features_t wanted_features;
+	netdev_features_t vlan_features;
+	netdev_features_t hw_enc_features;
+	netdev_features_t mpls_features;
+	unsigned int min_mtu;
+	unsigned int max_mtu;
+	short unsigned int type;
+	unsigned char min_header_len;
+	unsigned char name_assign_type;
+	int group;
+	struct net_device_stats stats;
+	struct net_device_core_stats *core_stats;
+	atomic_t carrier_up_count;
+	atomic_t carrier_down_count;
+	const struct ethtool_ops *ethtool_ops;
+	const struct l3mdev_ops *l3mdev_ops;
+	const struct ndisc_ops *ndisc_ops;
+	const struct tlsdev_ops *tlsdev_ops;
+	unsigned int operstate;
+	unsigned char link_mode;
+	unsigned char if_port;
+	unsigned char dma;
+	unsigned char perm_addr[32];
+	unsigned char addr_assign_type;
+	unsigned char addr_len;
+	unsigned char upper_level;
+	unsigned char lower_level;
+	short unsigned int neigh_priv_len;
+	short unsigned int dev_id;
+	short unsigned int dev_port;
+	int irq;
+	u32 priv_len;
+	spinlock_t addr_list_lock;
+	struct netdev_hw_addr_list uc;
+	struct netdev_hw_addr_list mc;
+	struct netdev_hw_addr_list dev_addrs;
+	struct kset *queues_kset;
+	unsigned int promiscuity;
+	unsigned int allmulti;
+	bool uc_promisc;
+	struct in_device *ip_ptr;
+	struct vlan_info *vlan_info;
+	struct dsa_port *dsa_ptr;
+	void *atalk_ptr;
+	void *ax25_ptr;
+	struct wireless_dev *ieee80211_ptr;
+	struct wpan_dev *ieee802154_ptr;
+	struct mpls_dev *mpls_ptr;
+	const unsigned char *dev_addr;
+	unsigned int num_rx_queues;
+	unsigned int xdp_zc_max_segs;
+	struct netdev_queue *ingress_queue;
+	struct nf_hook_entries *nf_hooks_ingress;
+	unsigned char broadcast[32];
+	struct cpu_rmap *rx_cpu_rmap;
+	struct hlist_node index_hlist;
+	unsigned int num_tx_queues;
+	struct Qdisc *qdisc;
+	unsigned int tx_queue_len;
+	spinlock_t tx_global_lock;
+	struct xdp_dev_bulk_queue *xdp_bulkq;
+	struct hlist_head qdisc_hash[16];
+	struct timer_list watchdog_timer;
+	int watchdog_timeo;
+	u32 proto_down_reason;
+	struct list_head todo_list;
+	int *pcpu_refcnt;
+	struct ref_tracker_dir refcnt_tracker;
+	struct list_head link_watch_list;
+	u8 reg_state;
+	bool dismantle;
+	enum {
+		RTNL_LINK_INITIALIZED = 0,
+		RTNL_LINK_INITIALIZING = 1,
+	} rtnl_link_state: 16;
+	bool needs_free_netdev;
+	void (*priv_destructor)(struct net_device *);
+	void *ml_priv;
+	enum netdev_ml_priv_type ml_priv_type;
+	enum netdev_stat_type pcpu_stat_type: 8;
+	long: 32;
+	struct device dev;
+	const struct attribute_group *sysfs_groups[4];
+	const struct attribute_group *sysfs_rx_queue_group;
+	const struct rtnl_link_ops *rtnl_link_ops;
+	const struct netdev_stat_ops *stat_ops;
+	const struct netdev_queue_mgmt_ops *queue_mgmt_ops;
+	unsigned int tso_max_size;
+	u16 tso_max_segs;
+	const struct dcbnl_rtnl_ops *dcbnl_ops;
+	u8 prio_tc_map[16];
+	struct phy_link_topology *link_topo;
+	struct phy_device *phydev;
+	struct sfp_bus *sfp_bus;
+	struct lock_class_key *qdisc_tx_busylock;
+	bool proto_down;
+	bool threaded;
+	long unsigned int see_all_hwtstamp_requests: 1;
+	long unsigned int change_proto_down: 1;
+	long unsigned int netns_local: 1;
+	long unsigned int fcoe_mtu: 1;
+	struct list_head net_notifier_list;
+	const struct macsec_ops *macsec_ops;
+	const struct udp_tunnel_nic_info *udp_tunnel_nic_info;
+	struct udp_tunnel_nic *udp_tunnel_nic;
+	struct ethtool_netdev_state *ethtool;
+	struct bpf_xdp_entity xdp_state[3];
+	u8 dev_addr_shadow[32];
+	netdevice_tracker linkwatch_dev_tracker;
+	netdevice_tracker watchdog_dev_tracker;
+	netdevice_tracker dev_registered_tracker;
+	struct rtnl_hw_stats64 *offload_xstats_l3;
+	struct devlink_port *devlink_port;
+	struct hlist_head page_pools;
+	struct dim_irq_moder *irq_moder;
+	u8 priv[0];
+};
+
+struct bpf_prog_stats {
+	u64_stats_t cnt;
+	u64_stats_t nsecs;
+	u64_stats_t misses;
+	struct u64_stats_sync syncp;
+	long: 32;
+};
+
+struct sock_fprog_kern {
+	u16 len;
+	struct sock_filter *filter;
+};
+
+typedef short unsigned int __kernel_sa_family_t;
+
+typedef __kernel_sa_family_t sa_family_t;
+
+struct sockaddr {
+	sa_family_t sa_family;
+	union {
+		char sa_data_min[14];
+		struct {
+			struct {} __empty_sa_data;
+			char sa_data[0];
+		};
+	};
+};
+
+struct ubuf_info;
+
+struct msghdr {
+	void *msg_name;
+	int msg_namelen;
+	int msg_inq;
+	long: 32;
+	struct iov_iter msg_iter;
+	union {
+		void *msg_control;
+		void *msg_control_user;
+	};
+	bool msg_control_is_user: 1;
+	bool msg_get_inq: 1;
+	unsigned int msg_flags;
+	__kernel_size_t msg_controllen;
+	struct kiocb *msg_iocb;
+	struct ubuf_info *msg_ubuf;
+	int (*sg_from_iter)(struct sk_buff *, struct iov_iter *, size_t);
+	long: 32;
+};
+
+struct ubuf_info_ops;
+
+struct ubuf_info {
+	const struct ubuf_info_ops *ops;
+	refcount_t refcnt;
+	u8 flags;
+};
+
+typedef struct {
+	unsigned int clock_rate;
+	unsigned int clock_type;
+	short unsigned int loopback;
+} sync_serial_settings;
+
+typedef struct {
+	unsigned int clock_rate;
+	unsigned int clock_type;
+	short unsigned int loopback;
+	unsigned int slot_map;
+} te1_settings;
+
+typedef struct {
+	short unsigned int encoding;
+	short unsigned int parity;
+} raw_hdlc_proto;
+
+typedef struct {
+	unsigned int t391;
+	unsigned int t392;
+	unsigned int n391;
+	unsigned int n392;
+	unsigned int n393;
+	short unsigned int lmi;
+	short unsigned int dce;
+} fr_proto;
+
+typedef struct {
+	unsigned int dlci;
+} fr_proto_pvc;
+
+typedef struct {
+	unsigned int dlci;
+	char master[16];
+} fr_proto_pvc_info;
+
+typedef struct {
+	unsigned int interval;
+	unsigned int timeout;
+} cisco_proto;
+
+typedef struct {
+	short unsigned int dce;
+	unsigned int modulo;
+	unsigned int window;
+	unsigned int t1;
+	unsigned int t2;
+	unsigned int n2;
+} x25_hdlc_proto;
+
+struct ifmap {
+	long unsigned int mem_start;
+	long unsigned int mem_end;
+	short unsigned int base_addr;
+	unsigned char irq;
+	unsigned char dma;
+	unsigned char port;
+};
+
+struct if_settings {
+	unsigned int type;
+	unsigned int size;
+	union {
+		raw_hdlc_proto *raw_hdlc;
+		cisco_proto *cisco;
+		fr_proto *fr;
+		fr_proto_pvc *fr_pvc;
+		fr_proto_pvc_info *fr_pvc_info;
+		x25_hdlc_proto *x25;
+		sync_serial_settings *sync;
+		te1_settings *te1;
+	} ifs_ifsu;
+};
+
+struct ifreq {
+	union {
+		char ifrn_name[16];
+	} ifr_ifrn;
+	union {
+		struct sockaddr ifru_addr;
+		struct sockaddr ifru_dstaddr;
+		struct sockaddr ifru_broadaddr;
+		struct sockaddr ifru_netmask;
+		struct sockaddr ifru_hwaddr;
+		short int ifru_flags;
+		int ifru_ivalue;
+		int ifru_mtu;
+		struct ifmap ifru_map;
+		char ifru_slave[16];
+		char ifru_newname[16];
+		void *ifru_data;
+		struct if_settings ifru_settings;
+	} ifr_ifru;
+};
+
+struct tc_stats {
+	__u64 bytes;
+	__u32 packets;
+	__u32 drops;
+	__u32 overlimits;
+	__u32 bps;
+	__u32 pps;
+	__u32 qlen;
+	__u32 backlog;
+	long: 32;
+};
+
+struct tc_sizespec {
+	unsigned char cell_log;
+	unsigned char size_log;
+	short int cell_align;
+	int overhead;
+	unsigned int linklayer;
+	unsigned int mpu;
+	unsigned int mtu;
+	unsigned int tsize;
+};
+
+struct flowi_tunnel {
+	__be64 tun_id;
+};
+
+struct flowi_common {
+	int flowic_oif;
+	int flowic_iif;
+	int flowic_l3mdev;
+	__u32 flowic_mark;
+	__u8 flowic_tos;
+	__u8 flowic_scope;
+	__u8 flowic_proto;
+	__u8 flowic_flags;
+	__u32 flowic_secid;
+	kuid_t flowic_uid;
+	__u32 flowic_multipath_hash;
+	struct flowi_tunnel flowic_tun_key;
+};
+
+union flowi_uli {
+	struct {
+		__be16 dport;
+		__be16 sport;
+	} ports;
+	struct {
+		__u8 type;
+		__u8 code;
+	} icmpt;
+	__be32 gre_key;
+	struct {
+		__u8 type;
+	} mht;
+};
+
+struct flowi4 {
+	struct flowi_common __fl_common;
+	__be32 saddr;
+	__be32 daddr;
+	union flowi_uli uli;
+	long: 32;
+};
+
+struct flowi6 {
+	struct flowi_common __fl_common;
+	struct in6_addr daddr;
+	struct in6_addr saddr;
+	__be32 flowlabel;
+	union flowi_uli uli;
+	__u32 mp_hash;
+	long: 32;
+};
+
+struct flowi {
+	union {
+		struct flowi_common __fl_common;
+		struct flowi4 ip4;
+		struct flowi6 ip6;
+	} u;
+};
+
+struct skb_shared_hwtstamps {
+	union {
+		ktime_t hwtstamp;
+		void *netdev_data;
+	};
+};
+
+struct ubuf_info_ops {
+	void (*complete)(struct sk_buff *, struct ubuf_info *, bool);
+	int (*link_skb)(struct sk_buff *, struct ubuf_info *);
+};
+
+struct dql {
+	unsigned int num_queued;
+	unsigned int adj_limit;
+	unsigned int last_obj_cnt;
+	short unsigned int stall_thrs;
+	long unsigned int history_head;
+	long unsigned int history[4];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	unsigned int limit;
+	unsigned int num_completed;
+	unsigned int prev_ovlimit;
+	unsigned int prev_num_queued;
+	unsigned int prev_last_obj_cnt;
+	unsigned int lowest_slack;
+	long unsigned int slack_start_time;
+	unsigned int max_limit;
+	unsigned int min_limit;
+	unsigned int slack_hold_time;
+	short unsigned int stall_max;
+	long unsigned int last_reap;
+	long unsigned int stall_cnt;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct prot_inuse {
+	int all;
+	int val[64];
+};
+
+struct icmpv6_mib_device {
+	atomic_long_t mibs[7];
+};
+
+struct icmpv6msg_mib_device {
+	atomic_long_t mibs[512];
+};
+
+struct fib_rule;
+
+struct fib_lookup_arg;
+
+struct fib_rule_hdr;
+
+struct nlattr;
+
+struct netlink_ext_ack;
+
+struct fib_rules_ops {
+	int family;
+	struct list_head list;
+	int rule_size;
+	int addr_size;
+	int unresolved_rules;
+	int nr_goto_rules;
+	unsigned int fib_rules_seq;
+	int (*action)(struct fib_rule *, struct flowi *, int, struct fib_lookup_arg *);
+	bool (*suppress)(struct fib_rule *, int, struct fib_lookup_arg *);
+	int (*match)(struct fib_rule *, struct flowi *, int);
+	int (*configure)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *, struct nlattr **, struct netlink_ext_ack *);
+	int (*delete)(struct fib_rule *);
+	int (*compare)(struct fib_rule *, struct fib_rule_hdr *, struct nlattr **);
+	int (*fill)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *);
+	size_t (*nlmsg_payload)(struct fib_rule *);
+	void (*flush_cache)(struct fib_rules_ops *);
+	int nlgroup;
+	struct list_head rules_list;
+	struct module *owner;
+	struct net *fro_net;
+	struct callback_head rcu;
+};
+
+struct fib_notifier_ops {
+	int family;
+	struct list_head list;
+	unsigned int (*fib_seq_read)(struct net *);
+	int (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *);
+	struct module *owner;
+	struct callback_head rcu;
+};
+
+struct hh_cache {
+	unsigned int hh_len;
+	seqlock_t hh_lock;
+	long unsigned int hh_data[32];
+};
+
+struct neigh_table;
+
+struct neigh_parms;
+
+struct neigh_ops;
+
+struct neighbour {
+	struct neighbour *next;
+	struct neigh_table *tbl;
+	struct neigh_parms *parms;
+	long unsigned int confirmed;
+	long unsigned int updated;
+	rwlock_t lock;
+	refcount_t refcnt;
+	unsigned int arp_queue_len_bytes;
+	struct sk_buff_head arp_queue;
+	struct timer_list timer;
+	long unsigned int used;
+	atomic_t probes;
+	u8 nud_state;
+	u8 type;
+	u8 dead;
+	u8 protocol;
+	u32 flags;
+	seqlock_t ha_lock;
+	long: 32;
+	unsigned char ha[32];
+	struct hh_cache hh;
+	int (*output)(struct neighbour *, struct sk_buff *);
+	const struct neigh_ops *ops;
+	struct list_head gc_list;
+	struct list_head managed_list;
+	struct callback_head rcu;
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	u8 primary_key[0];
+};
+
+struct ipv6_stable_secret {
+	bool initialized;
+	struct in6_addr secret;
+};
+
+struct ipv6_devconf {
+	__u8 __cacheline_group_begin__ipv6_devconf_read_txrx[0];
+	__s32 disable_ipv6;
+	__s32 hop_limit;
+	__s32 mtu6;
+	__s32 forwarding;
+	__s32 disable_policy;
+	__s32 proxy_ndp;
+	__u8 __cacheline_group_end__ipv6_devconf_read_txrx[0];
+	__s32 accept_ra;
+	__s32 accept_redirects;
+	__s32 autoconf;
+	__s32 dad_transmits;
+	__s32 rtr_solicits;
+	__s32 rtr_solicit_interval;
+	__s32 rtr_solicit_max_interval;
+	__s32 rtr_solicit_delay;
+	__s32 force_mld_version;
+	__s32 mldv1_unsolicited_report_interval;
+	__s32 mldv2_unsolicited_report_interval;
+	__s32 use_tempaddr;
+	__s32 temp_valid_lft;
+	__s32 temp_prefered_lft;
+	__s32 regen_min_advance;
+	__s32 regen_max_retry;
+	__s32 max_desync_factor;
+	__s32 max_addresses;
+	__s32 accept_ra_defrtr;
+	__u32 ra_defrtr_metric;
+	__s32 accept_ra_min_hop_limit;
+	__s32 accept_ra_min_lft;
+	__s32 accept_ra_pinfo;
+	__s32 ignore_routes_with_linkdown;
+	__s32 accept_source_route;
+	__s32 accept_ra_from_local;
+	atomic_t mc_forwarding;
+	__s32 drop_unicast_in_l2_multicast;
+	__s32 accept_dad;
+	__s32 force_tllao;
+	__s32 ndisc_notify;
+	__s32 suppress_frag_ndisc;
+	__s32 accept_ra_mtu;
+	__s32 drop_unsolicited_na;
+	__s32 accept_untracked_na;
+	struct ipv6_stable_secret stable_secret;
+	__s32 use_oif_addrs_only;
+	__s32 keep_addr_on_down;
+	__s32 seg6_enabled;
+	__u32 enhanced_dad;
+	__u32 addr_gen_mode;
+	__s32 ndisc_tclass;
+	__s32 rpl_seg_enabled;
+	__u32 ioam6_id;
+	__u32 ioam6_id_wide;
+	__u8 ioam6_enabled;
+	__u8 ndisc_evict_nocarrier;
+	__u8 ra_honor_pio_life;
+	__u8 ra_honor_pio_pflag;
+	struct ctl_table_header *sysctl_header;
+};
+
+enum {
+	IPPROTO_IP = 0,
+	IPPROTO_ICMP = 1,
+	IPPROTO_IGMP = 2,
+	IPPROTO_IPIP = 4,
+	IPPROTO_TCP = 6,
+	IPPROTO_EGP = 8,
+	IPPROTO_PUP = 12,
+	IPPROTO_UDP = 17,
+	IPPROTO_IDP = 22,
+	IPPROTO_TP = 29,
+	IPPROTO_DCCP = 33,
+	IPPROTO_IPV6 = 41,
+	IPPROTO_RSVP = 46,
+	IPPROTO_GRE = 47,
+	IPPROTO_ESP = 50,
+	IPPROTO_AH = 51,
+	IPPROTO_MTP = 92,
+	IPPROTO_BEETPH = 94,
+	IPPROTO_ENCAP = 98,
+	IPPROTO_PIM = 103,
+	IPPROTO_COMP = 108,
+	IPPROTO_L2TP = 115,
+	IPPROTO_SCTP = 132,
+	IPPROTO_UDPLITE = 136,
+	IPPROTO_MPLS = 137,
+	IPPROTO_ETHERNET = 143,
+	IPPROTO_RAW = 255,
+	IPPROTO_SMC = 256,
+	IPPROTO_MPTCP = 262,
+	IPPROTO_MAX = 263,
+};
+
+struct ieee_ets {
+	__u8 willing;
+	__u8 ets_cap;
+	__u8 cbs;
+	__u8 tc_tx_bw[8];
+	__u8 tc_rx_bw[8];
+	__u8 tc_tsa[8];
+	__u8 prio_tc[8];
+	__u8 tc_reco_bw[8];
+	__u8 tc_reco_tsa[8];
+	__u8 reco_prio_tc[8];
+};
+
+struct ieee_maxrate {
+	__u64 tc_maxrate[8];
+};
+
+struct ieee_qcn {
+	__u8 rpg_enable[8];
+	__u32 rppp_max_rps[8];
+	__u32 rpg_time_reset[8];
+	__u32 rpg_byte_reset[8];
+	__u32 rpg_threshold[8];
+	__u32 rpg_max_rate[8];
+	__u32 rpg_ai_rate[8];
+	__u32 rpg_hai_rate[8];
+	__u32 rpg_gd[8];
+	__u32 rpg_min_dec_fac[8];
+	__u32 rpg_min_rate[8];
+	__u32 cndd_state_machine[8];
+};
+
+struct ieee_qcn_stats {
+	__u64 rppp_rp_centiseconds[8];
+	__u32 rppp_created_rps[8];
+};
+
+struct ieee_pfc {
+	__u8 pfc_cap;
+	__u8 pfc_en;
+	__u8 mbc;
+	__u16 delay;
+	__u64 requests[8];
+	__u64 indications[8];
+};
+
+struct dcbnl_buffer {
+	__u8 prio2buffer[8];
+	__u32 buffer_size[8];
+	__u32 total_size;
+};
+
+struct cee_pg {
+	__u8 willing;
+	__u8 error;
+	__u8 pg_en;
+	__u8 tcs_supported;
+	__u8 pg_bw[8];
+	__u8 prio_pg[8];
+};
+
+struct cee_pfc {
+	__u8 willing;
+	__u8 error;
+	__u8 pfc_en;
+	__u8 tcs_supported;
+};
+
+struct dcb_app {
+	__u8 selector;
+	__u8 priority;
+	__u16 protocol;
+};
+
+struct dcb_peer_app_info {
+	__u8 willing;
+	__u8 error;
+};
+
+struct dcbnl_rtnl_ops {
+	int (*ieee_getets)(struct net_device *, struct ieee_ets *);
+	int (*ieee_setets)(struct net_device *, struct ieee_ets *);
+	int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *);
+	int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *);
+	int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *);
+	int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *);
+	int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *);
+	int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *);
+	int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *);
+	int (*ieee_getapp)(struct net_device *, struct dcb_app *);
+	int (*ieee_setapp)(struct net_device *, struct dcb_app *);
+	int (*ieee_delapp)(struct net_device *, struct dcb_app *);
+	int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *);
+	int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *);
+	u8 (*getstate)(struct net_device *);
+	u8 (*setstate)(struct net_device *, u8);
+	void (*getpermhwaddr)(struct net_device *, u8 *);
+	void (*setpgtccfgtx)(struct net_device *, int, u8, u8, u8, u8);
+	void (*setpgbwgcfgtx)(struct net_device *, int, u8);
+	void (*setpgtccfgrx)(struct net_device *, int, u8, u8, u8, u8);
+	void (*setpgbwgcfgrx)(struct net_device *, int, u8);
+	void (*getpgtccfgtx)(struct net_device *, int, u8 *, u8 *, u8 *, u8 *);
+	void (*getpgbwgcfgtx)(struct net_device *, int, u8 *);
+	void (*getpgtccfgrx)(struct net_device *, int, u8 *, u8 *, u8 *, u8 *);
+	void (*getpgbwgcfgrx)(struct net_device *, int, u8 *);
+	void (*setpfccfg)(struct net_device *, int, u8);
+	void (*getpfccfg)(struct net_device *, int, u8 *);
+	u8 (*setall)(struct net_device *);
+	u8 (*getcap)(struct net_device *, int, u8 *);
+	int (*getnumtcs)(struct net_device *, int, u8 *);
+	int (*setnumtcs)(struct net_device *, int, u8);
+	u8 (*getpfcstate)(struct net_device *);
+	void (*setpfcstate)(struct net_device *, u8);
+	void (*getbcncfg)(struct net_device *, int, u32 *);
+	void (*setbcncfg)(struct net_device *, int, u32);
+	void (*getbcnrp)(struct net_device *, int, u8 *);
+	void (*setbcnrp)(struct net_device *, int, u8);
+	int (*setapp)(struct net_device *, u8, u16, u8);
+	int (*getapp)(struct net_device *, u8, u16);
+	u8 (*getfeatcfg)(struct net_device *, int, u8 *);
+	u8 (*setfeatcfg)(struct net_device *, int, u8);
+	u8 (*getdcbx)(struct net_device *);
+	u8 (*setdcbx)(struct net_device *, u8);
+	int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *);
+	int (*peer_getapptable)(struct net_device *, struct dcb_app *);
+	int (*cee_peer_getpg)(struct net_device *, struct cee_pg *);
+	int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *);
+	int (*dcbnl_getbuffer)(struct net_device *, struct dcbnl_buffer *);
+	int (*dcbnl_setbuffer)(struct net_device *, struct dcbnl_buffer *);
+	int (*dcbnl_setapptrust)(struct net_device *, u8 *, int);
+	int (*dcbnl_getapptrust)(struct net_device *, u8 *, int *);
+	int (*dcbnl_setrewr)(struct net_device *, struct dcb_app *);
+	int (*dcbnl_delrewr)(struct net_device *, struct dcb_app *);
+};
+
+typedef enum {
+	SS_FREE = 0,
+	SS_UNCONNECTED = 1,
+	SS_CONNECTING = 2,
+	SS_CONNECTED = 3,
+	SS_DISCONNECTING = 4,
+} socket_state;
+
+struct socket_wq {
+	wait_queue_head_t wait;
+	struct fasync_struct *fasync_list;
+	long unsigned int flags;
+	struct callback_head rcu;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct proto_ops;
+
+struct socket {
+	socket_state state;
+	short int type;
+	long unsigned int flags;
+	struct file *file;
+	struct sock *sk;
+	const struct proto_ops *ops;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct socket_wq wq;
+};
+
+typedef struct {
+	size_t written;
+	size_t count;
+	union {
+		char *buf;
+		void *data;
+	} arg;
+	int error;
+} read_descriptor_t;
+
+typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *, unsigned int, size_t);
+
+typedef int (*skb_read_actor_t)(struct sock *, struct sk_buff *);
+
+struct proto_accept_arg;
+
+struct proto_ops {
+	int family;
+	struct module *owner;
+	int (*release)(struct socket *);
+	int (*bind)(struct socket *, struct sockaddr *, int);
+	int (*connect)(struct socket *, struct sockaddr *, int, int);
+	int (*socketpair)(struct socket *, struct socket *);
+	int (*accept)(struct socket *, struct socket *, struct proto_accept_arg *);
+	int (*getname)(struct socket *, struct sockaddr *, int);
+	__poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *);
+	int (*ioctl)(struct socket *, unsigned int, long unsigned int);
+	int (*gettstamp)(struct socket *, void *, bool, bool);
+	int (*listen)(struct socket *, int);
+	int (*shutdown)(struct socket *, int);
+	int (*setsockopt)(struct socket *, int, int, sockptr_t, unsigned int);
+	int (*getsockopt)(struct socket *, int, int, char *, int *);
+	void (*show_fdinfo)(struct seq_file *, struct socket *);
+	int (*sendmsg)(struct socket *, struct msghdr *, size_t);
+	int (*recvmsg)(struct socket *, struct msghdr *, size_t, int);
+	int (*mmap)(struct file *, struct socket *, struct vm_area_struct *);
+	ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
+	void (*splice_eof)(struct socket *);
+	int (*set_peek_off)(struct sock *, int);
+	int (*peek_len)(struct socket *);
+	int (*read_sock)(struct sock *, read_descriptor_t *, sk_read_actor_t);
+	int (*read_skb)(struct sock *, skb_read_actor_t);
+	int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t);
+	int (*set_rcvlowat)(struct sock *, int);
+};
+
+struct proto_accept_arg {
+	int flags;
+	int err;
+	int is_empty;
+	bool kern;
+};
+
+struct nlmsghdr {
+	__u32 nlmsg_len;
+	__u16 nlmsg_type;
+	__u16 nlmsg_flags;
+	__u32 nlmsg_seq;
+	__u32 nlmsg_pid;
+};
+
+struct nlattr {
+	__u16 nla_len;
+	__u16 nla_type;
+};
+
+struct nla_policy;
+
+struct netlink_ext_ack {
+	const char *_msg;
+	const struct nlattr *bad_attr;
+	const struct nla_policy *policy;
+	const struct nlattr *miss_nest;
+	u16 miss_type;
+	u8 cookie[20];
+	u8 cookie_len;
+	char _msg_buf[80];
+};
+
+struct netlink_range_validation;
+
+struct netlink_range_validation_signed;
+
+struct nla_policy {
+	u8 type;
+	u8 validation_type;
+	u16 len;
+	union {
+		u16 strict_start_type;
+		const u32 bitfield32_valid;
+		const u32 mask;
+		const char *reject_message;
+		const struct nla_policy *nested_policy;
+		const struct netlink_range_validation *range;
+		const struct netlink_range_validation_signed *range_signed;
+		struct {
+			s16 min;
+			s16 max;
+		};
+		int (*validate)(const struct nlattr *, struct netlink_ext_ack *);
+	};
+};
+
+struct netlink_callback {
+	struct sk_buff *skb;
+	const struct nlmsghdr *nlh;
+	int (*dump)(struct sk_buff *, struct netlink_callback *);
+	int (*done)(struct netlink_callback *);
+	void *data;
+	struct module *module;
+	struct netlink_ext_ack *extack;
+	u16 family;
+	u16 answer_flags;
+	u32 min_dump_alloc;
+	unsigned int prev_seq;
+	unsigned int seq;
+	int flags;
+	bool strict_check;
+	union {
+		u8 ctx[48];
+		long int args[6];
+	};
+};
+
+struct ndmsg {
+	__u8 ndm_family;
+	__u8 ndm_pad1;
+	__u16 ndm_pad2;
+	__s32 ndm_ifindex;
+	__u16 ndm_state;
+	__u8 ndm_flags;
+	__u8 ndm_type;
+};
+
+struct rtnl_link_stats64 {
+	__u64 rx_packets;
+	__u64 tx_packets;
+	__u64 rx_bytes;
+	__u64 tx_bytes;
+	__u64 rx_errors;
+	__u64 tx_errors;
+	__u64 rx_dropped;
+	__u64 tx_dropped;
+	__u64 multicast;
+	__u64 collisions;
+	__u64 rx_length_errors;
+	__u64 rx_over_errors;
+	__u64 rx_crc_errors;
+	__u64 rx_frame_errors;
+	__u64 rx_fifo_errors;
+	__u64 rx_missed_errors;
+	__u64 tx_aborted_errors;
+	__u64 tx_carrier_errors;
+	__u64 tx_fifo_errors;
+	__u64 tx_heartbeat_errors;
+	__u64 tx_window_errors;
+	__u64 rx_compressed;
+	__u64 tx_compressed;
+	__u64 rx_nohandler;
+	__u64 rx_otherhost_dropped;
+};
+
+struct rtnl_hw_stats64 {
+	__u64 rx_packets;
+	__u64 tx_packets;
+	__u64 rx_bytes;
+	__u64 tx_bytes;
+	__u64 rx_errors;
+	__u64 tx_errors;
+	__u64 rx_dropped;
+	__u64 tx_dropped;
+	__u64 multicast;
+};
+
+struct ifla_vf_guid {
+	__u32 vf;
+	long: 32;
+	__u64 guid;
+};
+
+struct ifla_vf_stats {
+	__u64 rx_packets;
+	__u64 tx_packets;
+	__u64 rx_bytes;
+	__u64 tx_bytes;
+	__u64 broadcast;
+	__u64 multicast;
+	__u64 rx_dropped;
+	__u64 tx_dropped;
+};
+
+struct ifla_vf_info {
+	__u32 vf;
+	__u8 mac[32];
+	__u32 vlan;
+	__u32 qos;
+	__u32 spoofchk;
+	__u32 linkstate;
+	__u32 min_tx_rate;
+	__u32 max_tx_rate;
+	__u32 rss_query_en;
+	__u32 trusted;
+	__be16 vlan_proto;
+};
+
+enum netdev_tx {
+	__NETDEV_TX_MIN = -2147483648,
+	NETDEV_TX_OK = 0,
+	NETDEV_TX_BUSY = 16,
+};
+
+typedef enum netdev_tx netdev_tx_t;
+
+struct net_device_core_stats {
+	long unsigned int rx_dropped;
+	long unsigned int tx_dropped;
+	long unsigned int rx_nohandler;
+	long unsigned int rx_otherhost_dropped;
+};
+
+struct header_ops {
+	int (*create)(struct sk_buff *, struct net_device *, short unsigned int, const void *, const void *, unsigned int);
+	int (*parse)(const struct sk_buff *, unsigned char *);
+	int (*cache)(const struct neighbour *, struct hh_cache *, __be16);
+	void (*cache_update)(struct hh_cache *, const struct net_device *, const unsigned char *);
+	bool (*validate)(const char *, unsigned int);
+	__be16 (*parse_protocol)(const struct sk_buff *);
+};
+
+struct gro_list {
+	struct list_head list;
+	int count;
+};
+
+struct napi_struct {
+	struct list_head poll_list;
+	long unsigned int state;
+	int weight;
+	u32 defer_hard_irqs_count;
+	long unsigned int gro_bitmask;
+	int (*poll)(struct napi_struct *, int);
+	int poll_owner;
+	int list_owner;
+	struct net_device *dev;
+	struct gro_list gro_hash[8];
+	struct sk_buff *skb;
+	struct list_head rx_list;
+	int rx_count;
+	unsigned int napi_id;
+	long: 32;
+	struct hrtimer timer;
+	struct task_struct *thread;
+	struct list_head dev_list;
+	struct hlist_node napi_hash_node;
+	int irq;
+};
+
+struct xsk_buff_pool;
+
+struct netdev_queue {
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	struct Qdisc *qdisc;
+	struct Qdisc *qdisc_sleeping;
+	struct kobject kobj;
+	long unsigned int tx_maxrate;
+	atomic_long_t trans_timeout;
+	struct net_device *sb_dev;
+	struct xsk_buff_pool *pool;
+	struct dql dql;
+	spinlock_t _xmit_lock;
+	int xmit_lock_owner;
+	long unsigned int trans_start;
+	long unsigned int state;
+	struct napi_struct *napi;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct qdisc_skb_head {
+	struct sk_buff *head;
+	struct sk_buff *tail;
+	__u32 qlen;
+	spinlock_t lock;
+};
+
+struct gnet_stats_basic_sync {
+	u64_stats_t bytes;
+	u64_stats_t packets;
+	struct u64_stats_sync syncp;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct gnet_stats_queue {
+	__u32 qlen;
+	__u32 backlog;
+	__u32 drops;
+	__u32 requeues;
+	__u32 overlimits;
+};
+
+struct Qdisc_ops;
+
+struct qdisc_size_table;
+
+struct net_rate_estimator;
+
+struct Qdisc {
+	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
+	struct sk_buff * (*dequeue)(struct Qdisc *);
+	unsigned int flags;
+	u32 limit;
+	const struct Qdisc_ops *ops;
+	struct qdisc_size_table *stab;
+	struct hlist_node hash;
+	u32 handle;
+	u32 parent;
+	struct netdev_queue *dev_queue;
+	struct net_rate_estimator *rate_est;
+	struct gnet_stats_basic_sync *cpu_bstats;
+	struct gnet_stats_queue *cpu_qstats;
+	int pad;
+	refcount_t refcnt;
+	struct sk_buff_head gso_skb;
+	struct qdisc_skb_head q;
+	struct gnet_stats_basic_sync bstats;
+	struct gnet_stats_queue qstats;
+	int owner;
+	long unsigned int state;
+	long unsigned int state2;
+	struct Qdisc *next_sched;
+	struct sk_buff_head skb_bad_txq;
+	long: 32;
+	long: 32;
+	long: 32;
+	spinlock_t busylock;
+	spinlock_t seqlock;
+	struct callback_head rcu;
+	netdevice_tracker dev_tracker;
+	struct lock_class_key root_lock_key;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long int privdata[0];
+};
+
+struct xps_map {
+	unsigned int len;
+	unsigned int alloc_len;
+	struct callback_head rcu;
+	u16 queues[0];
+};
+
+struct xps_dev_maps {
+	struct callback_head rcu;
+	unsigned int nr_ids;
+	s16 num_tc;
+	struct xps_map *attr_map[0];
+};
+
+struct netdev_phys_item_id {
+	unsigned char id[32];
+	unsigned char id_len;
+};
+
+enum net_device_path_type {
+	DEV_PATH_ETHERNET = 0,
+	DEV_PATH_VLAN = 1,
+	DEV_PATH_BRIDGE = 2,
+	DEV_PATH_PPPOE = 3,
+	DEV_PATH_DSA = 4,
+	DEV_PATH_MTK_WDMA = 5,
+};
+
+struct net_device_path {
+	enum net_device_path_type type;
+	const struct net_device *dev;
+	union {
+		struct {
+			u16 id;
+			__be16 proto;
+			u8 h_dest[6];
+		} encap;
+		struct {
+			enum {
+				DEV_PATH_BR_VLAN_KEEP = 0,
+				DEV_PATH_BR_VLAN_TAG = 1,
+				DEV_PATH_BR_VLAN_UNTAG = 2,
+				DEV_PATH_BR_VLAN_UNTAG_HW = 3,
+			} vlan_mode;
+			u16 vlan_id;
+			__be16 vlan_proto;
+		} bridge;
+		struct {
+			int port;
+			u16 proto;
+		} dsa;
+		struct {
+			u8 wdma_idx;
+			u8 queue;
+			u16 wcid;
+			u8 bss;
+			u8 amsdu;
+		} mtk_wdma;
+	};
+};
+
+struct net_device_path_ctx {
+	const struct net_device *dev;
+	u8 daddr[6];
+	int num_vlans;
+	struct {
+		u16 id;
+		__be16 proto;
+	} vlan[2];
+};
+
+enum tc_setup_type {
+	TC_QUERY_CAPS = 0,
+	TC_SETUP_QDISC_MQPRIO = 1,
+	TC_SETUP_CLSU32 = 2,
+	TC_SETUP_CLSFLOWER = 3,
+	TC_SETUP_CLSMATCHALL = 4,
+	TC_SETUP_CLSBPF = 5,
+	TC_SETUP_BLOCK = 6,
+	TC_SETUP_QDISC_CBS = 7,
+	TC_SETUP_QDISC_RED = 8,
+	TC_SETUP_QDISC_PRIO = 9,
+	TC_SETUP_QDISC_MQ = 10,
+	TC_SETUP_QDISC_ETF = 11,
+	TC_SETUP_ROOT_QDISC = 12,
+	TC_SETUP_QDISC_GRED = 13,
+	TC_SETUP_QDISC_TAPRIO = 14,
+	TC_SETUP_FT = 15,
+	TC_SETUP_QDISC_ETS = 16,
+	TC_SETUP_QDISC_TBF = 17,
+	TC_SETUP_QDISC_FIFO = 18,
+	TC_SETUP_QDISC_HTB = 19,
+	TC_SETUP_ACT = 20,
+};
+
+enum bpf_netdev_command {
+	XDP_SETUP_PROG = 0,
+	XDP_SETUP_PROG_HW = 1,
+	BPF_OFFLOAD_MAP_ALLOC = 2,
+	BPF_OFFLOAD_MAP_FREE = 3,
+	XDP_SETUP_XSK_POOL = 4,
+};
+
+struct netdev_bpf {
+	enum bpf_netdev_command command;
+	union {
+		struct {
+			u32 flags;
+			struct bpf_prog *prog;
+			struct netlink_ext_ack *extack;
+		};
+		struct {
+			struct bpf_offloaded_map *offmap;
+		};
+		struct {
+			struct xsk_buff_pool *pool;
+			u16 queue_id;
+		} xsk;
+	};
+};
+
+struct dev_ifalias {
+	struct callback_head rcuhead;
+	char ifalias[0];
+};
+
+struct xdp_frame;
+
+struct xdp_buff;
+
+struct ip_tunnel_parm_kern;
+
+struct kernel_hwtstamp_config;
+
+struct net_device_ops {
+	int (*ndo_init)(struct net_device *);
+	void (*ndo_uninit)(struct net_device *);
+	int (*ndo_open)(struct net_device *);
+	int (*ndo_stop)(struct net_device *);
+	netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *);
+	netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t);
+	u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *);
+	void (*ndo_change_rx_flags)(struct net_device *, int);
+	void (*ndo_set_rx_mode)(struct net_device *);
+	int (*ndo_set_mac_address)(struct net_device *, void *);
+	int (*ndo_validate_addr)(struct net_device *);
+	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
+	int (*ndo_eth_ioctl)(struct net_device *, struct ifreq *, int);
+	int (*ndo_siocbond)(struct net_device *, struct ifreq *, int);
+	int (*ndo_siocwandev)(struct net_device *, struct if_settings *);
+	int (*ndo_siocdevprivate)(struct net_device *, struct ifreq *, void *, int);
+	int (*ndo_set_config)(struct net_device *, struct ifmap *);
+	int (*ndo_change_mtu)(struct net_device *, int);
+	int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *);
+	void (*ndo_tx_timeout)(struct net_device *, unsigned int);
+	void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *);
+	bool (*ndo_has_offload_stats)(const struct net_device *, int);
+	int (*ndo_get_offload_stats)(int, const struct net_device *, void *);
+	struct net_device_stats * (*ndo_get_stats)(struct net_device *);
+	int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16, u16);
+	int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16, u16);
+	void (*ndo_poll_controller)(struct net_device *);
+	int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *);
+	void (*ndo_netpoll_cleanup)(struct net_device *);
+	int (*ndo_set_vf_mac)(struct net_device *, int, u8 *);
+	int (*ndo_set_vf_vlan)(struct net_device *, int, u16, u8, __be16);
+	int (*ndo_set_vf_rate)(struct net_device *, int, int, int);
+	int (*ndo_set_vf_spoofchk)(struct net_device *, int, bool);
+	int (*ndo_set_vf_trust)(struct net_device *, int, bool);
+	int (*ndo_get_vf_config)(struct net_device *, int, struct ifla_vf_info *);
+	int (*ndo_set_vf_link_state)(struct net_device *, int, int);
+	int (*ndo_get_vf_stats)(struct net_device *, int, struct ifla_vf_stats *);
+	int (*ndo_set_vf_port)(struct net_device *, int, struct nlattr **);
+	int (*ndo_get_vf_port)(struct net_device *, int, struct sk_buff *);
+	int (*ndo_get_vf_guid)(struct net_device *, int, struct ifla_vf_guid *, struct ifla_vf_guid *);
+	int (*ndo_set_vf_guid)(struct net_device *, int, u64, int);
+	int (*ndo_set_vf_rss_query_en)(struct net_device *, int, bool);
+	int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type, void *);
+	int (*ndo_rx_flow_steer)(struct net_device *, const struct sk_buff *, u16, u32);
+	int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *);
+	int (*ndo_del_slave)(struct net_device *, struct net_device *);
+	struct net_device * (*ndo_get_xmit_slave)(struct net_device *, struct sk_buff *, bool);
+	struct net_device * (*ndo_sk_get_lower_dev)(struct net_device *, struct sock *);
+	netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t);
+	int (*ndo_set_features)(struct net_device *, netdev_features_t);
+	int (*ndo_neigh_construct)(struct net_device *, struct neighbour *);
+	void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *);
+	int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16, struct netlink_ext_ack *);
+	int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, struct netlink_ext_ack *);
+	int (*ndo_fdb_del_bulk)(struct nlmsghdr *, struct net_device *, struct netlink_ext_ack *);
+	int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *);
+	int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);
+	int (*ndo_mdb_add)(struct net_device *, struct nlattr **, u16, struct netlink_ext_ack *);
+	int (*ndo_mdb_del)(struct net_device *, struct nlattr **, struct netlink_ext_ack *);
+	int (*ndo_mdb_del_bulk)(struct net_device *, struct nlattr **, struct netlink_ext_ack *);
+	int (*ndo_mdb_dump)(struct net_device *, struct sk_buff *, struct netlink_callback *);
+	int (*ndo_mdb_get)(struct net_device *, struct nlattr **, u32, u32, struct netlink_ext_ack *);
+	int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16, struct netlink_ext_ack *);
+	int (*ndo_bridge_getlink)(struct sk_buff *, u32, u32, struct net_device *, u32, int);
+	int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16);
+	int (*ndo_change_carrier)(struct net_device *, bool);
+	int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *);
+	int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *);
+	int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t);
+	void * (*ndo_dfwd_add_station)(struct net_device *, struct net_device *);
+	void (*ndo_dfwd_del_station)(struct net_device *, void *);
+	int (*ndo_set_tx_maxrate)(struct net_device *, int, u32);
+	int (*ndo_get_iflink)(const struct net_device *);
+	int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *);
+	void (*ndo_set_rx_headroom)(struct net_device *, int);
+	int (*ndo_bpf)(struct net_device *, struct netdev_bpf *);
+	int (*ndo_xdp_xmit)(struct net_device *, int, struct xdp_frame **, u32);
+	struct net_device * (*ndo_xdp_get_xmit_slave)(struct net_device *, struct xdp_buff *);
+	int (*ndo_xsk_wakeup)(struct net_device *, u32, u32);
+	int (*ndo_tunnel_ctl)(struct net_device *, struct ip_tunnel_parm_kern *, int);
+	struct net_device * (*ndo_get_peer_dev)(struct net_device *);
+	int (*ndo_fill_forward_path)(struct net_device_path_ctx *, struct net_device_path *);
+	ktime_t (*ndo_get_tstamp)(struct net_device *, const struct skb_shared_hwtstamps *, bool);
+	int (*ndo_hwtstamp_get)(struct net_device *, struct kernel_hwtstamp_config *);
+	int (*ndo_hwtstamp_set)(struct net_device *, struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
+};
+
+struct neigh_parms {
+	possible_net_t net;
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	struct list_head list;
+	int (*neigh_setup)(struct neighbour *);
+	struct neigh_table *tbl;
+	void *sysctl_table;
+	int dead;
+	refcount_t refcnt;
+	struct callback_head callback_head;
+	int reachable_time;
+	u32 qlen;
+	int data[14];
+	long unsigned int data_state[1];
+};
+
+enum hwtstamp_source {
+	HWTSTAMP_SOURCE_UNSPEC = 0,
+	HWTSTAMP_SOURCE_NETDEV = 1,
+	HWTSTAMP_SOURCE_PHYLIB = 2,
+};
+
+struct kernel_hwtstamp_config {
+	int flags;
+	int tx_type;
+	int rx_filter;
+	struct ifreq *ifr;
+	bool copied_to_user;
+	enum hwtstamp_source source;
+};
+
+struct pcpu_lstats {
+	u64_stats_t packets;
+	u64_stats_t bytes;
+	struct u64_stats_sync syncp;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct pcpu_sw_netstats {
+	u64_stats_t rx_packets;
+	u64_stats_t rx_bytes;
+	u64_stats_t tx_packets;
+	u64_stats_t tx_bytes;
+	struct u64_stats_sync syncp;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct pcpu_dstats {
+	u64_stats_t rx_packets;
+	u64_stats_t rx_bytes;
+	u64_stats_t rx_drops;
+	u64_stats_t tx_packets;
+	u64_stats_t tx_bytes;
+	u64_stats_t tx_drops;
+	struct u64_stats_sync syncp;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct ipv6_devstat {
+	struct proc_dir_entry *proc_dir_entry;
+	struct ipstats_mib *ipv6;
+	struct icmpv6_mib_device *icmpv6dev;
+	struct icmpv6msg_mib_device *icmpv6msgdev;
+};
+
+struct ifmcaddr6;
+
+struct ifacaddr6;
+
+struct inet6_dev {
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	struct list_head addr_list;
+	struct ifmcaddr6 *mc_list;
+	struct ifmcaddr6 *mc_tomb;
+	unsigned char mc_qrv;
+	unsigned char mc_gq_running;
+	unsigned char mc_ifc_count;
+	unsigned char mc_dad_count;
+	long unsigned int mc_v1_seen;
+	long unsigned int mc_qi;
+	long unsigned int mc_qri;
+	long unsigned int mc_maxdelay;
+	struct delayed_work mc_gq_work;
+	struct delayed_work mc_ifc_work;
+	struct delayed_work mc_dad_work;
+	struct delayed_work mc_query_work;
+	struct delayed_work mc_report_work;
+	struct sk_buff_head mc_query_queue;
+	struct sk_buff_head mc_report_queue;
+	spinlock_t mc_query_lock;
+	spinlock_t mc_report_lock;
+	struct mutex mc_lock;
+	struct ifacaddr6 *ac_list;
+	rwlock_t lock;
+	refcount_t refcnt;
+	__u32 if_flags;
+	int dead;
+	u32 desync_factor;
+	struct list_head tempaddr_list;
+	struct in6_addr token;
+	struct neigh_parms *nd_parms;
+	struct ipv6_devconf cnf;
+	struct ipv6_devstat stats;
+	struct timer_list rs_timer;
+	__s32 rs_interval;
+	__u8 rs_probes;
+	long unsigned int tstamp;
+	struct callback_head rcu;
+	unsigned int ra_mtu;
+};
+
+enum xdp_rss_hash_type {
+	XDP_RSS_L3_IPV4 = 1,
+	XDP_RSS_L3_IPV6 = 2,
+	XDP_RSS_L3_DYNHDR = 4,
+	XDP_RSS_L4 = 8,
+	XDP_RSS_L4_TCP = 16,
+	XDP_RSS_L4_UDP = 32,
+	XDP_RSS_L4_SCTP = 64,
+	XDP_RSS_L4_IPSEC = 128,
+	XDP_RSS_L4_ICMP = 256,
+	XDP_RSS_TYPE_NONE = 0,
+	XDP_RSS_TYPE_L2 = 0,
+	XDP_RSS_TYPE_L3_IPV4 = 1,
+	XDP_RSS_TYPE_L3_IPV6 = 2,
+	XDP_RSS_TYPE_L3_IPV4_OPT = 5,
+	XDP_RSS_TYPE_L3_IPV6_EX = 6,
+	XDP_RSS_TYPE_L4_ANY = 8,
+	XDP_RSS_TYPE_L4_IPV4_TCP = 25,
+	XDP_RSS_TYPE_L4_IPV4_UDP = 41,
+	XDP_RSS_TYPE_L4_IPV4_SCTP = 73,
+	XDP_RSS_TYPE_L4_IPV4_IPSEC = 137,
+	XDP_RSS_TYPE_L4_IPV4_ICMP = 265,
+	XDP_RSS_TYPE_L4_IPV6_TCP = 26,
+	XDP_RSS_TYPE_L4_IPV6_UDP = 42,
+	XDP_RSS_TYPE_L4_IPV6_SCTP = 74,
+	XDP_RSS_TYPE_L4_IPV6_IPSEC = 138,
+	XDP_RSS_TYPE_L4_IPV6_ICMP = 266,
+	XDP_RSS_TYPE_L4_IPV6_TCP_EX = 30,
+	XDP_RSS_TYPE_L4_IPV6_UDP_EX = 46,
+	XDP_RSS_TYPE_L4_IPV6_SCTP_EX = 78,
+};
+
+struct xdp_md;
+
+struct xdp_metadata_ops {
+	int (*xmo_rx_timestamp)(const struct xdp_md *, u64 *);
+	int (*xmo_rx_hash)(const struct xdp_md *, u32 *, enum xdp_rss_hash_type *);
+	int (*xmo_rx_vlan_tag)(const struct xdp_md *, __be16 *, u16 *);
+};
+
+struct xsk_tx_metadata_ops {
+	void (*tmo_request_timestamp)(void *);
+	u64 (*tmo_fill_timestamp)(void *);
+	void (*tmo_request_checksum)(u16, u16, void *);
+};
+
+enum ethtool_phys_id_state {
+	ETHTOOL_ID_INACTIVE = 0,
+	ETHTOOL_ID_ACTIVE = 1,
+	ETHTOOL_ID_ON = 2,
+	ETHTOOL_ID_OFF = 3,
+};
+
+struct ethtool_drvinfo;
+
+struct ethtool_regs;
+
+struct ethtool_wolinfo;
+
+struct ethtool_link_ext_state_info;
+
+struct ethtool_link_ext_stats;
+
+struct ethtool_eeprom;
+
+struct ethtool_coalesce;
+
+struct kernel_ethtool_coalesce;
+
+struct ethtool_ringparam;
+
+struct kernel_ethtool_ringparam;
+
+struct ethtool_pause_stats;
+
+struct ethtool_pauseparam;
+
+struct ethtool_test;
+
+struct ethtool_stats;
+
+struct ethtool_rxnfc;
+
+struct ethtool_flash;
+
+struct ethtool_rxfh_param;
+
+struct ethtool_rxfh_context;
+
+struct ethtool_channels;
+
+struct ethtool_dump;
+
+struct kernel_ethtool_ts_info;
+
+struct ethtool_ts_stats;
+
+struct ethtool_modinfo;
+
+struct ethtool_keee;
+
+struct ethtool_tunable;
+
+struct ethtool_link_ksettings;
+
+struct ethtool_fec_stats;
+
+struct ethtool_fecparam;
+
+struct ethtool_module_eeprom;
+
+struct ethtool_eth_phy_stats;
+
+struct ethtool_eth_mac_stats;
+
+struct ethtool_eth_ctrl_stats;
+
+struct ethtool_rmon_stats;
+
+struct ethtool_rmon_hist_range;
+
+struct ethtool_module_power_mode_params;
+
+struct ethtool_mm_state;
+
+struct ethtool_mm_cfg;
+
+struct ethtool_mm_stats;
+
+struct ethtool_ops {
+	u32 cap_link_lanes_supported: 1;
+	u32 cap_rss_ctx_supported: 1;
+	u32 cap_rss_sym_xor_supported: 1;
+	u32 rxfh_per_ctx_key: 1;
+	u32 rxfh_indir_space;
+	u16 rxfh_key_space;
+	u16 rxfh_priv_size;
+	u32 rxfh_max_num_contexts;
+	u32 supported_coalesce_params;
+	u32 supported_ring_params;
+	void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
+	int (*get_regs_len)(struct net_device *);
+	void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
+	void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
+	int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
+	u32 (*get_msglevel)(struct net_device *);
+	void (*set_msglevel)(struct net_device *, u32);
+	int (*nway_reset)(struct net_device *);
+	u32 (*get_link)(struct net_device *);
+	int (*get_link_ext_state)(struct net_device *, struct ethtool_link_ext_state_info *);
+	void (*get_link_ext_stats)(struct net_device *, struct ethtool_link_ext_stats *);
+	int (*get_eeprom_len)(struct net_device *);
+	int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+	int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+	int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);
+	int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);
+	void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *, struct kernel_ethtool_ringparam *, struct netlink_ext_ack *);
+	int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *, struct kernel_ethtool_ringparam *, struct netlink_ext_ack *);
+	void (*get_pause_stats)(struct net_device *, struct ethtool_pause_stats *);
+	void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
+	int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
+	void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
+	void (*get_strings)(struct net_device *, u32, u8 *);
+	int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);
+	void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);
+	int (*begin)(struct net_device *);
+	void (*complete)(struct net_device *);
+	u32 (*get_priv_flags)(struct net_device *);
+	int (*set_priv_flags)(struct net_device *, u32);
+	int (*get_sset_count)(struct net_device *, int);
+	int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *);
+	int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
+	int (*flash_device)(struct net_device *, struct ethtool_flash *);
+	int (*reset)(struct net_device *, u32 *);
+	u32 (*get_rxfh_key_size)(struct net_device *);
+	u32 (*get_rxfh_indir_size)(struct net_device *);
+	int (*get_rxfh)(struct net_device *, struct ethtool_rxfh_param *);
+	int (*set_rxfh)(struct net_device *, struct ethtool_rxfh_param *, struct netlink_ext_ack *);
+	int (*create_rxfh_context)(struct net_device *, struct ethtool_rxfh_context *, const struct ethtool_rxfh_param *, struct netlink_ext_ack *);
+	int (*modify_rxfh_context)(struct net_device *, struct ethtool_rxfh_context *, const struct ethtool_rxfh_param *, struct netlink_ext_ack *);
+	int (*remove_rxfh_context)(struct net_device *, struct ethtool_rxfh_context *, u32, struct netlink_ext_ack *);
+	void (*get_channels)(struct net_device *, struct ethtool_channels *);
+	int (*set_channels)(struct net_device *, struct ethtool_channels *);
+	int (*get_dump_flag)(struct net_device *, struct ethtool_dump *);
+	int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *);
+	int (*set_dump)(struct net_device *, struct ethtool_dump *);
+	int (*get_ts_info)(struct net_device *, struct kernel_ethtool_ts_info *);
+	void (*get_ts_stats)(struct net_device *, struct ethtool_ts_stats *);
+	int (*get_module_info)(struct net_device *, struct ethtool_modinfo *);
+	int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+	int (*get_eee)(struct net_device *, struct ethtool_keee *);
+	int (*set_eee)(struct net_device *, struct ethtool_keee *);
+	int (*get_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
+	int (*set_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
+	int (*get_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
+	int (*set_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
+	int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *);
+	int (*set_link_ksettings)(struct net_device *, const struct ethtool_link_ksettings *);
+	void (*get_fec_stats)(struct net_device *, struct ethtool_fec_stats *);
+	int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *);
+	int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *);
+	void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *);
+	int (*get_phy_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
+	int (*set_phy_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
+	int (*get_module_eeprom_by_page)(struct net_device *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);
+	int (*set_module_eeprom_by_page)(struct net_device *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);
+	void (*get_eth_phy_stats)(struct net_device *, struct ethtool_eth_phy_stats *);
+	void (*get_eth_mac_stats)(struct net_device *, struct ethtool_eth_mac_stats *);
+	void (*get_eth_ctrl_stats)(struct net_device *, struct ethtool_eth_ctrl_stats *);
+	void (*get_rmon_stats)(struct net_device *, struct ethtool_rmon_stats *, const struct ethtool_rmon_hist_range **);
+	int (*get_module_power_mode)(struct net_device *, struct ethtool_module_power_mode_params *, struct netlink_ext_ack *);
+	int (*set_module_power_mode)(struct net_device *, const struct ethtool_module_power_mode_params *, struct netlink_ext_ack *);
+	int (*get_mm)(struct net_device *, struct ethtool_mm_state *);
+	int (*set_mm)(struct net_device *, struct ethtool_mm_cfg *, struct netlink_ext_ack *);
+	void (*get_mm_stats)(struct net_device *, struct ethtool_mm_stats *);
+};
+
+struct l3mdev_ops {
+	u32 (*l3mdev_fib_table)(const struct net_device *);
+	struct sk_buff * (*l3mdev_l3_rcv)(struct net_device *, struct sk_buff *, u16);
+	struct sk_buff * (*l3mdev_l3_out)(struct net_device *, struct sock *, struct sk_buff *, u16);
+	struct dst_entry * (*l3mdev_link_scope_lookup)(const struct net_device *, struct flowi6 *);
+};
+
+struct nd_opt_hdr;
+
+struct ndisc_options;
+
+struct prefix_info;
+
+struct ndisc_ops {
+	int (*parse_options)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *);
+	void (*update)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *);
+	int (*opt_addr_space)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **);
+	void (*fill_addr_option)(const struct net_device *, struct sk_buff *, u8, const u8 *);
+	void (*prefix_rcv_add_addr)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool);
+};
+
+enum tls_offload_ctx_dir {
+	TLS_OFFLOAD_CTX_DIR_RX = 0,
+	TLS_OFFLOAD_CTX_DIR_TX = 1,
+};
+
+struct tls_crypto_info;
+
+struct tls_context;
+
+struct tlsdev_ops {
+	int (*tls_dev_add)(struct net_device *, struct sock *, enum tls_offload_ctx_dir, struct tls_crypto_info *, u32);
+	void (*tls_dev_del)(struct net_device *, struct tls_context *, enum tls_offload_ctx_dir);
+	int (*tls_dev_resync)(struct net_device *, struct sock *, u32, u8 *, enum tls_offload_ctx_dir);
+};
+
+struct rtnl_link_ops {
+	struct list_head list;
+	const char *kind;
+	size_t priv_size;
+	struct net_device * (*alloc)(struct nlattr **, const char *, unsigned char, unsigned int, unsigned int);
+	void (*setup)(struct net_device *);
+	bool netns_refund;
+	unsigned int maxtype;
+	const struct nla_policy *policy;
+	int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
+	int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
+	int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
+	void (*dellink)(struct net_device *, struct list_head *);
+	size_t (*get_size)(const struct net_device *);
+	int (*fill_info)(struct sk_buff *, const struct net_device *);
+	size_t (*get_xstats_size)(const struct net_device *);
+	int (*fill_xstats)(struct sk_buff *, const struct net_device *);
+	unsigned int (*get_num_tx_queues)();
+	unsigned int (*get_num_rx_queues)();
+	unsigned int slave_maxtype;
+	const struct nla_policy *slave_policy;
+	int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
+	size_t (*get_slave_size)(const struct net_device *, const struct net_device *);
+	int (*fill_slave_info)(struct sk_buff *, const struct net_device *, const struct net_device *);
+	struct net * (*get_link_net)(const struct net_device *);
+	size_t (*get_linkxstats_size)(const struct net_device *, int);
+	int (*fill_linkxstats)(struct sk_buff *, const struct net_device *, int *, int);
+};
+
+struct netdev_queue_stats_rx;
+
+struct netdev_queue_stats_tx;
+
+struct netdev_stat_ops {
+	void (*get_queue_stats_rx)(struct net_device *, int, struct netdev_queue_stats_rx *);
+	void (*get_queue_stats_tx)(struct net_device *, int, struct netdev_queue_stats_tx *);
+	void (*get_base_stats)(struct net_device *, struct netdev_queue_stats_rx *, struct netdev_queue_stats_tx *);
+};
+
+struct netdev_queue_mgmt_ops {
+	size_t ndo_queue_mem_size;
+	int (*ndo_queue_mem_alloc)(struct net_device *, void *, int);
+	void (*ndo_queue_mem_free)(struct net_device *, void *);
+	int (*ndo_queue_start)(struct net_device *, void *, int);
+	int (*ndo_queue_stop)(struct net_device *, void *, int);
+};
+
+struct macsec_context;
+
+struct macsec_ops {
+	int (*mdo_dev_open)(struct macsec_context *);
+	int (*mdo_dev_stop)(struct macsec_context *);
+	int (*mdo_add_secy)(struct macsec_context *);
+	int (*mdo_upd_secy)(struct macsec_context *);
+	int (*mdo_del_secy)(struct macsec_context *);
+	int (*mdo_add_rxsc)(struct macsec_context *);
+	int (*mdo_upd_rxsc)(struct macsec_context *);
+	int (*mdo_del_rxsc)(struct macsec_context *);
+	int (*mdo_add_rxsa)(struct macsec_context *);
+	int (*mdo_upd_rxsa)(struct macsec_context *);
+	int (*mdo_del_rxsa)(struct macsec_context *);
+	int (*mdo_add_txsa)(struct macsec_context *);
+	int (*mdo_upd_txsa)(struct macsec_context *);
+	int (*mdo_del_txsa)(struct macsec_context *);
+	int (*mdo_get_dev_stats)(struct macsec_context *);
+	int (*mdo_get_tx_sc_stats)(struct macsec_context *);
+	int (*mdo_get_tx_sa_stats)(struct macsec_context *);
+	int (*mdo_get_rx_sc_stats)(struct macsec_context *);
+	int (*mdo_get_rx_sa_stats)(struct macsec_context *);
+	int (*mdo_insert_tx_tag)(struct phy_device *, struct sk_buff *);
+	unsigned int needed_headroom;
+	unsigned int needed_tailroom;
+	bool rx_uses_md_dst;
+};
+
+struct udp_tunnel_nic_table_info {
+	unsigned int n_entries;
+	unsigned int tunnel_types;
+};
+
+struct udp_tunnel_info;
+
+struct udp_tunnel_nic_shared;
+
+struct udp_tunnel_nic_info {
+	int (*set_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
+	int (*unset_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
+	int (*sync_table)(struct net_device *, unsigned int);
+	struct udp_tunnel_nic_shared *shared;
+	unsigned int flags;
+	struct udp_tunnel_nic_table_info tables[4];
+};
+
+enum {
+	RTAX_UNSPEC = 0,
+	RTAX_LOCK = 1,
+	RTAX_MTU = 2,
+	RTAX_WINDOW = 3,
+	RTAX_RTT = 4,
+	RTAX_RTTVAR = 5,
+	RTAX_SSTHRESH = 6,
+	RTAX_CWND = 7,
+	RTAX_ADVMSS = 8,
+	RTAX_REORDERING = 9,
+	RTAX_HOPLIMIT = 10,
+	RTAX_INITCWND = 11,
+	RTAX_FEATURES = 12,
+	RTAX_RTO_MIN = 13,
+	RTAX_INITRWND = 14,
+	RTAX_QUICKACK = 15,
+	RTAX_CC_ALGO = 16,
+	RTAX_FASTOPEN_NO_COOKIE = 17,
+	__RTAX_MAX = 18,
+};
+
+struct tcmsg {
+	unsigned char tcm_family;
+	unsigned char tcm__pad1;
+	short unsigned int tcm__pad2;
+	int tcm_ifindex;
+	__u32 tcm_handle;
+	__u32 tcm_parent;
+	__u32 tcm_info;
+};
+
+struct gnet_dump {
+	spinlock_t *lock;
+	struct sk_buff *skb;
+	struct nlattr *tail;
+	int compat_tc_stats;
+	int compat_xstats;
+	int padattr;
+	void *xstats;
+	int xstats_len;
+	struct tc_stats tc_stats;
+};
+
+struct netlink_range_validation {
+	u64 min;
+	u64 max;
+};
+
+struct netlink_range_validation_signed {
+	s64 min;
+	s64 max;
+};
+
+enum flow_action_hw_stats_bit {
+	FLOW_ACTION_HW_STATS_IMMEDIATE_BIT = 0,
+	FLOW_ACTION_HW_STATS_DELAYED_BIT = 1,
+	FLOW_ACTION_HW_STATS_DISABLED_BIT = 2,
+	FLOW_ACTION_HW_STATS_NUM_BITS = 3,
+};
+
+struct flow_block {
+	struct list_head cb_list;
+};
+
+typedef int flow_setup_cb_t(enum tc_setup_type, void *, void *);
+
+struct qdisc_size_table {
+	struct callback_head rcu;
+	struct list_head list;
+	struct tc_sizespec szopts;
+	int refcnt;
+	u16 data[0];
+};
+
+struct Qdisc_class_ops;
+
+struct Qdisc_ops {
+	struct Qdisc_ops *next;
+	const struct Qdisc_class_ops *cl_ops;
+	char id[16];
+	int priv_size;
+	unsigned int static_flags;
+	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
+	struct sk_buff * (*dequeue)(struct Qdisc *);
+	struct sk_buff * (*peek)(struct Qdisc *);
+	int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
+	void (*reset)(struct Qdisc *);
+	void (*destroy)(struct Qdisc *);
+	int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
+	void (*attach)(struct Qdisc *);
+	int (*change_tx_queue_len)(struct Qdisc *, unsigned int);
+	void (*change_real_num_tx)(struct Qdisc *, unsigned int);
+	int (*dump)(struct Qdisc *, struct sk_buff *);
+	int (*dump_stats)(struct Qdisc *, struct gnet_dump *);
+	void (*ingress_block_set)(struct Qdisc *, u32);
+	void (*egress_block_set)(struct Qdisc *, u32);
+	u32 (*ingress_block_get)(struct Qdisc *);
+	u32 (*egress_block_get)(struct Qdisc *);
+	struct module *owner;
+};
+
+struct qdisc_walker;
+
+struct tcf_block;
+
+struct Qdisc_class_ops {
+	unsigned int flags;
+	struct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);
+	int (*graft)(struct Qdisc *, long unsigned int, struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *);
+	struct Qdisc * (*leaf)(struct Qdisc *, long unsigned int);
+	void (*qlen_notify)(struct Qdisc *, long unsigned int);
+	long unsigned int (*find)(struct Qdisc *, u32);
+	int (*change)(struct Qdisc *, u32, u32, struct nlattr **, long unsigned int *, struct netlink_ext_ack *);
+	int (*delete)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
+	void (*walk)(struct Qdisc *, struct qdisc_walker *);
+	struct tcf_block * (*tcf_block)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
+	long unsigned int (*bind_tcf)(struct Qdisc *, long unsigned int, u32);
+	void (*unbind_tcf)(struct Qdisc *, long unsigned int);
+	int (*dump)(struct Qdisc *, long unsigned int, struct sk_buff *, struct tcmsg *);
+	int (*dump_stats)(struct Qdisc *, long unsigned int, struct gnet_dump *);
+};
+
+struct tcf_chain;
+
+struct tcf_block {
+	struct xarray ports;
+	struct mutex lock;
+	struct list_head chain_list;
+	u32 index;
+	u32 classid;
+	refcount_t refcnt;
+	struct net *net;
+	struct Qdisc *q;
+	struct rw_semaphore cb_lock;
+	struct flow_block flow_block;
+	struct list_head owner_list;
+	bool keep_dst;
+	bool bypass_wanted;
+	atomic_t filtercnt;
+	atomic_t skipswcnt;
+	atomic_t offloadcnt;
+	unsigned int nooffloaddevcnt;
+	unsigned int lockeddevcnt;
+	struct {
+		struct tcf_chain *chain;
+		struct list_head filter_chain_list;
+	} chain0;
+	struct callback_head rcu;
+	struct hlist_head proto_destroy_ht[128];
+	struct mutex proto_destroy_lock;
+};
+
+struct tcf_result;
+
+struct tcf_proto_ops;
+
+struct tcf_proto {
+	struct tcf_proto *next;
+	void *root;
+	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
+	__be16 protocol;
+	u32 prio;
+	void *data;
+	const struct tcf_proto_ops *ops;
+	struct tcf_chain *chain;
+	spinlock_t lock;
+	bool deleting;
+	bool counted;
+	refcount_t refcnt;
+	struct callback_head rcu;
+	struct hlist_node destroy_ht_node;
+};
+
+struct tcf_result {
+	union {
+		struct {
+			long unsigned int class;
+			u32 classid;
+		};
+		const struct tcf_proto *goto_tp;
+	};
+};
+
+struct tcf_walker;
+
+struct tcf_exts;
+
+struct tcf_proto_ops {
+	struct list_head head;
+	char kind[16];
+	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
+	int (*init)(struct tcf_proto *);
+	void (*destroy)(struct tcf_proto *, bool, struct netlink_ext_ack *);
+	void * (*get)(struct tcf_proto *, u32);
+	void (*put)(struct tcf_proto *, void *);
+	int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, long unsigned int, u32, struct nlattr **, void **, u32, struct netlink_ext_ack *);
+	int (*delete)(struct tcf_proto *, void *, bool *, bool, struct netlink_ext_ack *);
+	bool (*delete_empty)(struct tcf_proto *);
+	void (*walk)(struct tcf_proto *, struct tcf_walker *, bool);
+	int (*reoffload)(struct tcf_proto *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);
+	void (*hw_add)(struct tcf_proto *, void *);
+	void (*hw_del)(struct tcf_proto *, void *);
+	void (*bind_class)(void *, u32, long unsigned int, void *, long unsigned int);
+	void * (*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *);
+	void (*tmplt_destroy)(void *);
+	void (*tmplt_reoffload)(struct tcf_chain *, bool, flow_setup_cb_t *, void *);
+	struct tcf_exts * (*get_exts)(const struct tcf_proto *, u32);
+	int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
+	int (*terse_dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
+	int (*tmplt_dump)(struct sk_buff *, struct net *, void *);
+	struct module *owner;
+	int flags;
+};
+
+struct tcf_chain {
+	struct mutex filter_chain_lock;
+	struct tcf_proto *filter_chain;
+	struct list_head list;
+	struct tcf_block *block;
+	u32 index;
+	unsigned int refcnt;
+	unsigned int action_refcnt;
+	bool explicitly_created;
+	bool flushing;
+	const struct tcf_proto_ops *tmplt_ops;
+	void *tmplt_priv;
+	struct callback_head rcu;
+};
+
+struct sk_filter {
+	refcount_t refcnt;
+	struct callback_head rcu;
+	struct bpf_prog *prog;
+};
+
+enum rpc_display_format_t {
+	RPC_DISPLAY_ADDR = 0,
+	RPC_DISPLAY_PORT = 1,
+	RPC_DISPLAY_PROTO = 2,
+	RPC_DISPLAY_HEX_ADDR = 3,
+	RPC_DISPLAY_HEX_PORT = 4,
+	RPC_DISPLAY_NETID = 5,
+	RPC_DISPLAY_MAX = 6,
+};
+
+enum {
+	NEIGH_VAR_MCAST_PROBES = 0,
+	NEIGH_VAR_UCAST_PROBES = 1,
+	NEIGH_VAR_APP_PROBES = 2,
+	NEIGH_VAR_MCAST_REPROBES = 3,
+	NEIGH_VAR_RETRANS_TIME = 4,
+	NEIGH_VAR_BASE_REACHABLE_TIME = 5,
+	NEIGH_VAR_DELAY_PROBE_TIME = 6,
+	NEIGH_VAR_INTERVAL_PROBE_TIME_MS = 7,
+	NEIGH_VAR_GC_STALETIME = 8,
+	NEIGH_VAR_QUEUE_LEN_BYTES = 9,
+	NEIGH_VAR_PROXY_QLEN = 10,
+	NEIGH_VAR_ANYCAST_DELAY = 11,
+	NEIGH_VAR_PROXY_DELAY = 12,
+	NEIGH_VAR_LOCKTIME = 13,
+	NEIGH_VAR_QUEUE_LEN = 14,
+	NEIGH_VAR_RETRANS_TIME_MS = 15,
+	NEIGH_VAR_BASE_REACHABLE_TIME_MS = 16,
+	NEIGH_VAR_GC_INTERVAL = 17,
+	NEIGH_VAR_GC_THRESH1 = 18,
+	NEIGH_VAR_GC_THRESH2 = 19,
+	NEIGH_VAR_GC_THRESH3 = 20,
+	NEIGH_VAR_MAX = 21,
+};
+
+struct pneigh_entry;
+
+struct neigh_statistics;
+
+struct neigh_hash_table;
+
+struct neigh_table {
+	int family;
+	unsigned int entry_size;
+	unsigned int key_len;
+	__be16 protocol;
+	__u32 (*hash)(const void *, const struct net_device *, __u32 *);
+	bool (*key_eq)(const struct neighbour *, const void *);
+	int (*constructor)(struct neighbour *);
+	int (*pconstructor)(struct pneigh_entry *);
+	void (*pdestructor)(struct pneigh_entry *);
+	void (*proxy_redo)(struct sk_buff *);
+	int (*is_multicast)(const void *);
+	bool (*allow_add)(const struct net_device *, struct netlink_ext_ack *);
+	char *id;
+	struct neigh_parms parms;
+	struct list_head parms_list;
+	int gc_interval;
+	int gc_thresh1;
+	int gc_thresh2;
+	int gc_thresh3;
+	long unsigned int last_flush;
+	struct delayed_work gc_work;
+	struct delayed_work managed_work;
+	struct timer_list proxy_timer;
+	struct sk_buff_head proxy_queue;
+	atomic_t entries;
+	atomic_t gc_entries;
+	struct list_head gc_list;
+	struct list_head managed_list;
+	rwlock_t lock;
+	long unsigned int last_rand;
+	struct neigh_statistics *stats;
+	struct neigh_hash_table *nht;
+	struct pneigh_entry **phash_buckets;
+};
+
+struct neigh_statistics {
+	long unsigned int allocs;
+	long unsigned int destroys;
+	long unsigned int hash_grows;
+	long unsigned int res_failed;
+	long unsigned int lookups;
+	long unsigned int hits;
+	long unsigned int rcv_probes_mcast;
+	long unsigned int rcv_probes_ucast;
+	long unsigned int periodic_gc_runs;
+	long unsigned int forced_gc_runs;
+	long unsigned int unres_discards;
+	long unsigned int table_fulls;
+};
+
+struct neigh_ops {
+	int family;
+	void (*solicit)(struct neighbour *, struct sk_buff *);
+	void (*error_report)(struct neighbour *, struct sk_buff *);
+	int (*output)(struct neighbour *, struct sk_buff *);
+	int (*connected_output)(struct neighbour *, struct sk_buff *);
+};
+
+struct pneigh_entry {
+	struct pneigh_entry *next;
+	possible_net_t net;
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	u32 flags;
+	u8 protocol;
+	u32 key[0];
+};
+
+struct neigh_hash_table {
+	struct neighbour **hash_buckets;
+	unsigned int hash_shift;
+	__u32 hash_rnd[4];
+	struct callback_head rcu;
+};
+
+enum {
+	TCP_ESTABLISHED = 1,
+	TCP_SYN_SENT = 2,
+	TCP_SYN_RECV = 3,
+	TCP_FIN_WAIT1 = 4,
+	TCP_FIN_WAIT2 = 5,
+	TCP_TIME_WAIT = 6,
+	TCP_CLOSE = 7,
+	TCP_CLOSE_WAIT = 8,
+	TCP_LAST_ACK = 9,
+	TCP_LISTEN = 10,
+	TCP_CLOSING = 11,
+	TCP_NEW_SYN_RECV = 12,
+	TCP_BOUND_INACTIVE = 13,
+	TCP_MAX_STATES = 14,
+};
+
+struct fib_rule_hdr {
+	__u8 family;
+	__u8 dst_len;
+	__u8 src_len;
+	__u8 tos;
+	__u8 table;
+	__u8 res1;
+	__u8 res2;
+	__u8 action;
+	__u32 flags;
+};
+
+struct fib_rule_port_range {
+	__u16 start;
+	__u16 end;
+};
+
+struct fib_kuid_range {
+	kuid_t start;
+	kuid_t end;
+};
+
+struct fib_rule {
+	struct list_head list;
+	int iifindex;
+	int oifindex;
+	u32 mark;
+	u32 mark_mask;
+	u32 flags;
+	u32 table;
+	u8 action;
+	u8 l3mdev;
+	u8 proto;
+	u8 ip_proto;
+	u32 target;
+	__be64 tun_id;
+	struct fib_rule *ctarget;
+	struct net *fr_net;
+	refcount_t refcnt;
+	u32 pref;
+	int suppress_ifgroup;
+	int suppress_prefixlen;
+	char iifname[16];
+	char oifname[16];
+	struct fib_kuid_range uid_range;
+	struct fib_rule_port_range sport_range;
+	struct fib_rule_port_range dport_range;
+	struct callback_head rcu;
+};
+
+struct fib_lookup_arg {
+	void *lookup_ptr;
+	const void *lookup_data;
+	void *result;
+	struct fib_rule *rule;
+	u32 table;
+	int flags;
+};
+
+struct smc_hashinfo;
+
+struct sk_psock;
+
+struct request_sock_ops;
+
+struct timewait_sock_ops;
+
+struct raw_hashinfo;
+
+struct proto {
+	void (*close)(struct sock *, long int);
+	int (*pre_connect)(struct sock *, struct sockaddr *, int);
+	int (*connect)(struct sock *, struct sockaddr *, int);
+	int (*disconnect)(struct sock *, int);
+	struct sock * (*accept)(struct sock *, struct proto_accept_arg *);
+	int (*ioctl)(struct sock *, int, int *);
+	int (*init)(struct sock *);
+	void (*destroy)(struct sock *);
+	void (*shutdown)(struct sock *, int);
+	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
+	int (*getsockopt)(struct sock *, int, int, char *, int *);
+	void (*keepalive)(struct sock *, int);
+	int (*sendmsg)(struct sock *, struct msghdr *, size_t);
+	int (*recvmsg)(struct sock *, struct msghdr *, size_t, int, int *);
+	void (*splice_eof)(struct socket *);
+	int (*bind)(struct sock *, struct sockaddr *, int);
+	int (*bind_add)(struct sock *, struct sockaddr *, int);
+	int (*backlog_rcv)(struct sock *, struct sk_buff *);
+	bool (*bpf_bypass_getsockopt)(int, int);
+	void (*release_cb)(struct sock *);
+	int (*hash)(struct sock *);
+	void (*unhash)(struct sock *);
+	void (*rehash)(struct sock *);
+	int (*get_port)(struct sock *, short unsigned int);
+	void (*put_port)(struct sock *);
+	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
+	unsigned int inuse_idx;
+	int (*forward_alloc_get)(const struct sock *);
+	bool (*stream_memory_free)(const struct sock *, int);
+	bool (*sock_is_readable)(struct sock *);
+	void (*enter_memory_pressure)(struct sock *);
+	void (*leave_memory_pressure)(struct sock *);
+	atomic_long_t *memory_allocated;
+	int *per_cpu_fw_alloc;
+	struct percpu_counter *sockets_allocated;
+	long unsigned int *memory_pressure;
+	long int *sysctl_mem;
+	int *sysctl_wmem;
+	int *sysctl_rmem;
+	u32 sysctl_wmem_offset;
+	u32 sysctl_rmem_offset;
+	int max_header;
+	bool no_autobind;
+	struct kmem_cache *slab;
+	unsigned int obj_size;
+	unsigned int ipv6_pinfo_offset;
+	slab_flags_t slab_flags;
+	unsigned int useroffset;
+	unsigned int usersize;
+	unsigned int *orphan_count;
+	struct request_sock_ops *rsk_prot;
+	struct timewait_sock_ops *twsk_prot;
+	union {
+		struct inet_hashinfo *hashinfo;
+		struct udp_table *udp_table;
+		struct raw_hashinfo *raw_hash;
+		struct smc_hashinfo *smc_hash;
+	} h;
+	struct module *owner;
+	char name[32];
+	struct list_head node;
+	int (*diag_destroy)(struct sock *, int);
+};
+
+enum sk_rst_reason {
+	SK_RST_REASON_NOT_SPECIFIED = 0,
+	SK_RST_REASON_NO_SOCKET = 1,
+	SK_RST_REASON_TCP_INVALID_ACK_SEQUENCE = 2,
+	SK_RST_REASON_TCP_RFC7323_PAWS = 3,
+	SK_RST_REASON_TCP_TOO_OLD_ACK = 4,
+	SK_RST_REASON_TCP_ACK_UNSENT_DATA = 5,
+	SK_RST_REASON_TCP_FLAGS = 6,
+	SK_RST_REASON_TCP_OLD_ACK = 7,
+	SK_RST_REASON_TCP_ABORT_ON_DATA = 8,
+	SK_RST_REASON_TCP_TIMEWAIT_SOCKET = 9,
+	SK_RST_REASON_INVALID_SYN = 10,
+	SK_RST_REASON_TCP_ABORT_ON_CLOSE = 11,
+	SK_RST_REASON_TCP_ABORT_ON_LINGER = 12,
+	SK_RST_REASON_TCP_ABORT_ON_MEMORY = 13,
+	SK_RST_REASON_TCP_STATE = 14,
+	SK_RST_REASON_TCP_KEEPALIVE_TIMEOUT = 15,
+	SK_RST_REASON_TCP_DISCONNECT_WITH_DATA = 16,
+	SK_RST_REASON_MPTCP_RST_EUNSPEC = 17,
+	SK_RST_REASON_MPTCP_RST_EMPTCP = 18,
+	SK_RST_REASON_MPTCP_RST_ERESOURCE = 19,
+	SK_RST_REASON_MPTCP_RST_EPROHIBIT = 20,
+	SK_RST_REASON_MPTCP_RST_EWQ2BIG = 21,
+	SK_RST_REASON_MPTCP_RST_EBADPERF = 22,
+	SK_RST_REASON_MPTCP_RST_EMIDDLEBOX = 23,
+	SK_RST_REASON_ERROR = 24,
+	SK_RST_REASON_MAX = 25,
+};
+
+struct request_sock;
+
+struct request_sock_ops {
+	int family;
+	unsigned int obj_size;
+	struct kmem_cache *slab;
+	char *slab_name;
+	int (*rtx_syn_ack)(const struct sock *, struct request_sock *);
+	void (*send_ack)(const struct sock *, struct sk_buff *, struct request_sock *);
+	void (*send_reset)(const struct sock *, struct sk_buff *, enum sk_rst_reason);
+	void (*destructor)(struct request_sock *);
+	void (*syn_ack_timeout)(const struct request_sock *);
+};
+
+struct timewait_sock_ops {
+	struct kmem_cache *twsk_slab;
+	char *twsk_slab_name;
+	unsigned int twsk_obj_size;
+	void (*twsk_destructor)(struct sock *);
+};
+
+struct saved_syn;
+
+struct request_sock {
+	struct sock_common __req_common;
+	struct request_sock *dl_next;
+	u16 mss;
+	u8 num_retrans;
+	u8 syncookie: 1;
+	u8 num_timeout: 7;
+	u32 ts_recent;
+	struct timer_list rsk_timer;
+	const struct request_sock_ops *rsk_ops;
+	struct sock *sk;
+	struct saved_syn *saved_syn;
+	u32 secid;
+	u32 peer_secid;
+	u32 timeout;
+};
+
+struct saved_syn {
+	u32 mac_hdrlen;
+	u32 network_hdrlen;
+	u32 tcp_hdrlen;
+	u8 data[0];
+};
+
+enum tsq_enum {
+	TSQ_THROTTLED = 0,
+	TSQ_QUEUED = 1,
+	TCP_TSQ_DEFERRED = 2,
+	TCP_WRITE_TIMER_DEFERRED = 3,
+	TCP_DELACK_TIMER_DEFERRED = 4,
+	TCP_MTU_REDUCED_DEFERRED = 5,
+	TCP_ACK_DEFERRED = 6,
+};
+
+struct ip6_sf_list {
+	struct ip6_sf_list *sf_next;
+	struct in6_addr sf_addr;
+	long unsigned int sf_count[2];
+	unsigned char sf_gsresp;
+	unsigned char sf_oldin;
+	unsigned char sf_crcount;
+	struct callback_head rcu;
+};
+
+struct ifmcaddr6 {
+	struct in6_addr mca_addr;
+	struct inet6_dev *idev;
+	struct ifmcaddr6 *next;
+	struct ip6_sf_list *mca_sources;
+	struct ip6_sf_list *mca_tomb;
+	unsigned int mca_sfmode;
+	unsigned char mca_crcount;
+	long unsigned int mca_sfcount[2];
+	struct delayed_work mca_work;
+	unsigned int mca_flags;
+	int mca_users;
+	refcount_t mca_refcnt;
+	long unsigned int mca_cstamp;
+	long unsigned int mca_tstamp;
+	struct callback_head rcu;
+};
+
+struct ifacaddr6 {
+	struct in6_addr aca_addr;
+	struct fib6_info *aca_rt;
+	struct ifacaddr6 *aca_next;
+	struct hlist_node aca_addr_lst;
+	int aca_users;
+	refcount_t aca_refcnt;
+	long unsigned int aca_cstamp;
+	long unsigned int aca_tstamp;
+	struct callback_head rcu;
+};
+
+enum nfs_opnum4 {
+	OP_ACCESS = 3,
+	OP_CLOSE = 4,
+	OP_COMMIT = 5,
+	OP_CREATE = 6,
+	OP_DELEGPURGE = 7,
+	OP_DELEGRETURN = 8,
+	OP_GETATTR = 9,
+	OP_GETFH = 10,
+	OP_LINK = 11,
+	OP_LOCK = 12,
+	OP_LOCKT = 13,
+	OP_LOCKU = 14,
+	OP_LOOKUP = 15,
+	OP_LOOKUPP = 16,
+	OP_NVERIFY = 17,
+	OP_OPEN = 18,
+	OP_OPENATTR = 19,
+	OP_OPEN_CONFIRM = 20,
+	OP_OPEN_DOWNGRADE = 21,
+	OP_PUTFH = 22,
+	OP_PUTPUBFH = 23,
+	OP_PUTROOTFH = 24,
+	OP_READ = 25,
+	OP_READDIR = 26,
+	OP_READLINK = 27,
+	OP_REMOVE = 28,
+	OP_RENAME = 29,
+	OP_RENEW = 30,
+	OP_RESTOREFH = 31,
+	OP_SAVEFH = 32,
+	OP_SECINFO = 33,
+	OP_SETATTR = 34,
+	OP_SETCLIENTID = 35,
+	OP_SETCLIENTID_CONFIRM = 36,
+	OP_VERIFY = 37,
+	OP_WRITE = 38,
+	OP_RELEASE_LOCKOWNER = 39,
+	OP_BACKCHANNEL_CTL = 40,
+	OP_BIND_CONN_TO_SESSION = 41,
+	OP_EXCHANGE_ID = 42,
+	OP_CREATE_SESSION = 43,
+	OP_DESTROY_SESSION = 44,
+	OP_FREE_STATEID = 45,
+	OP_GET_DIR_DELEGATION = 46,
+	OP_GETDEVICEINFO = 47,
+	OP_GETDEVICELIST = 48,
+	OP_LAYOUTCOMMIT = 49,
+	OP_LAYOUTGET = 50,
+	OP_LAYOUTRETURN = 51,
+	OP_SECINFO_NO_NAME = 52,
+	OP_SEQUENCE = 53,
+	OP_SET_SSV = 54,
+	OP_TEST_STATEID = 55,
+	OP_WANT_DELEGATION = 56,
+	OP_DESTROY_CLIENTID = 57,
+	OP_RECLAIM_COMPLETE = 58,
+	OP_ALLOCATE = 59,
+	OP_COPY = 60,
+	OP_COPY_NOTIFY = 61,
+	OP_DEALLOCATE = 62,
+	OP_IO_ADVISE = 63,
+	OP_LAYOUTERROR = 64,
+	OP_LAYOUTSTATS = 65,
+	OP_OFFLOAD_CANCEL = 66,
+	OP_OFFLOAD_STATUS = 67,
+	OP_READ_PLUS = 68,
+	OP_SEEK = 69,
+	OP_WRITE_SAME = 70,
+	OP_CLONE = 71,
+	OP_GETXATTR = 72,
+	OP_SETXATTR = 73,
+	OP_LISTXATTRS = 74,
+	OP_REMOVEXATTR = 75,
+	OP_ILLEGAL = 10044,
+};
+
+struct linux_binprm {
+	struct vm_area_struct *vma;
+	long unsigned int vma_pages;
+	long unsigned int argmin;
+	struct mm_struct *mm;
+	long unsigned int p;
+	unsigned int have_execfd: 1;
+	unsigned int execfd_creds: 1;
+	unsigned int secureexec: 1;
+	unsigned int point_of_no_return: 1;
+	struct file *executable;
+	struct file *interpreter;
+	struct file *file;
+	struct cred *cred;
+	int unsafe;
+	unsigned int per_clear;
+	int argc;
+	int envc;
+	const char *filename;
+	const char *interp;
+	const char *fdpath;
+	unsigned int interp_flags;
+	int execfd;
+	long unsigned int loader;
+	long unsigned int exec;
+	struct rlimit rlim_stack;
+	char buf[256];
+};
+
+enum sysctl_writes_mode {
+	SYSCTL_WRITES_LEGACY = -1,
+	SYSCTL_WRITES_WARN = 0,
+	SYSCTL_WRITES_STRICT = 1,
+};
+
+struct do_proc_dointvec_minmax_conv_param {
+	int *min;
+	int *max;
+};
+
+struct do_proc_douintvec_minmax_conv_param {
+	unsigned int *min;
+	unsigned int *max;
+};
+
+typedef void (*rcu_callback_t)(struct callback_head *);
+
+struct __va_list {
+	void *__ap;
+};
+
+typedef struct __va_list va_list;
+
+enum refcount_saturation_type {
+	REFCOUNT_ADD_NOT_ZERO_OVF = 0,
+	REFCOUNT_ADD_OVF = 1,
+	REFCOUNT_ADD_UAF = 2,
+	REFCOUNT_SUB_UAF = 3,
+	REFCOUNT_DEC_LEAK = 4,
+};
+
+enum work_flags {
+	WORK_STRUCT_PENDING = 1,
+	WORK_STRUCT_INACTIVE = 2,
+	WORK_STRUCT_PWQ = 4,
+	WORK_STRUCT_LINKED = 8,
+	WORK_STRUCT_STATIC = 0,
+};
+
+enum wq_misc_consts {
+	WORK_NR_COLORS = 16,
+	WORK_CPU_UNBOUND = 2,
+	WORK_BUSY_PENDING = 1,
+	WORK_BUSY_RUNNING = 2,
+	WORKER_DESC_LEN = 32,
+};
+
+struct wq_flusher;
+
+struct worker;
+
+struct workqueue_attrs;
+
+struct pool_workqueue;
+
+struct wq_device;
+
+struct wq_node_nr_active;
+
+struct workqueue_struct {
+	struct list_head pwqs;
+	struct list_head list;
+	struct mutex mutex;
+	int work_color;
+	int flush_color;
+	atomic_t nr_pwqs_to_flush;
+	struct wq_flusher *first_flusher;
+	struct list_head flusher_queue;
+	struct list_head flusher_overflow;
+	struct list_head maydays;
+	struct worker *rescuer;
+	int nr_drainers;
+	int max_active;
+	int min_active;
+	int saved_max_active;
+	int saved_min_active;
+	struct workqueue_attrs *unbound_attrs;
+	struct pool_workqueue *dfl_pwq;
+	struct wq_device *wq_dev;
+	char name[32];
+	struct callback_head rcu;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	unsigned int flags;
+	struct pool_workqueue **cpu_pwq;
+	struct wq_node_nr_active *node_nr_active[0];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+enum wq_affn_scope {
+	WQ_AFFN_DFL = 0,
+	WQ_AFFN_CPU = 1,
+	WQ_AFFN_SMT = 2,
+	WQ_AFFN_CACHE = 3,
+	WQ_AFFN_NUMA = 4,
+	WQ_AFFN_SYSTEM = 5,
+	WQ_AFFN_NR_TYPES = 6,
+};
+
+struct workqueue_attrs {
+	int nice;
+	cpumask_var_t cpumask;
+	cpumask_var_t __pod_cpumask;
+	bool affn_strict;
+	enum wq_affn_scope affn_scope;
+	bool ordered;
+};
+
+struct execute_work {
+	struct work_struct work;
+};
+
+enum wq_flags {
+	WQ_BH = 1,
+	WQ_UNBOUND = 2,
+	WQ_FREEZABLE = 4,
+	WQ_MEM_RECLAIM = 8,
+	WQ_HIGHPRI = 16,
+	WQ_CPU_INTENSIVE = 32,
+	WQ_SYSFS = 64,
+	WQ_POWER_EFFICIENT = 128,
+	__WQ_DESTROYING = 32768,
+	__WQ_DRAINING = 65536,
+	__WQ_ORDERED = 131072,
+	__WQ_LEGACY = 262144,
+	__WQ_BH_ALLOWS = 17,
+};
+
+enum wq_consts {
+	WQ_MAX_ACTIVE = 512,
+	WQ_UNBOUND_MAX_ACTIVE = 512,
+	WQ_DFL_ACTIVE = 256,
+	WQ_DFL_MIN_ACTIVE = 8,
+};
+
+enum _slab_flag_bits {
+	_SLAB_CONSISTENCY_CHECKS = 0,
+	_SLAB_RED_ZONE = 1,
+	_SLAB_POISON = 2,
+	_SLAB_KMALLOC = 3,
+	_SLAB_HWCACHE_ALIGN = 4,
+	_SLAB_CACHE_DMA = 5,
+	_SLAB_CACHE_DMA32 = 6,
+	_SLAB_STORE_USER = 7,
+	_SLAB_PANIC = 8,
+	_SLAB_TYPESAFE_BY_RCU = 9,
+	_SLAB_TRACE = 10,
+	_SLAB_NOLEAKTRACE = 11,
+	_SLAB_NO_MERGE = 12,
+	_SLAB_ACCOUNT = 13,
+	_SLAB_NO_USER_FLAGS = 14,
+	_SLAB_RECLAIM_ACCOUNT = 15,
+	_SLAB_OBJECT_POISON = 16,
+	_SLAB_CMPXCHG_DOUBLE = 17,
+	_SLAB_NO_OBJ_EXT = 18,
+	_SLAB_FLAGS_LAST_BIT = 19,
+};
+
+struct kmem_cache_args {
+	unsigned int align;
+	unsigned int useroffset;
+	unsigned int usersize;
+	unsigned int freeptr_offset;
+	bool use_freeptr_offset;
+	void (*ctor)(void *);
+};
+
+typedef unsigned int xa_mark_t;
+
+enum xa_lock_type {
+	XA_LOCK_IRQ = 1,
+	XA_LOCK_BH = 2,
+};
+
+struct ida {
+	struct xarray xa;
+};
+
+enum kobject_action {
+	KOBJ_ADD = 0,
+	KOBJ_REMOVE = 1,
+	KOBJ_CHANGE = 2,
+	KOBJ_MOVE = 3,
+	KOBJ_ONLINE = 4,
+	KOBJ_OFFLINE = 5,
+	KOBJ_BIND = 6,
+	KOBJ_UNBIND = 7,
+};
+
+struct device_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct device *, struct device_attribute *, char *);
+	ssize_t (*store)(struct device *, struct device_attribute *, const char *, size_t);
+};
+
+struct kthread_work;
+
+typedef void (*kthread_work_func_t)(struct kthread_work *);
+
+struct kthread_worker;
+
+struct kthread_work {
+	struct list_head node;
+	kthread_work_func_t func;
+	struct kthread_worker *worker;
+	int canceling;
+};
+
+struct kthread_worker {
+	unsigned int flags;
+	raw_spinlock_t lock;
+	struct list_head work_list;
+	struct list_head delayed_work_list;
+	struct task_struct *task;
+	struct kthread_work *current_work;
+};
+
+struct __una_u32 {
+	u32 x;
+};
+
+enum hk_type {
+	HK_TYPE_TIMER = 0,
+	HK_TYPE_RCU = 1,
+	HK_TYPE_MISC = 2,
+	HK_TYPE_SCHED = 3,
+	HK_TYPE_TICK = 4,
+	HK_TYPE_DOMAIN = 5,
+	HK_TYPE_WQ = 6,
+	HK_TYPE_MANAGED_IRQ = 7,
+	HK_TYPE_KTHREAD = 8,
+	HK_TYPE_MAX = 9,
+};
+
+struct worker_pool;
+
+struct worker {
+	union {
+		struct list_head entry;
+		struct hlist_node hentry;
+	};
+	struct work_struct *current_work;
+	work_func_t current_func;
+	struct pool_workqueue *current_pwq;
+	long: 32;
+	u64 current_at;
+	unsigned int current_color;
+	int sleeping;
+	work_func_t last_func;
+	struct list_head scheduled;
+	struct task_struct *task;
+	struct worker_pool *pool;
+	struct list_head node;
+	long unsigned int last_active;
+	unsigned int flags;
+	int id;
+	char desc[32];
+	struct workqueue_struct *rescue_wq;
+	long: 32;
+};
+
+struct pool_workqueue {
+	struct worker_pool *pool;
+	struct workqueue_struct *wq;
+	int work_color;
+	int flush_color;
+	int refcnt;
+	int nr_in_flight[16];
+	bool plugged;
+	int nr_active;
+	struct list_head inactive_works;
+	struct list_head pending_node;
+	struct list_head pwqs_node;
+	struct list_head mayday_node;
+	long: 32;
+	u64 stats[8];
+	struct kthread_work release_work;
+	struct callback_head rcu;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct worker_pool {
+	raw_spinlock_t lock;
+	int cpu;
+	int node;
+	int id;
+	unsigned int flags;
+	long unsigned int watchdog_ts;
+	bool cpu_stall;
+	int nr_running;
+	struct list_head worklist;
+	int nr_workers;
+	int nr_idle;
+	struct list_head idle_list;
+	struct timer_list idle_timer;
+	struct work_struct idle_cull_work;
+	struct timer_list mayday_timer;
+	struct hlist_head busy_hash[64];
+	struct worker *manager;
+	struct list_head workers;
+	struct ida worker_ida;
+	struct workqueue_attrs *attrs;
+	struct hlist_node hash_node;
+	int refcnt;
+	struct callback_head rcu;
+};
+
+enum worker_pool_flags {
+	POOL_BH = 1,
+	POOL_MANAGER_ACTIVE = 2,
+	POOL_DISASSOCIATED = 4,
+	POOL_BH_DRAINING = 8,
+};
+
+enum worker_flags {
+	WORKER_DIE = 2,
+	WORKER_IDLE = 4,
+	WORKER_PREP = 8,
+	WORKER_CPU_INTENSIVE = 64,
+	WORKER_UNBOUND = 128,
+	WORKER_REBOUND = 256,
+	WORKER_NOT_RUNNING = 456,
+};
+
+enum work_cancel_flags {
+	WORK_CANCEL_DELAYED = 1,
+	WORK_CANCEL_DISABLE = 2,
+};
+
+enum wq_internal_consts {
+	NR_STD_WORKER_POOLS = 2,
+	UNBOUND_POOL_HASH_ORDER = 6,
+	BUSY_WORKER_HASH_ORDER = 6,
+	MAX_IDLE_WORKERS_RATIO = 4,
+	IDLE_WORKER_TIMEOUT = 30000,
+	MAYDAY_INITIAL_TIMEOUT = 2,
+	MAYDAY_INTERVAL = 10,
+	CREATE_COOLDOWN = 100,
+	RESCUER_NICE_LEVEL = -20,
+	HIGHPRI_NICE_LEVEL = -20,
+	WQ_NAME_LEN = 32,
+	WORKER_ID_LEN = 42,
+};
+
+enum pool_workqueue_stats {
+	PWQ_STAT_STARTED = 0,
+	PWQ_STAT_COMPLETED = 1,
+	PWQ_STAT_CPU_TIME = 2,
+	PWQ_STAT_CPU_INTENSIVE = 3,
+	PWQ_STAT_CM_WAKEUP = 4,
+	PWQ_STAT_REPATRIATED = 5,
+	PWQ_STAT_MAYDAY = 6,
+	PWQ_STAT_RESCUED = 7,
+	PWQ_NR_STATS = 8,
+};
+
+struct wq_flusher {
+	struct list_head list;
+	int flush_color;
+	struct completion done;
+};
+
+struct wq_node_nr_active {
+	int max;
+	atomic_t nr;
+	raw_spinlock_t lock;
+	struct list_head pending_pwqs;
+};
+
+struct wq_device {
+	struct workqueue_struct *wq;
+	long: 32;
+	struct device dev;
+};
+
+struct wq_pod_type {
+	int nr_pods;
+	cpumask_var_t *pod_cpus;
+	int *pod_node;
+	int *cpu_pod;
+};
+
+struct work_offq_data {
+	u32 pool_id;
+	u32 disable;
+	u32 flags;
+};
+
+struct trace_event_raw_workqueue_queue_work {
+	struct trace_entry ent;
+	void *work;
+	void *function;
+	u32 __data_loc_workqueue;
+	int req_cpu;
+	int cpu;
+	char __data[0];
+};
+
+struct trace_event_raw_workqueue_activate_work {
+	struct trace_entry ent;
+	void *work;
+	void *function;
+	char __data[0];
+};
+
+struct trace_event_raw_workqueue_execute_start {
+	struct trace_entry ent;
+	void *work;
+	void *function;
+	char __data[0];
+};
+
+struct trace_event_raw_workqueue_execute_end {
+	struct trace_entry ent;
+	void *work;
+	void *function;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_workqueue_queue_work {
+	u32 workqueue;
+	const void *workqueue_ptr_;
+};
+
+struct trace_event_data_offsets_workqueue_activate_work {};
+
+struct trace_event_data_offsets_workqueue_execute_start {};
+
+struct trace_event_data_offsets_workqueue_execute_end {};
+
+typedef void (*btf_trace_workqueue_queue_work)(void *, int, struct pool_workqueue *, struct work_struct *);
+
+typedef void (*btf_trace_workqueue_activate_work)(void *, struct work_struct *);
+
+typedef void (*btf_trace_workqueue_execute_start)(void *, struct work_struct *);
+
+typedef void (*btf_trace_workqueue_execute_end)(void *, struct work_struct *, work_func_t);
+
+struct wq_drain_dead_softirq_work {
+	struct work_struct work;
+	struct worker_pool *pool;
+	struct completion done;
+};
+
+struct wq_barrier {
+	struct work_struct work;
+	struct completion done;
+	struct task_struct *task;
+};
+
+struct apply_wqattrs_ctx {
+	struct workqueue_struct *wq;
+	struct workqueue_attrs *attrs;
+	struct list_head list;
+	struct pool_workqueue *dfl_pwq;
+	struct pool_workqueue *pwq_tbl[0];
+};
+
+struct pr_cont_work_struct {
+	bool comma;
+	work_func_t func;
+	long int ctr;
+};
+
+struct work_for_cpu {
+	struct work_struct work;
+	long int (*fn)(void *);
+	void *arg;
+	long int ret;
+};
+
+enum rlimit_type {
+	UCOUNT_RLIMIT_NPROC = 0,
+	UCOUNT_RLIMIT_MSGQUEUE = 1,
+	UCOUNT_RLIMIT_SIGPENDING = 2,
+	UCOUNT_RLIMIT_MEMLOCK = 3,
+	UCOUNT_RLIMIT_COUNTS = 4,
+};
+
+enum proc_cn_event {
+	PROC_EVENT_NONE = 0,
+	PROC_EVENT_FORK = 1,
+	PROC_EVENT_EXEC = 2,
+	PROC_EVENT_UID = 4,
+	PROC_EVENT_GID = 64,
+	PROC_EVENT_SID = 128,
+	PROC_EVENT_PTRACE = 256,
+	PROC_EVENT_COMM = 512,
+	PROC_EVENT_NONZERO_EXIT = 536870912,
+	PROC_EVENT_COREDUMP = 1073741824,
+	PROC_EVENT_EXIT = 2147483648,
+};
+
+enum ucount_type {
+	UCOUNT_USER_NAMESPACES = 0,
+	UCOUNT_PID_NAMESPACES = 1,
+	UCOUNT_UTS_NAMESPACES = 2,
+	UCOUNT_IPC_NAMESPACES = 3,
+	UCOUNT_NET_NAMESPACES = 4,
+	UCOUNT_MNT_NAMESPACES = 5,
+	UCOUNT_CGROUP_NAMESPACES = 6,
+	UCOUNT_TIME_NAMESPACES = 7,
+	UCOUNT_INOTIFY_INSTANCES = 8,
+	UCOUNT_INOTIFY_WATCHES = 9,
+	UCOUNT_FANOTIFY_GROUPS = 10,
+	UCOUNT_FANOTIFY_MARKS = 11,
+	UCOUNT_COUNTS = 12,
+};
+
+typedef u64 uint64_t;
+
+struct pin_cookie {};
+
+typedef struct {
+	void *lock;
+} class_preempt_t;
+
+enum {
+	CSD_FLAG_LOCK = 1,
+	IRQ_WORK_PENDING = 1,
+	IRQ_WORK_BUSY = 2,
+	IRQ_WORK_LAZY = 4,
+	IRQ_WORK_HARD_IRQ = 8,
+	IRQ_WORK_CLAIMED = 3,
+	CSD_TYPE_ASYNC = 0,
+	CSD_TYPE_SYNC = 16,
+	CSD_TYPE_IRQ_WORK = 32,
+	CSD_TYPE_TTWU = 48,
+	CSD_FLAG_TYPE_MASK = 240,
+};
+
+typedef void (*smp_call_func_t)(void *);
+
+struct __call_single_data {
+	struct __call_single_node node;
+	smp_call_func_t func;
+	void *info;
+};
+
+typedef struct __call_single_data call_single_data_t;
+
+typedef int (*task_call_f)(struct task_struct *, void *);
+
+typedef struct mutex *class_mutex_t;
+
+struct static_key_true {
+	struct static_key key;
+};
+
+struct static_key_false {
+	struct static_key key;
+};
+
+typedef struct {
+	void *lock;
+} class_rcu_t;
+
+struct dl_bw {
+	raw_spinlock_t lock;
+	long: 32;
+	u64 bw;
+	u64 total_bw;
+};
+
+struct cpudl_item;
+
+struct cpudl {
+	raw_spinlock_t lock;
+	int size;
+	cpumask_var_t free_cpus;
+	struct cpudl_item *elements;
+};
+
+struct cpupri_vec {
+	atomic_t count;
+	cpumask_var_t mask;
+};
+
+struct cpupri {
+	struct cpupri_vec pri_to_cpu[101];
+	int *cpu_to_pri;
+};
+
+struct perf_domain;
+
+struct root_domain {
+	atomic_t refcount;
+	atomic_t rto_count;
+	struct callback_head rcu;
+	cpumask_var_t span;
+	cpumask_var_t online;
+	bool overloaded;
+	bool overutilized;
+	cpumask_var_t dlo_mask;
+	atomic_t dlo_count;
+	long: 32;
+	struct dl_bw dl_bw;
+	struct cpudl cpudl;
+	u64 visit_gen;
+	struct irq_work rto_push_work;
+	raw_spinlock_t rto_lock;
+	int rto_loop;
+	int rto_cpu;
+	atomic_t rto_loop_next;
+	atomic_t rto_loop_start;
+	cpumask_var_t rto_mask;
+	struct cpupri cpupri;
+	struct perf_domain *pd;
+};
+
+struct sched_param {
+	int sched_priority;
+};
+
+struct cfs_rq {
+	struct load_weight load;
+	unsigned int nr_running;
+	unsigned int h_nr_running;
+	unsigned int idle_nr_running;
+	unsigned int idle_h_nr_running;
+	s64 avg_vruntime;
+	u64 avg_load;
+	u64 min_vruntime;
+	struct rb_root_cached tasks_timeline;
+	struct sched_entity *curr;
+	struct sched_entity *next;
+	struct sched_avg avg;
+	u64 last_update_time_copy;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct {
+		raw_spinlock_t lock;
+		int nr;
+		long unsigned int load_avg;
+		long unsigned int util_avg;
+		long unsigned int runnable_avg;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+	} removed;
+	u64 last_update_tg_load_avg;
+	long unsigned int tg_load_avg_contrib;
+	long int propagate;
+	long int prop_runnable_sum;
+	long unsigned int h_load;
+	u64 last_h_load_update;
+	struct sched_entity *h_load_next;
+	struct rq *rq;
+	int on_list;
+	struct list_head leaf_cfs_rq_list;
+	struct task_group *tg;
+	int idle;
+	int runtime_enabled;
+	s64 runtime_remaining;
+	u64 throttled_pelt_idle;
+	u64 throttled_pelt_idle_copy;
+	u64 throttled_clock;
+	u64 throttled_clock_pelt;
+	u64 throttled_clock_pelt_time;
+	u64 throttled_clock_self;
+	u64 throttled_clock_self_time;
+	int throttled;
+	int throttle_count;
+	struct list_head throttled_list;
+	struct list_head throttled_csd_list;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct rt_prio_array {
+	long unsigned int bitmap[4];
+	struct list_head queue[100];
+};
+
+struct rt_rq {
+	struct rt_prio_array active;
+	unsigned int rt_nr_running;
+	unsigned int rr_nr_running;
+	struct {
+		int curr;
+		int next;
+	} highest_prio;
+	bool overloaded;
+	struct plist_head pushable_tasks;
+	int rt_queued;
+	int rt_throttled;
+	long: 32;
+	u64 rt_time;
+	u64 rt_runtime;
+	raw_spinlock_t rt_runtime_lock;
+	unsigned int rt_nr_boosted;
+	struct rq *rq;
+	struct task_group *tg;
+};
+
+struct dl_rq {
+	struct rb_root_cached root;
+	unsigned int dl_nr_running;
+	long: 32;
+	struct {
+		u64 curr;
+		u64 next;
+	} earliest_dl;
+	bool overloaded;
+	struct rb_root_cached pushable_dl_tasks_root;
+	long: 32;
+	u64 running_bw;
+	u64 this_bw;
+	u64 extra_bw;
+	u64 max_bw;
+	u64 bw_ratio;
+};
+
+struct cpu_stop_done;
+
+struct cpu_stop_work {
+	struct list_head list;
+	cpu_stop_fn_t fn;
+	long unsigned int caller;
+	void *arg;
+	struct cpu_stop_done *done;
+};
+
+struct sched_domain;
+
+struct balance_callback;
+
+struct rq {
+	raw_spinlock_t __lock;
+	unsigned int nr_running;
+	unsigned int ttwu_pending;
+	long: 32;
+	u64 nr_switches;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct cfs_rq cfs;
+	struct rt_rq rt;
+	struct dl_rq dl;
+	struct sched_dl_entity fair_server;
+	struct list_head leaf_cfs_rq_list;
+	struct list_head *tmp_alone_branch;
+	unsigned int nr_uninterruptible;
+	struct task_struct *curr;
+	struct sched_dl_entity *dl_server;
+	struct task_struct *idle;
+	struct task_struct *stop;
+	long unsigned int next_balance;
+	struct mm_struct *prev_mm;
+	unsigned int clock_update_flags;
+	long: 32;
+	u64 clock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	u64 clock_task;
+	u64 clock_pelt;
+	long unsigned int lost_idle_time;
+	long: 32;
+	u64 clock_pelt_idle;
+	u64 clock_idle;
+	u64 clock_pelt_idle_copy;
+	u64 clock_idle_copy;
+	atomic_t nr_iowait;
+	int membarrier_state;
+	struct root_domain *rd;
+	struct sched_domain *sd;
+	long unsigned int cpu_capacity;
+	struct balance_callback *balance_callback;
+	unsigned char nohz_idle_balance;
+	unsigned char idle_balance;
+	long unsigned int misfit_task_load;
+	int active_balance;
+	int push_cpu;
+	struct cpu_stop_work active_balance_work;
+	int cpu;
+	int online;
+	struct list_head cfs_tasks;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct sched_avg avg_rt;
+	struct sched_avg avg_dl;
+	u64 idle_stamp;
+	u64 avg_idle;
+	u64 max_idle_balance_cost;
+	long unsigned int calc_load_update;
+	long int calc_load_active;
+	call_single_data_t hrtick_csd;
+	struct hrtimer hrtick_timer;
+	ktime_t hrtick_time;
+	unsigned int nr_pinned;
+	unsigned int push_busy;
+	struct cpu_stop_work push_work;
+	cpumask_var_t scratch_mask;
+	long: 32;
+	call_single_data_t cfsb_csd;
+	struct list_head cfsb_csd_list;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct rt_bandwidth {
+	raw_spinlock_t rt_runtime_lock;
+	long: 32;
+	ktime_t rt_period;
+	u64 rt_runtime;
+	struct hrtimer rt_period_timer;
+	unsigned int rt_period_active;
+	long: 32;
+};
+
+struct cfs_bandwidth {
+	raw_spinlock_t lock;
+	long: 32;
+	ktime_t period;
+	u64 quota;
+	u64 runtime;
+	u64 burst;
+	u64 runtime_snap;
+	s64 hierarchical_quota;
+	u8 idle;
+	u8 period_active;
+	u8 slack_started;
+	long: 32;
+	struct hrtimer period_timer;
+	struct hrtimer slack_timer;
+	struct list_head throttled_cfs_rq;
+	int nr_periods;
+	int nr_throttled;
+	int nr_burst;
+	long: 32;
+	u64 throttled_time;
+	u64 burst_time;
+};
+
+struct task_group {
+	struct cgroup_subsys_state css;
+	int idle;
+	struct sched_entity **se;
+	struct cfs_rq **cfs_rq;
+	long unsigned int shares;
+	atomic_long_t load_avg;
+	struct sched_rt_entity **rt_se;
+	struct rt_rq **rt_rq;
+	long: 32;
+	struct rt_bandwidth rt_bandwidth;
+	struct callback_head rcu;
+	struct list_head list;
+	struct task_group *parent;
+	struct list_head siblings;
+	struct list_head children;
+	long: 32;
+	struct cfs_bandwidth cfs_bandwidth;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct wait_bit_key {
+	void *flags;
+	int bit_nr;
+	long unsigned int timeout;
+};
+
+struct wait_bit_queue_entry {
+	struct wait_bit_key key;
+	struct wait_queue_entry wq_entry;
+};
+
+enum {
+	MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY = 1,
+	MEMBARRIER_STATE_PRIVATE_EXPEDITED = 2,
+	MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY = 4,
+	MEMBARRIER_STATE_GLOBAL_EXPEDITED = 8,
+	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY = 16,
+	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE = 32,
+	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY = 64,
+	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ = 128,
+};
+
+struct kernel_clone_args {
+	u64 flags;
+	int *pidfd;
+	int *child_tid;
+	int *parent_tid;
+	const char *name;
+	int exit_signal;
+	u32 kthread: 1;
+	u32 io_thread: 1;
+	u32 user_worker: 1;
+	u32 no_files: 1;
+	long unsigned int stack;
+	long unsigned int stack_size;
+	long unsigned int tls;
+	pid_t *set_tid;
+	size_t set_tid_size;
+	int cgroup;
+	int idle;
+	int (*fn)(void *);
+	void *fn_arg;
+	struct cgroup *cgrp;
+	struct css_set *cset;
+	long: 32;
+};
+
+enum hrtimer_mode {
+	HRTIMER_MODE_ABS = 0,
+	HRTIMER_MODE_REL = 1,
+	HRTIMER_MODE_PINNED = 2,
+	HRTIMER_MODE_SOFT = 4,
+	HRTIMER_MODE_HARD = 8,
+	HRTIMER_MODE_ABS_PINNED = 2,
+	HRTIMER_MODE_REL_PINNED = 3,
+	HRTIMER_MODE_ABS_SOFT = 4,
+	HRTIMER_MODE_REL_SOFT = 5,
+	HRTIMER_MODE_ABS_PINNED_SOFT = 6,
+	HRTIMER_MODE_REL_PINNED_SOFT = 7,
+	HRTIMER_MODE_ABS_HARD = 8,
+	HRTIMER_MODE_REL_HARD = 9,
+	HRTIMER_MODE_ABS_PINNED_HARD = 10,
+	HRTIMER_MODE_REL_PINNED_HARD = 11,
+};
+
+struct trace_print_flags {
+	long unsigned int mask;
+	const char *name;
+};
+
+enum ctx_state {
+	CT_STATE_DISABLED = -1,
+	CT_STATE_KERNEL = 0,
+	CT_STATE_IDLE = 1,
+	CT_STATE_USER = 2,
+	CT_STATE_GUEST = 3,
+	CT_STATE_MAX = 4,
+};
+
+struct sched_domain_attr {
+	int relax_domain_level;
+};
+
+struct sched_domain_shared {
+	atomic_t ref;
+	atomic_t nr_busy_cpus;
+	int has_idle_cores;
+	int nr_idle_scan;
+};
+
+struct sched_group;
+
+struct sched_domain {
+	struct sched_domain *parent;
+	struct sched_domain *child;
+	struct sched_group *groups;
+	long unsigned int min_interval;
+	long unsigned int max_interval;
+	unsigned int busy_factor;
+	unsigned int imbalance_pct;
+	unsigned int cache_nice_tries;
+	unsigned int imb_numa_nr;
+	int nohz_idle;
+	int flags;
+	int level;
+	long unsigned int last_balance;
+	unsigned int balance_interval;
+	unsigned int nr_balance_failed;
+	long: 32;
+	u64 max_newidle_lb_cost;
+	long unsigned int last_decay_max_lb_cost;
+	union {
+		void *private;
+		struct callback_head rcu;
+	};
+	struct sched_domain_shared *shared;
+	unsigned int span_weight;
+	long unsigned int span[0];
+	long: 32;
+};
+
+struct sched_group_capacity;
+
+struct sched_group {
+	struct sched_group *next;
+	atomic_t ref;
+	unsigned int group_weight;
+	unsigned int cores;
+	struct sched_group_capacity *sgc;
+	int asym_prefer_cpu;
+	int flags;
+	long unsigned int cpumask[0];
+};
+
+struct sched_group_capacity {
+	atomic_t ref;
+	long unsigned int capacity;
+	long unsigned int min_capacity;
+	long unsigned int max_capacity;
+	long unsigned int next_update;
+	int imbalance;
+	long unsigned int cpumask[0];
+};
+
+struct em_perf_state {
+	long unsigned int performance;
+	long unsigned int frequency;
+	long unsigned int power;
+	long unsigned int cost;
+	long unsigned int flags;
+};
+
+struct em_perf_table {
+	struct callback_head rcu;
+	struct kref kref;
+	struct em_perf_state state[0];
+};
+
+struct em_perf_domain {
+	struct em_perf_table *em_table;
+	int nr_perf_states;
+	long unsigned int flags;
+	long unsigned int cpus[0];
+};
+
+typedef struct {
+	void *lock;
+} class_cpus_read_lock_t;
+
+struct kernel_cpustat {
+	u64 cpustat[10];
+};
+
+struct kernel_stat {
+	long unsigned int irqs_sum;
+	unsigned int softirqs[10];
+};
+
+enum cgroup_subsys_id {
+	cpuset_cgrp_id = 0,
+	cpu_cgrp_id = 1,
+	cpuacct_cgrp_id = 2,
+	io_cgrp_id = 3,
+	memory_cgrp_id = 4,
+	net_cls_cgrp_id = 5,
+	pids_cgrp_id = 6,
+	rdma_cgrp_id = 7,
+	CGROUP_SUBSYS_COUNT = 8,
+};
+
+enum {
+	CFTYPE_ONLY_ON_ROOT = 1,
+	CFTYPE_NOT_ON_ROOT = 2,
+	CFTYPE_NS_DELEGATABLE = 4,
+	CFTYPE_NO_PREFIX = 8,
+	CFTYPE_WORLD_WRITABLE = 16,
+	CFTYPE_DEBUG = 32,
+	__CFTYPE_ONLY_ON_DFL = 65536,
+	__CFTYPE_NOT_ON_DFL = 131072,
+	__CFTYPE_ADDED = 262144,
+};
+
+enum {
+	IPSTATS_MIB_NUM = 0,
+	IPSTATS_MIB_INPKTS = 1,
+	IPSTATS_MIB_INOCTETS = 2,
+	IPSTATS_MIB_INDELIVERS = 3,
+	IPSTATS_MIB_OUTFORWDATAGRAMS = 4,
+	IPSTATS_MIB_OUTREQUESTS = 5,
+	IPSTATS_MIB_OUTOCTETS = 6,
+	IPSTATS_MIB_INHDRERRORS = 7,
+	IPSTATS_MIB_INTOOBIGERRORS = 8,
+	IPSTATS_MIB_INNOROUTES = 9,
+	IPSTATS_MIB_INADDRERRORS = 10,
+	IPSTATS_MIB_INUNKNOWNPROTOS = 11,
+	IPSTATS_MIB_INTRUNCATEDPKTS = 12,
+	IPSTATS_MIB_INDISCARDS = 13,
+	IPSTATS_MIB_OUTDISCARDS = 14,
+	IPSTATS_MIB_OUTNOROUTES = 15,
+	IPSTATS_MIB_REASMTIMEOUT = 16,
+	IPSTATS_MIB_REASMREQDS = 17,
+	IPSTATS_MIB_REASMOKS = 18,
+	IPSTATS_MIB_REASMFAILS = 19,
+	IPSTATS_MIB_FRAGOKS = 20,
+	IPSTATS_MIB_FRAGFAILS = 21,
+	IPSTATS_MIB_FRAGCREATES = 22,
+	IPSTATS_MIB_INMCASTPKTS = 23,
+	IPSTATS_MIB_OUTMCASTPKTS = 24,
+	IPSTATS_MIB_INBCASTPKTS = 25,
+	IPSTATS_MIB_OUTBCASTPKTS = 26,
+	IPSTATS_MIB_INMCASTOCTETS = 27,
+	IPSTATS_MIB_OUTMCASTOCTETS = 28,
+	IPSTATS_MIB_INBCASTOCTETS = 29,
+	IPSTATS_MIB_OUTBCASTOCTETS = 30,
+	IPSTATS_MIB_CSUMERRORS = 31,
+	IPSTATS_MIB_NOECTPKTS = 32,
+	IPSTATS_MIB_ECT1PKTS = 33,
+	IPSTATS_MIB_ECT0PKTS = 34,
+	IPSTATS_MIB_CEPKTS = 35,
+	IPSTATS_MIB_REASM_OVERLAPS = 36,
+	IPSTATS_MIB_OUTPKTS = 37,
+	__IPSTATS_MIB_MAX = 38,
+};
+
+enum {
+	ICMP_MIB_NUM = 0,
+	ICMP_MIB_INMSGS = 1,
+	ICMP_MIB_INERRORS = 2,
+	ICMP_MIB_INDESTUNREACHS = 3,
+	ICMP_MIB_INTIMEEXCDS = 4,
+	ICMP_MIB_INPARMPROBS = 5,
+	ICMP_MIB_INSRCQUENCHS = 6,
+	ICMP_MIB_INREDIRECTS = 7,
+	ICMP_MIB_INECHOS = 8,
+	ICMP_MIB_INECHOREPS = 9,
+	ICMP_MIB_INTIMESTAMPS = 10,
+	ICMP_MIB_INTIMESTAMPREPS = 11,
+	ICMP_MIB_INADDRMASKS = 12,
+	ICMP_MIB_INADDRMASKREPS = 13,
+	ICMP_MIB_OUTMSGS = 14,
+	ICMP_MIB_OUTERRORS = 15,
+	ICMP_MIB_OUTDESTUNREACHS = 16,
+	ICMP_MIB_OUTTIMEEXCDS = 17,
+	ICMP_MIB_OUTPARMPROBS = 18,
+	ICMP_MIB_OUTSRCQUENCHS = 19,
+	ICMP_MIB_OUTREDIRECTS = 20,
+	ICMP_MIB_OUTECHOS = 21,
+	ICMP_MIB_OUTECHOREPS = 22,
+	ICMP_MIB_OUTTIMESTAMPS = 23,
+	ICMP_MIB_OUTTIMESTAMPREPS = 24,
+	ICMP_MIB_OUTADDRMASKS = 25,
+	ICMP_MIB_OUTADDRMASKREPS = 26,
+	ICMP_MIB_CSUMERRORS = 27,
+	ICMP_MIB_RATELIMITGLOBAL = 28,
+	ICMP_MIB_RATELIMITHOST = 29,
+	__ICMP_MIB_MAX = 30,
+};
+
+enum {
+	ICMP6_MIB_NUM = 0,
+	ICMP6_MIB_INMSGS = 1,
+	ICMP6_MIB_INERRORS = 2,
+	ICMP6_MIB_OUTMSGS = 3,
+	ICMP6_MIB_OUTERRORS = 4,
+	ICMP6_MIB_CSUMERRORS = 5,
+	ICMP6_MIB_RATELIMITHOST = 6,
+	__ICMP6_MIB_MAX = 7,
+};
+
+enum {
+	TCP_MIB_NUM = 0,
+	TCP_MIB_RTOALGORITHM = 1,
+	TCP_MIB_RTOMIN = 2,
+	TCP_MIB_RTOMAX = 3,
+	TCP_MIB_MAXCONN = 4,
+	TCP_MIB_ACTIVEOPENS = 5,
+	TCP_MIB_PASSIVEOPENS = 6,
+	TCP_MIB_ATTEMPTFAILS = 7,
+	TCP_MIB_ESTABRESETS = 8,
+	TCP_MIB_CURRESTAB = 9,
+	TCP_MIB_INSEGS = 10,
+	TCP_MIB_OUTSEGS = 11,
+	TCP_MIB_RETRANSSEGS = 12,
+	TCP_MIB_INERRS = 13,
+	TCP_MIB_OUTRSTS = 14,
+	TCP_MIB_CSUMERRORS = 15,
+	__TCP_MIB_MAX = 16,
+};
+
+enum {
+	UDP_MIB_NUM = 0,
+	UDP_MIB_INDATAGRAMS = 1,
+	UDP_MIB_NOPORTS = 2,
+	UDP_MIB_INERRORS = 3,
+	UDP_MIB_OUTDATAGRAMS = 4,
+	UDP_MIB_RCVBUFERRORS = 5,
+	UDP_MIB_SNDBUFERRORS = 6,
+	UDP_MIB_CSUMERRORS = 7,
+	UDP_MIB_IGNOREDMULTI = 8,
+	UDP_MIB_MEMERRORS = 9,
+	__UDP_MIB_MAX = 10,
+};
+
+enum {
+	LINUX_MIB_NUM = 0,
+	LINUX_MIB_SYNCOOKIESSENT = 1,
+	LINUX_MIB_SYNCOOKIESRECV = 2,
+	LINUX_MIB_SYNCOOKIESFAILED = 3,
+	LINUX_MIB_EMBRYONICRSTS = 4,
+	LINUX_MIB_PRUNECALLED = 5,
+	LINUX_MIB_RCVPRUNED = 6,
+	LINUX_MIB_OFOPRUNED = 7,
+	LINUX_MIB_OUTOFWINDOWICMPS = 8,
+	LINUX_MIB_LOCKDROPPEDICMPS = 9,
+	LINUX_MIB_ARPFILTER = 10,
+	LINUX_MIB_TIMEWAITED = 11,
+	LINUX_MIB_TIMEWAITRECYCLED = 12,
+	LINUX_MIB_TIMEWAITKILLED = 13,
+	LINUX_MIB_PAWSACTIVEREJECTED = 14,
+	LINUX_MIB_PAWSESTABREJECTED = 15,
+	LINUX_MIB_DELAYEDACKS = 16,
+	LINUX_MIB_DELAYEDACKLOCKED = 17,
+	LINUX_MIB_DELAYEDACKLOST = 18,
+	LINUX_MIB_LISTENOVERFLOWS = 19,
+	LINUX_MIB_LISTENDROPS = 20,
+	LINUX_MIB_TCPHPHITS = 21,
+	LINUX_MIB_TCPPUREACKS = 22,
+	LINUX_MIB_TCPHPACKS = 23,
+	LINUX_MIB_TCPRENORECOVERY = 24,
+	LINUX_MIB_TCPSACKRECOVERY = 25,
+	LINUX_MIB_TCPSACKRENEGING = 26,
+	LINUX_MIB_TCPSACKREORDER = 27,
+	LINUX_MIB_TCPRENOREORDER = 28,
+	LINUX_MIB_TCPTSREORDER = 29,
+	LINUX_MIB_TCPFULLUNDO = 30,
+	LINUX_MIB_TCPPARTIALUNDO = 31,
+	LINUX_MIB_TCPDSACKUNDO = 32,
+	LINUX_MIB_TCPLOSSUNDO = 33,
+	LINUX_MIB_TCPLOSTRETRANSMIT = 34,
+	LINUX_MIB_TCPRENOFAILURES = 35,
+	LINUX_MIB_TCPSACKFAILURES = 36,
+	LINUX_MIB_TCPLOSSFAILURES = 37,
+	LINUX_MIB_TCPFASTRETRANS = 38,
+	LINUX_MIB_TCPSLOWSTARTRETRANS = 39,
+	LINUX_MIB_TCPTIMEOUTS = 40,
+	LINUX_MIB_TCPLOSSPROBES = 41,
+	LINUX_MIB_TCPLOSSPROBERECOVERY = 42,
+	LINUX_MIB_TCPRENORECOVERYFAIL = 43,
+	LINUX_MIB_TCPSACKRECOVERYFAIL = 44,
+	LINUX_MIB_TCPRCVCOLLAPSED = 45,
+	LINUX_MIB_TCPDSACKOLDSENT = 46,
+	LINUX_MIB_TCPDSACKOFOSENT = 47,
+	LINUX_MIB_TCPDSACKRECV = 48,
+	LINUX_MIB_TCPDSACKOFORECV = 49,
+	LINUX_MIB_TCPABORTONDATA = 50,
+	LINUX_MIB_TCPABORTONCLOSE = 51,
+	LINUX_MIB_TCPABORTONMEMORY = 52,
+	LINUX_MIB_TCPABORTONTIMEOUT = 53,
+	LINUX_MIB_TCPABORTONLINGER = 54,
+	LINUX_MIB_TCPABORTFAILED = 55,
+	LINUX_MIB_TCPMEMORYPRESSURES = 56,
+	LINUX_MIB_TCPMEMORYPRESSURESCHRONO = 57,
+	LINUX_MIB_TCPSACKDISCARD = 58,
+	LINUX_MIB_TCPDSACKIGNOREDOLD = 59,
+	LINUX_MIB_TCPDSACKIGNOREDNOUNDO = 60,
+	LINUX_MIB_TCPSPURIOUSRTOS = 61,
+	LINUX_MIB_TCPMD5NOTFOUND = 62,
+	LINUX_MIB_TCPMD5UNEXPECTED = 63,
+	LINUX_MIB_TCPMD5FAILURE = 64,
+	LINUX_MIB_SACKSHIFTED = 65,
+	LINUX_MIB_SACKMERGED = 66,
+	LINUX_MIB_SACKSHIFTFALLBACK = 67,
+	LINUX_MIB_TCPBACKLOGDROP = 68,
+	LINUX_MIB_PFMEMALLOCDROP = 69,
+	LINUX_MIB_TCPMINTTLDROP = 70,
+	LINUX_MIB_TCPDEFERACCEPTDROP = 71,
+	LINUX_MIB_IPRPFILTER = 72,
+	LINUX_MIB_TCPTIMEWAITOVERFLOW = 73,
+	LINUX_MIB_TCPREQQFULLDOCOOKIES = 74,
+	LINUX_MIB_TCPREQQFULLDROP = 75,
+	LINUX_MIB_TCPRETRANSFAIL = 76,
+	LINUX_MIB_TCPRCVCOALESCE = 77,
+	LINUX_MIB_TCPBACKLOGCOALESCE = 78,
+	LINUX_MIB_TCPOFOQUEUE = 79,
+	LINUX_MIB_TCPOFODROP = 80,
+	LINUX_MIB_TCPOFOMERGE = 81,
+	LINUX_MIB_TCPCHALLENGEACK = 82,
+	LINUX_MIB_TCPSYNCHALLENGE = 83,
+	LINUX_MIB_TCPFASTOPENACTIVE = 84,
+	LINUX_MIB_TCPFASTOPENACTIVEFAIL = 85,
+	LINUX_MIB_TCPFASTOPENPASSIVE = 86,
+	LINUX_MIB_TCPFASTOPENPASSIVEFAIL = 87,
+	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW = 88,
+	LINUX_MIB_TCPFASTOPENCOOKIEREQD = 89,
+	LINUX_MIB_TCPFASTOPENBLACKHOLE = 90,
+	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES = 91,
+	LINUX_MIB_BUSYPOLLRXPACKETS = 92,
+	LINUX_MIB_TCPAUTOCORKING = 93,
+	LINUX_MIB_TCPFROMZEROWINDOWADV = 94,
+	LINUX_MIB_TCPTOZEROWINDOWADV = 95,
+	LINUX_MIB_TCPWANTZEROWINDOWADV = 96,
+	LINUX_MIB_TCPSYNRETRANS = 97,
+	LINUX_MIB_TCPORIGDATASENT = 98,
+	LINUX_MIB_TCPHYSTARTTRAINDETECT = 99,
+	LINUX_MIB_TCPHYSTARTTRAINCWND = 100,
+	LINUX_MIB_TCPHYSTARTDELAYDETECT = 101,
+	LINUX_MIB_TCPHYSTARTDELAYCWND = 102,
+	LINUX_MIB_TCPACKSKIPPEDSYNRECV = 103,
+	LINUX_MIB_TCPACKSKIPPEDPAWS = 104,
+	LINUX_MIB_TCPACKSKIPPEDSEQ = 105,
+	LINUX_MIB_TCPACKSKIPPEDFINWAIT2 = 106,
+	LINUX_MIB_TCPACKSKIPPEDTIMEWAIT = 107,
+	LINUX_MIB_TCPACKSKIPPEDCHALLENGE = 108,
+	LINUX_MIB_TCPWINPROBE = 109,
+	LINUX_MIB_TCPKEEPALIVE = 110,
+	LINUX_MIB_TCPMTUPFAIL = 111,
+	LINUX_MIB_TCPMTUPSUCCESS = 112,
+	LINUX_MIB_TCPDELIVERED = 113,
+	LINUX_MIB_TCPDELIVEREDCE = 114,
+	LINUX_MIB_TCPACKCOMPRESSED = 115,
+	LINUX_MIB_TCPZEROWINDOWDROP = 116,
+	LINUX_MIB_TCPRCVQDROP = 117,
+	LINUX_MIB_TCPWQUEUETOOBIG = 118,
+	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY = 119,
+	LINUX_MIB_TCPTIMEOUTREHASH = 120,
+	LINUX_MIB_TCPDUPLICATEDATAREHASH = 121,
+	LINUX_MIB_TCPDSACKRECVSEGS = 122,
+	LINUX_MIB_TCPDSACKIGNOREDDUBIOUS = 123,
+	LINUX_MIB_TCPMIGRATEREQSUCCESS = 124,
+	LINUX_MIB_TCPMIGRATEREQFAILURE = 125,
+	LINUX_MIB_TCPPLBREHASH = 126,
+	LINUX_MIB_TCPAOREQUIRED = 127,
+	LINUX_MIB_TCPAOBAD = 128,
+	LINUX_MIB_TCPAOKEYNOTFOUND = 129,
+	LINUX_MIB_TCPAOGOOD = 130,
+	LINUX_MIB_TCPAODROPPEDICMPS = 131,
+	__LINUX_MIB_MAX = 132,
+};
+
+enum {
+	LINUX_MIB_XFRMNUM = 0,
+	LINUX_MIB_XFRMINERROR = 1,
+	LINUX_MIB_XFRMINBUFFERERROR = 2,
+	LINUX_MIB_XFRMINHDRERROR = 3,
+	LINUX_MIB_XFRMINNOSTATES = 4,
+	LINUX_MIB_XFRMINSTATEPROTOERROR = 5,
+	LINUX_MIB_XFRMINSTATEMODEERROR = 6,
+	LINUX_MIB_XFRMINSTATESEQERROR = 7,
+	LINUX_MIB_XFRMINSTATEEXPIRED = 8,
+	LINUX_MIB_XFRMINSTATEMISMATCH = 9,
+	LINUX_MIB_XFRMINSTATEINVALID = 10,
+	LINUX_MIB_XFRMINTMPLMISMATCH = 11,
+	LINUX_MIB_XFRMINNOPOLS = 12,
+	LINUX_MIB_XFRMINPOLBLOCK = 13,
+	LINUX_MIB_XFRMINPOLERROR = 14,
+	LINUX_MIB_XFRMOUTERROR = 15,
+	LINUX_MIB_XFRMOUTBUNDLEGENERROR = 16,
+	LINUX_MIB_XFRMOUTBUNDLECHECKERROR = 17,
+	LINUX_MIB_XFRMOUTNOSTATES = 18,
+	LINUX_MIB_XFRMOUTSTATEPROTOERROR = 19,
+	LINUX_MIB_XFRMOUTSTATEMODEERROR = 20,
+	LINUX_MIB_XFRMOUTSTATESEQERROR = 21,
+	LINUX_MIB_XFRMOUTSTATEEXPIRED = 22,
+	LINUX_MIB_XFRMOUTPOLBLOCK = 23,
+	LINUX_MIB_XFRMOUTPOLDEAD = 24,
+	LINUX_MIB_XFRMOUTPOLERROR = 25,
+	LINUX_MIB_XFRMFWDHDRERROR = 26,
+	LINUX_MIB_XFRMOUTSTATEINVALID = 27,
+	LINUX_MIB_XFRMACQUIREERROR = 28,
+	LINUX_MIB_XFRMOUTSTATEDIRERROR = 29,
+	LINUX_MIB_XFRMINSTATEDIRERROR = 30,
+	__LINUX_MIB_XFRMMAX = 31,
+};
+
+enum {
+	LINUX_MIB_TLSNUM = 0,
+	LINUX_MIB_TLSCURRTXSW = 1,
+	LINUX_MIB_TLSCURRRXSW = 2,
+	LINUX_MIB_TLSCURRTXDEVICE = 3,
+	LINUX_MIB_TLSCURRRXDEVICE = 4,
+	LINUX_MIB_TLSTXSW = 5,
+	LINUX_MIB_TLSRXSW = 6,
+	LINUX_MIB_TLSTXDEVICE = 7,
+	LINUX_MIB_TLSRXDEVICE = 8,
+	LINUX_MIB_TLSDECRYPTERROR = 9,
+	LINUX_MIB_TLSRXDEVICERESYNC = 10,
+	LINUX_MIB_TLSDECRYPTRETRY = 11,
+	LINUX_MIB_TLSRXNOPADVIOL = 12,
+	__LINUX_MIB_TLSMAX = 13,
+};
+
+enum nf_inet_hooks {
+	NF_INET_PRE_ROUTING = 0,
+	NF_INET_LOCAL_IN = 1,
+	NF_INET_FORWARD = 2,
+	NF_INET_LOCAL_OUT = 3,
+	NF_INET_POST_ROUTING = 4,
+	NF_INET_NUMHOOKS = 5,
+	NF_INET_INGRESS = 5,
+};
+
+enum {
+	NFPROTO_UNSPEC = 0,
+	NFPROTO_INET = 1,
+	NFPROTO_IPV4 = 2,
+	NFPROTO_ARP = 3,
+	NFPROTO_NETDEV = 5,
+	NFPROTO_BRIDGE = 7,
+	NFPROTO_IPV6 = 10,
+	NFPROTO_NUMPROTO = 11,
+};
+
+enum tcp_conntrack {
+	TCP_CONNTRACK_NONE = 0,
+	TCP_CONNTRACK_SYN_SENT = 1,
+	TCP_CONNTRACK_SYN_RECV = 2,
+	TCP_CONNTRACK_ESTABLISHED = 3,
+	TCP_CONNTRACK_FIN_WAIT = 4,
+	TCP_CONNTRACK_CLOSE_WAIT = 5,
+	TCP_CONNTRACK_LAST_ACK = 6,
+	TCP_CONNTRACK_TIME_WAIT = 7,
+	TCP_CONNTRACK_CLOSE = 8,
+	TCP_CONNTRACK_LISTEN = 9,
+	TCP_CONNTRACK_MAX = 10,
+	TCP_CONNTRACK_IGNORE = 11,
+	TCP_CONNTRACK_RETRANS = 12,
+	TCP_CONNTRACK_UNACK = 13,
+	TCP_CONNTRACK_TIMEOUT_MAX = 14,
+};
+
+enum udp_conntrack {
+	UDP_CT_UNREPLIED = 0,
+	UDP_CT_REPLIED = 1,
+	UDP_CT_MAX = 2,
+};
+
+enum gre_conntrack {
+	GRE_CT_UNREPLIED = 0,
+	GRE_CT_REPLIED = 1,
+	GRE_CT_MAX = 2,
+};
+
+enum {
+	XFRM_POLICY_IN = 0,
+	XFRM_POLICY_OUT = 1,
+	XFRM_POLICY_FWD = 2,
+	XFRM_POLICY_MASK = 3,
+	XFRM_POLICY_MAX = 3,
+};
+
+enum netns_bpf_attach_type {
+	NETNS_BPF_INVALID = -1,
+	NETNS_BPF_FLOW_DISSECTOR = 0,
+	NETNS_BPF_SK_LOOKUP = 1,
+	MAX_NETNS_BPF_ATTACH_TYPE = 2,
+};
+
+struct wake_q_head {
+	struct wake_q_node *first;
+	struct wake_q_node **lastp;
+};
+
+struct sched_attr {
+	__u32 size;
+	__u32 sched_policy;
+	__u64 sched_flags;
+	__s32 sched_nice;
+	__u32 sched_priority;
+	__u64 sched_runtime;
+	__u64 sched_deadline;
+	__u64 sched_period;
+	__u32 sched_util_min;
+	__u32 sched_util_max;
+};
+
+struct trace_event_raw_sched_kthread_stop {
+	struct trace_entry ent;
+	char comm[16];
+	pid_t pid;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_kthread_stop_ret {
+	struct trace_entry ent;
+	int ret;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_kthread_work_queue_work {
+	struct trace_entry ent;
+	void *work;
+	void *function;
+	void *worker;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_kthread_work_execute_start {
+	struct trace_entry ent;
+	void *work;
+	void *function;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_kthread_work_execute_end {
+	struct trace_entry ent;
+	void *work;
+	void *function;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_wakeup_template {
+	struct trace_entry ent;
+	char comm[16];
+	pid_t pid;
+	int prio;
+	int target_cpu;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_switch {
+	struct trace_entry ent;
+	char prev_comm[16];
+	pid_t prev_pid;
+	int prev_prio;
+	long int prev_state;
+	char next_comm[16];
+	pid_t next_pid;
+	int next_prio;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_migrate_task {
+	struct trace_entry ent;
+	char comm[16];
+	pid_t pid;
+	int prio;
+	int orig_cpu;
+	int dest_cpu;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_process_template {
+	struct trace_entry ent;
+	char comm[16];
+	pid_t pid;
+	int prio;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_process_wait {
+	struct trace_entry ent;
+	char comm[16];
+	pid_t pid;
+	int prio;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_process_fork {
+	struct trace_entry ent;
+	char parent_comm[16];
+	pid_t parent_pid;
+	char child_comm[16];
+	pid_t child_pid;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_process_exec {
+	struct trace_entry ent;
+	u32 __data_loc_filename;
+	pid_t pid;
+	pid_t old_pid;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_prepare_exec {
+	struct trace_entry ent;
+	u32 __data_loc_interp;
+	u32 __data_loc_filename;
+	pid_t pid;
+	u32 __data_loc_comm;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_stat_runtime {
+	struct trace_entry ent;
+	char comm[16];
+	pid_t pid;
+	long: 32;
+	u64 runtime;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_pi_setprio {
+	struct trace_entry ent;
+	char comm[16];
+	pid_t pid;
+	int oldprio;
+	int newprio;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_move_numa {
+	struct trace_entry ent;
+	pid_t pid;
+	pid_t tgid;
+	pid_t ngid;
+	int src_cpu;
+	int src_nid;
+	int dst_cpu;
+	int dst_nid;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_numa_pair_template {
+	struct trace_entry ent;
+	pid_t src_pid;
+	pid_t src_tgid;
+	pid_t src_ngid;
+	int src_cpu;
+	int src_nid;
+	pid_t dst_pid;
+	pid_t dst_tgid;
+	pid_t dst_ngid;
+	int dst_cpu;
+	int dst_nid;
+	char __data[0];
+};
+
+struct trace_event_raw_sched_wake_idle_without_ipi {
+	struct trace_entry ent;
+	int cpu;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_sched_kthread_stop {};
+
+struct trace_event_data_offsets_sched_kthread_stop_ret {};
+
+struct trace_event_data_offsets_sched_kthread_work_queue_work {};
+
+struct trace_event_data_offsets_sched_kthread_work_execute_start {};
+
+struct trace_event_data_offsets_sched_kthread_work_execute_end {};
+
+struct trace_event_data_offsets_sched_wakeup_template {};
+
+struct trace_event_data_offsets_sched_switch {};
+
+struct trace_event_data_offsets_sched_migrate_task {};
+
+struct trace_event_data_offsets_sched_process_template {};
+
+struct trace_event_data_offsets_sched_process_wait {};
+
+struct trace_event_data_offsets_sched_process_fork {};
+
+struct trace_event_data_offsets_sched_process_exec {
+	u32 filename;
+	const void *filename_ptr_;
+};
+
+struct trace_event_data_offsets_sched_prepare_exec {
+	u32 interp;
+	const void *interp_ptr_;
+	u32 filename;
+	const void *filename_ptr_;
+	u32 comm;
+	const void *comm_ptr_;
+};
+
+struct trace_event_data_offsets_sched_stat_runtime {};
+
+struct trace_event_data_offsets_sched_pi_setprio {};
+
+struct trace_event_data_offsets_sched_move_numa {};
+
+struct trace_event_data_offsets_sched_numa_pair_template {};
+
+struct trace_event_data_offsets_sched_wake_idle_without_ipi {};
+
+typedef void (*btf_trace_sched_kthread_stop)(void *, struct task_struct *);
+
+typedef void (*btf_trace_sched_kthread_stop_ret)(void *, int);
+
+typedef void (*btf_trace_sched_kthread_work_queue_work)(void *, struct kthread_worker *, struct kthread_work *);
+
+typedef void (*btf_trace_sched_kthread_work_execute_start)(void *, struct kthread_work *);
+
+typedef void (*btf_trace_sched_kthread_work_execute_end)(void *, struct kthread_work *, kthread_work_func_t);
+
+typedef void (*btf_trace_sched_waking)(void *, struct task_struct *);
+
+typedef void (*btf_trace_sched_wakeup)(void *, struct task_struct *);
+
+typedef void (*btf_trace_sched_wakeup_new)(void *, struct task_struct *);
+
+typedef void (*btf_trace_sched_switch)(void *, bool, struct task_struct *, struct task_struct *, unsigned int);
+
+typedef void (*btf_trace_sched_migrate_task)(void *, struct task_struct *, int);
+
+typedef void (*btf_trace_sched_process_free)(void *, struct task_struct *);
+
+typedef void (*btf_trace_sched_process_exit)(void *, struct task_struct *);
+
+typedef void (*btf_trace_sched_wait_task)(void *, struct task_struct *);
+
+typedef void (*btf_trace_sched_process_wait)(void *, struct pid *);
+
+typedef void (*btf_trace_sched_process_fork)(void *, struct task_struct *, struct task_struct *);
+
+typedef void (*btf_trace_sched_process_exec)(void *, struct task_struct *, pid_t, struct linux_binprm *);
+
+typedef void (*btf_trace_sched_prepare_exec)(void *, struct task_struct *, struct linux_binprm *);
+
+typedef void (*btf_trace_sched_stat_runtime)(void *, struct task_struct *, u64);
+
+typedef void (*btf_trace_sched_pi_setprio)(void *, struct task_struct *, struct task_struct *);
+
+typedef void (*btf_trace_sched_move_numa)(void *, struct task_struct *, int, int);
+
+typedef void (*btf_trace_sched_stick_numa)(void *, struct task_struct *, int, struct task_struct *, int);
+
+typedef void (*btf_trace_sched_swap_numa)(void *, struct task_struct *, int, struct task_struct *, int);
+
+typedef void (*btf_trace_sched_wake_idle_without_ipi)(void *, int);
+
+typedef void (*btf_trace_pelt_cfs_tp)(void *, struct cfs_rq *);
+
+typedef void (*btf_trace_pelt_rt_tp)(void *, struct rq *);
+
+typedef void (*btf_trace_pelt_dl_tp)(void *, struct rq *);
+
+typedef void (*btf_trace_pelt_hw_tp)(void *, struct rq *);
+
+typedef void (*btf_trace_pelt_irq_tp)(void *, struct rq *);
+
+typedef void (*btf_trace_pelt_se_tp)(void *, struct sched_entity *);
+
+typedef void (*btf_trace_sched_cpu_capacity_tp)(void *, struct rq *);
+
+typedef void (*btf_trace_sched_overutilized_tp)(void *, struct root_domain *, bool);
+
+typedef void (*btf_trace_sched_util_est_cfs_tp)(void *, struct cfs_rq *);
+
+typedef void (*btf_trace_sched_util_est_se_tp)(void *, struct sched_entity *);
+
+typedef void (*btf_trace_sched_update_nr_running_tp)(void *, struct rq *, int);
+
+typedef void (*btf_trace_sched_compute_energy_tp)(void *, struct task_struct *, int, long unsigned int, long unsigned int, long unsigned int);
+
+struct trace_event_raw_ipi_raise {
+	struct trace_entry ent;
+	u32 __data_loc_target_cpus;
+	const char *reason;
+	char __data[0];
+};
+
+struct trace_event_raw_ipi_send_cpu {
+	struct trace_entry ent;
+	unsigned int cpu;
+	void *callsite;
+	void *callback;
+	char __data[0];
+};
+
+struct trace_event_raw_ipi_send_cpumask {
+	struct trace_entry ent;
+	u32 __data_loc_cpumask;
+	void *callsite;
+	void *callback;
+	char __data[0];
+};
+
+struct trace_event_raw_ipi_handler {
+	struct trace_entry ent;
+	const char *reason;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_ipi_raise {
+	u32 target_cpus;
+	const void *target_cpus_ptr_;
+};
+
+struct trace_event_data_offsets_ipi_send_cpu {};
+
+struct trace_event_data_offsets_ipi_send_cpumask {
+	u32 cpumask;
+	const void *cpumask_ptr_;
+};
+
+struct trace_event_data_offsets_ipi_handler {};
+
+typedef void (*btf_trace_ipi_raise)(void *, const struct cpumask *, const char *);
+
+typedef void (*btf_trace_ipi_send_cpu)(void *, const unsigned int, long unsigned int, void *);
+
+typedef void (*btf_trace_ipi_send_cpumask)(void *, const struct cpumask *, long unsigned int, void *);
+
+typedef void (*btf_trace_ipi_entry)(void *, const char *);
+
+typedef void (*btf_trace_ipi_exit)(void *, const char *);
+
+struct cpudl_item {
+	u64 dl;
+	int cpu;
+	int idx;
+};
+
+typedef int (*tg_visitor)(struct task_group *, void *);
+
+struct balance_callback {
+	struct balance_callback *next;
+	void (*func)(struct rq *);
+};
+
+struct perf_domain {
+	struct em_perf_domain *em_pd;
+	struct perf_domain *next;
+	struct callback_head rcu;
+};
+
+struct rq_flags {
+	long unsigned int flags;
+	struct pin_cookie cookie;
+};
+
+typedef struct {
+	struct task_struct *lock;
+	struct rq *rq;
+	struct rq_flags rf;
+} class_task_rq_lock_t;
+
+typedef struct {
+	struct rq *lock;
+	struct rq_flags rf;
+} class_rq_lock_irq_t;
+
+typedef struct {
+	struct rq *lock;
+	struct rq_flags rf;
+} class_rq_lock_irqsave_t;
+
+enum {
+	__SCHED_FEAT_PLACE_LAG = 0,
+	__SCHED_FEAT_PLACE_DEADLINE_INITIAL = 1,
+	__SCHED_FEAT_PLACE_REL_DEADLINE = 2,
+	__SCHED_FEAT_RUN_TO_PARITY = 3,
+	__SCHED_FEAT_PREEMPT_SHORT = 4,
+	__SCHED_FEAT_NEXT_BUDDY = 5,
+	__SCHED_FEAT_CACHE_HOT_BUDDY = 6,
+	__SCHED_FEAT_DELAY_DEQUEUE = 7,
+	__SCHED_FEAT_DELAY_ZERO = 8,
+	__SCHED_FEAT_WAKEUP_PREEMPTION = 9,
+	__SCHED_FEAT_HRTICK = 10,
+	__SCHED_FEAT_HRTICK_DL = 11,
+	__SCHED_FEAT_DOUBLE_TICK = 12,
+	__SCHED_FEAT_NONTASK_CAPACITY = 13,
+	__SCHED_FEAT_TTWU_QUEUE = 14,
+	__SCHED_FEAT_SIS_UTIL = 15,
+	__SCHED_FEAT_WARN_DOUBLE_CLOCK = 16,
+	__SCHED_FEAT_RT_PUSH_IPI = 17,
+	__SCHED_FEAT_RT_RUNTIME_SHARE = 18,
+	__SCHED_FEAT_LB_MIN = 19,
+	__SCHED_FEAT_ATTACH_AGE_LOAD = 20,
+	__SCHED_FEAT_WA_IDLE = 21,
+	__SCHED_FEAT_WA_WEIGHT = 22,
+	__SCHED_FEAT_WA_BIAS = 23,
+	__SCHED_FEAT_UTIL_EST = 24,
+	__SCHED_FEAT_LATENCY_WARN = 25,
+	__SCHED_FEAT_NR = 26,
+};
+
+struct affinity_context {
+	const struct cpumask *new_mask;
+	struct cpumask *user_mask;
+	unsigned int flags;
+};
+
+enum io_uring_sqe_flags_bit {
+	IOSQE_FIXED_FILE_BIT = 0,
+	IOSQE_IO_DRAIN_BIT = 1,
+	IOSQE_IO_LINK_BIT = 2,
+	IOSQE_IO_HARDLINK_BIT = 3,
+	IOSQE_ASYNC_BIT = 4,
+	IOSQE_BUFFER_SELECT_BIT = 5,
+	IOSQE_CQE_SKIP_SUCCESS_BIT = 6,
+};
+
+enum io_uring_op {
+	IORING_OP_NOP = 0,
+	IORING_OP_READV = 1,
+	IORING_OP_WRITEV = 2,
+	IORING_OP_FSYNC = 3,
+	IORING_OP_READ_FIXED = 4,
+	IORING_OP_WRITE_FIXED = 5,
+	IORING_OP_POLL_ADD = 6,
+	IORING_OP_POLL_REMOVE = 7,
+	IORING_OP_SYNC_FILE_RANGE = 8,
+	IORING_OP_SENDMSG = 9,
+	IORING_OP_RECVMSG = 10,
+	IORING_OP_TIMEOUT = 11,
+	IORING_OP_TIMEOUT_REMOVE = 12,
+	IORING_OP_ACCEPT = 13,
+	IORING_OP_ASYNC_CANCEL = 14,
+	IORING_OP_LINK_TIMEOUT = 15,
+	IORING_OP_CONNECT = 16,
+	IORING_OP_FALLOCATE = 17,
+	IORING_OP_OPENAT = 18,
+	IORING_OP_CLOSE = 19,
+	IORING_OP_FILES_UPDATE = 20,
+	IORING_OP_STATX = 21,
+	IORING_OP_READ = 22,
+	IORING_OP_WRITE = 23,
+	IORING_OP_FADVISE = 24,
+	IORING_OP_MADVISE = 25,
+	IORING_OP_SEND = 26,
+	IORING_OP_RECV = 27,
+	IORING_OP_OPENAT2 = 28,
+	IORING_OP_EPOLL_CTL = 29,
+	IORING_OP_SPLICE = 30,
+	IORING_OP_PROVIDE_BUFFERS = 31,
+	IORING_OP_REMOVE_BUFFERS = 32,
+	IORING_OP_TEE = 33,
+	IORING_OP_SHUTDOWN = 34,
+	IORING_OP_RENAMEAT = 35,
+	IORING_OP_UNLINKAT = 36,
+	IORING_OP_MKDIRAT = 37,
+	IORING_OP_SYMLINKAT = 38,
+	IORING_OP_LINKAT = 39,
+	IORING_OP_MSG_RING = 40,
+	IORING_OP_FSETXATTR = 41,
+	IORING_OP_SETXATTR = 42,
+	IORING_OP_FGETXATTR = 43,
+	IORING_OP_GETXATTR = 44,
+	IORING_OP_SOCKET = 45,
+	IORING_OP_URING_CMD = 46,
+	IORING_OP_SEND_ZC = 47,
+	IORING_OP_SENDMSG_ZC = 48,
+	IORING_OP_READ_MULTISHOT = 49,
+	IORING_OP_WAITID = 50,
+	IORING_OP_FUTEX_WAIT = 51,
+	IORING_OP_FUTEX_WAKE = 52,
+	IORING_OP_FUTEX_WAITV = 53,
+	IORING_OP_FIXED_FD_INSTALL = 54,
+	IORING_OP_FTRUNCATE = 55,
+	IORING_OP_BIND = 56,
+	IORING_OP_LISTEN = 57,
+	IORING_OP_LAST = 58,
+};
+
+enum io_uring_register_op {
+	IORING_REGISTER_BUFFERS = 0,
+	IORING_UNREGISTER_BUFFERS = 1,
+	IORING_REGISTER_FILES = 2,
+	IORING_UNREGISTER_FILES = 3,
+	IORING_REGISTER_EVENTFD = 4,
+	IORING_UNREGISTER_EVENTFD = 5,
+	IORING_REGISTER_FILES_UPDATE = 6,
+	IORING_REGISTER_EVENTFD_ASYNC = 7,
+	IORING_REGISTER_PROBE = 8,
+	IORING_REGISTER_PERSONALITY = 9,
+	IORING_UNREGISTER_PERSONALITY = 10,
+	IORING_REGISTER_RESTRICTIONS = 11,
+	IORING_REGISTER_ENABLE_RINGS = 12,
+	IORING_REGISTER_FILES2 = 13,
+	IORING_REGISTER_FILES_UPDATE2 = 14,
+	IORING_REGISTER_BUFFERS2 = 15,
+	IORING_REGISTER_BUFFERS_UPDATE = 16,
+	IORING_REGISTER_IOWQ_AFF = 17,
+	IORING_UNREGISTER_IOWQ_AFF = 18,
+	IORING_REGISTER_IOWQ_MAX_WORKERS = 19,
+	IORING_REGISTER_RING_FDS = 20,
+	IORING_UNREGISTER_RING_FDS = 21,
+	IORING_REGISTER_PBUF_RING = 22,
+	IORING_UNREGISTER_PBUF_RING = 23,
+	IORING_REGISTER_SYNC_CANCEL = 24,
+	IORING_REGISTER_FILE_ALLOC_RANGE = 25,
+	IORING_REGISTER_PBUF_STATUS = 26,
+	IORING_REGISTER_NAPI = 27,
+	IORING_UNREGISTER_NAPI = 28,
+	IORING_REGISTER_CLOCK = 29,
+	IORING_REGISTER_CLONE_BUFFERS = 30,
+	IORING_REGISTER_LAST = 31,
+	IORING_REGISTER_USE_REGISTERED_RING = 2147483648,
+};
+
+enum {
+	REQ_F_FIXED_FILE_BIT = 0,
+	REQ_F_IO_DRAIN_BIT = 1,
+	REQ_F_LINK_BIT = 2,
+	REQ_F_HARDLINK_BIT = 3,
+	REQ_F_FORCE_ASYNC_BIT = 4,
+	REQ_F_BUFFER_SELECT_BIT = 5,
+	REQ_F_CQE_SKIP_BIT = 6,
+	REQ_F_FAIL_BIT = 8,
+	REQ_F_INFLIGHT_BIT = 9,
+	REQ_F_CUR_POS_BIT = 10,
+	REQ_F_NOWAIT_BIT = 11,
+	REQ_F_LINK_TIMEOUT_BIT = 12,
+	REQ_F_NEED_CLEANUP_BIT = 13,
+	REQ_F_POLLED_BIT = 14,
+	REQ_F_BUFFER_SELECTED_BIT = 15,
+	REQ_F_BUFFER_RING_BIT = 16,
+	REQ_F_REISSUE_BIT = 17,
+	REQ_F_CREDS_BIT = 18,
+	REQ_F_REFCOUNT_BIT = 19,
+	REQ_F_ARM_LTIMEOUT_BIT = 20,
+	REQ_F_ASYNC_DATA_BIT = 21,
+	REQ_F_SKIP_LINK_CQES_BIT = 22,
+	REQ_F_SINGLE_POLL_BIT = 23,
+	REQ_F_DOUBLE_POLL_BIT = 24,
+	REQ_F_APOLL_MULTISHOT_BIT = 25,
+	REQ_F_CLEAR_POLLIN_BIT = 26,
+	REQ_F_HASH_LOCKED_BIT = 27,
+	REQ_F_SUPPORT_NOWAIT_BIT = 28,
+	REQ_F_ISREG_BIT = 29,
+	REQ_F_POLL_NO_LAZY_BIT = 30,
+	REQ_F_CAN_POLL_BIT = 31,
+	REQ_F_BL_EMPTY_BIT = 32,
+	REQ_F_BL_NO_RECYCLE_BIT = 33,
+	REQ_F_BUFFERS_COMMIT_BIT = 34,
+	__REQ_F_LAST_BIT = 35,
+};
+
+typedef u64 io_req_flags_t;
+
+struct set_affinity_pending;
+
+struct migration_arg {
+	struct task_struct *task;
+	int dest_cpu;
+	struct set_affinity_pending *pending;
+};
+
+struct set_affinity_pending {
+	refcount_t refs;
+	unsigned int stop_pending;
+	struct completion done;
+	struct cpu_stop_work stop_work;
+	struct migration_arg arg;
+};
+
+struct cfs_schedulable_data {
+	struct task_group *tg;
+	long: 32;
+	u64 period;
+	u64 quota;
+};
+
+enum {
+	cpuset = 0,
+	possible = 1,
+	fail = 2,
+};
+
+union cpumask_rcuhead {
+	cpumask_t cpumask;
+	struct callback_head rcu;
+};
+
+struct optimistic_spin_node {
+	struct optimistic_spin_node *next;
+	struct optimistic_spin_node *prev;
+	int locked;
+	int cpu;
+};
+
+struct sysrq_key_op {
+	void (* const handler)(u8);
+	const char * const help_msg;
+	const char * const action_msg;
+	const int enable_mask;
+};
+
+typedef unsigned int uint;
+
+typedef initcall_t initcall_entry_t;
+
+enum system_states {
+	SYSTEM_BOOTING = 0,
+	SYSTEM_SCHEDULING = 1,
+	SYSTEM_FREEING_INITMEM = 2,
+	SYSTEM_RUNNING = 3,
+	SYSTEM_HALT = 4,
+	SYSTEM_POWER_OFF = 5,
+	SYSTEM_RESTART = 6,
+	SYSTEM_SUSPEND = 7,
+};
+
+typedef struct {
+	seqcount_t seqcount;
+} seqcount_latch_t;
+
+struct semaphore {
+	raw_spinlock_t lock;
+	unsigned int count;
+	struct list_head wait_list;
+};
+
+struct ld_semaphore {
+	atomic_long_t count;
+	raw_spinlock_t wait_lock;
+	unsigned int wait_readers;
+	struct list_head read_wait;
+	struct list_head write_wait;
+};
+
+typedef unsigned int tcflag_t;
+
+typedef unsigned char cc_t;
+
+typedef unsigned int speed_t;
+
+struct ktermios {
+	tcflag_t c_iflag;
+	tcflag_t c_oflag;
+	tcflag_t c_cflag;
+	tcflag_t c_lflag;
+	cc_t c_line;
+	cc_t c_cc[19];
+	speed_t c_ispeed;
+	speed_t c_ospeed;
+};
+
+struct winsize {
+	short unsigned int ws_row;
+	short unsigned int ws_col;
+	short unsigned int ws_xpixel;
+	short unsigned int ws_ypixel;
+};
+
+struct tty_driver;
+
+struct tty_port;
+
+struct tty_operations;
+
+struct tty_ldisc;
+
+struct tty_struct {
+	struct kref kref;
+	int index;
+	struct device *dev;
+	struct tty_driver *driver;
+	struct tty_port *port;
+	const struct tty_operations *ops;
+	struct tty_ldisc *ldisc;
+	struct ld_semaphore ldisc_sem;
+	struct mutex atomic_write_lock;
+	struct mutex legacy_mutex;
+	struct mutex throttle_mutex;
+	struct rw_semaphore termios_rwsem;
+	struct mutex winsize_mutex;
+	struct ktermios termios;
+	struct ktermios termios_locked;
+	char name[64];
+	long unsigned int flags;
+	int count;
+	unsigned int receive_room;
+	struct winsize winsize;
+	struct {
+		spinlock_t lock;
+		bool stopped;
+		bool tco_stopped;
+	} flow;
+	struct {
+		struct pid *pgrp;
+		struct pid *session;
+		spinlock_t lock;
+		unsigned char pktstatus;
+		bool packet;
+	} ctrl;
+	bool hw_stopped;
+	bool closing;
+	int flow_change;
+	struct tty_struct *link;
+	struct fasync_struct *fasync;
+	wait_queue_head_t write_wait;
+	wait_queue_head_t read_wait;
+	struct work_struct hangup_work;
+	void *disc_data;
+	void *driver_data;
+	spinlock_t files_lock;
+	int write_cnt;
+	u8 *write_buf;
+	struct list_head tty_files;
+	struct work_struct SAK_work;
+};
+
+struct cdev {
+	struct kobject kobj;
+	struct module *owner;
+	const struct file_operations *ops;
+	struct list_head list;
+	dev_t dev;
+	unsigned int count;
+};
+
+struct dev_printk_info {
+	char subsystem[16];
+	char device[48];
+};
+
+struct serial_icounter_struct;
+
+struct serial_struct;
+
+struct tty_operations {
+	struct tty_struct * (*lookup)(struct tty_driver *, struct file *, int);
+	int (*install)(struct tty_driver *, struct tty_struct *);
+	void (*remove)(struct tty_driver *, struct tty_struct *);
+	int (*open)(struct tty_struct *, struct file *);
+	void (*close)(struct tty_struct *, struct file *);
+	void (*shutdown)(struct tty_struct *);
+	void (*cleanup)(struct tty_struct *);
+	ssize_t (*write)(struct tty_struct *, const u8 *, size_t);
+	int (*put_char)(struct tty_struct *, u8);
+	void (*flush_chars)(struct tty_struct *);
+	unsigned int (*write_room)(struct tty_struct *);
+	unsigned int (*chars_in_buffer)(struct tty_struct *);
+	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
+	long int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
+	void (*set_termios)(struct tty_struct *, const struct ktermios *);
+	void (*throttle)(struct tty_struct *);
+	void (*unthrottle)(struct tty_struct *);
+	void (*stop)(struct tty_struct *);
+	void (*start)(struct tty_struct *);
+	void (*hangup)(struct tty_struct *);
+	int (*break_ctl)(struct tty_struct *, int);
+	void (*flush_buffer)(struct tty_struct *);
+	int (*ldisc_ok)(struct tty_struct *, int);
+	void (*set_ldisc)(struct tty_struct *);
+	void (*wait_until_sent)(struct tty_struct *, int);
+	void (*send_xchar)(struct tty_struct *, u8);
+	int (*tiocmget)(struct tty_struct *);
+	int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);
+	int (*resize)(struct tty_struct *, struct winsize *);
+	int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *);
+	int (*get_serial)(struct tty_struct *, struct serial_struct *);
+	int (*set_serial)(struct tty_struct *, struct serial_struct *);
+	void (*show_fdinfo)(struct tty_struct *, struct seq_file *);
+	int (*proc_show)(struct seq_file *, void *);
+};
+
+struct tty_driver {
+	struct kref kref;
+	struct cdev **cdevs;
+	struct module *owner;
+	const char *driver_name;
+	const char *name;
+	int name_base;
+	int major;
+	int minor_start;
+	unsigned int num;
+	short int type;
+	short int subtype;
+	struct ktermios init_termios;
+	long unsigned int flags;
+	struct proc_dir_entry *proc_entry;
+	struct tty_driver *other;
+	struct tty_struct **ttys;
+	struct tty_port **ports;
+	struct ktermios **termios;
+	void *driver_state;
+	const struct tty_operations *ops;
+	struct list_head tty_drivers;
+};
+
+struct tty_buffer {
+	union {
+		struct tty_buffer *next;
+		struct llist_node free;
+	};
+	unsigned int used;
+	unsigned int size;
+	unsigned int commit;
+	unsigned int lookahead;
+	unsigned int read;
+	bool flags;
+	long: 0;
+	u8 data[0];
+};
+
+struct tty_bufhead {
+	struct tty_buffer *head;
+	struct work_struct work;
+	struct mutex lock;
+	atomic_t priority;
+	struct tty_buffer sentinel;
+	struct llist_head free;
+	atomic_t mem_used;
+	int mem_limit;
+	struct tty_buffer *tail;
+};
+
+struct __kfifo {
+	unsigned int in;
+	unsigned int out;
+	unsigned int mask;
+	unsigned int esize;
+	void *data;
+};
+
+struct tty_port_operations;
+
+struct tty_port_client_operations;
+
+struct tty_port {
+	struct tty_bufhead buf;
+	struct tty_struct *tty;
+	struct tty_struct *itty;
+	const struct tty_port_operations *ops;
+	const struct tty_port_client_operations *client_ops;
+	spinlock_t lock;
+	int blocked_open;
+	int count;
+	wait_queue_head_t open_wait;
+	wait_queue_head_t delta_msr_wait;
+	long unsigned int flags;
+	long unsigned int iflags;
+	unsigned char console: 1;
+	struct mutex mutex;
+	struct mutex buf_mutex;
+	u8 *xmit_buf;
+	struct {
+		union {
+			struct __kfifo kfifo;
+			u8 *type;
+			const u8 *const_type;
+			char (*rectype)[0];
+			u8 *ptr;
+			const u8 *ptr_const;
+		};
+		u8 buf[0];
+	} xmit_fifo;
+	unsigned int close_delay;
+	unsigned int closing_wait;
+	int drain_delay;
+	struct kref kref;
+	void *client_data;
+};
+
+struct tty_ldisc_ops {
+	char *name;
+	int num;
+	int (*open)(struct tty_struct *);
+	void (*close)(struct tty_struct *);
+	void (*flush_buffer)(struct tty_struct *);
+	ssize_t (*read)(struct tty_struct *, struct file *, u8 *, size_t, void **, long unsigned int);
+	ssize_t (*write)(struct tty_struct *, struct file *, const u8 *, size_t);
+	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
+	int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
+	void (*set_termios)(struct tty_struct *, const struct ktermios *);
+	__poll_t (*poll)(struct tty_struct *, struct file *, struct poll_table_struct *);
+	void (*hangup)(struct tty_struct *);
+	void (*receive_buf)(struct tty_struct *, const u8 *, const u8 *, size_t);
+	void (*write_wakeup)(struct tty_struct *);
+	void (*dcd_change)(struct tty_struct *, bool);
+	size_t (*receive_buf2)(struct tty_struct *, const u8 *, const u8 *, size_t);
+	void (*lookahead_buf)(struct tty_struct *, const u8 *, const u8 *, size_t);
+	struct module *owner;
+};
+
+struct tty_ldisc {
+	struct tty_ldisc_ops *ops;
+	struct tty_struct *tty;
+};
+
+struct tty_port_operations {
+	bool (*carrier_raised)(struct tty_port *);
+	void (*dtr_rts)(struct tty_port *, bool);
+	void (*shutdown)(struct tty_port *);
+	int (*activate)(struct tty_port *, struct tty_struct *);
+	void (*destruct)(struct tty_port *);
+};
+
+struct tty_port_client_operations {
+	size_t (*receive_buf)(struct tty_port *, const u8 *, const u8 *, size_t);
+	void (*lookahead_buf)(struct tty_port *, const u8 *, const u8 *, size_t);
+	void (*write_wakeup)(struct tty_port *);
+};
+
+enum cons_flags {
+	CON_PRINTBUFFER = 1,
+	CON_CONSDEV = 2,
+	CON_ENABLED = 4,
+	CON_BOOT = 8,
+	CON_ANYTIME = 16,
+	CON_BRL = 32,
+	CON_EXTENDED = 64,
+	CON_SUSPENDED = 128,
+	CON_NBCON = 256,
+};
+
+enum nbcon_prio {
+	NBCON_PRIO_NONE = 0,
+	NBCON_PRIO_NORMAL = 1,
+	NBCON_PRIO_EMERGENCY = 2,
+	NBCON_PRIO_PANIC = 3,
+	NBCON_PRIO_MAX = 4,
+};
+
+struct console;
+
+struct printk_buffers;
+
+struct nbcon_context {
+	struct console *console;
+	unsigned int spinwait_max_us;
+	enum nbcon_prio prio;
+	unsigned int allow_unsafe_takeover: 1;
+	unsigned int backlog: 1;
+	struct printk_buffers *pbufs;
+	long: 32;
+	u64 seq;
+};
+
+struct nbcon_write_context;
+
+struct console {
+	char name[16];
+	void (*write)(struct console *, const char *, unsigned int);
+	int (*read)(struct console *, char *, unsigned int);
+	struct tty_driver * (*device)(struct console *, int *);
+	void (*unblank)();
+	int (*setup)(struct console *, char *);
+	int (*exit)(struct console *);
+	int (*match)(struct console *, char *, int, char *);
+	short int flags;
+	short int index;
+	int cflag;
+	uint ispeed;
+	uint ospeed;
+	long: 32;
+	u64 seq;
+	long unsigned int dropped;
+	void *data;
+	struct hlist_node node;
+	void (*write_atomic)(struct console *, struct nbcon_write_context *);
+	void (*write_thread)(struct console *, struct nbcon_write_context *);
+	void (*device_lock)(struct console *, long unsigned int *);
+	void (*device_unlock)(struct console *, long unsigned int);
+	atomic_t nbcon_state;
+	atomic_long_t nbcon_seq;
+	struct nbcon_context nbcon_device_ctxt;
+	atomic_long_t nbcon_prev_seq;
+	struct printk_buffers *pbufs;
+	struct task_struct *kthread;
+	struct rcuwait rcuwait;
+	struct irq_work irq_work;
+};
+
+struct printk_buffers {
+	char outbuf[2048];
+	char scratchbuf[1024];
+};
+
+struct nbcon_write_context {
+	struct nbcon_context ctxt;
+	char *outbuf;
+	unsigned int len;
+	bool unsafe_takeover;
+	long: 32;
+};
+
+enum con_flush_mode {
+	CONSOLE_FLUSH_PENDING = 0,
+	CONSOLE_REPLAY_ALL = 1,
+};
+
+typedef struct poll_table_struct poll_table;
+
+struct syscore_ops {
+	struct list_head node;
+	int (*suspend)();
+	void (*resume)();
+	void (*shutdown)();
+};
+
+enum kmsg_dump_reason {
+	KMSG_DUMP_UNDEF = 0,
+	KMSG_DUMP_PANIC = 1,
+	KMSG_DUMP_OOPS = 2,
+	KMSG_DUMP_EMERG = 3,
+	KMSG_DUMP_SHUTDOWN = 4,
+	KMSG_DUMP_MAX = 5,
+};
+
+struct kmsg_dump_iter {
+	u64 cur_seq;
+	u64 next_seq;
+};
+
+struct kmsg_dump_detail {
+	enum kmsg_dump_reason reason;
+	const char *description;
+};
+
+struct kmsg_dumper {
+	struct list_head list;
+	void (*dump)(struct kmsg_dumper *, struct kmsg_dump_detail *);
+	enum kmsg_dump_reason max_reason;
+	bool registered;
+};
+
+struct trace_event_raw_console {
+	struct trace_entry ent;
+	u32 __data_loc_msg;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_console {
+	u32 msg;
+	const void *msg_ptr_;
+};
+
+typedef void (*btf_trace_console)(void *, const char *, size_t);
+
+struct printk_info {
+	u64 seq;
+	u64 ts_nsec;
+	u16 text_len;
+	u8 facility;
+	u8 flags: 5;
+	u8 level: 3;
+	u32 caller_id;
+	struct dev_printk_info dev_info;
+};
+
+struct printk_record {
+	struct printk_info *info;
+	char *text_buf;
+	unsigned int text_buf_size;
+};
+
+struct prb_data_blk_lpos {
+	long unsigned int begin;
+	long unsigned int next;
+};
+
+struct prb_desc {
+	atomic_long_t state_var;
+	struct prb_data_blk_lpos text_blk_lpos;
+};
+
+struct prb_data_ring {
+	unsigned int size_bits;
+	char *data;
+	atomic_long_t head_lpos;
+	atomic_long_t tail_lpos;
+};
+
+struct prb_desc_ring {
+	unsigned int count_bits;
+	struct prb_desc *descs;
+	struct printk_info *infos;
+	atomic_long_t head_id;
+	atomic_long_t tail_id;
+	atomic_long_t last_finalized_seq;
+};
+
+struct printk_ringbuffer {
+	struct prb_desc_ring desc_ring;
+	struct prb_data_ring text_data_ring;
+	atomic_long_t fail;
+};
+
+struct prb_reserved_entry {
+	struct printk_ringbuffer *rb;
+	long unsigned int irqflags;
+	long unsigned int id;
+	unsigned int text_space;
+};
+
+enum desc_state {
+	desc_miss = -1,
+	desc_reserved = 0,
+	desc_committed = 1,
+	desc_finalized = 2,
+	desc_reusable = 3,
+};
+
+struct console_cmdline {
+	char name[16];
+	int index;
+	char devname[32];
+	bool user_specified;
+	char *options;
+};
+
+enum printk_info_flags {
+	LOG_NEWLINE = 2,
+	LOG_CONT = 8,
+};
+
+struct console_flush_type {
+	bool nbcon_atomic;
+	bool nbcon_offload;
+	bool legacy_direct;
+	bool legacy_offload;
+};
+
+struct printk_message {
+	struct printk_buffers *pbufs;
+	unsigned int outbuf_len;
+	u64 seq;
+	long unsigned int dropped;
+	long: 32;
+};
+
+enum devkmsg_log_bits {
+	__DEVKMSG_LOG_BIT_ON = 0,
+	__DEVKMSG_LOG_BIT_OFF = 1,
+	__DEVKMSG_LOG_BIT_LOCK = 2,
+};
+
+enum devkmsg_log_masks {
+	DEVKMSG_LOG_MASK_ON = 1,
+	DEVKMSG_LOG_MASK_OFF = 2,
+	DEVKMSG_LOG_MASK_LOCK = 4,
+};
+
+enum con_msg_format_flags {
+	MSG_FORMAT_DEFAULT = 0,
+	MSG_FORMAT_SYSLOG = 1,
+};
+
+struct latched_seq {
+	seqcount_latch_t latch;
+	long: 32;
+	u64 val[2];
+};
+
+struct devkmsg_user {
+	atomic64_t seq;
+	struct ratelimit_state rs;
+	struct mutex lock;
+	struct printk_buffers pbufs;
+};
+
+typedef long unsigned int irq_hw_number_t;
+
+enum irqreturn {
+	IRQ_NONE = 0,
+	IRQ_HANDLED = 1,
+	IRQ_WAKE_THREAD = 2,
+};
+
+typedef enum irqreturn irqreturn_t;
+
+struct irq_desc;
+
+typedef void (*irq_flow_handler_t)(struct irq_desc *);
+
+struct msi_desc;
+
+struct irq_common_data {
+	unsigned int state_use_accessors;
+	void *handler_data;
+	struct msi_desc *msi_desc;
+	cpumask_var_t affinity;
+	cpumask_var_t effective_affinity;
+	unsigned int ipi_offset;
+};
+
+struct irq_chip;
+
+struct irq_domain;
+
+struct irq_data {
+	u32 mask;
+	unsigned int irq;
+	irq_hw_number_t hwirq;
+	struct irq_common_data *common;
+	struct irq_chip *chip;
+	struct irq_domain *domain;
+	struct irq_data *parent_data;
+	void *chip_data;
+};
+
+struct irqstat;
+
+struct irqaction;
+
+struct irq_affinity_notify;
+
+struct irq_desc {
+	struct irq_common_data irq_common_data;
+	struct irq_data irq_data;
+	struct irqstat *kstat_irqs;
+	irq_flow_handler_t handle_irq;
+	struct irqaction *action;
+	unsigned int status_use_accessors;
+	unsigned int core_internal_state__do_not_mess_with_it;
+	unsigned int depth;
+	unsigned int wake_depth;
+	unsigned int tot_count;
+	unsigned int irq_count;
+	long unsigned int last_unhandled;
+	unsigned int irqs_unhandled;
+	atomic_t threads_handled;
+	int threads_handled_last;
+	raw_spinlock_t lock;
+	struct cpumask *percpu_enabled;
+	const struct cpumask *percpu_affinity;
+	const struct cpumask *affinity_hint;
+	struct irq_affinity_notify *affinity_notify;
+	long unsigned int threads_oneshot;
+	atomic_t threads_active;
+	wait_queue_head_t wait_for_threads;
+	struct proc_dir_entry *dir;
+	struct callback_head rcu;
+	struct kobject kobj;
+	struct mutex request_mutex;
+	int parent_irq;
+	struct module *owner;
+	const char *name;
+	struct hlist_node resend_node;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+enum {
+	IRQ_TYPE_NONE = 0,
+	IRQ_TYPE_EDGE_RISING = 1,
+	IRQ_TYPE_EDGE_FALLING = 2,
+	IRQ_TYPE_EDGE_BOTH = 3,
+	IRQ_TYPE_LEVEL_HIGH = 4,
+	IRQ_TYPE_LEVEL_LOW = 8,
+	IRQ_TYPE_LEVEL_MASK = 12,
+	IRQ_TYPE_SENSE_MASK = 15,
+	IRQ_TYPE_DEFAULT = 15,
+	IRQ_TYPE_PROBE = 16,
+	IRQ_LEVEL = 256,
+	IRQ_PER_CPU = 512,
+	IRQ_NOPROBE = 1024,
+	IRQ_NOREQUEST = 2048,
+	IRQ_NOAUTOEN = 4096,
+	IRQ_NO_BALANCING = 8192,
+	IRQ_MOVE_PCNTXT = 16384,
+	IRQ_NESTED_THREAD = 32768,
+	IRQ_NOTHREAD = 65536,
+	IRQ_PER_CPU_DEVID = 131072,
+	IRQ_IS_POLLED = 262144,
+	IRQ_DISABLE_UNLAZY = 524288,
+	IRQ_HIDDEN = 1048576,
+	IRQ_NO_DEBUG = 2097152,
+};
+
+enum irqchip_irq_state {
+	IRQCHIP_STATE_PENDING = 0,
+	IRQCHIP_STATE_ACTIVE = 1,
+	IRQCHIP_STATE_MASKED = 2,
+	IRQCHIP_STATE_LINE_LEVEL = 3,
+};
+
+struct msi_msg;
+
+struct irq_chip {
+	const char *name;
+	unsigned int (*irq_startup)(struct irq_data *);
+	void (*irq_shutdown)(struct irq_data *);
+	void (*irq_enable)(struct irq_data *);
+	void (*irq_disable)(struct irq_data *);
+	void (*irq_ack)(struct irq_data *);
+	void (*irq_mask)(struct irq_data *);
+	void (*irq_mask_ack)(struct irq_data *);
+	void (*irq_unmask)(struct irq_data *);
+	void (*irq_eoi)(struct irq_data *);
+	int (*irq_set_affinity)(struct irq_data *, const struct cpumask *, bool);
+	int (*irq_retrigger)(struct irq_data *);
+	int (*irq_set_type)(struct irq_data *, unsigned int);
+	int (*irq_set_wake)(struct irq_data *, unsigned int);
+	void (*irq_bus_lock)(struct irq_data *);
+	void (*irq_bus_sync_unlock)(struct irq_data *);
+	void (*irq_suspend)(struct irq_data *);
+	void (*irq_resume)(struct irq_data *);
+	void (*irq_pm_shutdown)(struct irq_data *);
+	void (*irq_calc_mask)(struct irq_data *);
+	void (*irq_print_chip)(struct irq_data *, struct seq_file *);
+	int (*irq_request_resources)(struct irq_data *);
+	void (*irq_release_resources)(struct irq_data *);
+	void (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *);
+	void (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *);
+	int (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool *);
+	int (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool);
+	int (*irq_set_vcpu_affinity)(struct irq_data *, void *);
+	void (*ipi_send_single)(struct irq_data *, unsigned int);
+	void (*ipi_send_mask)(struct irq_data *, const struct cpumask *);
+	int (*irq_nmi_setup)(struct irq_data *);
+	void (*irq_nmi_teardown)(struct irq_data *);
+	long unsigned int flags;
+};
+
+enum irq_domain_bus_token {
+	DOMAIN_BUS_ANY = 0,
+	DOMAIN_BUS_WIRED = 1,
+	DOMAIN_BUS_GENERIC_MSI = 2,
+	DOMAIN_BUS_PCI_MSI = 3,
+	DOMAIN_BUS_PLATFORM_MSI = 4,
+	DOMAIN_BUS_NEXUS = 5,
+	DOMAIN_BUS_IPI = 6,
+	DOMAIN_BUS_FSL_MC_MSI = 7,
+	DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
+	DOMAIN_BUS_WAKEUP = 9,
+	DOMAIN_BUS_VMD_MSI = 10,
+	DOMAIN_BUS_PCI_DEVICE_MSI = 11,
+	DOMAIN_BUS_PCI_DEVICE_MSIX = 12,
+	DOMAIN_BUS_DMAR = 13,
+	DOMAIN_BUS_AMDVI = 14,
+	DOMAIN_BUS_DEVICE_MSI = 15,
+	DOMAIN_BUS_WIRED_TO_MSI = 16,
+};
+
+struct irq_domain_ops;
+
+struct irq_domain_chip_generic;
+
+struct irq_domain {
+	struct list_head link;
+	const char *name;
+	const struct irq_domain_ops *ops;
+	void *host_data;
+	unsigned int flags;
+	unsigned int mapcount;
+	struct mutex mutex;
+	struct irq_domain *root;
+	struct fwnode_handle *fwnode;
+	enum irq_domain_bus_token bus_token;
+	struct irq_domain_chip_generic *gc;
+	struct device *dev;
+	struct device *pm_dev;
+	struct irq_domain *parent;
+	void (*exit)(struct irq_domain *);
+	irq_hw_number_t hwirq_max;
+	unsigned int revmap_size;
+	struct xarray revmap_tree;
+	struct irq_data *revmap[0];
+};
+
+struct irqstat {
+	unsigned int cnt;
+};
+
+typedef irqreturn_t (*irq_handler_t)(int, void *);
+
+struct irqaction {
+	irq_handler_t handler;
+	void *dev_id;
+	void *percpu_dev_id;
+	struct irqaction *next;
+	irq_handler_t thread_fn;
+	struct task_struct *thread;
+	struct irqaction *secondary;
+	unsigned int irq;
+	unsigned int flags;
+	long unsigned int thread_flags;
+	long unsigned int thread_mask;
+	const char *name;
+	struct proc_dir_entry *dir;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct irq_affinity_notify {
+	unsigned int irq;
+	struct kref kref;
+	struct work_struct work;
+	void (*notify)(struct irq_affinity_notify *, const cpumask_t *);
+	void (*release)(struct kref *);
+};
+
+struct irq_chip_regs {
+	long unsigned int enable;
+	long unsigned int disable;
+	long unsigned int mask;
+	long unsigned int ack;
+	long unsigned int eoi;
+	long unsigned int type;
+};
+
+struct irq_chip_type {
+	struct irq_chip chip;
+	struct irq_chip_regs regs;
+	irq_flow_handler_t handler;
+	u32 type;
+	u32 mask_cache_priv;
+	u32 *mask_cache;
+};
+
+struct irq_chip_generic {
+	raw_spinlock_t lock;
+	void *reg_base;
+	u32 (*reg_readl)(void *);
+	void (*reg_writel)(u32, void *);
+	void (*suspend)(struct irq_chip_generic *);
+	void (*resume)(struct irq_chip_generic *);
+	unsigned int irq_base;
+	unsigned int irq_cnt;
+	u32 mask_cache;
+	u32 wake_enabled;
+	u32 wake_active;
+	unsigned int num_ct;
+	void *private;
+	long unsigned int installed;
+	long unsigned int unused;
+	struct irq_domain *domain;
+	struct list_head list;
+	struct irq_chip_type chip_types[0];
+};
+
+enum irq_gc_flags {
+	IRQ_GC_INIT_MASK_CACHE = 1,
+	IRQ_GC_INIT_NESTED_LOCK = 2,
+	IRQ_GC_MASK_CACHE_PER_TYPE = 4,
+	IRQ_GC_NO_MASK = 8,
+	IRQ_GC_BE_IO = 16,
+};
+
+struct irq_domain_chip_generic {
+	unsigned int irqs_per_chip;
+	unsigned int num_chips;
+	unsigned int irq_flags_to_clear;
+	unsigned int irq_flags_to_set;
+	enum irq_gc_flags gc_flags;
+	void (*exit)(struct irq_chip_generic *);
+	struct irq_chip_generic *gc[0];
+};
+
+struct irq_domain_chip_generic_info {
+	const char *name;
+	irq_flow_handler_t handler;
+	unsigned int irqs_per_chip;
+	unsigned int num_ct;
+	unsigned int irq_flags_to_clear;
+	unsigned int irq_flags_to_set;
+	enum irq_gc_flags gc_flags;
+	int (*init)(struct irq_chip_generic *);
+	void (*exit)(struct irq_chip_generic *);
+};
+
+struct irq_affinity_desc {
+	struct cpumask mask;
+	unsigned int is_managed: 1;
+};
+
+struct irq_fwspec {
+	struct fwnode_handle *fwnode;
+	int param_count;
+	u32 param[16];
+};
+
+struct irq_domain_ops {
+	int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token);
+	int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token);
+	int (*map)(struct irq_domain *, unsigned int, irq_hw_number_t);
+	void (*unmap)(struct irq_domain *, unsigned int);
+	int (*xlate)(struct irq_domain *, struct device_node *, const u32 *, unsigned int, long unsigned int *, unsigned int *);
+	int (*alloc)(struct irq_domain *, unsigned int, unsigned int, void *);
+	void (*free)(struct irq_domain *, unsigned int, unsigned int);
+	int (*activate)(struct irq_domain *, struct irq_data *, bool);
+	void (*deactivate)(struct irq_domain *, struct irq_data *);
+	int (*translate)(struct irq_domain *, struct irq_fwspec *, long unsigned int *, unsigned int *);
+};
+
+struct irq_domain_info {
+	struct fwnode_handle *fwnode;
+	unsigned int domain_flags;
+	unsigned int size;
+	irq_hw_number_t hwirq_max;
+	int direct_max;
+	unsigned int hwirq_base;
+	unsigned int virq_base;
+	enum irq_domain_bus_token bus_token;
+	const char *name_suffix;
+	const struct irq_domain_ops *ops;
+	void *host_data;
+	struct irq_domain *parent;
+	struct irq_domain_chip_generic_info *dgc_info;
+	int (*init)(struct irq_domain *);
+	void (*exit)(struct irq_domain *);
+};
+
+typedef void (*dr_release_t)(struct device *, void *);
+
+typedef int (*dr_match_t)(struct device *, void *, void *);
+
+enum cpu_usage_stat {
+	CPUTIME_USER = 0,
+	CPUTIME_NICE = 1,
+	CPUTIME_SYSTEM = 2,
+	CPUTIME_SOFTIRQ = 3,
+	CPUTIME_IRQ = 4,
+	CPUTIME_IDLE = 5,
+	CPUTIME_IOWAIT = 6,
+	CPUTIME_STEAL = 7,
+	CPUTIME_GUEST = 8,
+	CPUTIME_GUEST_NICE = 9,
+	NR_STATS = 10,
+};
+
+struct irq_devres {
+	unsigned int irq;
+	void *dev_id;
+};
+
+struct irq_desc_devres {
+	unsigned int from;
+	unsigned int cnt;
+};
+
+enum {
+	IRQ_DOMAIN_FLAG_HIERARCHY = 1,
+	IRQ_DOMAIN_NAME_ALLOCATED = 2,
+	IRQ_DOMAIN_FLAG_IPI_PER_CPU = 4,
+	IRQ_DOMAIN_FLAG_IPI_SINGLE = 8,
+	IRQ_DOMAIN_FLAG_MSI = 16,
+	IRQ_DOMAIN_FLAG_ISOLATED_MSI = 32,
+	IRQ_DOMAIN_FLAG_NO_MAP = 64,
+	IRQ_DOMAIN_FLAG_MSI_PARENT = 256,
+	IRQ_DOMAIN_FLAG_MSI_DEVICE = 512,
+	IRQ_DOMAIN_FLAG_DESTROY_GC = 1024,
+	IRQ_DOMAIN_FLAG_NONCORE = 65536,
+};
+
+enum {
+	GP_IDLE = 0,
+	GP_ENTER = 1,
+	GP_PASSED = 2,
+	GP_EXIT = 3,
+	GP_REPLAY = 4,
+};
+
+typedef long unsigned int ulong;
+
+struct rcu_synchronize {
+	struct callback_head head;
+	struct completion completion;
+};
+
+struct rcu_cblist {
+	struct callback_head *head;
+	struct callback_head **tail;
+	long int len;
+};
+
+struct scatterlist {
+	long unsigned int page_link;
+	unsigned int offset;
+	unsigned int length;
+	dma_addr_t dma_address;
+};
+
+struct sg_table {
+	struct scatterlist *sgl;
+	unsigned int nents;
+	unsigned int orig_nents;
+};
+
+enum pci_p2pdma_map_type {
+	PCI_P2PDMA_MAP_UNKNOWN = 0,
+	PCI_P2PDMA_MAP_NOT_SUPPORTED = 1,
+	PCI_P2PDMA_MAP_BUS_ADDR = 2,
+	PCI_P2PDMA_MAP_THRU_HOST_BRIDGE = 3,
+};
+
+struct pci_p2pdma_map_state {
+	struct dev_pagemap *pgmap;
+	int map;
+	u64 bus_off;
+};
+
+struct io_tlb_pool;
+
+typedef int (*cmp_func_t)(const void *, const void *);
+
+struct load_info {
+	const char *name;
+	struct module *mod;
+	Elf32_Ehdr *hdr;
+	long unsigned int len;
+	Elf32_Shdr *sechdrs;
+	char *secstrings;
+	char *strtab;
+	long unsigned int symoffs;
+	long unsigned int stroffs;
+	long unsigned int init_typeoffs;
+	long unsigned int core_typeoffs;
+	bool sig_ok;
+	long unsigned int mod_kallsyms_init_off;
+	struct {
+		unsigned int sym;
+		unsigned int str;
+		unsigned int mod;
+		unsigned int vers;
+		unsigned int info;
+		unsigned int pcpu;
+	} index;
+};
+
+typedef bool (*stack_trace_consume_fn)(void *, long unsigned int);
+
+struct stacktrace_cookie {
+	long unsigned int *store;
+	unsigned int size;
+	unsigned int skip;
+	unsigned int len;
+};
+
+struct __kernel_timex_timeval {
+	__kernel_time64_t tv_sec;
+	long long int tv_usec;
+};
+
+struct __kernel_timex {
+	unsigned int modes;
+	long: 32;
+	long long int offset;
+	long long int freq;
+	long long int maxerror;
+	long long int esterror;
+	int status;
+	long: 32;
+	long long int constant;
+	long long int precision;
+	long long int tolerance;
+	struct __kernel_timex_timeval time;
+	long long int tick;
+	long long int ppsfreq;
+	long long int jitter;
+	int shift;
+	long: 32;
+	long long int stabil;
+	long long int jitcnt;
+	long long int calcnt;
+	long long int errcnt;
+	long long int stbcnt;
+	int tai;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+enum audit_ntp_type {
+	AUDIT_NTP_OFFSET = 0,
+	AUDIT_NTP_FREQ = 1,
+	AUDIT_NTP_STATUS = 2,
+	AUDIT_NTP_TAI = 3,
+	AUDIT_NTP_TICK = 4,
+	AUDIT_NTP_ADJUST = 5,
+	AUDIT_NTP_NVALS = 6,
+};
+
+struct audit_ntp_data {};
+
+enum clocksource_ids {
+	CSID_GENERIC = 0,
+	CSID_ARM_ARCH_COUNTER = 1,
+	CSID_X86_TSC_EARLY = 2,
+	CSID_X86_TSC = 3,
+	CSID_X86_KVM_CLK = 4,
+	CSID_X86_ART = 5,
+	CSID_MAX = 6,
+};
+
+enum vdso_clock_mode {
+	VDSO_CLOCKMODE_NONE = 0,
+	VDSO_CLOCKMODE_ARCHTIMER = 1,
+	VDSO_CLOCKMODE_MAX = 2,
+	VDSO_CLOCKMODE_TIMENS = 2147483647,
+};
+
+struct clocksource_base;
+
+struct clocksource {
+	u64 (*read)(struct clocksource *);
+	long: 32;
+	u64 mask;
+	u32 mult;
+	u32 shift;
+	u64 max_idle_ns;
+	u32 maxadj;
+	u32 uncertainty_margin;
+	u64 max_cycles;
+	const char *name;
+	struct list_head list;
+	u32 freq_khz;
+	int rating;
+	enum clocksource_ids id;
+	enum vdso_clock_mode vdso_clock_mode;
+	long unsigned int flags;
+	struct clocksource_base *base;
+	int (*enable)(struct clocksource *);
+	void (*disable)(struct clocksource *);
+	void (*suspend)(struct clocksource *);
+	void (*resume)(struct clocksource *);
+	void (*mark_unstable)(struct clocksource *);
+	void (*tick_stable)(struct clocksource *);
+	struct module *owner;
+};
+
+struct clocksource_base {
+	enum clocksource_ids id;
+	u32 freq_khz;
+	u64 offset;
+	u32 numerator;
+	u32 denominator;
+};
+
+struct tm {
+	int tm_sec;
+	int tm_min;
+	int tm_hour;
+	int tm_mday;
+	int tm_mon;
+	long int tm_year;
+	int tm_wday;
+	int tm_yday;
+};
+
+struct cyclecounter {
+	u64 (*read)(const struct cyclecounter *);
+	long: 32;
+	u64 mask;
+	u32 mult;
+	u32 shift;
+};
+
+struct timecounter {
+	const struct cyclecounter *cc;
+	long: 32;
+	u64 cycle_last;
+	u64 nsec;
+	u64 mask;
+	u64 frac;
+};
+
+typedef __kernel_timer_t timer_t;
+
+typedef __u64 timeu64_t;
+
+struct itimerspec64 {
+	struct timespec64 it_interval;
+	struct timespec64 it_value;
+};
+
+enum tk_offsets {
+	TK_OFFS_REAL = 0,
+	TK_OFFS_BOOT = 1,
+	TK_OFFS_TAI = 2,
+	TK_OFFS_MAX = 3,
+};
+
+struct sigqueue {
+	struct list_head list;
+	int flags;
+	kernel_siginfo_t info;
+	struct ucounts *ucounts;
+};
+
+struct pdev_archdata {};
+
+struct rtc_time {
+	int tm_sec;
+	int tm_min;
+	int tm_hour;
+	int tm_mday;
+	int tm_mon;
+	int tm_year;
+	int tm_wday;
+	int tm_yday;
+	int tm_isdst;
+};
+
+struct rtc_wkalrm {
+	unsigned char enabled;
+	unsigned char pending;
+	struct rtc_time time;
+};
+
+struct rtc_param {
+	__u64 param;
+	union {
+		__u64 uvalue;
+		__s64 svalue;
+		__u64 ptr;
+	};
+	__u32 index;
+	__u32 __pad;
+};
+
+enum alarmtimer_type {
+	ALARM_REALTIME = 0,
+	ALARM_BOOTTIME = 1,
+	ALARM_NUMTYPE = 2,
+	ALARM_REALTIME_FREEZER = 3,
+	ALARM_BOOTTIME_FREEZER = 4,
+};
+
+enum alarmtimer_restart {
+	ALARMTIMER_NORESTART = 0,
+	ALARMTIMER_RESTART = 1,
+};
+
+struct alarm {
+	struct timerqueue_node node;
+	struct hrtimer timer;
+	enum alarmtimer_restart (*function)(struct alarm *, ktime_t);
+	enum alarmtimer_type type;
+	int state;
+	void *data;
+};
+
+struct cpu_timer {
+	struct timerqueue_node node;
+	struct timerqueue_head *head;
+	struct pid *pid;
+	struct list_head elist;
+	int firing;
+	struct task_struct *handling;
+};
+
+struct k_clock;
+
+struct k_itimer {
+	struct hlist_node list;
+	struct hlist_node t_hash;
+	spinlock_t it_lock;
+	const struct k_clock *kclock;
+	clockid_t it_clock;
+	timer_t it_id;
+	int it_active;
+	long: 32;
+	s64 it_overrun;
+	s64 it_overrun_last;
+	int it_requeue_pending;
+	int it_sigev_notify;
+	ktime_t it_interval;
+	struct signal_struct *it_signal;
+	union {
+		struct pid *it_pid;
+		struct task_struct *it_process;
+	};
+	struct sigqueue *sigq;
+	long: 32;
+	union {
+		struct {
+			struct hrtimer timer;
+		} real;
+		struct cpu_timer cpu;
+		struct {
+			struct alarm alarmtimer;
+		} alarm;
+	} it;
+	struct callback_head rcu;
+};
+
+struct k_clock {
+	int (*clock_getres)(const clockid_t, struct timespec64 *);
+	int (*clock_set)(const clockid_t, const struct timespec64 *);
+	int (*clock_get_timespec)(const clockid_t, struct timespec64 *);
+	ktime_t (*clock_get_ktime)(const clockid_t);
+	int (*clock_adj)(const clockid_t, struct __kernel_timex *);
+	int (*timer_create)(struct k_itimer *);
+	int (*nsleep)(const clockid_t, int, const struct timespec64 *);
+	int (*timer_set)(struct k_itimer *, int, struct itimerspec64 *, struct itimerspec64 *);
+	int (*timer_del)(struct k_itimer *);
+	void (*timer_get)(struct k_itimer *, struct itimerspec64 *);
+	void (*timer_rearm)(struct k_itimer *);
+	s64 (*timer_forward)(struct k_itimer *, ktime_t);
+	ktime_t (*timer_remaining)(struct k_itimer *, ktime_t);
+	int (*timer_try_to_cancel)(struct k_itimer *);
+	void (*timer_arm)(struct k_itimer *, ktime_t, bool, bool);
+	void (*timer_wait_running)(struct k_itimer *);
+};
+
+struct rtc_class_ops {
+	int (*ioctl)(struct device *, unsigned int, long unsigned int);
+	int (*read_time)(struct device *, struct rtc_time *);
+	int (*set_time)(struct device *, struct rtc_time *);
+	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
+	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
+	int (*proc)(struct device *, struct seq_file *);
+	int (*alarm_irq_enable)(struct device *, unsigned int);
+	int (*read_offset)(struct device *, long int *);
+	int (*set_offset)(struct device *, long int);
+	int (*param_get)(struct device *, struct rtc_param *);
+	int (*param_set)(struct device *, struct rtc_param *);
+};
+
+struct rtc_device;
+
+struct rtc_timer {
+	struct timerqueue_node node;
+	ktime_t period;
+	void (*func)(struct rtc_device *);
+	struct rtc_device *rtc;
+	int enabled;
+	long: 32;
+};
+
+struct rtc_device {
+	struct device dev;
+	struct module *owner;
+	int id;
+	const struct rtc_class_ops *ops;
+	struct mutex ops_lock;
+	struct cdev char_dev;
+	long unsigned int flags;
+	long unsigned int irq_data;
+	spinlock_t irq_lock;
+	wait_queue_head_t irq_queue;
+	struct fasync_struct *async_queue;
+	int irq_freq;
+	int max_user_freq;
+	struct timerqueue_head timerqueue;
+	struct rtc_timer aie_timer;
+	struct rtc_timer uie_rtctimer;
+	struct hrtimer pie_timer;
+	int pie_enabled;
+	struct work_struct irqwork;
+	long unsigned int set_offset_nsec;
+	long unsigned int features[1];
+	long: 32;
+	time64_t range_min;
+	timeu64_t range_max;
+	timeu64_t alarm_offset_max;
+	time64_t start_secs;
+	time64_t offset_secs;
+	bool set_start_time;
+	long: 32;
+};
+
+struct mfd_cell;
+
+struct platform_device_id;
+
+struct platform_device {
+	const char *name;
+	int id;
+	bool id_auto;
+	long: 32;
+	struct device dev;
+	u64 platform_dma_mask;
+	struct device_dma_parameters dma_parms;
+	u32 num_resources;
+	struct resource *resource;
+	const struct platform_device_id *id_entry;
+	const char *driver_override;
+	struct mfd_cell *mfd_cell;
+	struct pdev_archdata archdata;
+};
+
+struct platform_device_id {
+	char name[20];
+	kernel_ulong_t driver_data;
+};
+
+struct platform_driver {
+	int (*probe)(struct platform_device *);
+	union {
+		void (*remove)(struct platform_device *);
+		void (*remove_new)(struct platform_device *);
+	};
+	void (*shutdown)(struct platform_device *);
+	int (*suspend)(struct platform_device *, pm_message_t);
+	int (*resume)(struct platform_device *);
+	struct device_driver driver;
+	const struct platform_device_id *id_table;
+	bool prevent_deferred_probe;
+	bool driver_managed_dma;
+};
+
+struct timens_offsets {
+	struct timespec64 monotonic;
+	struct timespec64 boottime;
+};
+
+struct time_namespace {
+	struct user_namespace *user_ns;
+	struct ucounts *ucounts;
+	struct ns_common ns;
+	struct timens_offsets offsets;
+	struct page *vvar_page;
+	bool frozen_offsets;
+};
+
+struct trace_event_raw_alarmtimer_suspend {
+	struct trace_entry ent;
+	s64 expires;
+	unsigned char alarm_type;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_alarm_class {
+	struct trace_entry ent;
+	void *alarm;
+	unsigned char alarm_type;
+	s64 expires;
+	s64 now;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_alarmtimer_suspend {};
+
+struct trace_event_data_offsets_alarm_class {};
+
+typedef void (*btf_trace_alarmtimer_suspend)(void *, ktime_t, int);
+
+typedef void (*btf_trace_alarmtimer_fired)(void *, struct alarm *, ktime_t);
+
+typedef void (*btf_trace_alarmtimer_start)(void *, struct alarm *, ktime_t);
+
+typedef void (*btf_trace_alarmtimer_cancel)(void *, struct alarm *, ktime_t);
+
+struct alarm_base {
+	spinlock_t lock;
+	struct timerqueue_head timerqueue;
+	ktime_t (*get_ktime)();
+	void (*get_timespec)(struct timespec64 *);
+	clockid_t base_clockid;
+};
+
+typedef s64 int64_t;
+
+enum clock_event_state {
+	CLOCK_EVT_STATE_DETACHED = 0,
+	CLOCK_EVT_STATE_SHUTDOWN = 1,
+	CLOCK_EVT_STATE_PERIODIC = 2,
+	CLOCK_EVT_STATE_ONESHOT = 3,
+	CLOCK_EVT_STATE_ONESHOT_STOPPED = 4,
+};
+
+struct clock_event_device {
+	void (*event_handler)(struct clock_event_device *);
+	int (*set_next_event)(long unsigned int, struct clock_event_device *);
+	int (*set_next_ktime)(ktime_t, struct clock_event_device *);
+	long: 32;
+	ktime_t next_event;
+	u64 max_delta_ns;
+	u64 min_delta_ns;
+	u32 mult;
+	u32 shift;
+	enum clock_event_state state_use_accessors;
+	unsigned int features;
+	long unsigned int retries;
+	int (*set_state_periodic)(struct clock_event_device *);
+	int (*set_state_oneshot)(struct clock_event_device *);
+	int (*set_state_oneshot_stopped)(struct clock_event_device *);
+	int (*set_state_shutdown)(struct clock_event_device *);
+	int (*tick_resume)(struct clock_event_device *);
+	void (*broadcast)(const struct cpumask *);
+	void (*suspend)(struct clock_event_device *);
+	void (*resume)(struct clock_event_device *);
+	long unsigned int min_delta_ticks;
+	long unsigned int max_delta_ticks;
+	const char *name;
+	int rating;
+	int irq;
+	int bound_on;
+	const struct cpumask *cpumask;
+	struct list_head list;
+	struct module *owner;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+enum tick_device_mode {
+	TICKDEV_MODE_PERIODIC = 0,
+	TICKDEV_MODE_ONESHOT = 1,
+};
+
+struct tick_device {
+	struct clock_event_device *evtdev;
+	enum tick_device_mode mode;
+};
+
+struct ce_unbind {
+	struct clock_event_device *ce;
+	int res;
+};
+
+enum memcg_memory_event {
+	MEMCG_LOW = 0,
+	MEMCG_HIGH = 1,
+	MEMCG_MAX = 2,
+	MEMCG_OOM = 3,
+	MEMCG_OOM_KILL = 4,
+	MEMCG_OOM_GROUP_KILL = 5,
+	MEMCG_SWAP_HIGH = 6,
+	MEMCG_SWAP_MAX = 7,
+	MEMCG_SWAP_FAIL = 8,
+	MEMCG_NR_MEMORY_EVENTS = 9,
+};
+
+enum page_memcg_data_flags {
+	MEMCG_DATA_OBJEXTS = 1,
+	MEMCG_DATA_KMEM = 2,
+	__NR_MEMCG_DATA_FLAGS = 4,
+};
+
+struct rt_waiter_node {
+	struct rb_node entry;
+	int prio;
+	u64 deadline;
+};
+
+struct rt_mutex_base;
+
+struct ww_acquire_ctx;
+
+struct rt_mutex_waiter {
+	struct rt_waiter_node tree;
+	struct rt_waiter_node pi_tree;
+	struct task_struct *task;
+	struct rt_mutex_base *lock;
+	unsigned int wake_state;
+	struct ww_acquire_ctx *ww_ctx;
+};
+
+struct robust_list {
+	struct robust_list *next;
+};
+
+struct robust_list_head {
+	struct robust_list list;
+	long int futex_offset;
+	struct robust_list *list_op_pending;
+};
+
+struct rt_mutex_base {
+	raw_spinlock_t wait_lock;
+	struct rb_root_cached waiters;
+	struct task_struct *owner;
+};
+
+union futex_key {
+	struct {
+		u64 i_seq;
+		long unsigned int pgoff;
+		unsigned int offset;
+	} shared;
+	struct {
+		union {
+			struct mm_struct *mm;
+			u64 __tmp;
+		};
+		long unsigned int address;
+		unsigned int offset;
+	} private;
+	struct {
+		u64 ptr;
+		long unsigned int word;
+		unsigned int offset;
+	} both;
+};
+
+struct futex_pi_state {
+	struct list_head list;
+	struct rt_mutex_base pi_mutex;
+	struct task_struct *owner;
+	refcount_t refcount;
+	union futex_key key;
+};
+
+struct hrtimer_sleeper {
+	struct hrtimer timer;
+	struct task_struct *task;
+	long: 32;
+};
+
+struct futex_hash_bucket {
+	atomic_t waiters;
+	spinlock_t lock;
+	struct plist_head chain;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct futex_q;
+
+typedef void futex_wake_fn(struct wake_q_head *, struct futex_q *);
+
+struct futex_q {
+	struct plist_node list;
+	struct task_struct *task;
+	spinlock_t *lock_ptr;
+	futex_wake_fn *wake;
+	void *wake_data;
+	long: 32;
+	union futex_key key;
+	struct futex_pi_state *pi_state;
+	struct rt_mutex_waiter *rt_waiter;
+	union futex_key *requeue_pi_key;
+	u32 bitset;
+	atomic_t requeue_state;
+	long: 32;
+};
+
+enum futex_access {
+	FUTEX_READ = 0,
+	FUTEX_WRITE = 1,
+};
+
+enum {
+	Q_REQUEUE_PI_NONE = 0,
+	Q_REQUEUE_PI_IGNORE = 1,
+	Q_REQUEUE_PI_IN_PROGRESS = 2,
+	Q_REQUEUE_PI_WAIT = 3,
+	Q_REQUEUE_PI_DONE = 4,
+	Q_REQUEUE_PI_LOCKED = 5,
+};
+
+typedef short unsigned int __kernel_uid_t;
+
+typedef short unsigned int __kernel_gid_t;
+
+typedef __kernel_uid_t __kernel_old_uid_t;
+
+typedef __kernel_gid_t __kernel_old_gid_t;
+
+typedef __kernel_old_uid_t old_uid_t;
+
+typedef __kernel_old_gid_t old_gid_t;
+
+struct fc_log;
+
+struct p_log {
+	const char *prefix;
+	struct fc_log *log;
+};
+
+enum fs_context_purpose {
+	FS_CONTEXT_FOR_MOUNT = 0,
+	FS_CONTEXT_FOR_SUBMOUNT = 1,
+	FS_CONTEXT_FOR_RECONFIGURE = 2,
+};
+
+enum fs_context_phase {
+	FS_CONTEXT_CREATE_PARAMS = 0,
+	FS_CONTEXT_CREATING = 1,
+	FS_CONTEXT_AWAITING_MOUNT = 2,
+	FS_CONTEXT_AWAITING_RECONF = 3,
+	FS_CONTEXT_RECONF_PARAMS = 4,
+	FS_CONTEXT_RECONFIGURING = 5,
+	FS_CONTEXT_FAILED = 6,
+};
+
+struct fs_context_operations;
+
+struct fs_context {
+	const struct fs_context_operations *ops;
+	struct mutex uapi_mutex;
+	struct file_system_type *fs_type;
+	void *fs_private;
+	void *sget_key;
+	struct dentry *root;
+	struct user_namespace *user_ns;
+	struct net *net_ns;
+	const struct cred *cred;
+	struct p_log log;
+	const char *source;
+	void *security;
+	void *s_fs_info;
+	unsigned int sb_flags;
+	unsigned int sb_flags_mask;
+	unsigned int s_iflags;
+	enum fs_context_purpose purpose: 8;
+	enum fs_context_phase phase: 8;
+	bool need_free: 1;
+	bool global: 1;
+	bool oldapi: 1;
+	bool exclusive: 1;
+};
+
+struct audit_names;
+
+struct filename {
+	const char *name;
+	const char *uptr;
+	atomic_t refcnt;
+	struct audit_names *aname;
+	const char iname[0];
+};
+
+struct nsset {
+	unsigned int flags;
+	struct nsproxy *nsproxy;
+	struct fs_struct *fs;
+	const struct cred *cred;
+};
+
+struct cgroup_taskset {
+	struct list_head src_csets;
+	struct list_head dst_csets;
+	int nr_tasks;
+	int ssid;
+	struct list_head *csets;
+	struct css_set *cur_cset;
+	struct task_struct *cur_task;
+};
+
+enum fs_value_type {
+	fs_value_is_undefined = 0,
+	fs_value_is_flag = 1,
+	fs_value_is_string = 2,
+	fs_value_is_blob = 3,
+	fs_value_is_filename = 4,
+	fs_value_is_file = 5,
+};
+
+struct fs_parameter {
+	const char *key;
+	enum fs_value_type type: 8;
+	union {
+		char *string;
+		void *blob;
+		struct filename *name;
+		struct file *file;
+	};
+	size_t size;
+	int dirfd;
+};
+
+struct fc_log {
+	refcount_t usage;
+	u8 head;
+	u8 tail;
+	u8 need_free;
+	struct module *owner;
+	char *buffer[8];
+};
+
+struct fs_context_operations {
+	void (*free)(struct fs_context *);
+	int (*dup)(struct fs_context *, struct fs_context *);
+	int (*parse_param)(struct fs_context *, struct fs_parameter *);
+	int (*parse_monolithic)(struct fs_context *, void *);
+	int (*get_tree)(struct fs_context *);
+	int (*reconfigure)(struct fs_context *);
+};
+
+struct fs_parse_result {
+	bool negated;
+	long: 32;
+	union {
+		bool boolean;
+		int int_32;
+		unsigned int uint_32;
+		u64 uint_64;
+		kuid_t uid;
+		kgid_t gid;
+	};
+};
+
+enum {
+	TASKSTATS_CMD_UNSPEC = 0,
+	TASKSTATS_CMD_GET = 1,
+	TASKSTATS_CMD_NEW = 2,
+	__TASKSTATS_CMD_MAX = 3,
+};
+
+enum cgroup_bpf_attach_type {
+	CGROUP_BPF_ATTACH_TYPE_INVALID = -1,
+	CGROUP_INET_INGRESS = 0,
+	CGROUP_INET_EGRESS = 1,
+	CGROUP_INET_SOCK_CREATE = 2,
+	CGROUP_SOCK_OPS = 3,
+	CGROUP_DEVICE = 4,
+	CGROUP_INET4_BIND = 5,
+	CGROUP_INET6_BIND = 6,
+	CGROUP_INET4_CONNECT = 7,
+	CGROUP_INET6_CONNECT = 8,
+	CGROUP_UNIX_CONNECT = 9,
+	CGROUP_INET4_POST_BIND = 10,
+	CGROUP_INET6_POST_BIND = 11,
+	CGROUP_UDP4_SENDMSG = 12,
+	CGROUP_UDP6_SENDMSG = 13,
+	CGROUP_UNIX_SENDMSG = 14,
+	CGROUP_SYSCTL = 15,
+	CGROUP_UDP4_RECVMSG = 16,
+	CGROUP_UDP6_RECVMSG = 17,
+	CGROUP_UNIX_RECVMSG = 18,
+	CGROUP_GETSOCKOPT = 19,
+	CGROUP_SETSOCKOPT = 20,
+	CGROUP_INET4_GETPEERNAME = 21,
+	CGROUP_INET6_GETPEERNAME = 22,
+	CGROUP_UNIX_GETPEERNAME = 23,
+	CGROUP_INET4_GETSOCKNAME = 24,
+	CGROUP_INET6_GETSOCKNAME = 25,
+	CGROUP_UNIX_GETSOCKNAME = 26,
+	CGROUP_INET_SOCK_RELEASE = 27,
+	CGROUP_LSM_START = 28,
+	CGROUP_LSM_END = 27,
+	MAX_CGROUP_BPF_ATTACH_TYPE = 28,
+};
+
+enum {
+	CGRP_ROOT_NOPREFIX = 2,
+	CGRP_ROOT_XATTR = 4,
+	CGRP_ROOT_NS_DELEGATE = 8,
+	CGRP_ROOT_FAVOR_DYNMODS = 16,
+	CGRP_ROOT_CPUSET_V2_MODE = 65536,
+	CGRP_ROOT_MEMORY_LOCAL_EVENTS = 131072,
+	CGRP_ROOT_MEMORY_RECURSIVE_PROT = 262144,
+	CGRP_ROOT_MEMORY_HUGETLB_ACCOUNTING = 524288,
+	CGRP_ROOT_PIDS_LOCAL_EVENTS = 1048576,
+};
+
+enum pidcg_event {
+	PIDCG_MAX = 0,
+	PIDCG_FORKFAIL = 1,
+	NR_PIDCG_EVENTS = 2,
+};
+
+struct pids_cgroup {
+	struct cgroup_subsys_state css;
+	atomic64_t counter;
+	atomic64_t limit;
+	int64_t watermark;
+	struct cgroup_file events_file;
+	struct cgroup_file events_local_file;
+	atomic64_t events[2];
+	atomic64_t events_local[2];
+};
+
+enum {
+	__PERCPU_REF_ATOMIC = 1,
+	__PERCPU_REF_DEAD = 2,
+	__PERCPU_REF_ATOMIC_DEAD = 3,
+	__PERCPU_REF_FLAG_BITS = 2,
+};
+
+enum {
+	CSS_NO_REF = 1,
+	CSS_ONLINE = 2,
+	CSS_RELEASED = 4,
+	CSS_VISIBLE = 8,
+	CSS_DYING = 16,
+};
+
+typedef struct {
+	char *from;
+	char *to;
+} substring_t;
+
+enum rdmacg_resource_type {
+	RDMACG_RESOURCE_HCA_HANDLE = 0,
+	RDMACG_RESOURCE_HCA_OBJECT = 1,
+	RDMACG_RESOURCE_MAX = 2,
+};
+
+struct rdma_cgroup {
+	struct cgroup_subsys_state css;
+	struct list_head rpools;
+};
+
+struct rdmacg_device {
+	struct list_head dev_node;
+	struct list_head rpools;
+	char *name;
+};
+
+enum rdmacg_file_type {
+	RDMACG_RESOURCE_TYPE_MAX = 0,
+	RDMACG_RESOURCE_TYPE_STAT = 1,
+};
+
+struct rdmacg_resource {
+	int max;
+	int usage;
+};
+
+struct rdmacg_resource_pool {
+	struct rdmacg_device *device;
+	struct rdmacg_resource resources[2];
+	struct list_head cg_node;
+	struct list_head dev_node;
+	long: 32;
+	u64 usage_sum;
+	int num_max_cnt;
+	long: 32;
+};
+
+struct __kernel_old_timeval {
+	__kernel_long_t tv_sec;
+	__kernel_long_t tv_usec;
+};
+
+struct rusage {
+	struct __kernel_old_timeval ru_utime;
+	struct __kernel_old_timeval ru_stime;
+	__kernel_long_t ru_maxrss;
+	__kernel_long_t ru_ixrss;
+	__kernel_long_t ru_idrss;
+	__kernel_long_t ru_isrss;
+	__kernel_long_t ru_minflt;
+	__kernel_long_t ru_majflt;
+	__kernel_long_t ru_nswap;
+	__kernel_long_t ru_inblock;
+	__kernel_long_t ru_oublock;
+	__kernel_long_t ru_msgsnd;
+	__kernel_long_t ru_msgrcv;
+	__kernel_long_t ru_nsignals;
+	__kernel_long_t ru_nvcsw;
+	__kernel_long_t ru_nivcsw;
+};
+
+enum uts_proc {
+	UTS_PROC_ARCH = 0,
+	UTS_PROC_OSTYPE = 1,
+	UTS_PROC_OSRELEASE = 2,
+	UTS_PROC_VERSION = 3,
+	UTS_PROC_HOSTNAME = 4,
+	UTS_PROC_DOMAINNAME = 5,
+};
+
+struct tp_module {
+	struct list_head list;
+	struct module *mod;
+};
+
+enum tp_func_state {
+	TP_FUNC_0 = 0,
+	TP_FUNC_1 = 1,
+	TP_FUNC_2 = 2,
+	TP_FUNC_N = 3,
+};
+
+enum tp_transition_sync {
+	TP_TRANSITION_SYNC_1_0_1 = 0,
+	TP_TRANSITION_SYNC_N_2_1 = 1,
+	_NR_TP_TRANSITION_SYNC = 2,
+};
+
+struct tp_transition_snapshot {
+	long unsigned int rcu;
+	long unsigned int srcu;
+	bool ongoing;
+};
+
+struct tp_probes {
+	struct callback_head rcu;
+	struct tracepoint_func probes[0];
+};
+
+struct trace_buffer_meta {
+	__u32 meta_page_size;
+	__u32 meta_struct_len;
+	__u32 subbuf_size;
+	__u32 nr_subbufs;
+	struct {
+		__u64 lost_events;
+		__u32 id;
+		__u32 read;
+	} reader;
+	__u64 flags;
+	__u64 entries;
+	__u64 overrun;
+	__u64 read;
+	__u64 Reserved1;
+	__u64 Reserved2;
+};
+
+enum ring_buffer_type {
+	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,
+	RINGBUF_TYPE_PADDING = 29,
+	RINGBUF_TYPE_TIME_EXTEND = 30,
+	RINGBUF_TYPE_TIME_STAMP = 31,
+};
+
+typedef bool (*ring_buffer_cond_fn)(void *);
+
+enum ring_buffer_flags {
+	RB_FL_OVERWRITE = 1,
+};
+
+struct prog_entry;
+
+struct event_filter {
+	struct prog_entry *prog;
+	char *filter_string;
+};
+
+struct trace_array_cpu;
+
+struct array_buffer {
+	struct trace_array *tr;
+	struct trace_buffer *buffer;
+	struct trace_array_cpu *data;
+	long: 32;
+	u64 time_start;
+	int cpu;
+	long: 32;
+};
+
+struct trace_pid_list;
+
+struct trace_options;
+
+struct trace_func_repeats;
+
+struct trace_array {
+	struct list_head list;
+	char *name;
+	long: 32;
+	struct array_buffer array_buffer;
+	unsigned int mapped;
+	long unsigned int range_addr_start;
+	long unsigned int range_addr_size;
+	long int text_delta;
+	long int data_delta;
+	struct trace_pid_list *filtered_pids;
+	struct trace_pid_list *filtered_no_pids;
+	arch_spinlock_t max_lock;
+	int buffer_disabled;
+	int stop_count;
+	int clock_id;
+	int nr_topts;
+	bool clear_trace;
+	int buffer_percent;
+	unsigned int n_err_log_entries;
+	struct tracer *current_trace;
+	unsigned int trace_flags;
+	unsigned char trace_flags_index[32];
+	unsigned int flags;
+	raw_spinlock_t start_lock;
+	const char *system_names;
+	struct list_head err_log;
+	struct dentry *dir;
+	struct dentry *options;
+	struct dentry *percpu_dir;
+	struct eventfs_inode *event_dir;
+	struct trace_options *topts;
+	struct list_head systems;
+	struct list_head events;
+	struct trace_event_file *trace_marker_file;
+	cpumask_var_t tracing_cpumask;
+	cpumask_var_t pipe_cpumask;
+	int ref;
+	int trace_ref;
+	int no_filter_buffering_ref;
+	struct list_head hist_vars;
+	struct trace_func_repeats *last_func_repeats;
+	bool ring_buffer_expanded;
+	long: 32;
+};
+
+struct tracer_flags;
+
+struct tracer {
+	const char *name;
+	int (*init)(struct trace_array *);
+	void (*reset)(struct trace_array *);
+	void (*start)(struct trace_array *);
+	void (*stop)(struct trace_array *);
+	int (*update_thresh)(struct trace_array *);
+	void (*open)(struct trace_iterator *);
+	void (*pipe_open)(struct trace_iterator *);
+	void (*close)(struct trace_iterator *);
+	void (*pipe_close)(struct trace_iterator *);
+	ssize_t (*read)(struct trace_iterator *, struct file *, char *, size_t, loff_t *);
+	ssize_t (*splice_read)(struct trace_iterator *, struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
+	void (*print_header)(struct seq_file *);
+	enum print_line_t (*print_line)(struct trace_iterator *);
+	int (*set_flag)(struct trace_array *, u32, u32, int);
+	int (*flag_changed)(struct trace_array *, u32, int);
+	struct tracer *next;
+	struct tracer_flags *flags;
+	int enabled;
+	bool print_max;
+	bool allow_instances;
+	bool noboot;
+};
+
+struct ring_buffer_per_cpu;
+
+struct buffer_page;
+
+struct ring_buffer_iter {
+	struct ring_buffer_per_cpu *cpu_buffer;
+	long unsigned int head;
+	long unsigned int next_event;
+	struct buffer_page *head_page;
+	struct buffer_page *cache_reader_page;
+	long unsigned int cache_read;
+	long unsigned int cache_pages_removed;
+	long: 32;
+	u64 read_stamp;
+	u64 page_stamp;
+	struct ring_buffer_event *event;
+	size_t event_size;
+	int missed_events;
+	long: 32;
+};
+
+struct rb_irq_work {
+	struct irq_work work;
+	wait_queue_head_t waiters;
+	wait_queue_head_t full_waiters;
+	atomic_t seq;
+	bool waiters_pending;
+	bool full_waiters_pending;
+	bool wakeup_full;
+};
+
+struct trace_buffer {
+	unsigned int flags;
+	int cpus;
+	atomic_t record_disabled;
+	atomic_t resizing;
+	cpumask_var_t cpumask;
+	struct lock_class_key *reader_lock_key;
+	struct mutex mutex;
+	struct ring_buffer_per_cpu **buffers;
+	struct hlist_node node;
+	u64 (*clock)();
+	struct rb_irq_work irq_work;
+	bool time_stamp_abs;
+	long unsigned int range_addr_start;
+	long unsigned int range_addr_end;
+	long int last_text_delta;
+	long int last_data_delta;
+	unsigned int subbuf_size;
+	unsigned int subbuf_order;
+	unsigned int max_data_size;
+};
+
+struct event_subsystem;
+
+struct trace_subsystem_dir {
+	struct list_head list;
+	struct event_subsystem *subsystem;
+	struct trace_array *tr;
+	struct eventfs_inode *ei;
+	int ref_count;
+	int nr_events;
+};
+
+union lower_chunk {
+	union lower_chunk *next;
+	long unsigned int data[512];
+};
+
+union upper_chunk {
+	union upper_chunk *next;
+	union lower_chunk *data[256];
+};
+
+struct trace_pid_list {
+	raw_spinlock_t lock;
+	struct irq_work refill_irqwork;
+	union upper_chunk *upper[256];
+	union upper_chunk *upper_list;
+	union lower_chunk *lower_list;
+	int free_upper_chunks;
+	int free_lower_chunks;
+};
+
+struct trace_array_cpu {
+	atomic_t disabled;
+	void *buffer_page;
+	long unsigned int entries;
+	long unsigned int saved_latency;
+	long unsigned int critical_start;
+	long unsigned int critical_end;
+	long unsigned int critical_sequence;
+	long unsigned int nice;
+	long unsigned int policy;
+	long unsigned int rt_priority;
+	long unsigned int skipped_entries;
+	long: 32;
+	u64 preempt_timestamp;
+	pid_t pid;
+	kuid_t uid;
+	char comm[16];
+	bool ignore_pid;
+	long: 32;
+};
+
+struct trace_option_dentry;
+
+struct trace_options {
+	struct tracer *tracer;
+	struct trace_option_dentry *topts;
+};
+
+struct tracer_opt;
+
+struct trace_option_dentry {
+	struct tracer_opt *opt;
+	struct tracer_flags *flags;
+	struct trace_array *tr;
+	struct dentry *entry;
+};
+
+struct trace_func_repeats {
+	long unsigned int ip;
+	long unsigned int parent_ip;
+	long unsigned int count;
+	long: 32;
+	u64 ts_last_call;
+};
+
+struct tracer_opt {
+	const char *name;
+	u32 bit;
+};
+
+struct tracer_flags {
+	u32 val;
+	struct tracer_opt *opts;
+	struct tracer *trace;
+};
+
+enum trace_iterator_bits {
+	TRACE_ITER_PRINT_PARENT_BIT = 0,
+	TRACE_ITER_SYM_OFFSET_BIT = 1,
+	TRACE_ITER_SYM_ADDR_BIT = 2,
+	TRACE_ITER_VERBOSE_BIT = 3,
+	TRACE_ITER_RAW_BIT = 4,
+	TRACE_ITER_HEX_BIT = 5,
+	TRACE_ITER_BIN_BIT = 6,
+	TRACE_ITER_BLOCK_BIT = 7,
+	TRACE_ITER_FIELDS_BIT = 8,
+	TRACE_ITER_PRINTK_BIT = 9,
+	TRACE_ITER_ANNOTATE_BIT = 10,
+	TRACE_ITER_USERSTACKTRACE_BIT = 11,
+	TRACE_ITER_SYM_USEROBJ_BIT = 12,
+	TRACE_ITER_PRINTK_MSGONLY_BIT = 13,
+	TRACE_ITER_CONTEXT_INFO_BIT = 14,
+	TRACE_ITER_LATENCY_FMT_BIT = 15,
+	TRACE_ITER_RECORD_CMD_BIT = 16,
+	TRACE_ITER_RECORD_TGID_BIT = 17,
+	TRACE_ITER_OVERWRITE_BIT = 18,
+	TRACE_ITER_STOP_ON_FREE_BIT = 19,
+	TRACE_ITER_IRQ_INFO_BIT = 20,
+	TRACE_ITER_MARKERS_BIT = 21,
+	TRACE_ITER_EVENT_FORK_BIT = 22,
+	TRACE_ITER_TRACE_PRINTK_BIT = 23,
+	TRACE_ITER_PAUSE_ON_TRACE_BIT = 24,
+	TRACE_ITER_HASH_PTR_BIT = 25,
+	TRACE_ITER_STACKTRACE_BIT = 26,
+	TRACE_ITER_LAST_BIT = 27,
+};
+
+struct event_subsystem {
+	struct list_head list;
+	const char *name;
+	struct event_filter *filter;
+	int ref_count;
+};
+
+struct ring_buffer_meta {
+	int magic;
+	int struct_size;
+	long unsigned int text_addr;
+	long unsigned int data_addr;
+	long unsigned int first_buffer;
+	long unsigned int head_buffer;
+	long unsigned int commit_buffer;
+	__u32 subbuf_size;
+	__u32 nr_subbufs;
+	int buffers[0];
+};
+
+enum {
+	RB_LEN_TIME_EXTEND = 8,
+	RB_LEN_TIME_STAMP = 8,
+};
+
+struct buffer_data_page {
+	u64 time_stamp;
+	local_t commit;
+	unsigned char data[0];
+	long: 32;
+};
+
+struct buffer_data_read_page {
+	unsigned int order;
+	struct buffer_data_page *data;
+};
+
+struct buffer_page {
+	struct list_head list;
+	local_t write;
+	unsigned int read;
+	local_t entries;
+	long unsigned int real_end;
+	unsigned int order;
+	u32 id: 30;
+	u32 range: 1;
+	struct buffer_data_page *page;
+};
+
+struct rb_event_info {
+	u64 ts;
+	u64 delta;
+	u64 before;
+	u64 after;
+	long unsigned int length;
+	struct buffer_page *tail_page;
+	int add_timestamp;
+	long: 32;
+};
+
+enum {
+	RB_ADD_STAMP_NONE = 0,
+	RB_ADD_STAMP_EXTEND = 2,
+	RB_ADD_STAMP_ABSOLUTE = 4,
+	RB_ADD_STAMP_FORCE = 8,
+};
+
+enum {
+	RB_CTX_TRANSITION = 0,
+	RB_CTX_NMI = 1,
+	RB_CTX_IRQ = 2,
+	RB_CTX_SOFTIRQ = 3,
+	RB_CTX_NORMAL = 4,
+	RB_CTX_MAX = 5,
+};
+
+struct rb_time_struct {
+	local64_t time;
+};
+
+typedef struct rb_time_struct rb_time_t;
+
+struct ring_buffer_per_cpu {
+	int cpu;
+	atomic_t record_disabled;
+	atomic_t resize_disabled;
+	struct trace_buffer *buffer;
+	raw_spinlock_t reader_lock;
+	arch_spinlock_t lock;
+	struct lock_class_key lock_key;
+	struct buffer_data_page *free_page;
+	long unsigned int nr_pages;
+	unsigned int current_context;
+	struct list_head *pages;
+	struct buffer_page *head_page;
+	struct buffer_page *tail_page;
+	struct buffer_page *commit_page;
+	struct buffer_page *reader_page;
+	long unsigned int lost_events;
+	long unsigned int last_overrun;
+	long unsigned int nest;
+	local_t entries_bytes;
+	local_t entries;
+	local_t overrun;
+	local_t commit_overrun;
+	local_t dropped_events;
+	local_t committing;
+	local_t commits;
+	local_t pages_touched;
+	local_t pages_lost;
+	local_t pages_read;
+	long int last_pages_touch;
+	size_t shortest_full;
+	long unsigned int read;
+	long unsigned int read_bytes;
+	long: 32;
+	rb_time_t write_stamp;
+	rb_time_t before_stamp;
+	u64 event_stamp[5];
+	u64 read_stamp;
+	long unsigned int pages_removed;
+	unsigned int mapped;
+	unsigned int user_mapped;
+	struct mutex mapping_lock;
+	long unsigned int *subbuf_ids;
+	struct trace_buffer_meta *meta_page;
+	struct ring_buffer_meta *ring_meta;
+	long int nr_pages_to_update;
+	struct list_head new_pages;
+	struct work_struct update_pages_work;
+	struct completion update_done;
+	struct rb_irq_work irq_work;
+};
+
+struct rb_wait_data {
+	struct rb_irq_work *irq_work;
+	int seq;
+};
+
+enum lockdown_reason {
+	LOCKDOWN_NONE = 0,
+	LOCKDOWN_MODULE_SIGNATURE = 1,
+	LOCKDOWN_DEV_MEM = 2,
+	LOCKDOWN_EFI_TEST = 3,
+	LOCKDOWN_KEXEC = 4,
+	LOCKDOWN_HIBERNATION = 5,
+	LOCKDOWN_PCI_ACCESS = 6,
+	LOCKDOWN_IOPORT = 7,
+	LOCKDOWN_MSR = 8,
+	LOCKDOWN_ACPI_TABLES = 9,
+	LOCKDOWN_DEVICE_TREE = 10,
+	LOCKDOWN_PCMCIA_CIS = 11,
+	LOCKDOWN_TIOCSSERIAL = 12,
+	LOCKDOWN_MODULE_PARAMETERS = 13,
+	LOCKDOWN_MMIOTRACE = 14,
+	LOCKDOWN_DEBUGFS = 15,
+	LOCKDOWN_XMON_WR = 16,
+	LOCKDOWN_BPF_WRITE_USER = 17,
+	LOCKDOWN_DBG_WRITE_KERNEL = 18,
+	LOCKDOWN_RTAS_ERROR_INJECTION = 19,
+	LOCKDOWN_INTEGRITY_MAX = 20,
+	LOCKDOWN_KCORE = 21,
+	LOCKDOWN_KPROBES = 22,
+	LOCKDOWN_BPF_READ_KERNEL = 23,
+	LOCKDOWN_DBG_READ_KERNEL = 24,
+	LOCKDOWN_PERF = 25,
+	LOCKDOWN_TRACEFS = 26,
+	LOCKDOWN_XMON_RW = 27,
+	LOCKDOWN_XFRM_SECRET = 28,
+	LOCKDOWN_CONFIDENTIALITY_MAX = 29,
+};
+
+struct tracer_stat {
+	const char *name;
+	void * (*stat_start)(struct tracer_stat *);
+	void * (*stat_next)(void *, int);
+	cmp_func_t stat_cmp;
+	int (*stat_show)(struct seq_file *, void *);
+	void (*stat_release)(void *);
+	int (*stat_headers)(struct seq_file *);
+};
+
+struct stat_node {
+	struct rb_node node;
+	void *stat;
+};
+
+struct stat_session {
+	struct list_head session_list;
+	struct tracer_stat *ts;
+	struct rb_root stat_root;
+	struct mutex stat_mutex;
+	struct dentry *file;
+};
+
+struct saved_cmdlines_buffer {
+	unsigned int map_pid_to_cmdline[32769];
+	unsigned int *map_cmdline_to_pid;
+	unsigned int cmdline_num;
+	int cmdline_idx;
+	char saved_cmdlines[0];
+};
+
+enum trace_type {
+	__TRACE_FIRST_TYPE = 0,
+	TRACE_FN = 1,
+	TRACE_CTX = 2,
+	TRACE_WAKE = 3,
+	TRACE_STACK = 4,
+	TRACE_PRINT = 5,
+	TRACE_BPRINT = 6,
+	TRACE_MMIO_RW = 7,
+	TRACE_MMIO_MAP = 8,
+	TRACE_BRANCH = 9,
+	TRACE_GRAPH_RET = 10,
+	TRACE_GRAPH_ENT = 11,
+	TRACE_USER_STACK = 12,
+	TRACE_BLK = 13,
+	TRACE_BPUTS = 14,
+	TRACE_HWLAT = 15,
+	TRACE_OSNOISE = 16,
+	TRACE_TIMERLAT = 17,
+	TRACE_RAW_DATA = 18,
+	TRACE_FUNC_REPEATS = 19,
+	__TRACE_LAST_TYPE = 20,
+};
+
+struct bpf_local_storage_data;
+
+struct bpf_local_storage {
+	struct bpf_local_storage_data *cache[16];
+	struct bpf_local_storage_map *smap;
+	struct hlist_head list;
+	void *owner;
+	struct callback_head rcu;
+	raw_spinlock_t lock;
+};
+
+enum {
+	BPF_REG_0 = 0,
+	BPF_REG_1 = 1,
+	BPF_REG_2 = 2,
+	BPF_REG_3 = 3,
+	BPF_REG_4 = 4,
+	BPF_REG_5 = 5,
+	BPF_REG_6 = 6,
+	BPF_REG_7 = 7,
+	BPF_REG_8 = 8,
+	BPF_REG_9 = 9,
+	BPF_REG_10 = 10,
+	__MAX_BPF_REG = 11,
+};
+
+enum bpf_func_id {
+	BPF_FUNC_unspec = 0,
+	BPF_FUNC_map_lookup_elem = 1,
+	BPF_FUNC_map_update_elem = 2,
+	BPF_FUNC_map_delete_elem = 3,
+	BPF_FUNC_probe_read = 4,
+	BPF_FUNC_ktime_get_ns = 5,
+	BPF_FUNC_trace_printk = 6,
+	BPF_FUNC_get_prandom_u32 = 7,
+	BPF_FUNC_get_smp_processor_id = 8,
+	BPF_FUNC_skb_store_bytes = 9,
+	BPF_FUNC_l3_csum_replace = 10,
+	BPF_FUNC_l4_csum_replace = 11,
+	BPF_FUNC_tail_call = 12,
+	BPF_FUNC_clone_redirect = 13,
+	BPF_FUNC_get_current_pid_tgid = 14,
+	BPF_FUNC_get_current_uid_gid = 15,
+	BPF_FUNC_get_current_comm = 16,
+	BPF_FUNC_get_cgroup_classid = 17,
+	BPF_FUNC_skb_vlan_push = 18,
+	BPF_FUNC_skb_vlan_pop = 19,
+	BPF_FUNC_skb_get_tunnel_key = 20,
+	BPF_FUNC_skb_set_tunnel_key = 21,
+	BPF_FUNC_perf_event_read = 22,
+	BPF_FUNC_redirect = 23,
+	BPF_FUNC_get_route_realm = 24,
+	BPF_FUNC_perf_event_output = 25,
+	BPF_FUNC_skb_load_bytes = 26,
+	BPF_FUNC_get_stackid = 27,
+	BPF_FUNC_csum_diff = 28,
+	BPF_FUNC_skb_get_tunnel_opt = 29,
+	BPF_FUNC_skb_set_tunnel_opt = 30,
+	BPF_FUNC_skb_change_proto = 31,
+	BPF_FUNC_skb_change_type = 32,
+	BPF_FUNC_skb_under_cgroup = 33,
+	BPF_FUNC_get_hash_recalc = 34,
+	BPF_FUNC_get_current_task = 35,
+	BPF_FUNC_probe_write_user = 36,
+	BPF_FUNC_current_task_under_cgroup = 37,
+	BPF_FUNC_skb_change_tail = 38,
+	BPF_FUNC_skb_pull_data = 39,
+	BPF_FUNC_csum_update = 40,
+	BPF_FUNC_set_hash_invalid = 41,
+	BPF_FUNC_get_numa_node_id = 42,
+	BPF_FUNC_skb_change_head = 43,
+	BPF_FUNC_xdp_adjust_head = 44,
+	BPF_FUNC_probe_read_str = 45,
+	BPF_FUNC_get_socket_cookie = 46,
+	BPF_FUNC_get_socket_uid = 47,
+	BPF_FUNC_set_hash = 48,
+	BPF_FUNC_setsockopt = 49,
+	BPF_FUNC_skb_adjust_room = 50,
+	BPF_FUNC_redirect_map = 51,
+	BPF_FUNC_sk_redirect_map = 52,
+	BPF_FUNC_sock_map_update = 53,
+	BPF_FUNC_xdp_adjust_meta = 54,
+	BPF_FUNC_perf_event_read_value = 55,
+	BPF_FUNC_perf_prog_read_value = 56,
+	BPF_FUNC_getsockopt = 57,
+	BPF_FUNC_override_return = 58,
+	BPF_FUNC_sock_ops_cb_flags_set = 59,
+	BPF_FUNC_msg_redirect_map = 60,
+	BPF_FUNC_msg_apply_bytes = 61,
+	BPF_FUNC_msg_cork_bytes = 62,
+	BPF_FUNC_msg_pull_data = 63,
+	BPF_FUNC_bind = 64,
+	BPF_FUNC_xdp_adjust_tail = 65,
+	BPF_FUNC_skb_get_xfrm_state = 66,
+	BPF_FUNC_get_stack = 67,
+	BPF_FUNC_skb_load_bytes_relative = 68,
+	BPF_FUNC_fib_lookup = 69,
+	BPF_FUNC_sock_hash_update = 70,
+	BPF_FUNC_msg_redirect_hash = 71,
+	BPF_FUNC_sk_redirect_hash = 72,
+	BPF_FUNC_lwt_push_encap = 73,
+	BPF_FUNC_lwt_seg6_store_bytes = 74,
+	BPF_FUNC_lwt_seg6_adjust_srh = 75,
+	BPF_FUNC_lwt_seg6_action = 76,
+	BPF_FUNC_rc_repeat = 77,
+	BPF_FUNC_rc_keydown = 78,
+	BPF_FUNC_skb_cgroup_id = 79,
+	BPF_FUNC_get_current_cgroup_id = 80,
+	BPF_FUNC_get_local_storage = 81,
+	BPF_FUNC_sk_select_reuseport = 82,
+	BPF_FUNC_skb_ancestor_cgroup_id = 83,
+	BPF_FUNC_sk_lookup_tcp = 84,
+	BPF_FUNC_sk_lookup_udp = 85,
+	BPF_FUNC_sk_release = 86,
+	BPF_FUNC_map_push_elem = 87,
+	BPF_FUNC_map_pop_elem = 88,
+	BPF_FUNC_map_peek_elem = 89,
+	BPF_FUNC_msg_push_data = 90,
+	BPF_FUNC_msg_pop_data = 91,
+	BPF_FUNC_rc_pointer_rel = 92,
+	BPF_FUNC_spin_lock = 93,
+	BPF_FUNC_spin_unlock = 94,
+	BPF_FUNC_sk_fullsock = 95,
+	BPF_FUNC_tcp_sock = 96,
+	BPF_FUNC_skb_ecn_set_ce = 97,
+	BPF_FUNC_get_listener_sock = 98,
+	BPF_FUNC_skc_lookup_tcp = 99,
+	BPF_FUNC_tcp_check_syncookie = 100,
+	BPF_FUNC_sysctl_get_name = 101,
+	BPF_FUNC_sysctl_get_current_value = 102,
+	BPF_FUNC_sysctl_get_new_value = 103,
+	BPF_FUNC_sysctl_set_new_value = 104,
+	BPF_FUNC_strtol = 105,
+	BPF_FUNC_strtoul = 106,
+	BPF_FUNC_sk_storage_get = 107,
+	BPF_FUNC_sk_storage_delete = 108,
+	BPF_FUNC_send_signal = 109,
+	BPF_FUNC_tcp_gen_syncookie = 110,
+	BPF_FUNC_skb_output = 111,
+	BPF_FUNC_probe_read_user = 112,
+	BPF_FUNC_probe_read_kernel = 113,
+	BPF_FUNC_probe_read_user_str = 114,
+	BPF_FUNC_probe_read_kernel_str = 115,
+	BPF_FUNC_tcp_send_ack = 116,
+	BPF_FUNC_send_signal_thread = 117,
+	BPF_FUNC_jiffies64 = 118,
+	BPF_FUNC_read_branch_records = 119,
+	BPF_FUNC_get_ns_current_pid_tgid = 120,
+	BPF_FUNC_xdp_output = 121,
+	BPF_FUNC_get_netns_cookie = 122,
+	BPF_FUNC_get_current_ancestor_cgroup_id = 123,
+	BPF_FUNC_sk_assign = 124,
+	BPF_FUNC_ktime_get_boot_ns = 125,
+	BPF_FUNC_seq_printf = 126,
+	BPF_FUNC_seq_write = 127,
+	BPF_FUNC_sk_cgroup_id = 128,
+	BPF_FUNC_sk_ancestor_cgroup_id = 129,
+	BPF_FUNC_ringbuf_output = 130,
+	BPF_FUNC_ringbuf_reserve = 131,
+	BPF_FUNC_ringbuf_submit = 132,
+	BPF_FUNC_ringbuf_discard = 133,
+	BPF_FUNC_ringbuf_query = 134,
+	BPF_FUNC_csum_level = 135,
+	BPF_FUNC_skc_to_tcp6_sock = 136,
+	BPF_FUNC_skc_to_tcp_sock = 137,
+	BPF_FUNC_skc_to_tcp_timewait_sock = 138,
+	BPF_FUNC_skc_to_tcp_request_sock = 139,
+	BPF_FUNC_skc_to_udp6_sock = 140,
+	BPF_FUNC_get_task_stack = 141,
+	BPF_FUNC_load_hdr_opt = 142,
+	BPF_FUNC_store_hdr_opt = 143,
+	BPF_FUNC_reserve_hdr_opt = 144,
+	BPF_FUNC_inode_storage_get = 145,
+	BPF_FUNC_inode_storage_delete = 146,
+	BPF_FUNC_d_path = 147,
+	BPF_FUNC_copy_from_user = 148,
+	BPF_FUNC_snprintf_btf = 149,
+	BPF_FUNC_seq_printf_btf = 150,
+	BPF_FUNC_skb_cgroup_classid = 151,
+	BPF_FUNC_redirect_neigh = 152,
+	BPF_FUNC_per_cpu_ptr = 153,
+	BPF_FUNC_this_cpu_ptr = 154,
+	BPF_FUNC_redirect_peer = 155,
+	BPF_FUNC_task_storage_get = 156,
+	BPF_FUNC_task_storage_delete = 157,
+	BPF_FUNC_get_current_task_btf = 158,
+	BPF_FUNC_bprm_opts_set = 159,
+	BPF_FUNC_ktime_get_coarse_ns = 160,
+	BPF_FUNC_ima_inode_hash = 161,
+	BPF_FUNC_sock_from_file = 162,
+	BPF_FUNC_check_mtu = 163,
+	BPF_FUNC_for_each_map_elem = 164,
+	BPF_FUNC_snprintf = 165,
+	BPF_FUNC_sys_bpf = 166,
+	BPF_FUNC_btf_find_by_name_kind = 167,
+	BPF_FUNC_sys_close = 168,
+	BPF_FUNC_timer_init = 169,
+	BPF_FUNC_timer_set_callback = 170,
+	BPF_FUNC_timer_start = 171,
+	BPF_FUNC_timer_cancel = 172,
+	BPF_FUNC_get_func_ip = 173,
+	BPF_FUNC_get_attach_cookie = 174,
+	BPF_FUNC_task_pt_regs = 175,
+	BPF_FUNC_get_branch_snapshot = 176,
+	BPF_FUNC_trace_vprintk = 177,
+	BPF_FUNC_skc_to_unix_sock = 178,
+	BPF_FUNC_kallsyms_lookup_name = 179,
+	BPF_FUNC_find_vma = 180,
+	BPF_FUNC_loop = 181,
+	BPF_FUNC_strncmp = 182,
+	BPF_FUNC_get_func_arg = 183,
+	BPF_FUNC_get_func_ret = 184,
+	BPF_FUNC_get_func_arg_cnt = 185,
+	BPF_FUNC_get_retval = 186,
+	BPF_FUNC_set_retval = 187,
+	BPF_FUNC_xdp_get_buff_len = 188,
+	BPF_FUNC_xdp_load_bytes = 189,
+	BPF_FUNC_xdp_store_bytes = 190,
+	BPF_FUNC_copy_from_user_task = 191,
+	BPF_FUNC_skb_set_tstamp = 192,
+	BPF_FUNC_ima_file_hash = 193,
+	BPF_FUNC_kptr_xchg = 194,
+	BPF_FUNC_map_lookup_percpu_elem = 195,
+	BPF_FUNC_skc_to_mptcp_sock = 196,
+	BPF_FUNC_dynptr_from_mem = 197,
+	BPF_FUNC_ringbuf_reserve_dynptr = 198,
+	BPF_FUNC_ringbuf_submit_dynptr = 199,
+	BPF_FUNC_ringbuf_discard_dynptr = 200,
+	BPF_FUNC_dynptr_read = 201,
+	BPF_FUNC_dynptr_write = 202,
+	BPF_FUNC_dynptr_data = 203,
+	BPF_FUNC_tcp_raw_gen_syncookie_ipv4 = 204,
+	BPF_FUNC_tcp_raw_gen_syncookie_ipv6 = 205,
+	BPF_FUNC_tcp_raw_check_syncookie_ipv4 = 206,
+	BPF_FUNC_tcp_raw_check_syncookie_ipv6 = 207,
+	BPF_FUNC_ktime_get_tai_ns = 208,
+	BPF_FUNC_user_ringbuf_drain = 209,
+	BPF_FUNC_cgrp_storage_get = 210,
+	BPF_FUNC_cgrp_storage_delete = 211,
+	__BPF_FUNC_MAX_ID = 212,
+};
+
+enum {
+	BPF_F_INDEX_MASK = 4294967295ULL,
+	BPF_F_CURRENT_CPU = 4294967295ULL,
+	BPF_F_CTXLEN_MASK = 4503595332403200ULL,
+};
+
+enum {
+	BPF_F_GET_BRANCH_RECORDS_SIZE = 1,
+};
+
+struct bpf_perf_event_value {
+	__u64 counter;
+	__u64 enabled;
+	__u64 running;
+};
+
+struct bpf_raw_tracepoint_args {
+	__u64 args[0];
+};
+
+enum bpf_task_fd_type {
+	BPF_FD_TYPE_RAW_TRACEPOINT = 0,
+	BPF_FD_TYPE_TRACEPOINT = 1,
+	BPF_FD_TYPE_KPROBE = 2,
+	BPF_FD_TYPE_KRETPROBE = 3,
+	BPF_FD_TYPE_UPROBE = 4,
+	BPF_FD_TYPE_URETPROBE = 5,
+};
+
+struct btf_ptr {
+	void *ptr;
+	__u32 type_id;
+	__u32 flags;
+};
+
+enum {
+	BTF_F_COMPACT = 1,
+	BTF_F_NONAME = 2,
+	BTF_F_PTR_RAW = 4,
+	BTF_F_ZERO = 8,
+};
+
+enum key_need_perm {
+	KEY_NEED_UNSPECIFIED = 0,
+	KEY_NEED_VIEW = 1,
+	KEY_NEED_READ = 2,
+	KEY_NEED_WRITE = 3,
+	KEY_NEED_SEARCH = 4,
+	KEY_NEED_LINK = 5,
+	KEY_NEED_SETATTR = 6,
+	KEY_NEED_UNLINK = 7,
+	KEY_SYSADMIN_OVERRIDE = 8,
+	KEY_AUTHTOKEN_OVERRIDE = 9,
+	KEY_DEFER_PERM_CHECK = 10,
+};
+
+enum key_lookup_flag {
+	KEY_LOOKUP_CREATE = 1,
+	KEY_LOOKUP_PARTIAL = 2,
+	KEY_LOOKUP_ALL = 3,
+};
+
+struct __key_reference_with_attributes;
+
+typedef struct __key_reference_with_attributes *key_ref_t;
+
+typedef sockptr_t bpfptr_t;
+
+struct btf_id_set {
+	u32 cnt;
+	u32 ids[0];
+};
+
+struct btf_id_set8 {
+	u32 cnt;
+	u32 flags;
+	struct {
+		u32 id;
+		u32 flags;
+	} pairs[0];
+};
+
+enum {
+	BTF_TRACING_TYPE_TASK = 0,
+	BTF_TRACING_TYPE_FILE = 1,
+	BTF_TRACING_TYPE_VMA = 2,
+	MAX_BTF_TRACING_TYPE = 3,
+};
+
+typedef int (*btf_kfunc_filter_t)(const struct bpf_prog *, u32);
+
+struct btf_kfunc_id_set {
+	struct module *owner;
+	struct btf_id_set8 *set;
+	btf_kfunc_filter_t filter;
+};
+
+struct btf_struct_meta {
+	u32 btf_id;
+	struct btf_record *record;
+};
+
+struct bpf_mem_caches;
+
+struct bpf_mem_cache;
+
+struct bpf_mem_alloc {
+	struct bpf_mem_caches *caches;
+	struct bpf_mem_cache *cache;
+	struct obj_cgroup *objcg;
+	bool percpu;
+	struct work_struct work;
+};
+
+typedef unsigned int (*bpf_func_t)(const void *, const struct bpf_insn *);
+
+struct bpf_local_storage_map_bucket;
+
+struct bpf_local_storage_map {
+	struct bpf_map map;
+	struct bpf_local_storage_map_bucket *buckets;
+	u32 bucket_log;
+	u16 elem_size;
+	u16 cache_idx;
+	struct bpf_mem_alloc selem_ma;
+	struct bpf_mem_alloc storage_ma;
+	bool bpf_ma;
+};
+
+struct bpf_verifier_log {
+	u64 start_pos;
+	u64 end_pos;
+	char *ubuf;
+	u32 level;
+	u32 len_total;
+	u32 len_max;
+	char kbuf[1024];
+};
+
+enum bpf_arg_type {
+	ARG_DONTCARE = 0,
+	ARG_CONST_MAP_PTR = 1,
+	ARG_PTR_TO_MAP_KEY = 2,
+	ARG_PTR_TO_MAP_VALUE = 3,
+	ARG_PTR_TO_MEM = 4,
+	ARG_PTR_TO_ARENA = 5,
+	ARG_CONST_SIZE = 6,
+	ARG_CONST_SIZE_OR_ZERO = 7,
+	ARG_PTR_TO_CTX = 8,
+	ARG_ANYTHING = 9,
+	ARG_PTR_TO_SPIN_LOCK = 10,
+	ARG_PTR_TO_SOCK_COMMON = 11,
+	ARG_PTR_TO_SOCKET = 12,
+	ARG_PTR_TO_BTF_ID = 13,
+	ARG_PTR_TO_RINGBUF_MEM = 14,
+	ARG_CONST_ALLOC_SIZE_OR_ZERO = 15,
+	ARG_PTR_TO_BTF_ID_SOCK_COMMON = 16,
+	ARG_PTR_TO_PERCPU_BTF_ID = 17,
+	ARG_PTR_TO_FUNC = 18,
+	ARG_PTR_TO_STACK = 19,
+	ARG_PTR_TO_CONST_STR = 20,
+	ARG_PTR_TO_TIMER = 21,
+	ARG_KPTR_XCHG_DEST = 22,
+	ARG_PTR_TO_DYNPTR = 23,
+	__BPF_ARG_TYPE_MAX = 24,
+	ARG_PTR_TO_MAP_VALUE_OR_NULL = 259,
+	ARG_PTR_TO_MEM_OR_NULL = 260,
+	ARG_PTR_TO_CTX_OR_NULL = 264,
+	ARG_PTR_TO_SOCKET_OR_NULL = 268,
+	ARG_PTR_TO_STACK_OR_NULL = 275,
+	ARG_PTR_TO_BTF_ID_OR_NULL = 269,
+	ARG_PTR_TO_UNINIT_MEM = 67141636,
+	ARG_PTR_TO_FIXED_SIZE_MEM = 262148,
+	__BPF_ARG_TYPE_LIMIT = 134217727,
+};
+
+struct bpf_subprog_arg_info {
+	enum bpf_arg_type arg_type;
+	union {
+		u32 mem_size;
+		u32 btf_id;
+	};
+};
+
+struct bpf_subprog_info {
+	u32 start;
+	u32 linfo_idx;
+	u16 stack_depth;
+	u16 stack_extra;
+	s16 fastcall_stack_off;
+	bool has_tail_call: 1;
+	bool tail_call_reachable: 1;
+	bool has_ld_abs: 1;
+	bool is_cb: 1;
+	bool is_async_cb: 1;
+	bool is_exception_cb: 1;
+	bool args_cached: 1;
+	bool keep_fastcall_stack: 1;
+	u8 arg_cnt;
+	struct bpf_subprog_arg_info args[5];
+};
+
+struct bpf_id_pair {
+	u32 old;
+	u32 cur;
+};
+
+struct bpf_idmap {
+	u32 tmp_id_gen;
+	struct bpf_id_pair map[600];
+};
+
+struct bpf_idset {
+	u32 count;
+	u32 ids[600];
+};
+
+struct backtrack_state {
+	struct bpf_verifier_env *env;
+	u32 frame;
+	u32 reg_masks[8];
+	u64 stack_masks[8];
+};
+
+enum bpf_dynptr_type {
+	BPF_DYNPTR_TYPE_INVALID = 0,
+	BPF_DYNPTR_TYPE_LOCAL = 1,
+	BPF_DYNPTR_TYPE_RINGBUF = 2,
+	BPF_DYNPTR_TYPE_SKB = 3,
+	BPF_DYNPTR_TYPE_XDP = 4,
+};
+
+enum bpf_iter_state {
+	BPF_ITER_STATE_INVALID = 0,
+	BPF_ITER_STATE_ACTIVE = 1,
+	BPF_ITER_STATE_DRAINED = 2,
+};
+
+struct tnum {
+	u64 value;
+	u64 mask;
+};
+
+enum bpf_reg_liveness {
+	REG_LIVE_NONE = 0,
+	REG_LIVE_READ32 = 1,
+	REG_LIVE_READ64 = 2,
+	REG_LIVE_READ = 3,
+	REG_LIVE_WRITTEN = 4,
+	REG_LIVE_DONE = 8,
+};
+
+struct bpf_reg_state {
+	enum bpf_reg_type type;
+	s32 off;
+	union {
+		int range;
+		struct {
+			struct bpf_map *map_ptr;
+			u32 map_uid;
+		};
+		struct {
+			struct btf *btf;
+			u32 btf_id;
+		};
+		struct {
+			u32 mem_size;
+			u32 dynptr_id;
+		};
+		struct {
+			enum bpf_dynptr_type type;
+			bool first_slot;
+		} dynptr;
+		struct {
+			struct btf *btf;
+			u32 btf_id;
+			enum bpf_iter_state state: 2;
+			int depth: 30;
+		} iter;
+		struct {
+			long unsigned int raw1;
+			long unsigned int raw2;
+		} raw;
+		u32 subprogno;
+	};
+	long: 32;
+	struct tnum var_off;
+	s64 smin_value;
+	s64 smax_value;
+	u64 umin_value;
+	u64 umax_value;
+	s32 s32_min_value;
+	s32 s32_max_value;
+	u32 u32_min_value;
+	u32 u32_max_value;
+	u32 id;
+	u32 ref_obj_id;
+	struct bpf_reg_state *parent;
+	u32 frameno;
+	s32 subreg_def;
+	enum bpf_reg_liveness live;
+	bool precise;
+	long: 32;
+};
+
+struct bpf_verifier_ops;
+
+struct bpf_verifier_stack_elem;
+
+struct bpf_verifier_state;
+
+struct bpf_verifier_state_list;
+
+struct bpf_insn_aux_data;
+
+struct bpf_jmp_history_entry;
+
+struct bpf_verifier_env {
+	u32 insn_idx;
+	u32 prev_insn_idx;
+	struct bpf_prog *prog;
+	const struct bpf_verifier_ops *ops;
+	struct module *attach_btf_mod;
+	struct bpf_verifier_stack_elem *head;
+	int stack_size;
+	bool strict_alignment;
+	bool test_state_freq;
+	bool test_reg_invariants;
+	struct bpf_verifier_state *cur_state;
+	struct bpf_verifier_state_list **explored_states;
+	struct bpf_verifier_state_list *free_list;
+	struct bpf_map *used_maps[64];
+	struct btf_mod_pair used_btfs[64];
+	u32 used_map_cnt;
+	u32 used_btf_cnt;
+	u32 id_gen;
+	u32 hidden_subprog_cnt;
+	int exception_callback_subprog;
+	bool explore_alu_limits;
+	bool allow_ptr_leaks;
+	bool allow_uninit_stack;
+	bool bpf_capable;
+	bool bypass_spec_v1;
+	bool bypass_spec_v4;
+	bool seen_direct_write;
+	bool seen_exception;
+	struct bpf_insn_aux_data *insn_aux_data;
+	const struct bpf_line_info *prev_linfo;
+	struct bpf_verifier_log log;
+	struct bpf_subprog_info subprog_info[258];
+	union {
+		struct bpf_idmap idmap_scratch;
+		struct bpf_idset idset_scratch;
+	};
+	struct {
+		int *insn_state;
+		int *insn_stack;
+		int cur_stack;
+	} cfg;
+	struct backtrack_state bt;
+	struct bpf_jmp_history_entry *cur_hist_ent;
+	u32 pass_cnt;
+	u32 subprog_cnt;
+	u32 prev_insn_processed;
+	u32 insn_processed;
+	u32 prev_jmps_processed;
+	u32 jmps_processed;
+	long: 32;
+	u64 verification_time;
+	u32 max_states_per_insn;
+	u32 total_states;
+	u32 peak_states;
+	u32 longest_mark_read_walk;
+	bpfptr_t fd_array;
+	u32 scratched_regs;
+	long: 32;
+	u64 scratched_stack_slots;
+	u64 prev_log_pos;
+	u64 prev_insn_print_pos;
+	struct bpf_reg_state fake_reg[2];
+	char tmp_str_buf[320];
+	struct bpf_insn insn_buf[32];
+	struct bpf_insn epilogue_buf[32];
+};
+
+struct bpf_retval_range {
+	s32 minval;
+	s32 maxval;
+};
+
+struct bpf_reference_state;
+
+struct bpf_stack_state;
+
+struct bpf_func_state {
+	struct bpf_reg_state regs[11];
+	int callsite;
+	u32 frameno;
+	u32 subprogno;
+	u32 async_entry_cnt;
+	struct bpf_retval_range callback_ret_range;
+	bool in_callback_fn;
+	bool in_async_callback_fn;
+	bool in_exception_callback_fn;
+	u32 callback_depth;
+	int acquired_refs;
+	struct bpf_reference_state *refs;
+	struct bpf_stack_state *stack;
+	int allocated_stack;
+};
+
+enum bpf_type_flag {
+	PTR_MAYBE_NULL = 256,
+	MEM_RDONLY = 512,
+	MEM_RINGBUF = 1024,
+	MEM_USER = 2048,
+	MEM_PERCPU = 4096,
+	OBJ_RELEASE = 8192,
+	PTR_UNTRUSTED = 16384,
+	MEM_UNINIT = 32768,
+	DYNPTR_TYPE_LOCAL = 65536,
+	DYNPTR_TYPE_RINGBUF = 131072,
+	MEM_FIXED_SIZE = 262144,
+	MEM_ALLOC = 524288,
+	PTR_TRUSTED = 1048576,
+	MEM_RCU = 2097152,
+	NON_OWN_REF = 4194304,
+	DYNPTR_TYPE_SKB = 8388608,
+	DYNPTR_TYPE_XDP = 16777216,
+	MEM_ALIGNED = 33554432,
+	MEM_WRITE = 67108864,
+	__BPF_TYPE_FLAG_MAX = 67108865,
+	__BPF_TYPE_LAST_FLAG = 67108864,
+};
+
+enum bpf_return_type {
+	RET_INTEGER = 0,
+	RET_VOID = 1,
+	RET_PTR_TO_MAP_VALUE = 2,
+	RET_PTR_TO_SOCKET = 3,
+	RET_PTR_TO_TCP_SOCK = 4,
+	RET_PTR_TO_SOCK_COMMON = 5,
+	RET_PTR_TO_MEM = 6,
+	RET_PTR_TO_MEM_OR_BTF_ID = 7,
+	RET_PTR_TO_BTF_ID = 8,
+	__BPF_RET_TYPE_MAX = 9,
+	RET_PTR_TO_MAP_VALUE_OR_NULL = 258,
+	RET_PTR_TO_SOCKET_OR_NULL = 259,
+	RET_PTR_TO_TCP_SOCK_OR_NULL = 260,
+	RET_PTR_TO_SOCK_COMMON_OR_NULL = 261,
+	RET_PTR_TO_RINGBUF_MEM_OR_NULL = 1286,
+	RET_PTR_TO_DYNPTR_MEM_OR_NULL = 262,
+	RET_PTR_TO_BTF_ID_OR_NULL = 264,
+	RET_PTR_TO_BTF_ID_TRUSTED = 1048584,
+	__BPF_RET_TYPE_LIMIT = 134217727,
+};
+
+struct bpf_func_proto {
+	u64 (*func)(u64, u64, u64, u64, u64);
+	bool gpl_only;
+	bool pkt_access;
+	bool might_sleep;
+	bool allow_fastcall;
+	enum bpf_return_type ret_type;
+	union {
+		struct {
+			enum bpf_arg_type arg1_type;
+			enum bpf_arg_type arg2_type;
+			enum bpf_arg_type arg3_type;
+			enum bpf_arg_type arg4_type;
+			enum bpf_arg_type arg5_type;
+		};
+		enum bpf_arg_type arg_type[5];
+	};
+	union {
+		struct {
+			u32 *arg1_btf_id;
+			u32 *arg2_btf_id;
+			u32 *arg3_btf_id;
+			u32 *arg4_btf_id;
+			u32 *arg5_btf_id;
+		};
+		u32 *arg_btf_id[5];
+		struct {
+			size_t arg1_size;
+			size_t arg2_size;
+			size_t arg3_size;
+			size_t arg4_size;
+			size_t arg5_size;
+		};
+		size_t arg_size[5];
+	};
+	int *ret_btf_id;
+	bool (*allowed)(const struct bpf_prog *);
+};
+
+enum bpf_access_type {
+	BPF_READ = 1,
+	BPF_WRITE = 2,
+};
+
+struct bpf_insn_access_aux {
+	enum bpf_reg_type reg_type;
+	bool is_ldsx;
+	union {
+		int ctx_field_size;
+		struct {
+			struct btf *btf;
+			u32 btf_id;
+		};
+	};
+	struct bpf_verifier_log *log;
+	bool is_retval;
+};
+
+struct bpf_verifier_ops {
+	const struct bpf_func_proto * (*get_func_proto)(enum bpf_func_id, const struct bpf_prog *);
+	bool (*is_valid_access)(int, int, enum bpf_access_type, const struct bpf_prog *, struct bpf_insn_access_aux *);
+	int (*gen_prologue)(struct bpf_insn *, bool, const struct bpf_prog *);
+	int (*gen_epilogue)(struct bpf_insn *, const struct bpf_prog *, s16);
+	int (*gen_ld_abs)(const struct bpf_insn *, struct bpf_insn *);
+	u32 (*convert_ctx_access)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);
+	int (*btf_struct_access)(struct bpf_verifier_log *, const struct bpf_reg_state *, int, int);
+};
+
+struct bpf_array_aux {
+	struct list_head poke_progs;
+	struct bpf_map *map;
+	struct mutex poke_mutex;
+	struct work_struct work;
+};
+
+struct bpf_array {
+	struct bpf_map map;
+	u32 elem_size;
+	u32 index_mask;
+	struct bpf_array_aux *aux;
+	long: 32;
+	union {
+		struct {
+			struct {} __empty_value;
+			char value[0];
+		};
+		struct {
+			struct {} __empty_ptrs;
+			void *ptrs[0];
+		};
+		struct {
+			struct {} __empty_pptrs;
+			void *pptrs[0];
+		};
+	};
+};
+
+struct bpf_event_entry {
+	struct perf_event *event;
+	struct file *perf_file;
+	struct file *map_file;
+	struct callback_head rcu;
+};
+
+typedef long unsigned int (*bpf_ctx_copy_t)(void *, const void *, long unsigned int, long unsigned int);
+
+struct bpf_trace_run_ctx {
+	struct bpf_run_ctx run_ctx;
+	u64 bpf_cookie;
+	bool is_uprobe;
+	long: 32;
+};
+
+typedef u32 (*bpf_prog_run_fn)(const struct bpf_prog *, const void *);
+
+struct bpf_bprintf_data {
+	u32 *bin_args;
+	char *buf;
+	bool get_bin_args;
+	bool get_buf;
+};
+
+struct bpf_key {
+	struct key *key;
+	bool has_ref;
+};
+
+typedef unsigned int (*bpf_dispatcher_fn)(const void *, const struct bpf_insn *, unsigned int (*)(const void *, const struct bpf_insn *));
+
+struct bpf_active_lock {
+	void *ptr;
+	u32 id;
+};
+
+struct bpf_stack_state {
+	struct bpf_reg_state spilled_ptr;
+	u8 slot_type[8];
+};
+
+struct bpf_reference_state {
+	int id;
+	int insn_idx;
+	int callback_ref;
+};
+
+enum {
+	INSN_F_FRAMENO_MASK = 7,
+	INSN_F_SPI_MASK = 63,
+	INSN_F_SPI_SHIFT = 3,
+	INSN_F_STACK_ACCESS = 512,
+};
+
+struct bpf_jmp_history_entry {
+	u32 idx;
+	u32 prev_idx: 22;
+	u32 flags: 10;
+	u64 linked_regs;
+};
+
+struct bpf_verifier_state {
+	struct bpf_func_state *frame[8];
+	struct bpf_verifier_state *parent;
+	u32 branches;
+	u32 insn_idx;
+	u32 curframe;
+	struct bpf_active_lock active_lock;
+	bool speculative;
+	bool active_rcu_lock;
+	u32 active_preempt_lock;
+	bool used_as_loop_entry;
+	bool in_sleepable;
+	u32 first_insn_idx;
+	u32 last_insn_idx;
+	struct bpf_verifier_state *loop_entry;
+	struct bpf_jmp_history_entry *jmp_history;
+	u32 jmp_history_cnt;
+	u32 dfs_depth;
+	u32 callback_unroll_depth;
+	u32 may_goto_depth;
+};
+
+struct bpf_verifier_state_list {
+	struct bpf_verifier_state state;
+	struct bpf_verifier_state_list *next;
+	int miss_cnt;
+	int hit_cnt;
+};
+
+struct bpf_loop_inline_state {
+	unsigned int initialized: 1;
+	unsigned int fit_for_inline: 1;
+	u32 callback_subprogno;
+};
+
+struct bpf_map_ptr_state {
+	struct bpf_map *map_ptr;
+	bool poison;
+	bool unpriv;
+};
+
+struct bpf_insn_aux_data {
+	union {
+		enum bpf_reg_type ptr_type;
+		struct bpf_map_ptr_state map_ptr_state;
+		s32 call_imm;
+		u32 alu_limit;
+		struct {
+			u32 map_index;
+			u32 map_off;
+		};
+		struct {
+			enum bpf_reg_type reg_type;
+			union {
+				struct {
+					struct btf *btf;
+					u32 btf_id;
+				};
+				u32 mem_size;
+			};
+		} btf_var;
+		struct bpf_loop_inline_state loop_inline_state;
+	};
+	long: 32;
+	union {
+		u64 obj_new_size;
+		u64 insert_off;
+	};
+	struct btf_struct_meta *kptr_struct_meta;
+	long: 32;
+	u64 map_key_state;
+	int ctx_field_size;
+	u32 seen;
+	bool sanitize_stack_spill;
+	bool zext_dst;
+	bool needs_zext;
+	bool storage_get_func_atomic;
+	bool is_iter_next;
+	bool call_with_percpu_alloc_ptr;
+	u8 alu_state;
+	u8 fastcall_pattern: 1;
+	u8 fastcall_spills_num: 3;
+	unsigned int orig_idx;
+	bool jmp_point;
+	bool prune_point;
+	bool force_checkpoint;
+	bool calls_callback;
+};
+
+typedef struct pt_regs bpf_user_pt_regs_t;
+
+struct bpf_perf_event_data {
+	bpf_user_pt_regs_t regs;
+	__u64 sample_period;
+	__u64 addr;
+};
+
+enum perf_event_sample_format {
+	PERF_SAMPLE_IP = 1,
+	PERF_SAMPLE_TID = 2,
+	PERF_SAMPLE_TIME = 4,
+	PERF_SAMPLE_ADDR = 8,
+	PERF_SAMPLE_READ = 16,
+	PERF_SAMPLE_CALLCHAIN = 32,
+	PERF_SAMPLE_ID = 64,
+	PERF_SAMPLE_CPU = 128,
+	PERF_SAMPLE_PERIOD = 256,
+	PERF_SAMPLE_STREAM_ID = 512,
+	PERF_SAMPLE_RAW = 1024,
+	PERF_SAMPLE_BRANCH_STACK = 2048,
+	PERF_SAMPLE_REGS_USER = 4096,
+	PERF_SAMPLE_STACK_USER = 8192,
+	PERF_SAMPLE_WEIGHT = 16384,
+	PERF_SAMPLE_DATA_SRC = 32768,
+	PERF_SAMPLE_IDENTIFIER = 65536,
+	PERF_SAMPLE_TRANSACTION = 131072,
+	PERF_SAMPLE_REGS_INTR = 262144,
+	PERF_SAMPLE_PHYS_ADDR = 524288,
+	PERF_SAMPLE_AUX = 1048576,
+	PERF_SAMPLE_CGROUP = 2097152,
+	PERF_SAMPLE_DATA_PAGE_SIZE = 4194304,
+	PERF_SAMPLE_CODE_PAGE_SIZE = 8388608,
+	PERF_SAMPLE_WEIGHT_STRUCT = 16777216,
+	PERF_SAMPLE_MAX = 33554432,
+};
+
+struct perf_event_query_bpf {
+	__u32 ids_len;
+	__u32 prog_cnt;
+	__u32 ids[0];
+};
+
+struct bpf_perf_event_data_kern {
+	bpf_user_pt_regs_t *regs;
+	struct perf_sample_data *data;
+	struct perf_event *event;
+};
+
+typedef int perf_snapshot_branch_stack_t(struct perf_branch_entry *, unsigned int);
+
+struct bpf_local_storage_map_bucket {
+	struct hlist_head list;
+	raw_spinlock_t lock;
+};
+
+struct bpf_local_storage_data {
+	struct bpf_local_storage_map *smap;
+	long: 32;
+	u8 data[0];
+};
+
+struct trace_event_raw_bpf_trace_printk {
+	struct trace_entry ent;
+	u32 __data_loc_bpf_string;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_bpf_trace_printk {
+	u32 bpf_string;
+	const void *bpf_string_ptr_;
+};
+
+typedef void (*btf_trace_bpf_trace_printk)(void *, const char *);
+
+struct bpf_trace_module {
+	struct module *module;
+	struct list_head list;
+};
+
+typedef u64 (*btf_bpf_probe_read_user)(void *, u32, const void *);
+
+typedef u64 (*btf_bpf_probe_read_user_str)(void *, u32, const void *);
+
+typedef u64 (*btf_bpf_probe_read_kernel)(void *, u32, const void *);
+
+typedef u64 (*btf_bpf_probe_read_kernel_str)(void *, u32, const void *);
+
+typedef u64 (*btf_bpf_probe_read_compat)(void *, u32, const void *);
+
+typedef u64 (*btf_bpf_probe_read_compat_str)(void *, u32, const void *);
+
+typedef u64 (*btf_bpf_probe_write_user)(void *, const void *, u32);
+
+typedef u64 (*btf_bpf_trace_printk)(char *, u32, u64, u64, u64);
+
+typedef u64 (*btf_bpf_trace_vprintk)(char *, u32, const void *, u32);
+
+typedef u64 (*btf_bpf_seq_printf)(struct seq_file *, char *, u32, const void *, u32);
+
+typedef u64 (*btf_bpf_seq_write)(struct seq_file *, const void *, u32);
+
+typedef u64 (*btf_bpf_seq_printf_btf)(struct seq_file *, struct btf_ptr *, u32, u64);
+
+typedef u64 (*btf_bpf_perf_event_read)(struct bpf_map *, u64);
+
+typedef u64 (*btf_bpf_perf_event_read_value)(struct bpf_map *, u64, struct bpf_perf_event_value *, u32);
+
+struct bpf_trace_sample_data {
+	struct perf_sample_data sds[3];
+};
+
+typedef u64 (*btf_bpf_perf_event_output)(struct pt_regs *, struct bpf_map *, u64, void *, u64);
+
+struct bpf_nested_pt_regs {
+	struct pt_regs regs[3];
+};
+
+typedef u64 (*btf_bpf_get_current_task)();
+
+typedef u64 (*btf_bpf_get_current_task_btf)();
+
+typedef u64 (*btf_bpf_task_pt_regs)(struct task_struct *);
+
+struct send_signal_irq_work {
+	struct irq_work irq_work;
+	struct task_struct *task;
+	u32 sig;
+	enum pid_type type;
+};
+
+typedef u64 (*btf_bpf_send_signal)(u32);
+
+typedef u64 (*btf_bpf_send_signal_thread)(u32);
+
+typedef u64 (*btf_bpf_d_path)(struct path *, char *, u32);
+
+typedef u64 (*btf_bpf_snprintf_btf)(char *, u32, struct btf_ptr *, u32, u64);
+
+typedef u64 (*btf_bpf_get_func_ip_tracing)(void *);
+
+typedef u64 (*btf_bpf_get_func_ip_kprobe)(struct pt_regs *);
+
+typedef u64 (*btf_bpf_get_func_ip_kprobe_multi)(struct pt_regs *);
+
+typedef u64 (*btf_bpf_get_attach_cookie_kprobe_multi)(struct pt_regs *);
+
+typedef u64 (*btf_bpf_get_func_ip_uprobe_multi)(struct pt_regs *);
+
+typedef u64 (*btf_bpf_get_attach_cookie_uprobe_multi)(struct pt_regs *);
+
+typedef u64 (*btf_bpf_get_attach_cookie_trace)(void *);
+
+typedef u64 (*btf_bpf_get_attach_cookie_pe)(struct bpf_perf_event_data_kern *);
+
+typedef u64 (*btf_bpf_get_attach_cookie_tracing)(void *);
+
+typedef u64 (*btf_bpf_get_branch_snapshot)(void *, u32, u64);
+
+typedef u64 (*btf_get_func_arg)(void *, u32, u64 *);
+
+typedef u64 (*btf_get_func_ret)(void *, u64 *);
+
+typedef u64 (*btf_get_func_arg_cnt)(void *);
+
+typedef u64 (*btf_bpf_perf_event_output_tp)(void *, struct bpf_map *, u64, void *, u64);
+
+typedef u64 (*btf_bpf_get_stackid_tp)(void *, struct bpf_map *, u64);
+
+typedef u64 (*btf_bpf_get_stack_tp)(void *, void *, u32, u64);
+
+typedef u64 (*btf_bpf_perf_prog_read_value)(struct bpf_perf_event_data_kern *, struct bpf_perf_event_value *, u32);
+
+typedef u64 (*btf_bpf_read_branch_records)(struct bpf_perf_event_data_kern *, void *, u32, u64);
+
+struct bpf_raw_tp_regs {
+	struct pt_regs regs[3];
+};
+
+typedef u64 (*btf_bpf_perf_event_output_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64, void *, u64);
+
+typedef u64 (*btf_bpf_get_stackid_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64);
+
+typedef u64 (*btf_bpf_get_stack_raw_tp)(struct bpf_raw_tracepoint_args *, void *, u32, u64);
+
+struct bpf_session_run_ctx {
+	struct bpf_run_ctx run_ctx;
+	bool is_return;
+	void *data;
+};
+
+typedef __u16 __le16;
+
+typedef __u64 __le64;
+
+enum xdp_action {
+	XDP_ABORTED = 0,
+	XDP_DROP = 1,
+	XDP_PASS = 2,
+	XDP_TX = 3,
+	XDP_REDIRECT = 4,
+};
+
+struct xdp_md {
+	__u32 data;
+	__u32 data_end;
+	__u32 data_meta;
+	__u32 ingress_ifindex;
+	__u32 rx_queue_index;
+	__u32 egress_ifindex;
+};
+
+struct latch_tree_root {
+	seqcount_latch_t seq;
+	struct rb_root tree[2];
+};
+
+struct latch_tree_ops {
+	bool (*less)(struct latch_tree_node *, struct latch_tree_node *);
+	int (*comp)(void *, struct latch_tree_node *);
+};
+
+struct rnd_state {
+	__u32 s1;
+	__u32 s2;
+	__u32 s3;
+	__u32 s4;
+};
+
+enum bpf_jit_poke_reason {
+	BPF_POKE_REASON_TAIL_CALL = 0,
+};
+
+struct bpf_empty_prog_array {
+	struct bpf_prog_array hdr;
+	struct bpf_prog *null_prog;
+	long: 32;
+};
+
+enum bpf_text_poke_type {
+	BPF_MOD_CALL = 0,
+	BPF_MOD_JUMP = 1,
+};
+
+struct rhash_lock_head;
+
+struct bucket_table {
+	unsigned int size;
+	unsigned int nest;
+	u32 hash_rnd;
+	struct list_head walkers;
+	struct callback_head rcu;
+	struct bucket_table *future_tbl;
+	struct lockdep_map dep_map;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct rhash_lock_head *buckets[0];
+};
+
+struct xdp_mem_info {
+	u32 type;
+	u32 id;
+};
+
+struct xdp_frame {
+	void *data;
+	u16 len;
+	u16 headroom;
+	u32 metasize;
+	struct xdp_mem_info mem;
+	struct net_device *dev_rx;
+	u32 frame_sz;
+	u32 flags;
+};
+
+struct xdp_rxq_info;
+
+struct xdp_txq_info;
+
+struct xdp_buff {
+	void *data;
+	void *data_end;
+	void *data_meta;
+	void *data_hard_start;
+	struct xdp_rxq_info *rxq;
+	struct xdp_txq_info *txq;
+	u32 frame_sz;
+	u32 flags;
+};
+
+struct bpf_binary_header {
+	u32 size;
+	long: 32;
+	u8 image[0];
+};
+
+typedef void (*bpf_jit_fill_hole_t)(void *, unsigned int);
+
+enum execmem_type {
+	EXECMEM_DEFAULT = 0,
+	EXECMEM_MODULE_TEXT = 0,
+	EXECMEM_KPROBES = 1,
+	EXECMEM_FTRACE = 2,
+	EXECMEM_BPF = 3,
+	EXECMEM_MODULE_DATA = 4,
+	EXECMEM_TYPE_MAX = 5,
+};
+
+enum page_size_enum {
+	__PAGE_SIZE = 4096,
+};
+
+struct bpf_prog_pack {
+	struct list_head list;
+	void *ptr;
+	long unsigned int bitmap[0];
+};
+
+struct bpf_prog_dummy {
+	struct bpf_prog prog;
+};
+
+typedef u64 (*btf_bpf_user_rnd_u32)();
+
+typedef u64 (*btf_bpf_get_raw_cpu_id)();
+
+enum xdp_mem_type {
+	MEM_TYPE_PAGE_SHARED = 0,
+	MEM_TYPE_PAGE_ORDER0 = 1,
+	MEM_TYPE_PAGE_POOL = 2,
+	MEM_TYPE_XSK_BUFF_POOL = 3,
+	MEM_TYPE_MAX = 4,
+};
+
+struct xdp_rxq_info {
+	struct net_device *dev;
+	u32 queue_index;
+	u32 reg_state;
+	struct xdp_mem_info mem;
+	unsigned int napi_id;
+	u32 frag_size;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct xdp_txq_info {
+	struct net_device *dev;
+};
+
+struct xdp_cpumap_stats {
+	unsigned int redirect;
+	unsigned int pass;
+	unsigned int drop;
+};
+
+struct _bpf_dtab_netdev {
+	struct net_device *dev;
+};
+
+struct rhash_lock_head {};
+
+struct xdp_mem_allocator {
+	struct xdp_mem_info mem;
+	union {
+		void *allocator;
+		struct page_pool *page_pool;
+	};
+	struct rhash_head node;
+	struct callback_head rcu;
+};
+
+struct trace_event_raw_xdp_exception {
+	struct trace_entry ent;
+	int prog_id;
+	u32 act;
+	int ifindex;
+	char __data[0];
+};
+
+struct trace_event_raw_xdp_bulk_tx {
+	struct trace_entry ent;
+	int ifindex;
+	u32 act;
+	int drops;
+	int sent;
+	int err;
+	char __data[0];
+};
+
+struct trace_event_raw_xdp_redirect_template {
+	struct trace_entry ent;
+	int prog_id;
+	u32 act;
+	int ifindex;
+	int err;
+	int to_ifindex;
+	u32 map_id;
+	int map_index;
+	char __data[0];
+};
+
+struct trace_event_raw_xdp_cpumap_kthread {
+	struct trace_entry ent;
+	int map_id;
+	u32 act;
+	int cpu;
+	unsigned int drops;
+	unsigned int processed;
+	int sched;
+	unsigned int xdp_pass;
+	unsigned int xdp_drop;
+	unsigned int xdp_redirect;
+	char __data[0];
+};
+
+struct trace_event_raw_xdp_cpumap_enqueue {
+	struct trace_entry ent;
+	int map_id;
+	u32 act;
+	int cpu;
+	unsigned int drops;
+	unsigned int processed;
+	int to_cpu;
+	char __data[0];
+};
+
+struct trace_event_raw_xdp_devmap_xmit {
+	struct trace_entry ent;
+	int from_ifindex;
+	u32 act;
+	int to_ifindex;
+	int drops;
+	int sent;
+	int err;
+	char __data[0];
+};
+
+struct trace_event_raw_mem_disconnect {
+	struct trace_entry ent;
+	const struct xdp_mem_allocator *xa;
+	u32 mem_id;
+	u32 mem_type;
+	const void *allocator;
+	char __data[0];
+};
+
+struct trace_event_raw_mem_connect {
+	struct trace_entry ent;
+	const struct xdp_mem_allocator *xa;
+	u32 mem_id;
+	u32 mem_type;
+	const void *allocator;
+	const struct xdp_rxq_info *rxq;
+	int ifindex;
+	char __data[0];
+};
+
+struct trace_event_raw_mem_return_failed {
+	struct trace_entry ent;
+	const struct page *page;
+	u32 mem_id;
+	u32 mem_type;
+	char __data[0];
+};
+
+struct trace_event_raw_bpf_xdp_link_attach_failed {
+	struct trace_entry ent;
+	u32 __data_loc_msg;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_xdp_exception {};
+
+struct trace_event_data_offsets_xdp_bulk_tx {};
+
+struct trace_event_data_offsets_xdp_redirect_template {};
+
+struct trace_event_data_offsets_xdp_cpumap_kthread {};
+
+struct trace_event_data_offsets_xdp_cpumap_enqueue {};
+
+struct trace_event_data_offsets_xdp_devmap_xmit {};
+
+struct trace_event_data_offsets_mem_disconnect {};
+
+struct trace_event_data_offsets_mem_connect {};
+
+struct trace_event_data_offsets_mem_return_failed {};
+
+struct trace_event_data_offsets_bpf_xdp_link_attach_failed {
+	u32 msg;
+	const void *msg_ptr_;
+};
+
+typedef void (*btf_trace_xdp_exception)(void *, const struct net_device *, const struct bpf_prog *, u32);
+
+typedef void (*btf_trace_xdp_bulk_tx)(void *, const struct net_device *, int, int, int);
+
+typedef void (*btf_trace_xdp_redirect)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);
+
+typedef void (*btf_trace_xdp_redirect_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);
+
+typedef void (*btf_trace_xdp_redirect_map)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);
+
+typedef void (*btf_trace_xdp_redirect_map_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);
+
+typedef void (*btf_trace_xdp_cpumap_kthread)(void *, int, unsigned int, unsigned int, int, struct xdp_cpumap_stats *);
+
+typedef void (*btf_trace_xdp_cpumap_enqueue)(void *, int, unsigned int, unsigned int, int);
+
+typedef void (*btf_trace_xdp_devmap_xmit)(void *, const struct net_device *, const struct net_device *, int, int, int);
+
+typedef void (*btf_trace_mem_disconnect)(void *, const struct xdp_mem_allocator *);
+
+typedef void (*btf_trace_mem_connect)(void *, const struct xdp_mem_allocator *, const struct xdp_rxq_info *);
+
+typedef void (*btf_trace_mem_return_failed)(void *, const struct xdp_mem_info *, const struct page *);
+
+typedef void (*btf_trace_bpf_xdp_link_attach_failed)(void *, const char *);
+
+enum bpf_stack_slot_type {
+	STACK_INVALID = 0,
+	STACK_SPILL = 1,
+	STACK_MISC = 2,
+	STACK_ZERO = 3,
+	STACK_DYNPTR = 4,
+	STACK_ITER = 5,
+};
+
+struct maple_alloc {
+	long unsigned int total;
+	unsigned char node_count;
+	unsigned int request_count;
+	struct maple_alloc *slot[61];
+};
+
+struct maple_enode;
+
+enum store_type {
+	wr_invalid = 0,
+	wr_new_root = 1,
+	wr_store_root = 2,
+	wr_exact_fit = 3,
+	wr_spanning_store = 4,
+	wr_split_store = 5,
+	wr_rebalance = 6,
+	wr_append = 7,
+	wr_node_store = 8,
+	wr_slot_store = 9,
+};
+
+enum maple_status {
+	ma_active = 0,
+	ma_start = 1,
+	ma_root = 2,
+	ma_none = 3,
+	ma_pause = 4,
+	ma_overflow = 5,
+	ma_underflow = 6,
+	ma_error = 7,
+};
+
+struct ma_state {
+	struct maple_tree *tree;
+	long unsigned int index;
+	long unsigned int last;
+	struct maple_enode *node;
+	long unsigned int min;
+	long unsigned int max;
+	struct maple_alloc *alloc;
+	enum maple_status status;
+	unsigned char depth;
+	unsigned char offset;
+	unsigned char mas_flags;
+	unsigned char end;
+	enum store_type store_type;
+};
+
+struct fdtable {
+	unsigned int max_fds;
+	struct file **fd;
+	long unsigned int *close_on_exec;
+	long unsigned int *open_fds;
+	long unsigned int *full_fds_bits;
+	struct callback_head rcu;
+};
+
+struct files_struct {
+	atomic_t count;
+	bool resize_in_progress;
+	wait_queue_head_t resize_wait;
+	struct fdtable *fdt;
+	struct fdtable fdtab;
+	long: 32;
+	long: 32;
+	long: 32;
+	spinlock_t file_lock;
+	unsigned int next_fd;
+	long unsigned int close_on_exec_init[1];
+	long unsigned int open_fds_init[1];
+	long unsigned int full_fds_bits_init[1];
+	struct file *fd_array[32];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct vma_iterator {
+	struct ma_state mas;
+};
+
+union bpf_iter_link_info {
+	struct {
+		__u32 map_fd;
+	} map;
+	struct {
+		enum bpf_cgroup_iter_order order;
+		__u32 cgroup_fd;
+		__u64 cgroup_id;
+	} cgroup;
+	struct {
+		__u32 tid;
+		__u32 pid;
+		__u32 pid_fd;
+	} task;
+};
+
+enum {
+	CSS_TASK_ITER_PROCS = 1,
+	CSS_TASK_ITER_THREADED = 2,
+	CSS_TASK_ITER_SKIPPED = 65536,
+};
+
+struct css_task_iter {
+	struct cgroup_subsys *ss;
+	unsigned int flags;
+	struct list_head *cset_pos;
+	struct list_head *cset_head;
+	struct list_head *tcset_pos;
+	struct list_head *tcset_head;
+	struct list_head *task_pos;
+	struct list_head *cur_tasks_head;
+	struct css_set *cur_cset;
+	struct css_set *cur_dcset;
+	struct task_struct *cur_task;
+	struct list_head iters_node;
+};
+
+typedef int (*bpf_iter_attach_target_t)(struct bpf_prog *, union bpf_iter_link_info *, struct bpf_iter_aux_info *);
+
+typedef void (*bpf_iter_detach_target_t)(struct bpf_iter_aux_info *);
+
+typedef void (*bpf_iter_show_fdinfo_t)(const struct bpf_iter_aux_info *, struct seq_file *);
+
+typedef int (*bpf_iter_fill_link_info_t)(const struct bpf_iter_aux_info *, struct bpf_link_info *);
+
+typedef const struct bpf_func_proto * (*bpf_iter_get_func_proto_t)(enum bpf_func_id, const struct bpf_prog *);
+
+enum bpf_iter_feature {
+	BPF_ITER_RESCHED = 1,
+};
+
+struct bpf_iter_reg {
+	const char *target;
+	bpf_iter_attach_target_t attach_target;
+	bpf_iter_detach_target_t detach_target;
+	bpf_iter_show_fdinfo_t show_fdinfo;
+	bpf_iter_fill_link_info_t fill_link_info;
+	bpf_iter_get_func_proto_t get_func_proto;
+	u32 ctx_arg_info_size;
+	u32 feature;
+	struct bpf_ctx_arg_aux ctx_arg_info[2];
+	const struct bpf_iter_seq_info *seq_info;
+};
+
+struct bpf_iter_meta {
+	union {
+		struct seq_file *seq;
+	};
+	u64 session_id;
+	u64 seq_num;
+};
+
+struct mmap_unlock_irq_work {
+	struct irq_work irq_work;
+	struct mm_struct *mm;
+};
+
+struct bpf_iter_seq_task_common {
+	struct pid_namespace *ns;
+	enum bpf_iter_task_type type;
+	u32 pid;
+	u32 pid_visiting;
+};
+
+struct bpf_iter_seq_task_info {
+	struct bpf_iter_seq_task_common common;
+	u32 tid;
+};
+
+struct bpf_iter__task {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct task_struct *task;
+	};
+};
+
+struct bpf_iter_seq_task_file_info {
+	struct bpf_iter_seq_task_common common;
+	struct task_struct *task;
+	u32 tid;
+	u32 fd;
+};
+
+struct bpf_iter__task_file {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct task_struct *task;
+	};
+	u32 fd;
+	long: 32;
+	union {
+		struct file *file;
+	};
+};
+
+struct bpf_iter_seq_task_vma_info {
+	struct bpf_iter_seq_task_common common;
+	struct task_struct *task;
+	struct mm_struct *mm;
+	struct vm_area_struct *vma;
+	u32 tid;
+	long unsigned int prev_vm_start;
+	long unsigned int prev_vm_end;
+};
+
+enum bpf_task_vma_iter_find_op {
+	task_vma_iter_first_vma = 0,
+	task_vma_iter_next_vma = 1,
+	task_vma_iter_find_vma = 2,
+};
+
+struct bpf_iter__task_vma {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct task_struct *task;
+	};
+	union {
+		struct vm_area_struct *vma;
+	};
+};
+
+typedef u64 (*btf_bpf_find_vma)(struct task_struct *, u64, bpf_callback_t, void *, u64);
+
+struct bpf_iter_task_vma_kern_data {
+	struct task_struct *task;
+	struct mm_struct *mm;
+	struct mmap_unlock_irq_work *work;
+	struct vma_iterator vmi;
+};
+
+struct bpf_iter_task_vma {
+	__u64 __opaque[1];
+};
+
+struct bpf_iter_task_vma_kern {
+	struct bpf_iter_task_vma_kern_data *data;
+	long: 32;
+};
+
+struct bpf_iter_css_task {
+	__u64 __opaque[1];
+};
+
+struct bpf_iter_css_task_kern {
+	struct css_task_iter *css_it;
+	long: 32;
+};
+
+struct bpf_iter_task {
+	__u64 __opaque[3];
+};
+
+struct bpf_iter_task_kern {
+	struct task_struct *task;
+	struct task_struct *pos;
+	unsigned int flags;
+	long: 32;
+};
+
+enum {
+	BPF_TASK_ITER_ALL_PROCS = 0,
+	BPF_TASK_ITER_ALL_THREADS = 1,
+	BPF_TASK_ITER_PROC_THREADS = 2,
+};
+
+enum {
+	BPF_ANY = 0,
+	BPF_NOEXIST = 1,
+	BPF_EXIST = 2,
+	BPF_F_LOCK = 4,
+};
+
+enum {
+	BPF_F_NO_PREALLOC = 1,
+	BPF_F_NO_COMMON_LRU = 2,
+	BPF_F_NUMA_NODE = 4,
+	BPF_F_RDONLY = 8,
+	BPF_F_WRONLY = 16,
+	BPF_F_STACK_BUILD_ID = 32,
+	BPF_F_ZERO_SEED = 64,
+	BPF_F_RDONLY_PROG = 128,
+	BPF_F_WRONLY_PROG = 256,
+	BPF_F_CLONE = 512,
+	BPF_F_MMAPABLE = 1024,
+	BPF_F_PRESERVE_ELEMS = 2048,
+	BPF_F_INNER_MAP = 4096,
+	BPF_F_LINK = 8192,
+	BPF_F_PATH_FD = 16384,
+	BPF_F_VTYPE_BTF_OBJ_FD = 32768,
+	BPF_F_TOKEN_FD = 65536,
+	BPF_F_SEGV_ON_FAULT = 131072,
+	BPF_F_NO_USER_CONV = 262144,
+};
+
+enum {
+	BTF_KIND_UNKN = 0,
+	BTF_KIND_INT = 1,
+	BTF_KIND_PTR = 2,
+	BTF_KIND_ARRAY = 3,
+	BTF_KIND_STRUCT = 4,
+	BTF_KIND_UNION = 5,
+	BTF_KIND_ENUM = 6,
+	BTF_KIND_FWD = 7,
+	BTF_KIND_TYPEDEF = 8,
+	BTF_KIND_VOLATILE = 9,
+	BTF_KIND_CONST = 10,
+	BTF_KIND_RESTRICT = 11,
+	BTF_KIND_FUNC = 12,
+	BTF_KIND_FUNC_PROTO = 13,
+	BTF_KIND_VAR = 14,
+	BTF_KIND_DATASEC = 15,
+	BTF_KIND_FLOAT = 16,
+	BTF_KIND_DECL_TAG = 17,
+	BTF_KIND_TYPE_TAG = 18,
+	BTF_KIND_ENUM64 = 19,
+	NR_BTF_KINDS = 20,
+	BTF_KIND_MAX = 19,
+};
+
+struct bpf_iter__bpf_map_elem {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct bpf_map *map;
+	};
+	union {
+		void *key;
+	};
+	union {
+		void *value;
+	};
+};
+
+struct bpf_iter_seq_array_map_info {
+	struct bpf_map *map;
+	void *percpu_value_buf;
+	u32 index;
+};
+
+struct prog_poke_elem {
+	struct list_head list;
+	struct bpf_prog_aux *aux;
+};
+
+struct bpf_cgroup_storage_key {
+	__u64 cgroup_inode_id;
+	__u32 attach_type;
+	long: 32;
+};
+
+struct btf_member {
+	__u32 name_off;
+	__u32 type;
+	__u32 offset;
+};
+
+enum bpf_cgroup_storage_type {
+	BPF_CGROUP_STORAGE_SHARED = 0,
+	BPF_CGROUP_STORAGE_PERCPU = 1,
+	__BPF_CGROUP_STORAGE_MAX = 2,
+};
+
+struct bpf_storage_buffer;
+
+struct bpf_cgroup_storage_map;
+
+struct bpf_cgroup_storage {
+	union {
+		struct bpf_storage_buffer *buf;
+		void *percpu_buf;
+	};
+	struct bpf_cgroup_storage_map *map;
+	struct bpf_cgroup_storage_key key;
+	struct list_head list_map;
+	struct list_head list_cg;
+	struct rb_node node;
+	struct callback_head rcu;
+	long: 32;
+};
+
+struct bpf_storage_buffer {
+	struct callback_head rcu;
+	char data[0];
+};
+
+struct bpf_cgroup_storage_map {
+	struct bpf_map map;
+	spinlock_t lock;
+	struct rb_root root;
+	struct list_head list;
+};
+
+enum bpf_cond_pseudo_jmp {
+	BPF_MAY_GOTO = 0,
+};
+
+enum bpf_addr_space_cast {
+	BPF_ADDR_SPACE_CAST = 1,
+};
+
+enum {
+	BPF_MAX_TRAMP_LINKS = 38,
+};
+
+enum bpf_tramp_prog_type {
+	BPF_TRAMP_FENTRY = 0,
+	BPF_TRAMP_FEXIT = 1,
+	BPF_TRAMP_MODIFY_RETURN = 2,
+	BPF_TRAMP_MAX = 3,
+	BPF_TRAMP_REPLACE = 4,
+};
+
+typedef void (*bpf_insn_print_t)(void *, const char *, ...);
+
+typedef const char * (*bpf_insn_revmap_call_t)(void *, const struct bpf_insn *);
+
+typedef const char * (*bpf_insn_print_imm_t)(void *, const struct bpf_insn *, __u64);
+
+struct bpf_insn_cbs {
+	bpf_insn_print_t cb_print;
+	bpf_insn_revmap_call_t cb_call;
+	bpf_insn_print_imm_t cb_imm;
+	void *private_data;
+};
+
+struct bpf_mprog_fp {
+	struct bpf_prog *prog;
+};
+
+struct bpf_mprog_cp {
+	struct bpf_link *link;
+};
+
+struct bpf_mprog_bundle;
+
+struct bpf_mprog_entry {
+	struct bpf_mprog_fp fp_items[64];
+	struct bpf_mprog_bundle *parent;
+};
+
+struct bpf_mprog_bundle {
+	struct bpf_mprog_entry a;
+	struct bpf_mprog_entry b;
+	struct bpf_mprog_cp cp_items[64];
+	struct bpf_prog *ref;
+	long: 32;
+	atomic64_t revision;
+	u32 count;
+	long: 32;
+};
+
+struct bpf_tuple {
+	struct bpf_prog *prog;
+	struct bpf_link *link;
+};
+
+struct bpf_dispatcher_prog {
+	struct bpf_prog *prog;
+	refcount_t users;
+};
+
+struct bpf_dispatcher {
+	struct mutex mutex;
+	void *func;
+	struct bpf_dispatcher_prog progs[48];
+	int num_progs;
+	void *image;
+	void *rw_image;
+	u32 image_off;
+	struct bpf_ksym ksym;
+};
+
+struct bpf_prog_info {
+	__u32 type;
+	__u32 id;
+	__u8 tag[8];
+	__u32 jited_prog_len;
+	__u32 xlated_prog_len;
+	__u64 jited_prog_insns;
+	__u64 xlated_prog_insns;
+	__u64 load_time;
+	__u32 created_by_uid;
+	__u32 nr_map_ids;
+	__u64 map_ids;
+	char name[16];
+	__u32 ifindex;
+	__u32 gpl_compatible: 1;
+	__u64 netns_dev;
+	__u64 netns_ino;
+	__u32 nr_jited_ksyms;
+	__u32 nr_jited_func_lens;
+	__u64 jited_ksyms;
+	__u64 jited_func_lens;
+	__u32 btf_id;
+	__u32 func_info_rec_size;
+	__u64 func_info;
+	__u32 nr_func_info;
+	__u32 nr_line_info;
+	__u64 line_info;
+	__u64 jited_line_info;
+	__u32 nr_jited_line_info;
+	__u32 line_info_rec_size;
+	__u32 jited_line_info_rec_size;
+	__u32 nr_prog_tags;
+	__u64 prog_tags;
+	__u64 run_time_ns;
+	__u64 run_cnt;
+	__u64 recursion_misses;
+	__u32 verified_insns;
+	__u32 attach_btf_obj_id;
+	__u32 attach_btf_id;
+	long: 32;
+};
+
+struct bpf_map_info {
+	__u32 type;
+	__u32 id;
+	__u32 key_size;
+	__u32 value_size;
+	__u32 max_entries;
+	__u32 map_flags;
+	char name[16];
+	__u32 ifindex;
+	__u32 btf_vmlinux_value_type_id;
+	__u64 netns_dev;
+	__u64 netns_ino;
+	__u32 btf_id;
+	__u32 btf_key_type_id;
+	__u32 btf_value_type_id;
+	__u32 btf_vmlinux_id;
+	__u64 map_extra;
+};
+
+struct bpf_prog_offload_ops {
+	int (*insn_hook)(struct bpf_verifier_env *, int, int);
+	int (*finalize)(struct bpf_verifier_env *);
+	int (*replace_insn)(struct bpf_verifier_env *, u32, struct bpf_insn *);
+	int (*remove_insns)(struct bpf_verifier_env *, u32, u32);
+	int (*prepare)(struct bpf_prog *);
+	int (*translate)(struct bpf_prog *);
+	void (*destroy)(struct bpf_prog *);
+};
+
+struct bpf_offload_dev {
+	const struct bpf_prog_offload_ops *ops;
+	struct list_head netdevs;
+	void *priv;
+};
+
+typedef struct ns_common *ns_get_path_helper_t(void *);
+
+enum xdp_rx_metadata {
+	XDP_METADATA_KFUNC_RX_TIMESTAMP = 0,
+	XDP_METADATA_KFUNC_RX_HASH = 1,
+	XDP_METADATA_KFUNC_RX_VLAN_TAG = 2,
+	MAX_XDP_METADATA_KFUNC = 3,
+};
+
+struct bpf_offload_netdev {
+	struct rhash_head l;
+	struct net_device *netdev;
+	struct bpf_offload_dev *offdev;
+	struct list_head progs;
+	struct list_head maps;
+	struct list_head offdev_netdevs;
+};
+
+struct ns_get_path_bpf_prog_args {
+	struct bpf_prog *prog;
+	struct bpf_prog_info *info;
+};
+
+struct ns_get_path_bpf_map_args {
+	struct bpf_offloaded_map *offmap;
+	struct bpf_map_info *info;
+};
+
+struct bpf_iter__cgroup {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct cgroup *cgroup;
+	};
+};
+
+struct cgroup_iter_priv {
+	struct cgroup_subsys_state *start_css;
+	bool visited_all;
+	bool terminate;
+	int order;
+};
+
+struct bpf_iter_css {
+	__u64 __opaque[3];
+};
+
+struct bpf_iter_css_kern {
+	struct cgroup_subsys_state *start;
+	struct cgroup_subsys_state *pos;
+	unsigned int flags;
+	long: 32;
+};
+
+enum {
+	BPF_F_SYSCTL_BASE_NAME = 1,
+};
+
+struct bpf_flow_keys {
+	__u16 nhoff;
+	__u16 thoff;
+	__u16 addr_proto;
+	__u8 is_frag;
+	__u8 is_first_frag;
+	__u8 is_encap;
+	__u8 ip_proto;
+	__be16 n_proto;
+	__be16 sport;
+	__be16 dport;
+	union {
+		struct {
+			__be32 ipv4_src;
+			__be32 ipv4_dst;
+		};
+		struct {
+			__u32 ipv6_src[4];
+			__u32 ipv6_dst[4];
+		};
+	};
+	__u32 flags;
+	__be32 flow_label;
+};
+
+struct bpf_sock {
+	__u32 bound_dev_if;
+	__u32 family;
+	__u32 type;
+	__u32 protocol;
+	__u32 mark;
+	__u32 priority;
+	__u32 src_ip4;
+	__u32 src_ip6[4];
+	__u32 src_port;
+	__be16 dst_port;
+	__u32 dst_ip4;
+	__u32 dst_ip6[4];
+	__u32 state;
+	__s32 rx_queue_mapping;
+};
+
+struct __sk_buff {
+	__u32 len;
+	__u32 pkt_type;
+	__u32 mark;
+	__u32 queue_mapping;
+	__u32 protocol;
+	__u32 vlan_present;
+	__u32 vlan_tci;
+	__u32 vlan_proto;
+	__u32 priority;
+	__u32 ingress_ifindex;
+	__u32 ifindex;
+	__u32 tc_index;
+	__u32 cb[5];
+	__u32 hash;
+	__u32 tc_classid;
+	__u32 data;
+	__u32 data_end;
+	__u32 napi_id;
+	__u32 family;
+	__u32 remote_ip4;
+	__u32 local_ip4;
+	__u32 remote_ip6[4];
+	__u32 local_ip6[4];
+	__u32 remote_port;
+	__u32 local_port;
+	__u32 data_meta;
+	union {
+		struct bpf_flow_keys *flow_keys;
+	};
+	__u64 tstamp;
+	__u32 wire_len;
+	__u32 gso_segs;
+	union {
+		struct bpf_sock *sk;
+	};
+	__u32 gso_size;
+	__u8 tstamp_type;
+	__u64 hwtstamp;
+};
+
+struct bpf_cgroup_dev_ctx {
+	__u32 access_type;
+	__u32 major;
+	__u32 minor;
+};
+
+struct bpf_sysctl {
+	__u32 write;
+	__u32 file_pos;
+};
+
+struct bpf_link_primer {
+	struct bpf_link *link;
+	struct file *file;
+	int fd;
+	u32 id;
+};
+
+struct bpf_cg_run_ctx {
+	struct bpf_run_ctx run_ctx;
+	const struct bpf_prog_array_item *prog_item;
+	int retval;
+};
+
+struct __kernel_sockaddr_storage {
+	union {
+		struct {
+			__kernel_sa_family_t ss_family;
+			char __data[126];
+		};
+		void *__align;
+	};
+};
+
+struct qdisc_skb_cb {
+	struct {
+		unsigned int pkt_len;
+		u16 slave_dev_queue_mapping;
+		u16 tc_classid;
+	};
+	unsigned char data[20];
+};
+
+struct bpf_skb_data_end {
+	struct qdisc_skb_cb qdisc_cb;
+	void *data_meta;
+	void *data_end;
+};
+
+struct bpf_sock_addr_kern {
+	struct sock *sk;
+	struct sockaddr *uaddr;
+	u64 tmp_reg;
+	void *t_ctx;
+	u32 uaddrlen;
+};
+
+struct bpf_sock_ops_kern {
+	struct sock *sk;
+	union {
+		u32 args[4];
+		u32 reply;
+		u32 replylong[4];
+	};
+	struct sk_buff *syn_skb;
+	struct sk_buff *skb;
+	void *skb_data_end;
+	u8 op;
+	u8 is_fullsock;
+	u8 remaining_opt_len;
+	long: 32;
+	u64 temp;
+};
+
+struct bpf_sysctl_kern {
+	struct ctl_table_header *head;
+	const struct ctl_table *table;
+	void *cur_val;
+	size_t cur_len;
+	void *new_val;
+	size_t new_len;
+	int new_updated;
+	int write;
+	loff_t *ppos;
+	long: 32;
+	u64 tmp_reg;
+};
+
+struct bpf_sockopt_buf {
+	u8 data[32];
+};
+
+struct bpf_sockopt_kern {
+	struct sock *sk;
+	u8 *optval;
+	u8 *optval_end;
+	s32 level;
+	s32 optname;
+	s32 optlen;
+	struct task_struct *current_task;
+	long: 32;
+	u64 tmp_reg;
+};
+
+struct bpf_cgroup_link {
+	struct bpf_link link;
+	struct cgroup *cgroup;
+	enum bpf_attach_type type;
+};
+
+struct bpf_prog_list {
+	struct hlist_node node;
+	struct bpf_prog *prog;
+	struct bpf_cgroup_link *link;
+	struct bpf_cgroup_storage *storage[2];
+};
+
+typedef u64 (*btf_bpf_get_local_storage)(struct bpf_map *, u64);
+
+typedef u64 (*btf_bpf_get_retval)();
+
+typedef u64 (*btf_bpf_set_retval)(int);
+
+typedef u64 (*btf_bpf_sysctl_get_name)(struct bpf_sysctl_kern *, char *, size_t, u64);
+
+typedef u64 (*btf_bpf_sysctl_get_current_value)(struct bpf_sysctl_kern *, char *, size_t);
+
+typedef u64 (*btf_bpf_sysctl_get_new_value)(struct bpf_sysctl_kern *, char *, size_t);
+
+typedef u64 (*btf_bpf_sysctl_set_new_value)(struct bpf_sysctl_kern *, const char *, size_t);
+
+typedef u64 (*btf_bpf_get_netns_cookie_sockopt)(struct bpf_sockopt_kern *);
+
+typedef void (*swap_func_t)(void *, void *, int);
+
+struct btf_array {
+	__u32 type;
+	__u32 index_type;
+	__u32 nelems;
+};
+
+enum btf_field_iter_kind {
+	BTF_FIELD_ITER_IDS = 0,
+	BTF_FIELD_ITER_STRS = 1,
+};
+
+struct btf_field_desc {
+	int t_off_cnt;
+	int t_offs[2];
+	int m_sz;
+	int m_off_cnt;
+	int m_offs[1];
+};
+
+struct btf_field_iter {
+	struct btf_field_desc desc;
+	void *p;
+	int m_idx;
+	int off_idx;
+	int vlen;
+};
+
+struct btf_relocate {
+	struct btf *btf;
+	const struct btf *base_btf;
+	const struct btf *dist_base_btf;
+	unsigned int nr_base_types;
+	unsigned int nr_split_types;
+	unsigned int nr_dist_base_types;
+	int dist_str_len;
+	int base_str_len;
+	__u32 *id_map;
+	__u32 *str_map;
+};
+
+struct btf_name_info {
+	const char *name;
+	bool needs_size: 1;
+	unsigned int size: 31;
+	__u32 id;
+};
+
+struct perf_event_mmap_page {
+	__u32 version;
+	__u32 compat_version;
+	__u32 lock;
+	__u32 index;
+	__s64 offset;
+	__u64 time_enabled;
+	__u64 time_running;
+	union {
+		__u64 capabilities;
+		struct {
+			__u64 cap_bit0: 1;
+			__u64 cap_bit0_is_deprecated: 1;
+			__u64 cap_user_rdpmc: 1;
+			__u64 cap_user_time: 1;
+			__u64 cap_user_time_zero: 1;
+			__u64 cap_user_time_short: 1;
+			__u64 cap_____res: 58;
+		};
+	};
+	__u16 pmc_width;
+	__u16 time_shift;
+	__u32 time_mult;
+	__u64 time_offset;
+	__u64 time_zero;
+	__u32 size;
+	__u32 __reserved_1;
+	__u64 time_cycles;
+	__u64 time_mask;
+	__u8 __reserved[928];
+	__u64 data_head;
+	__u64 data_tail;
+	__u64 data_offset;
+	__u64 data_size;
+	__u64 aux_head;
+	__u64 aux_tail;
+	__u64 aux_offset;
+	__u64 aux_size;
+};
+
+struct perf_event_header {
+	__u32 type;
+	__u16 misc;
+	__u16 size;
+};
+
+enum perf_event_type {
+	PERF_RECORD_MMAP = 1,
+	PERF_RECORD_LOST = 2,
+	PERF_RECORD_COMM = 3,
+	PERF_RECORD_EXIT = 4,
+	PERF_RECORD_THROTTLE = 5,
+	PERF_RECORD_UNTHROTTLE = 6,
+	PERF_RECORD_FORK = 7,
+	PERF_RECORD_READ = 8,
+	PERF_RECORD_SAMPLE = 9,
+	PERF_RECORD_MMAP2 = 10,
+	PERF_RECORD_AUX = 11,
+	PERF_RECORD_ITRACE_START = 12,
+	PERF_RECORD_LOST_SAMPLES = 13,
+	PERF_RECORD_SWITCH = 14,
+	PERF_RECORD_SWITCH_CPU_WIDE = 15,
+	PERF_RECORD_NAMESPACES = 16,
+	PERF_RECORD_KSYMBOL = 17,
+	PERF_RECORD_BPF_EVENT = 18,
+	PERF_RECORD_CGROUP = 19,
+	PERF_RECORD_TEXT_POKE = 20,
+	PERF_RECORD_AUX_OUTPUT_HW_ID = 21,
+	PERF_RECORD_MAX = 22,
+};
+
+enum pageflags {
+	PG_locked = 0,
+	PG_writeback = 1,
+	PG_referenced = 2,
+	PG_uptodate = 3,
+	PG_dirty = 4,
+	PG_lru = 5,
+	PG_head = 6,
+	PG_waiters = 7,
+	PG_active = 8,
+	PG_workingset = 9,
+	PG_owner_priv_1 = 10,
+	PG_owner_2 = 11,
+	PG_arch_1 = 12,
+	PG_reserved = 13,
+	PG_private = 14,
+	PG_private_2 = 15,
+	PG_reclaim = 16,
+	PG_swapbacked = 17,
+	PG_unevictable = 18,
+	PG_mlocked = 19,
+	__NR_PAGEFLAGS = 20,
+	PG_readahead = 16,
+	PG_swapcache = 10,
+	PG_checked = 10,
+	PG_anon_exclusive = 11,
+	PG_mappedtodisk = 11,
+	PG_fscache = 15,
+	PG_pinned = 10,
+	PG_savepinned = 4,
+	PG_foreign = 10,
+	PG_xen_remapped = 10,
+	PG_isolated = 16,
+	PG_reported = 3,
+	PG_has_hwpoisoned = 8,
+	PG_large_rmappable = 9,
+	PG_partially_mapped = 16,
+};
+
+struct perf_buffer {
+	refcount_t refcount;
+	struct callback_head callback_head;
+	struct work_struct work;
+	int page_order;
+	int nr_pages;
+	int overwrite;
+	int paused;
+	atomic_t poll;
+	local_t head;
+	unsigned int nest;
+	local_t events;
+	local_t wakeup;
+	local_t lost;
+	long int watermark;
+	long int aux_watermark;
+	spinlock_t event_lock;
+	struct list_head event_list;
+	atomic_t mmap_count;
+	long unsigned int mmap_locked;
+	struct user_struct *mmap_user;
+	struct mutex aux_mutex;
+	long int aux_head;
+	unsigned int aux_nest;
+	long int aux_wakeup;
+	long unsigned int aux_pgoff;
+	int aux_nr_pages;
+	int aux_overwrite;
+	atomic_t aux_mmap_count;
+	long unsigned int aux_mmap_locked;
+	void (*free_aux)(void *);
+	refcount_t aux_refcount;
+	int aux_in_sampling;
+	void **aux_pages;
+	void *aux_priv;
+	struct perf_event_mmap_page *user_page;
+	void *data_pages[0];
+};
+
+struct context_tracking {
+	atomic_t state;
+	long int nesting;
+	long int nmi_nesting;
+};
+
+struct compact_control;
+
+struct capture_control {
+	struct compact_control *cc;
+	struct page *page;
+};
+
+struct pipe_buffer;
+
+struct pipe_inode_info {
+	struct mutex mutex;
+	wait_queue_head_t rd_wait;
+	wait_queue_head_t wr_wait;
+	unsigned int head;
+	unsigned int tail;
+	unsigned int max_usage;
+	unsigned int ring_size;
+	unsigned int nr_accounted;
+	unsigned int readers;
+	unsigned int writers;
+	unsigned int files;
+	unsigned int r_counter;
+	unsigned int w_counter;
+	bool poll_usage;
+	struct page *tmp_page;
+	struct fasync_struct *fasync_readers;
+	struct fasync_struct *fasync_writers;
+	struct pipe_buffer *bufs;
+	struct user_struct *user;
+};
+
+struct anon_vma {
+	struct anon_vma *root;
+	struct rw_semaphore rwsem;
+	atomic_t refcount;
+	long unsigned int num_children;
+	long unsigned int num_active_vmas;
+	struct anon_vma *parent;
+	struct rb_root_cached rb_root;
+};
+
+enum vm_fault_reason {
+	VM_FAULT_OOM = 1,
+	VM_FAULT_SIGBUS = 2,
+	VM_FAULT_MAJOR = 4,
+	VM_FAULT_HWPOISON = 16,
+	VM_FAULT_HWPOISON_LARGE = 32,
+	VM_FAULT_SIGSEGV = 64,
+	VM_FAULT_NOPAGE = 256,
+	VM_FAULT_LOCKED = 512,
+	VM_FAULT_RETRY = 1024,
+	VM_FAULT_FALLBACK = 2048,
+	VM_FAULT_DONE_COW = 4096,
+	VM_FAULT_NEEDDSYNC = 8192,
+	VM_FAULT_COMPLETED = 16384,
+	VM_FAULT_HINDEX_MASK = 983040,
+};
+
+enum pagetype {
+	PGTY_buddy = 240,
+	PGTY_offline = 241,
+	PGTY_table = 242,
+	PGTY_guard = 243,
+	PGTY_hugetlb = 244,
+	PGTY_slab = 245,
+	PGTY_zsmalloc = 246,
+	PGTY_unaccepted = 247,
+	PGTY_mapcount_underflow = 255,
+};
+
+typedef struct pglist_data pg_data_t;
+
+struct xa_node {
+	unsigned char shift;
+	unsigned char offset;
+	unsigned char count;
+	unsigned char nr_values;
+	struct xa_node *parent;
+	struct xarray *array;
+	union {
+		struct list_head private_list;
+		struct callback_head callback_head;
+	};
+	void *slots[64];
+	union {
+		long unsigned int tags[6];
+		long unsigned int marks[6];
+	};
+};
+
+typedef void (*xa_update_node_t)(struct xa_node *);
+
+struct xa_state {
+	struct xarray *xa;
+	long unsigned int xa_index;
+	unsigned char xa_shift;
+	unsigned char xa_sibs;
+	unsigned char xa_offset;
+	unsigned char xa_pad;
+	struct xa_node *xa_node;
+	struct xa_node *xa_alloc;
+	xa_update_node_t xa_update;
+	struct list_lru *xa_lru;
+};
+
+enum migrate_reason {
+	MR_COMPACTION = 0,
+	MR_MEMORY_FAILURE = 1,
+	MR_MEMORY_HOTPLUG = 2,
+	MR_SYSCALL = 3,
+	MR_MEMPOLICY_MBIND = 4,
+	MR_NUMA_MISPLACED = 5,
+	MR_CONTIG_RANGE = 6,
+	MR_LONGTERM_PIN = 7,
+	MR_DEMOTION = 8,
+	MR_DAMON = 9,
+	MR_TYPES = 10,
+};
+
+enum {
+	IOPRIO_CLASS_NONE = 0,
+	IOPRIO_CLASS_RT = 1,
+	IOPRIO_CLASS_BE = 2,
+	IOPRIO_CLASS_IDLE = 3,
+	IOPRIO_CLASS_INVALID = 7,
+};
+
+enum {
+	IOPRIO_HINT_NONE = 0,
+	IOPRIO_HINT_DEV_DURATION_LIMIT_1 = 1,
+	IOPRIO_HINT_DEV_DURATION_LIMIT_2 = 2,
+	IOPRIO_HINT_DEV_DURATION_LIMIT_3 = 3,
+	IOPRIO_HINT_DEV_DURATION_LIMIT_4 = 4,
+	IOPRIO_HINT_DEV_DURATION_LIMIT_5 = 5,
+	IOPRIO_HINT_DEV_DURATION_LIMIT_6 = 6,
+	IOPRIO_HINT_DEV_DURATION_LIMIT_7 = 7,
+};
+
+typedef int __kernel_rwf_t;
+
+enum positive_aop_returns {
+	AOP_WRITEPAGE_ACTIVATE = 524288,
+	AOP_TRUNCATED_PAGE = 524289,
+};
+
+enum vm_event_item {
+	PGPGIN = 0,
+	PGPGOUT = 1,
+	PSWPIN = 2,
+	PSWPOUT = 3,
+	PGALLOC_NORMAL = 4,
+	PGALLOC_HIGH = 5,
+	PGALLOC_MOVABLE = 6,
+	ALLOCSTALL_NORMAL = 7,
+	ALLOCSTALL_HIGH = 8,
+	ALLOCSTALL_MOVABLE = 9,
+	PGSCAN_SKIP_NORMAL = 10,
+	PGSCAN_SKIP_HIGH = 11,
+	PGSCAN_SKIP_MOVABLE = 12,
+	PGFREE = 13,
+	PGACTIVATE = 14,
+	PGDEACTIVATE = 15,
+	PGLAZYFREE = 16,
+	PGFAULT = 17,
+	PGMAJFAULT = 18,
+	PGLAZYFREED = 19,
+	PGREFILL = 20,
+	PGREUSE = 21,
+	PGSTEAL_KSWAPD = 22,
+	PGSTEAL_DIRECT = 23,
+	PGSTEAL_KHUGEPAGED = 24,
+	PGSCAN_KSWAPD = 25,
+	PGSCAN_DIRECT = 26,
+	PGSCAN_KHUGEPAGED = 27,
+	PGSCAN_DIRECT_THROTTLE = 28,
+	PGSCAN_ANON = 29,
+	PGSCAN_FILE = 30,
+	PGSTEAL_ANON = 31,
+	PGSTEAL_FILE = 32,
+	PGINODESTEAL = 33,
+	SLABS_SCANNED = 34,
+	KSWAPD_INODESTEAL = 35,
+	KSWAPD_LOW_WMARK_HIT_QUICKLY = 36,
+	KSWAPD_HIGH_WMARK_HIT_QUICKLY = 37,
+	PAGEOUTRUN = 38,
+	PGROTATED = 39,
+	DROP_PAGECACHE = 40,
+	DROP_SLAB = 41,
+	OOM_KILL = 42,
+	PGMIGRATE_SUCCESS = 43,
+	PGMIGRATE_FAIL = 44,
+	THP_MIGRATION_SUCCESS = 45,
+	THP_MIGRATION_FAIL = 46,
+	THP_MIGRATION_SPLIT = 47,
+	COMPACTMIGRATE_SCANNED = 48,
+	COMPACTFREE_SCANNED = 49,
+	COMPACTISOLATED = 50,
+	COMPACTSTALL = 51,
+	COMPACTFAIL = 52,
+	COMPACTSUCCESS = 53,
+	KCOMPACTD_WAKE = 54,
+	KCOMPACTD_MIGRATE_SCANNED = 55,
+	KCOMPACTD_FREE_SCANNED = 56,
+	UNEVICTABLE_PGCULLED = 57,
+	UNEVICTABLE_PGSCANNED = 58,
+	UNEVICTABLE_PGRESCUED = 59,
+	UNEVICTABLE_PGMLOCKED = 60,
+	UNEVICTABLE_PGMUNLOCKED = 61,
+	UNEVICTABLE_PGCLEARED = 62,
+	UNEVICTABLE_PGSTRANDED = 63,
+	SWAP_RA = 64,
+	SWAP_RA_HIT = 65,
+	SWPIN_ZERO = 66,
+	SWPOUT_ZERO = 67,
+	NR_VM_EVENT_ITEMS = 68,
+};
+
+enum mapping_flags {
+	AS_EIO = 0,
+	AS_ENOSPC = 1,
+	AS_MM_ALL_LOCKS = 2,
+	AS_UNEVICTABLE = 3,
+	AS_EXITING = 4,
+	AS_NO_WRITEBACK_TAGS = 5,
+	AS_RELEASE_ALWAYS = 6,
+	AS_STABLE_WRITES = 7,
+	AS_INACCESSIBLE = 8,
+	AS_FOLIO_ORDER_BITS = 5,
+	AS_FOLIO_ORDER_MIN = 16,
+	AS_FOLIO_ORDER_MAX = 21,
+};
+
+typedef int filler_t(struct file *, struct folio *);
+
+typedef unsigned int fgf_t;
+
+struct wait_page_key {
+	struct folio *folio;
+	int bit_nr;
+	int page_match;
+};
+
+struct pipe_buf_operations;
+
+struct pipe_buffer {
+	struct page *page;
+	unsigned int offset;
+	unsigned int len;
+	const struct pipe_buf_operations *ops;
+	unsigned int flags;
+	long unsigned int private;
+};
+
+struct pipe_buf_operations {
+	int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);
+	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
+	bool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);
+	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
+};
+
+struct compact_control {
+	struct list_head freepages[11];
+	struct list_head migratepages;
+	unsigned int nr_freepages;
+	unsigned int nr_migratepages;
+	long unsigned int free_pfn;
+	long unsigned int migrate_pfn;
+	long unsigned int fast_start_pfn;
+	struct zone *zone;
+	long unsigned int total_migrate_scanned;
+	long unsigned int total_free_scanned;
+	short unsigned int fast_search_fail;
+	short int search_order;
+	const gfp_t gfp_mask;
+	int order;
+	int migratetype;
+	const unsigned int alloc_flags;
+	const int highest_zoneidx;
+	enum migrate_mode mode;
+	bool ignore_skip_hint;
+	bool no_set_skip_hint;
+	bool ignore_block_suitable;
+	bool direct_compaction;
+	bool proactive_compaction;
+	bool whole_zone;
+	bool contended;
+	bool finish_pageblock;
+	bool alloc_contig;
+};
+
+struct trace_event_raw_mm_filemap_op_page_cache {
+	struct trace_entry ent;
+	long unsigned int pfn;
+	long unsigned int i_ino;
+	long unsigned int index;
+	dev_t s_dev;
+	unsigned char order;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_filemap_op_page_cache_range {
+	struct trace_entry ent;
+	long unsigned int i_ino;
+	dev_t s_dev;
+	long unsigned int index;
+	long unsigned int last_index;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_filemap_fault {
+	struct trace_entry ent;
+	long unsigned int i_ino;
+	dev_t s_dev;
+	long unsigned int index;
+	char __data[0];
+};
+
+struct trace_event_raw_filemap_set_wb_err {
+	struct trace_entry ent;
+	long unsigned int i_ino;
+	dev_t s_dev;
+	errseq_t errseq;
+	char __data[0];
+};
+
+struct trace_event_raw_file_check_and_advance_wb_err {
+	struct trace_entry ent;
+	struct file *file;
+	long unsigned int i_ino;
+	dev_t s_dev;
+	errseq_t old;
+	errseq_t new;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_mm_filemap_op_page_cache {};
+
+struct trace_event_data_offsets_mm_filemap_op_page_cache_range {};
+
+struct trace_event_data_offsets_mm_filemap_fault {};
+
+struct trace_event_data_offsets_filemap_set_wb_err {};
+
+struct trace_event_data_offsets_file_check_and_advance_wb_err {};
+
+typedef void (*btf_trace_mm_filemap_delete_from_page_cache)(void *, struct folio *);
+
+typedef void (*btf_trace_mm_filemap_add_to_page_cache)(void *, struct folio *);
+
+typedef void (*btf_trace_mm_filemap_get_pages)(void *, struct address_space *, long unsigned int, long unsigned int);
+
+typedef void (*btf_trace_mm_filemap_map_pages)(void *, struct address_space *, long unsigned int, long unsigned int);
+
+typedef void (*btf_trace_mm_filemap_fault)(void *, struct address_space *, long unsigned int);
+
+typedef void (*btf_trace_filemap_set_wb_err)(void *, struct address_space *, errseq_t);
+
+typedef void (*btf_trace_file_check_and_advance_wb_err)(void *, struct file *, errseq_t);
+
+enum behavior {
+	EXCLUSIVE = 0,
+	SHARED = 1,
+	DROP = 2,
+};
+
+struct fd {
+	long unsigned int word;
+};
+
+struct lru_gen_mm_list {
+	struct list_head fifo;
+	spinlock_t lock;
+};
+
+enum lruvec_flags {
+	LRUVEC_CGROUP_CONGESTED = 0,
+	LRUVEC_NODE_CONGESTED = 1,
+};
+
+enum {
+	LRU_GEN_ANON = 0,
+	LRU_GEN_FILE = 1,
+};
+
+enum {
+	LRU_GEN_CORE = 0,
+	LRU_GEN_MM_WALK = 1,
+	LRU_GEN_NONLEAF_YOUNG = 2,
+	NR_LRU_GEN_CAPS = 3,
+};
+
+struct lru_gen_mm_state {
+	long unsigned int seq;
+	struct list_head *head;
+	struct list_head *tail;
+	long unsigned int *filters[2];
+	long unsigned int stats[4];
+};
+
+enum pgdat_flags {
+	PGDAT_DIRTY = 0,
+	PGDAT_WRITEBACK = 1,
+	PGDAT_RECLAIM_LOCKED = 2,
+};
+
+enum zone_flags {
+	ZONE_BOOSTED_WATERMARK = 0,
+	ZONE_RECLAIM_ACTIVE = 1,
+	ZONE_BELOW_HIGH = 2,
+};
+
+struct kobj_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
+	ssize_t (*store)(struct kobject *, struct kobj_attribute *, const char *, size_t);
+};
+
+struct reclaim_stat {
+	unsigned int nr_dirty;
+	unsigned int nr_unqueued_dirty;
+	unsigned int nr_congested;
+	unsigned int nr_writeback;
+	unsigned int nr_immediate;
+	unsigned int nr_pageout;
+	unsigned int nr_activate[2];
+	unsigned int nr_ref_keep;
+	unsigned int nr_unmap_fail;
+	unsigned int nr_lazyfree_fail;
+	unsigned int nr_demoted;
+};
+
+struct mem_cgroup_reclaim_cookie {
+	pg_data_t *pgdat;
+	int generation;
+};
+
+enum objext_flags {
+	OBJEXTS_ALLOC_FAIL = 4,
+	__NR_OBJEXTS_FLAGS = 8,
+};
+
+enum {
+	SWP_USED = 1,
+	SWP_WRITEOK = 2,
+	SWP_DISCARDABLE = 4,
+	SWP_DISCARDING = 8,
+	SWP_SOLIDSTATE = 16,
+	SWP_CONTINUED = 32,
+	SWP_BLKDEV = 64,
+	SWP_ACTIVATED = 128,
+	SWP_FS_OPS = 256,
+	SWP_AREA_DISCARD = 512,
+	SWP_PAGE_DISCARD = 1024,
+	SWP_STABLE_WRITES = 2048,
+	SWP_SYNCHRONOUS_IO = 4096,
+	SWP_SCANNING = 16384,
+};
+
+enum ttu_flags {
+	TTU_SPLIT_HUGE_PMD = 4,
+	TTU_IGNORE_MLOCK = 8,
+	TTU_SYNC = 16,
+	TTU_HWPOISON = 32,
+	TTU_BATCH_FLUSH = 64,
+	TTU_RMAP_LOCKED = 128,
+};
+
+struct page_vma_mapped_walk {
+	long unsigned int pfn;
+	long unsigned int nr_pages;
+	long unsigned int pgoff;
+	struct vm_area_struct *vma;
+	long unsigned int address;
+	pmd_t *pmd;
+	pte_t *pte;
+	spinlock_t *ptl;
+	unsigned int flags;
+};
+
+enum compact_priority {
+	COMPACT_PRIO_SYNC_FULL = 0,
+	MIN_COMPACT_PRIORITY = 0,
+	COMPACT_PRIO_SYNC_LIGHT = 1,
+	MIN_COMPACT_COSTLY_PRIORITY = 1,
+	DEF_COMPACT_PRIORITY = 1,
+	COMPACT_PRIO_ASYNC = 2,
+	INIT_COMPACT_PRIORITY = 2,
+};
+
+enum compact_result {
+	COMPACT_NOT_SUITABLE_ZONE = 0,
+	COMPACT_SKIPPED = 1,
+	COMPACT_DEFERRED = 2,
+	COMPACT_NO_SUITABLE_PAGE = 3,
+	COMPACT_CONTINUE = 4,
+	COMPACT_COMPLETE = 5,
+	COMPACT_PARTIAL_SKIPPED = 6,
+	COMPACT_CONTENDED = 7,
+	COMPACT_SUCCESS = 8,
+};
+
+typedef struct folio *new_folio_t(struct folio *, long unsigned int);
+
+typedef void free_folio_t(struct folio *, long unsigned int);
+
+enum oom_constraint {
+	CONSTRAINT_NONE = 0,
+	CONSTRAINT_CPUSET = 1,
+	CONSTRAINT_MEMORY_POLICY = 2,
+	CONSTRAINT_MEMCG = 3,
+};
+
+struct oom_control {
+	struct zonelist *zonelist;
+	nodemask_t *nodemask;
+	struct mem_cgroup *memcg;
+	const gfp_t gfp_mask;
+	const int order;
+	long unsigned int totalpages;
+	struct task_struct *chosen;
+	long int chosen_points;
+	enum oom_constraint constraint;
+};
+
+enum page_walk_lock {
+	PGWALK_RDLOCK = 0,
+	PGWALK_WRLOCK = 1,
+	PGWALK_WRLOCK_VERIFY = 2,
+};
+
+struct mm_walk;
+
+struct mm_walk_ops {
+	int (*pgd_entry)(pgd_t *, long unsigned int, long unsigned int, struct mm_walk *);
+	int (*p4d_entry)(p4d_t *, long unsigned int, long unsigned int, struct mm_walk *);
+	int (*pud_entry)(pud_t *, long unsigned int, long unsigned int, struct mm_walk *);
+	int (*pmd_entry)(pmd_t *, long unsigned int, long unsigned int, struct mm_walk *);
+	int (*pte_entry)(pte_t *, long unsigned int, long unsigned int, struct mm_walk *);
+	int (*pte_hole)(long unsigned int, long unsigned int, int, struct mm_walk *);
+	int (*hugetlb_entry)(pte_t *, long unsigned int, long unsigned int, long unsigned int, struct mm_walk *);
+	int (*test_walk)(long unsigned int, long unsigned int, struct mm_walk *);
+	int (*pre_vma)(long unsigned int, long unsigned int, struct mm_walk *);
+	void (*post_vma)(struct mm_walk *);
+	enum page_walk_lock walk_lock;
+};
+
+enum page_walk_action {
+	ACTION_SUBTREE = 0,
+	ACTION_CONTINUE = 1,
+	ACTION_AGAIN = 2,
+};
+
+struct mm_walk {
+	const struct mm_walk_ops *ops;
+	struct mm_struct *mm;
+	pgd_t *pgd;
+	struct vm_area_struct *vma;
+	enum page_walk_action action;
+	bool no_vma;
+	void *private;
+};
+
+struct migration_target_control {
+	int nid;
+	nodemask_t *nmask;
+	gfp_t gfp_mask;
+	enum migrate_reason reason;
+};
+
+struct trace_event_raw_mm_vmscan_kswapd_sleep {
+	struct trace_entry ent;
+	int nid;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_vmscan_kswapd_wake {
+	struct trace_entry ent;
+	int nid;
+	int zid;
+	int order;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_vmscan_wakeup_kswapd {
+	struct trace_entry ent;
+	int nid;
+	int zid;
+	int order;
+	long unsigned int gfp_flags;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_vmscan_direct_reclaim_begin_template {
+	struct trace_entry ent;
+	int order;
+	long unsigned int gfp_flags;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_vmscan_direct_reclaim_end_template {
+	struct trace_entry ent;
+	long unsigned int nr_reclaimed;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_shrink_slab_start {
+	struct trace_entry ent;
+	struct shrinker *shr;
+	void *shrink;
+	int nid;
+	long int nr_objects_to_shrink;
+	long unsigned int gfp_flags;
+	long unsigned int cache_items;
+	long long unsigned int delta;
+	long unsigned int total_scan;
+	int priority;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_shrink_slab_end {
+	struct trace_entry ent;
+	struct shrinker *shr;
+	int nid;
+	void *shrink;
+	long int unused_scan;
+	long int new_scan;
+	int retval;
+	long int total_scan;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_vmscan_lru_isolate {
+	struct trace_entry ent;
+	int highest_zoneidx;
+	int order;
+	long unsigned int nr_requested;
+	long unsigned int nr_scanned;
+	long unsigned int nr_skipped;
+	long unsigned int nr_taken;
+	int lru;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_vmscan_write_folio {
+	struct trace_entry ent;
+	long unsigned int pfn;
+	int reclaim_flags;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_vmscan_lru_shrink_inactive {
+	struct trace_entry ent;
+	int nid;
+	long unsigned int nr_scanned;
+	long unsigned int nr_reclaimed;
+	long unsigned int nr_dirty;
+	long unsigned int nr_writeback;
+	long unsigned int nr_congested;
+	long unsigned int nr_immediate;
+	unsigned int nr_activate0;
+	unsigned int nr_activate1;
+	long unsigned int nr_ref_keep;
+	long unsigned int nr_unmap_fail;
+	int priority;
+	int reclaim_flags;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_vmscan_lru_shrink_active {
+	struct trace_entry ent;
+	int nid;
+	long unsigned int nr_taken;
+	long unsigned int nr_active;
+	long unsigned int nr_deactivated;
+	long unsigned int nr_referenced;
+	int priority;
+	int reclaim_flags;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_vmscan_node_reclaim_begin {
+	struct trace_entry ent;
+	int nid;
+	int order;
+	long unsigned int gfp_flags;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_vmscan_throttled {
+	struct trace_entry ent;
+	int nid;
+	int usec_timeout;
+	int usec_delayed;
+	int reason;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_mm_vmscan_kswapd_sleep {};
+
+struct trace_event_data_offsets_mm_vmscan_kswapd_wake {};
+
+struct trace_event_data_offsets_mm_vmscan_wakeup_kswapd {};
+
+struct trace_event_data_offsets_mm_vmscan_direct_reclaim_begin_template {};
+
+struct trace_event_data_offsets_mm_vmscan_direct_reclaim_end_template {};
+
+struct trace_event_data_offsets_mm_shrink_slab_start {};
+
+struct trace_event_data_offsets_mm_shrink_slab_end {};
+
+struct trace_event_data_offsets_mm_vmscan_lru_isolate {};
+
+struct trace_event_data_offsets_mm_vmscan_write_folio {};
+
+struct trace_event_data_offsets_mm_vmscan_lru_shrink_inactive {};
+
+struct trace_event_data_offsets_mm_vmscan_lru_shrink_active {};
+
+struct trace_event_data_offsets_mm_vmscan_node_reclaim_begin {};
+
+struct trace_event_data_offsets_mm_vmscan_throttled {};
+
+typedef void (*btf_trace_mm_vmscan_kswapd_sleep)(void *, int);
+
+typedef void (*btf_trace_mm_vmscan_kswapd_wake)(void *, int, int, int);
+
+typedef void (*btf_trace_mm_vmscan_wakeup_kswapd)(void *, int, int, int, gfp_t);
+
+typedef void (*btf_trace_mm_vmscan_direct_reclaim_begin)(void *, int, gfp_t);
+
+typedef void (*btf_trace_mm_vmscan_memcg_reclaim_begin)(void *, int, gfp_t);
+
+typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_begin)(void *, int, gfp_t);
+
+typedef void (*btf_trace_mm_vmscan_direct_reclaim_end)(void *, long unsigned int);
+
+typedef void (*btf_trace_mm_vmscan_memcg_reclaim_end)(void *, long unsigned int);
+
+typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_end)(void *, long unsigned int);
+
+typedef void (*btf_trace_mm_shrink_slab_start)(void *, struct shrinker *, struct shrink_control *, long int, long unsigned int, long long unsigned int, long unsigned int, int);
+
+typedef void (*btf_trace_mm_shrink_slab_end)(void *, struct shrinker *, int, int, long int, long int, long int);
+
+typedef void (*btf_trace_mm_vmscan_lru_isolate)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);
+
+typedef void (*btf_trace_mm_vmscan_write_folio)(void *, struct folio *);
+
+typedef void (*btf_trace_mm_vmscan_lru_shrink_inactive)(void *, int, long unsigned int, long unsigned int, struct reclaim_stat *, int, int);
+
+typedef void (*btf_trace_mm_vmscan_lru_shrink_active)(void *, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int, int);
+
+typedef void (*btf_trace_mm_vmscan_node_reclaim_begin)(void *, int, int, gfp_t);
+
+typedef void (*btf_trace_mm_vmscan_node_reclaim_end)(void *, long unsigned int);
+
+typedef void (*btf_trace_mm_vmscan_throttled)(void *, int, int, int, int);
+
+struct scan_control {
+	long unsigned int nr_to_reclaim;
+	nodemask_t *nodemask;
+	struct mem_cgroup *target_mem_cgroup;
+	long unsigned int anon_cost;
+	long unsigned int file_cost;
+	int *proactive_swappiness;
+	unsigned int may_deactivate: 2;
+	unsigned int force_deactivate: 1;
+	unsigned int skipped_deactivate: 1;
+	unsigned int may_writepage: 1;
+	unsigned int may_unmap: 1;
+	unsigned int may_swap: 1;
+	unsigned int no_cache_trim_mode: 1;
+	unsigned int cache_trim_mode_failed: 1;
+	unsigned int proactive: 1;
+	unsigned int memcg_low_reclaim: 1;
+	unsigned int memcg_low_skipped: 1;
+	unsigned int memcg_full_walk: 1;
+	unsigned int hibernation_mode: 1;
+	unsigned int compaction_ready: 1;
+	unsigned int cache_trim_mode: 1;
+	unsigned int file_is_tiny: 1;
+	unsigned int no_demotion: 1;
+	s8 order;
+	s8 priority;
+	s8 reclaim_idx;
+	gfp_t gfp_mask;
+	long unsigned int nr_scanned;
+	long unsigned int nr_reclaimed;
+	struct {
+		unsigned int dirty;
+		unsigned int unqueued_dirty;
+		unsigned int congested;
+		unsigned int writeback;
+		unsigned int immediate;
+		unsigned int file_taken;
+		unsigned int taken;
+	} nr;
+	struct reclaim_state reclaim_state;
+};
+
+typedef enum {
+	PAGE_KEEP = 0,
+	PAGE_ACTIVATE = 1,
+	PAGE_SUCCESS = 2,
+	PAGE_CLEAN = 3,
+} pageout_t;
+
+enum folio_references {
+	FOLIOREF_RECLAIM = 0,
+	FOLIOREF_RECLAIM_CLEAN = 1,
+	FOLIOREF_KEEP = 2,
+	FOLIOREF_ACTIVATE = 3,
+};
+
+enum scan_balance {
+	SCAN_EQUAL = 0,
+	SCAN_FRACT = 1,
+	SCAN_ANON = 2,
+	SCAN_FILE = 3,
+};
+
+struct ctrl_pos {
+	long unsigned int refaulted;
+	long unsigned int total;
+	int gain;
+};
+
+enum {
+	MEMCG_LRU_NOP = 0,
+	MEMCG_LRU_HEAD = 1,
+	MEMCG_LRU_TAIL = 2,
+	MEMCG_LRU_OLD = 3,
+	MEMCG_LRU_YOUNG = 4,
+};
+
+enum pageblock_bits {
+	PB_migrate = 0,
+	PB_migrate_end = 2,
+	PB_migrate_skip = 3,
+	NR_PAGEBLOCK_BITS = 4,
+};
+
+typedef unsigned int isolate_mode_t;
+
+struct movable_operations {
+	bool (*isolate_page)(struct page *, isolate_mode_t);
+	int (*migrate_page)(struct page *, struct page *, enum migrate_mode);
+	void (*putback_page)(struct page *);
+};
+
+struct alloc_context {
+	struct zonelist *zonelist;
+	nodemask_t *nodemask;
+	struct zoneref *preferred_zoneref;
+	int migratetype;
+	enum zone_type highest_zoneidx;
+	bool spread_dirty_pages;
+};
+
+struct trace_event_raw_mm_compaction_isolate_template {
+	struct trace_entry ent;
+	long unsigned int start_pfn;
+	long unsigned int end_pfn;
+	long unsigned int nr_scanned;
+	long unsigned int nr_taken;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_compaction_migratepages {
+	struct trace_entry ent;
+	long unsigned int nr_migrated;
+	long unsigned int nr_failed;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_compaction_begin {
+	struct trace_entry ent;
+	long unsigned int zone_start;
+	long unsigned int migrate_pfn;
+	long unsigned int free_pfn;
+	long unsigned int zone_end;
+	bool sync;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_compaction_end {
+	struct trace_entry ent;
+	long unsigned int zone_start;
+	long unsigned int migrate_pfn;
+	long unsigned int free_pfn;
+	long unsigned int zone_end;
+	bool sync;
+	int status;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_compaction_try_to_compact_pages {
+	struct trace_entry ent;
+	int order;
+	long unsigned int gfp_mask;
+	int prio;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_compaction_suitable_template {
+	struct trace_entry ent;
+	int nid;
+	enum zone_type idx;
+	int order;
+	int ret;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_compaction_defer_template {
+	struct trace_entry ent;
+	int nid;
+	enum zone_type idx;
+	int order;
+	unsigned int considered;
+	unsigned int defer_shift;
+	int order_failed;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_compaction_kcompactd_sleep {
+	struct trace_entry ent;
+	int nid;
+	char __data[0];
+};
+
+struct trace_event_raw_kcompactd_wake_template {
+	struct trace_entry ent;
+	int nid;
+	int order;
+	enum zone_type highest_zoneidx;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_mm_compaction_isolate_template {};
+
+struct trace_event_data_offsets_mm_compaction_migratepages {};
+
+struct trace_event_data_offsets_mm_compaction_begin {};
+
+struct trace_event_data_offsets_mm_compaction_end {};
+
+struct trace_event_data_offsets_mm_compaction_try_to_compact_pages {};
+
+struct trace_event_data_offsets_mm_compaction_suitable_template {};
+
+struct trace_event_data_offsets_mm_compaction_defer_template {};
+
+struct trace_event_data_offsets_mm_compaction_kcompactd_sleep {};
+
+struct trace_event_data_offsets_kcompactd_wake_template {};
+
+typedef void (*btf_trace_mm_compaction_isolate_migratepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
+
+typedef void (*btf_trace_mm_compaction_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
+
+typedef void (*btf_trace_mm_compaction_fast_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
+
+typedef void (*btf_trace_mm_compaction_migratepages)(void *, unsigned int, unsigned int);
+
+typedef void (*btf_trace_mm_compaction_begin)(void *, struct compact_control *, long unsigned int, long unsigned int, bool);
+
+typedef void (*btf_trace_mm_compaction_end)(void *, struct compact_control *, long unsigned int, long unsigned int, bool, int);
+
+typedef void (*btf_trace_mm_compaction_try_to_compact_pages)(void *, int, gfp_t, int);
+
+typedef void (*btf_trace_mm_compaction_finished)(void *, struct zone *, int, int);
+
+typedef void (*btf_trace_mm_compaction_suitable)(void *, struct zone *, int, int);
+
+typedef void (*btf_trace_mm_compaction_deferred)(void *, struct zone *, int);
+
+typedef void (*btf_trace_mm_compaction_defer_compaction)(void *, struct zone *, int);
+
+typedef void (*btf_trace_mm_compaction_defer_reset)(void *, struct zone *, int);
+
+typedef void (*btf_trace_mm_compaction_kcompactd_sleep)(void *, int);
+
+typedef void (*btf_trace_mm_compaction_wakeup_kcompactd)(void *, int, int, enum zone_type);
+
+typedef void (*btf_trace_mm_compaction_kcompactd_wake)(void *, int, int, enum zone_type);
+
+typedef enum {
+	ISOLATE_ABORT = 0,
+	ISOLATE_NONE = 1,
+	ISOLATE_SUCCESS = 2,
+} isolate_migrate_t;
+
+enum {
+	DUMP_PREFIX_NONE = 0,
+	DUMP_PREFIX_ADDRESS = 1,
+	DUMP_PREFIX_OFFSET = 2,
+};
+
+struct page_address_map {
+	struct page *page;
+	void *virtual;
+	struct list_head list;
+};
+
+struct page_address_slot {
+	struct list_head lh;
+	spinlock_t lock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct anon_vma_name {
+	struct kref kref;
+	char name[0];
+};
+
+struct encoded_page;
+
+struct vm_unmapped_area_info {
+	long unsigned int flags;
+	long unsigned int length;
+	long unsigned int low_limit;
+	long unsigned int high_limit;
+	long unsigned int align_mask;
+	long unsigned int align_offset;
+	long unsigned int start_gap;
+};
+
+enum {
+	HUGETLB_SHMFS_INODE = 1,
+	HUGETLB_ANONHUGE_INODE = 2,
+};
+
+struct hstate {};
+
+struct mempolicy {};
+
+struct mmu_gather_batch {
+	struct mmu_gather_batch *next;
+	unsigned int nr;
+	unsigned int max;
+	struct encoded_page *encoded_pages[0];
+};
+
+struct mmu_gather {
+	struct mm_struct *mm;
+	long unsigned int start;
+	long unsigned int end;
+	unsigned int fullmm: 1;
+	unsigned int need_flush_all: 1;
+	unsigned int freed_tables: 1;
+	unsigned int delayed_rmap: 1;
+	unsigned int cleared_ptes: 1;
+	unsigned int cleared_pmds: 1;
+	unsigned int cleared_puds: 1;
+	unsigned int cleared_p4ds: 1;
+	unsigned int vma_exec: 1;
+	unsigned int vma_huge: 1;
+	unsigned int vma_pfn: 1;
+	unsigned int batch_count;
+	struct mmu_gather_batch *active;
+	struct mmu_gather_batch local;
+	struct page *__pages[8];
+};
+
+struct trace_event_raw_vm_unmapped_area {
+	struct trace_entry ent;
+	long unsigned int addr;
+	long unsigned int total_vm;
+	long unsigned int flags;
+	long unsigned int length;
+	long unsigned int low_limit;
+	long unsigned int high_limit;
+	long unsigned int align_mask;
+	long unsigned int align_offset;
+	char __data[0];
+};
+
+struct trace_event_raw_vma_mas_szero {
+	struct trace_entry ent;
+	struct maple_tree *mt;
+	long unsigned int start;
+	long unsigned int end;
+	char __data[0];
+};
+
+struct trace_event_raw_vma_store {
+	struct trace_entry ent;
+	struct maple_tree *mt;
+	struct vm_area_struct *vma;
+	long unsigned int vm_start;
+	long unsigned int vm_end;
+	char __data[0];
+};
+
+struct trace_event_raw_exit_mmap {
+	struct trace_entry ent;
+	struct mm_struct *mm;
+	struct maple_tree *mt;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_vm_unmapped_area {};
+
+struct trace_event_data_offsets_vma_mas_szero {};
+
+struct trace_event_data_offsets_vma_store {};
+
+struct trace_event_data_offsets_exit_mmap {};
+
+typedef void (*btf_trace_vm_unmapped_area)(void *, long unsigned int, struct vm_unmapped_area_info *);
+
+typedef void (*btf_trace_vma_mas_szero)(void *, struct maple_tree *, long unsigned int, long unsigned int);
+
+typedef void (*btf_trace_vma_store)(void *, struct maple_tree *, struct vm_area_struct *);
+
+typedef void (*btf_trace_exit_mmap)(void *, struct mm_struct *);
+
+struct vma_munmap_struct {
+	struct vma_iterator *vmi;
+	struct vm_area_struct *vma;
+	struct vm_area_struct *prev;
+	struct vm_area_struct *next;
+	struct list_head *uf;
+	long unsigned int start;
+	long unsigned int end;
+	long unsigned int unmap_start;
+	long unsigned int unmap_end;
+	int vma_count;
+	bool unlock;
+	bool clear_ptes;
+	long unsigned int nr_pages;
+	long unsigned int locked_vm;
+	long unsigned int nr_accounted;
+	long unsigned int exec_vm;
+	long unsigned int stack_vm;
+	long unsigned int data_vm;
+};
+
+enum vma_merge_state {
+	VMA_MERGE_START = 0,
+	VMA_MERGE_ERROR_NOMEM = 1,
+	VMA_MERGE_NOMERGE = 2,
+	VMA_MERGE_SUCCESS = 3,
+};
+
+enum vma_merge_flags {
+	VMG_FLAG_DEFAULT = 0,
+	VMG_FLAG_JUST_EXPAND = 1,
+};
+
+struct vma_merge_struct {
+	struct mm_struct *mm;
+	struct vma_iterator *vmi;
+	long unsigned int pgoff;
+	struct vm_area_struct *prev;
+	struct vm_area_struct *next;
+	struct vm_area_struct *vma;
+	long unsigned int start;
+	long unsigned int end;
+	long unsigned int flags;
+	struct file *file;
+	struct anon_vma *anon_vma;
+	struct mempolicy *policy;
+	struct vm_userfaultfd_ctx uffd_ctx;
+	struct anon_vma_name *anon_name;
+	enum vma_merge_flags merge_flags;
+	enum vma_merge_state state;
+};
+
+struct mmap_arg_struct {
+	long unsigned int addr;
+	long unsigned int len;
+	long unsigned int prot;
+	long unsigned int flags;
+	long unsigned int fd;
+	long unsigned int offset;
+};
+
+struct mmu_notifier_range {
+	long unsigned int start;
+	long unsigned int end;
+};
+
+enum pgt_entry {
+	NORMAL_PMD = 0,
+	HPAGE_PMD = 1,
+	NORMAL_PUD = 2,
+	HPAGE_PUD = 3,
+};
+
+typedef int folio_walk_flags_t;
+
+enum folio_walk_level {
+	FW_LEVEL_PTE = 0,
+	FW_LEVEL_PMD = 1,
+	FW_LEVEL_PUD = 2,
+};
+
+struct folio_walk {
+	struct page *page;
+	enum folio_walk_level level;
+	union {
+		pte_t *ptep;
+		pud_t *pudp;
+		pmd_t *pmdp;
+	};
+	union {
+		pte_t pte;
+		pud_t pud;
+		pmd_t pmd;
+	};
+	struct vm_area_struct *vma;
+	spinlock_t *ptl;
+};
+
+struct vmap_area {
+	long unsigned int va_start;
+	long unsigned int va_end;
+	struct rb_node rb_node;
+	struct list_head list;
+	union {
+		long unsigned int subtree_max_size;
+		struct vm_struct *vm;
+	};
+	long unsigned int flags;
+};
+
+typedef unsigned int pgtbl_mod_mask;
+
+typedef unsigned int kasan_vmalloc_flags_t;
+
+enum wb_stat_item {
+	WB_RECLAIMABLE = 0,
+	WB_WRITEBACK = 1,
+	WB_DIRTIED = 2,
+	WB_WRITTEN = 3,
+	NR_WB_STAT_ITEMS = 4,
+};
+
+enum memcg_stat_item {
+	MEMCG_SWAP = 44,
+	MEMCG_SOCK = 45,
+	MEMCG_PERCPU_B = 46,
+	MEMCG_VMALLOC = 47,
+	MEMCG_KMEM = 48,
+	MEMCG_ZSWAP_B = 49,
+	MEMCG_ZSWAPPED = 50,
+	MEMCG_NR_STAT = 51,
+};
+
+struct rb_augment_callbacks {
+	void (*propagate)(struct rb_node *, struct rb_node *);
+	void (*copy)(struct rb_node *, struct rb_node *);
+	void (*rotate)(struct rb_node *, struct rb_node *);
+};
+
+struct trace_event_raw_alloc_vmap_area {
+	struct trace_entry ent;
+	long unsigned int addr;
+	long unsigned int size;
+	long unsigned int align;
+	long unsigned int vstart;
+	long unsigned int vend;
+	int failed;
+	char __data[0];
+};
+
+struct trace_event_raw_purge_vmap_area_lazy {
+	struct trace_entry ent;
+	long unsigned int start;
+	long unsigned int end;
+	unsigned int npurged;
+	char __data[0];
+};
+
+struct trace_event_raw_free_vmap_area_noflush {
+	struct trace_entry ent;
+	long unsigned int va_start;
+	long unsigned int nr_lazy;
+	long unsigned int nr_lazy_max;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_alloc_vmap_area {};
+
+struct trace_event_data_offsets_purge_vmap_area_lazy {};
+
+struct trace_event_data_offsets_free_vmap_area_noflush {};
+
+typedef void (*btf_trace_alloc_vmap_area)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);
+
+typedef void (*btf_trace_purge_vmap_area_lazy)(void *, long unsigned int, long unsigned int, unsigned int);
+
+typedef void (*btf_trace_free_vmap_area_noflush)(void *, long unsigned int, long unsigned int, long unsigned int);
+
+struct vfree_deferred {
+	struct llist_head list;
+	struct work_struct wq;
+};
+
+struct rb_list {
+	struct rb_root root;
+	struct list_head head;
+	spinlock_t lock;
+};
+
+struct vmap_pool {
+	struct list_head head;
+	long unsigned int len;
+};
+
+struct vmap_node {
+	struct vmap_pool pool[256];
+	spinlock_t pool_lock;
+	bool skip_populate;
+	struct rb_list busy;
+	struct rb_list lazy;
+	struct list_head purge_list;
+	struct work_struct purge_work;
+	long unsigned int nr_purged;
+};
+
+enum fit_type {
+	NOTHING_FIT = 0,
+	FL_FIT_TYPE = 1,
+	LE_FIT_TYPE = 2,
+	RE_FIT_TYPE = 3,
+	NE_FIT_TYPE = 4,
+};
+
+struct vmap_block_queue {
+	spinlock_t lock;
+	struct list_head free;
+	struct xarray vmap_blocks;
+};
+
+struct vmap_block {
+	spinlock_t lock;
+	struct vmap_area *va;
+	long unsigned int free;
+	long unsigned int dirty;
+	long unsigned int used_map[32];
+	long unsigned int dirty_min;
+	long unsigned int dirty_max;
+	struct list_head free_list;
+	struct callback_head callback_head;
+	struct list_head purge;
+	unsigned int cpu;
+};
+
+struct swap_slots_cache {
+	bool lock_initialized;
+	struct mutex alloc_lock;
+	swp_entry_t *slots;
+	int nr;
+	int cur;
+	spinlock_t free_lock;
+	swp_entry_t *slots_ret;
+	int n_ret;
+};
+
+enum vmpressure_levels {
+	VMPRESSURE_LOW = 0,
+	VMPRESSURE_MEDIUM = 1,
+	VMPRESSURE_CRITICAL = 2,
+	VMPRESSURE_NUM_LEVELS = 3,
+};
+
+enum vmpressure_modes {
+	VMPRESSURE_NO_PASSTHROUGH = 0,
+	VMPRESSURE_HIERARCHY = 1,
+	VMPRESSURE_LOCAL = 2,
+	VMPRESSURE_NUM_MODES = 3,
+};
+
+struct eventfd_ctx;
+
+struct vmpressure_event {
+	struct eventfd_ctx *efd;
+	enum vmpressure_levels level;
+	enum vmpressure_modes mode;
+	struct list_head node;
+};
+
+enum execmem_range_flags {
+	EXECMEM_KASAN_SHADOW = 1,
+};
+
+struct execmem_range {
+	long unsigned int start;
+	long unsigned int end;
+	long unsigned int fallback_start;
+	long unsigned int fallback_end;
+	pgprot_t pgprot;
+	unsigned int alignment;
+	enum execmem_range_flags flags;
+};
+
+struct execmem_info {
+	struct execmem_range ranges[5];
+};
+
+struct files_stat_struct {
+	long unsigned int nr_files;
+	long unsigned int nr_free_files;
+	long unsigned int max_files;
+};
+
+struct file_lock_context {
+	spinlock_t flc_lock;
+	struct list_head flc_flock;
+	struct list_head flc_posix;
+	struct list_head flc_lease;
+};
+
+struct fsnotify_mark_connector {
+	spinlock_t lock;
+	unsigned char type;
+	unsigned char prio;
+	short unsigned int flags;
+	union {
+		void *obj;
+		struct fsnotify_mark_connector *destroy_next;
+	};
+	struct hlist_head list;
+};
+
+struct fsnotify_sb_info {
+	struct fsnotify_mark_connector *sb_marks;
+	atomic_long_t watched_objects[3];
+};
+
+struct file_lock_core {
+	struct file_lock_core *flc_blocker;
+	struct list_head flc_list;
+	struct hlist_node flc_link;
+	struct list_head flc_blocked_requests;
+	struct list_head flc_blocked_member;
+	fl_owner_t flc_owner;
+	unsigned int flc_flags;
+	unsigned char flc_type;
+	pid_t flc_pid;
+	int flc_link_cpu;
+	wait_queue_head_t flc_wait;
+	struct file *flc_file;
+};
+
+struct nlm_lockowner;
+
+struct nfs_lock_info {
+	u32 state;
+	struct nlm_lockowner *owner;
+	struct list_head list;
+};
+
+struct nfs4_lock_state;
+
+struct nfs4_lock_info {
+	struct nfs4_lock_state *owner;
+};
+
+struct file_lock_operations;
+
+struct lock_manager_operations;
+
+struct file_lock {
+	struct file_lock_core c;
+	loff_t fl_start;
+	loff_t fl_end;
+	const struct file_lock_operations *fl_ops;
+	const struct lock_manager_operations *fl_lmops;
+	union {
+		struct nfs_lock_info nfs_fl;
+		struct nfs4_lock_info nfs4_fl;
+		struct {
+			struct list_head link;
+			int state;
+			unsigned int debug_id;
+		} afs;
+		struct {
+			struct inode *inode;
+		} ceph;
+	} fl_u;
+};
+
+struct lease_manager_operations;
+
+struct file_lease {
+	struct file_lock_core c;
+	struct fasync_struct *fl_fasync;
+	long unsigned int fl_break_time;
+	long unsigned int fl_downgrade_time;
+	const struct lease_manager_operations *fl_lmops;
+};
+
+struct file_lock_operations {
+	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
+	void (*fl_release_private)(struct file_lock *);
+};
+
+struct lock_manager_operations {
+	void *lm_mod_owner;
+	fl_owner_t (*lm_get_owner)(fl_owner_t);
+	void (*lm_put_owner)(fl_owner_t);
+	void (*lm_notify)(struct file_lock *);
+	int (*lm_grant)(struct file_lock *, int);
+	bool (*lm_lock_expirable)(struct file_lock *);
+	void (*lm_expire_lock)();
+};
+
+struct lease_manager_operations {
+	bool (*lm_break)(struct file_lease *);
+	int (*lm_change)(struct file_lease *, int, struct list_head *);
+	void (*lm_setup)(struct file_lease *, void **);
+	bool (*lm_breaker_owns_lease)(struct file_lease *);
+};
+
+enum fsnotify_group_prio {
+	FSNOTIFY_PRIO_NORMAL = 0,
+	FSNOTIFY_PRIO_CONTENT = 1,
+	FSNOTIFY_PRIO_PRE_CONTENT = 2,
+	__FSNOTIFY_PRIO_NUM = 3,
+};
+
+enum fsnotify_data_type {
+	FSNOTIFY_EVENT_NONE = 0,
+	FSNOTIFY_EVENT_PATH = 1,
+	FSNOTIFY_EVENT_INODE = 2,
+	FSNOTIFY_EVENT_DENTRY = 3,
+	FSNOTIFY_EVENT_ERROR = 4,
+};
+
+enum fsnotify_iter_type {
+	FSNOTIFY_ITER_TYPE_INODE = 0,
+	FSNOTIFY_ITER_TYPE_VFSMOUNT = 1,
+	FSNOTIFY_ITER_TYPE_SB = 2,
+	FSNOTIFY_ITER_TYPE_PARENT = 3,
+	FSNOTIFY_ITER_TYPE_INODE2 = 4,
+	FSNOTIFY_ITER_TYPE_COUNT = 5,
+};
+
+typedef void (*task_work_func_t)(struct callback_head *);
+
+enum task_work_notify_mode {
+	TWA_NONE = 0,
+	TWA_RESUME = 1,
+	TWA_SIGNAL = 2,
+	TWA_SIGNAL_NO_IPI = 3,
+	TWA_NMI_CURRENT = 4,
+	TWA_FLAGS = 65280,
+	TWAF_NO_ALLOC = 256,
+};
+
+struct backing_file {
+	struct file file;
+	struct path user_path;
+};
+
+typedef __kernel_long_t __kernel_off_t;
+
+struct f_owner_ex {
+	int type;
+	__kernel_pid_t pid;
+};
+
+struct flock {
+	short int l_type;
+	short int l_whence;
+	__kernel_off_t l_start;
+	__kernel_off_t l_len;
+	__kernel_pid_t l_pid;
+};
+
+struct flock64 {
+	short int l_type;
+	short int l_whence;
+	long: 32;
+	__kernel_loff_t l_start;
+	__kernel_loff_t l_len;
+	__kernel_pid_t l_pid;
+	long: 32;
+};
+
+typedef struct fd class_fd_raw_t;
+
+typedef __kernel_ulong_t ino_t;
+
+enum dentry_d_lock_class {
+	DENTRY_D_LOCK_NORMAL = 0,
+	DENTRY_D_LOCK_NESTED = 1,
+};
+
+struct name_snapshot {
+	struct qstr name;
+	unsigned char inline_name[36];
+	long: 32;
+};
+
+enum lru_status {
+	LRU_REMOVED = 0,
+	LRU_REMOVED_RETRY = 1,
+	LRU_ROTATE = 2,
+	LRU_SKIP = 3,
+	LRU_RETRY = 4,
+	LRU_STOP = 5,
+};
+
+typedef enum lru_status (*list_lru_walk_cb)(struct list_head *, struct list_lru_one *, spinlock_t *, void *);
+
+struct mount;
+
+struct mnt_namespace {
+	struct ns_common ns;
+	struct mount *root;
+	struct rb_root mounts;
+	struct user_namespace *user_ns;
+	struct ucounts *ucounts;
+	u64 seq;
+	wait_queue_head_t poll;
+	long: 32;
+	u64 event;
+	unsigned int nr_mounts;
+	unsigned int pending_mounts;
+	struct rb_node mnt_ns_tree_node;
+	refcount_t passive;
+};
+
+struct mnt_pcp;
+
+struct mountpoint;
+
+struct mount {
+	struct hlist_node mnt_hash;
+	struct mount *mnt_parent;
+	struct dentry *mnt_mountpoint;
+	struct vfsmount mnt;
+	union {
+		struct callback_head mnt_rcu;
+		struct llist_node mnt_llist;
+	};
+	struct mnt_pcp *mnt_pcp;
+	struct list_head mnt_mounts;
+	struct list_head mnt_child;
+	struct list_head mnt_instance;
+	const char *mnt_devname;
+	union {
+		struct rb_node mnt_node;
+		struct list_head mnt_list;
+	};
+	struct list_head mnt_expire;
+	struct list_head mnt_share;
+	struct list_head mnt_slave_list;
+	struct list_head mnt_slave;
+	struct mount *mnt_master;
+	struct mnt_namespace *mnt_ns;
+	struct mountpoint *mnt_mp;
+	union {
+		struct hlist_node mnt_mp_list;
+		struct hlist_node mnt_umount;
+	};
+	struct list_head mnt_umounting;
+	struct fsnotify_mark_connector *mnt_fsnotify_marks;
+	__u32 mnt_fsnotify_mask;
+	int mnt_id;
+	long: 32;
+	u64 mnt_id_unique;
+	int mnt_group_id;
+	int mnt_expiry_mark;
+	struct hlist_head mnt_pins;
+	struct hlist_head mnt_stuck_children;
+};
+
+struct mnt_pcp {
+	int mnt_count;
+	int mnt_writers;
+};
+
+struct mountpoint {
+	struct hlist_node m_hash;
+	struct dentry *m_dentry;
+	struct hlist_head m_list;
+	int m_count;
+};
+
+struct dentry_stat_t {
+	long int nr_dentry;
+	long int nr_unused;
+	long int age_limit;
+	long int want_pages;
+	long int nr_negative;
+	long int dummy;
+};
+
+struct external_name {
+	union {
+		atomic_t count;
+		struct callback_head head;
+	} u;
+	unsigned char name[0];
+};
+
+enum d_walk_ret {
+	D_WALK_CONTINUE = 0,
+	D_WALK_QUIT = 1,
+	D_WALK_NORETRY = 2,
+	D_WALK_SKIP = 3,
+};
+
+struct check_mount {
+	struct vfsmount *mnt;
+	unsigned int mounted;
+};
+
+struct select_data {
+	struct dentry *start;
+	union {
+		long int found;
+		struct dentry *victim;
+	};
+	struct list_head dispose;
+};
+
+typedef struct fd class_fd_t;
+
+struct simple_xattrs {
+	struct rb_root rb_root;
+	rwlock_t lock;
+};
+
+struct simple_xattr {
+	struct rb_node rb_node;
+	char *name;
+	size_t size;
+	char value[0];
+};
+
+struct xattr_name {
+	char name[256];
+};
+
+struct xattr_ctx {
+	union {
+		const void *cvalue;
+		void *value;
+	};
+	void *kvalue;
+	size_t size;
+	struct xattr_name *kname;
+	unsigned int flags;
+};
+
+struct old_timeval32 {
+	old_time32_t tv_sec;
+	s32 tv_usec;
+};
+
+struct old_utimbuf32 {
+	old_time32_t actime;
+	old_time32_t modtime;
+};
+
+struct fs_pin {
+	wait_queue_head_t wait;
+	int done;
+	struct hlist_node s_list;
+	struct hlist_node m_list;
+	void (*kill)(struct fs_pin *);
+};
+
+struct constant_table {
+	const char *name;
+	int value;
+};
+
+struct fs_struct {
+	int users;
+	spinlock_t lock;
+	seqcount_spinlock_t seq;
+	int umask;
+	int in_exec;
+	struct path root;
+	struct path pwd;
+};
+
+struct file_dedupe_range_info {
+	__s64 dest_fd;
+	__u64 dest_offset;
+	__u64 bytes_deduped;
+	__s32 status;
+	__u32 reserved;
+};
+
+struct file_dedupe_range {
+	__u64 src_offset;
+	__u64 src_length;
+	__u16 dest_count;
+	__u16 reserved1;
+	__u32 reserved2;
+	struct file_dedupe_range_info info[0];
+};
+
+struct iomap_ops {
+	int (*iomap_begin)(struct inode *, loff_t, loff_t, unsigned int, struct iomap *, struct iomap *);
+	int (*iomap_end)(struct inode *, loff_t, loff_t, ssize_t, unsigned int, struct iomap *);
+};
+
+typedef u32 nlink_t;
+
+typedef int (*proc_write_t)(struct file *, char *, size_t);
+
+struct proc_ops;
+
+struct proc_dir_entry {
+	atomic_t in_use;
+	refcount_t refcnt;
+	struct list_head pde_openers;
+	spinlock_t pde_unload_lock;
+	struct completion *pde_unload_completion;
+	const struct inode_operations *proc_iops;
+	union {
+		const struct proc_ops *proc_ops;
+		const struct file_operations *proc_dir_ops;
+	};
+	const struct dentry_operations *proc_dops;
+	union {
+		const struct seq_operations *seq_ops;
+		int (*single_show)(struct seq_file *, void *);
+	};
+	proc_write_t write;
+	void *data;
+	unsigned int state_size;
+	unsigned int low_ino;
+	nlink_t nlink;
+	kuid_t uid;
+	kgid_t gid;
+	long: 32;
+	loff_t size;
+	struct proc_dir_entry *parent;
+	struct rb_root subdir;
+	struct rb_node subdir_node;
+	char *name;
+	umode_t mode;
+	u8 flags;
+	u8 namelen;
+	char inline_name[0];
+	long: 32;
+};
+
+struct proc_ops {
+	unsigned int proc_flags;
+	int (*proc_open)(struct inode *, struct file *);
+	ssize_t (*proc_read)(struct file *, char *, size_t, loff_t *);
+	ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
+	ssize_t (*proc_write)(struct file *, const char *, size_t, loff_t *);
+	loff_t (*proc_lseek)(struct file *, loff_t, int);
+	int (*proc_release)(struct inode *, struct file *);
+	__poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
+	long int (*proc_ioctl)(struct file *, unsigned int, long unsigned int);
+	int (*proc_mmap)(struct file *, struct vm_area_struct *);
+	long unsigned int (*proc_get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
+};
+
+union proc_op {
+	int (*proc_get_link)(struct dentry *, struct path *);
+	int (*proc_show)(struct seq_file *, struct pid_namespace *, struct pid *, struct task_struct *);
+	int lsmid;
+};
+
+struct proc_inode {
+	struct pid *pid;
+	unsigned int fd;
+	union proc_op op;
+	struct proc_dir_entry *pde;
+	struct ctl_table_header *sysctl;
+	struct ctl_table *sysctl_entry;
+	struct hlist_node sibling_inodes;
+	const struct proc_ns_operations *ns_ops;
+	long: 32;
+	struct inode vfs_inode;
+};
+
+struct proc_mounts {
+	struct mnt_namespace *ns;
+	struct path root;
+	int (*show)(struct seq_file *, struct vfsmount *);
+};
+
+struct proc_fs_opts {
+	int flag;
+	const char *str;
+};
+
+struct buffer_head;
+
+typedef int get_block_t(struct inode *, sector_t, struct buffer_head *, int);
+
+typedef void bh_end_io_t(struct buffer_head *, int);
+
+struct buffer_head {
+	long unsigned int b_state;
+	struct buffer_head *b_this_page;
+	union {
+		struct page *b_page;
+		struct folio *b_folio;
+	};
+	long: 32;
+	sector_t b_blocknr;
+	size_t b_size;
+	char *b_data;
+	struct block_device *b_bdev;
+	bh_end_io_t *b_end_io;
+	void *b_private;
+	struct list_head b_assoc_buffers;
+	struct address_space *b_assoc_map;
+	atomic_t b_count;
+	spinlock_t b_uptodate_lock;
+};
+
+typedef int dio_iodone_t(struct kiocb *, loff_t, ssize_t, void *);
+
+enum {
+	DIO_LOCKING = 1,
+	DIO_SKIP_HOLES = 2,
+};
+
+enum {
+	BIO_PAGE_PINNED = 0,
+	BIO_CLONED = 1,
+	BIO_BOUNCED = 2,
+	BIO_QUIET = 3,
+	BIO_CHAIN = 4,
+	BIO_REFFED = 5,
+	BIO_BPS_THROTTLED = 6,
+	BIO_TRACE_COMPLETION = 7,
+	BIO_CGROUP_ACCT = 8,
+	BIO_QOS_THROTTLED = 9,
+	BIO_QOS_MERGED = 10,
+	BIO_REMAPPED = 11,
+	BIO_ZONE_WRITE_PLUGGING = 12,
+	BIO_EMULATES_ZONE_APPEND = 13,
+	BIO_FLAG_LAST = 14,
+};
+
+enum req_op {
+	REQ_OP_READ = 0,
+	REQ_OP_WRITE = 1,
+	REQ_OP_FLUSH = 2,
+	REQ_OP_DISCARD = 3,
+	REQ_OP_SECURE_ERASE = 5,
+	REQ_OP_ZONE_APPEND = 7,
+	REQ_OP_WRITE_ZEROES = 9,
+	REQ_OP_ZONE_OPEN = 10,
+	REQ_OP_ZONE_CLOSE = 11,
+	REQ_OP_ZONE_FINISH = 12,
+	REQ_OP_ZONE_RESET = 13,
+	REQ_OP_ZONE_RESET_ALL = 15,
+	REQ_OP_DRV_IN = 34,
+	REQ_OP_DRV_OUT = 35,
+	REQ_OP_LAST = 36,
+};
+
+enum req_flag_bits {
+	__REQ_FAILFAST_DEV = 8,
+	__REQ_FAILFAST_TRANSPORT = 9,
+	__REQ_FAILFAST_DRIVER = 10,
+	__REQ_SYNC = 11,
+	__REQ_META = 12,
+	__REQ_PRIO = 13,
+	__REQ_NOMERGE = 14,
+	__REQ_IDLE = 15,
+	__REQ_INTEGRITY = 16,
+	__REQ_FUA = 17,
+	__REQ_PREFLUSH = 18,
+	__REQ_RAHEAD = 19,
+	__REQ_BACKGROUND = 20,
+	__REQ_NOWAIT = 21,
+	__REQ_POLLED = 22,
+	__REQ_ALLOC_CACHE = 23,
+	__REQ_SWAP = 24,
+	__REQ_DRV = 25,
+	__REQ_FS_PRIVATE = 26,
+	__REQ_ATOMIC = 27,
+	__REQ_NOUNMAP = 28,
+	__REQ_NR_BITS = 29,
+};
+
+typedef unsigned int iov_iter_extraction_t;
+
+enum iter_type {
+	ITER_UBUF = 0,
+	ITER_IOVEC = 1,
+	ITER_BVEC = 2,
+	ITER_KVEC = 3,
+	ITER_FOLIOQ = 4,
+	ITER_XARRAY = 5,
+	ITER_DISCARD = 6,
+};
+
+enum bh_state_bits {
+	BH_Uptodate = 0,
+	BH_Dirty = 1,
+	BH_Lock = 2,
+	BH_Req = 3,
+	BH_Mapped = 4,
+	BH_New = 5,
+	BH_Async_Read = 6,
+	BH_Async_Write = 7,
+	BH_Delay = 8,
+	BH_Boundary = 9,
+	BH_Write_EIO = 10,
+	BH_Unwritten = 11,
+	BH_Quiet = 12,
+	BH_Meta = 13,
+	BH_Prio = 14,
+	BH_Defer_Completion = 15,
+	BH_PrivateStart = 16,
+};
+
+struct dio_submit {
+	struct bio *bio;
+	unsigned int blkbits;
+	unsigned int blkfactor;
+	unsigned int start_zero_done;
+	int pages_in_io;
+	long: 32;
+	sector_t block_in_file;
+	unsigned int blocks_available;
+	int reap_counter;
+	sector_t final_block_in_request;
+	int boundary;
+	get_block_t *get_block;
+	loff_t logical_offset_in_bio;
+	sector_t final_block_in_bio;
+	sector_t next_block_for_io;
+	struct page *cur_page;
+	unsigned int cur_page_offset;
+	unsigned int cur_page_len;
+	long: 32;
+	sector_t cur_page_block;
+	loff_t cur_page_fs_offset;
+	struct iov_iter *iter;
+	unsigned int head;
+	unsigned int tail;
+	size_t from;
+	size_t to;
+	long: 32;
+};
+
+struct dio {
+	int flags;
+	blk_opf_t opf;
+	struct gendisk *bio_disk;
+	struct inode *inode;
+	loff_t i_size;
+	dio_iodone_t *end_io;
+	bool is_pinned;
+	void *private;
+	spinlock_t bio_lock;
+	int page_errors;
+	int is_async;
+	bool defer_completion;
+	bool should_dirty;
+	int io_error;
+	long unsigned int refcount;
+	struct bio *bio_list;
+	struct task_struct *waiter;
+	struct kiocb *iocb;
+	ssize_t result;
+	union {
+		struct page *pages[64];
+		struct work_struct complete_work;
+	};
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct fsnotify_group;
+
+struct fsnotify_iter_info;
+
+struct fsnotify_mark;
+
+struct fsnotify_event;
+
+struct fsnotify_ops {
+	int (*handle_event)(struct fsnotify_group *, u32, const void *, int, struct inode *, const struct qstr *, u32, struct fsnotify_iter_info *);
+	int (*handle_inode_event)(struct fsnotify_mark *, u32, struct inode *, struct inode *, const struct qstr *, u32);
+	void (*free_group_priv)(struct fsnotify_group *);
+	void (*freeing_mark)(struct fsnotify_mark *, struct fsnotify_group *);
+	void (*free_event)(struct fsnotify_group *, struct fsnotify_event *);
+	void (*free_mark)(struct fsnotify_mark *);
+};
+
+struct inotify_group_private_data {
+	spinlock_t idr_lock;
+	struct idr idr;
+	struct ucounts *ucounts;
+};
+
+struct fanotify_group_private_data {
+	struct hlist_head *merge_hash;
+	struct list_head access_list;
+	wait_queue_head_t access_waitq;
+	int flags;
+	int f_flags;
+	struct ucounts *ucounts;
+	mempool_t error_events_pool;
+};
+
+struct fsnotify_group {
+	const struct fsnotify_ops *ops;
+	refcount_t refcnt;
+	spinlock_t notification_lock;
+	struct list_head notification_list;
+	wait_queue_head_t notification_waitq;
+	unsigned int q_len;
+	unsigned int max_events;
+	enum fsnotify_group_prio priority;
+	bool shutdown;
+	int flags;
+	unsigned int owner_flags;
+	struct mutex mark_mutex;
+	atomic_t user_waits;
+	struct list_head marks_list;
+	struct fasync_struct *fsn_fa;
+	struct fsnotify_event *overflow_event;
+	struct mem_cgroup *memcg;
+	union {
+		void *private;
+		struct inotify_group_private_data inotify_data;
+		struct fanotify_group_private_data fanotify_data;
+	};
+};
+
+struct fsnotify_iter_info {
+	struct fsnotify_mark *marks[5];
+	struct fsnotify_group *current_group;
+	unsigned int report_mask;
+	int srcu_idx;
+};
+
+struct fsnotify_mark {
+	__u32 mask;
+	refcount_t refcnt;
+	struct fsnotify_group *group;
+	struct list_head g_list;
+	spinlock_t lock;
+	struct hlist_node obj_list;
+	struct fsnotify_mark_connector *connector;
+	__u32 ignore_mask;
+	unsigned int flags;
+};
+
+struct fsnotify_event {
+	struct list_head list;
+};
+
+enum fsnotify_obj_type {
+	FSNOTIFY_OBJ_TYPE_ANY = -1,
+	FSNOTIFY_OBJ_TYPE_INODE = 0,
+	FSNOTIFY_OBJ_TYPE_VFSMOUNT = 1,
+	FSNOTIFY_OBJ_TYPE_SB = 2,
+	FSNOTIFY_OBJ_TYPE_COUNT = 3,
+	FSNOTIFY_OBJ_TYPE_DETACHED = 3,
+};
+
+typedef struct fsnotify_mark_connector *fsnotify_connp_t;
+
+typedef struct {
+	int val[2];
+} __kernel_fsid_t;
+
+struct fanotify_response_info_header {
+	__u8 type;
+	__u8 pad;
+	__u16 len;
+};
+
+struct fanotify_response_info_audit_rule {
+	struct fanotify_response_info_header hdr;
+	__u32 rule_number;
+	__u32 subj_trust;
+	__u32 obj_trust;
+};
+
+struct kstatfs {
+	long int f_type;
+	long int f_bsize;
+	u64 f_blocks;
+	u64 f_bfree;
+	u64 f_bavail;
+	u64 f_files;
+	u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	long int f_namelen;
+	long int f_frsize;
+	long int f_flags;
+	long int f_spare[4];
+	long: 32;
+};
+
+struct fs_error_report {
+	int error;
+	struct inode *inode;
+	struct super_block *sb;
+};
+
+enum fid_type {
+	FILEID_ROOT = 0,
+	FILEID_INO32_GEN = 1,
+	FILEID_INO32_GEN_PARENT = 2,
+	FILEID_BTRFS_WITHOUT_PARENT = 77,
+	FILEID_BTRFS_WITH_PARENT = 78,
+	FILEID_BTRFS_WITH_PARENT_ROOT = 79,
+	FILEID_UDF_WITHOUT_PARENT = 81,
+	FILEID_UDF_WITH_PARENT = 82,
+	FILEID_NILFS_WITHOUT_PARENT = 97,
+	FILEID_NILFS_WITH_PARENT = 98,
+	FILEID_FAT_WITHOUT_PARENT = 113,
+	FILEID_FAT_WITH_PARENT = 114,
+	FILEID_INO64_GEN = 129,
+	FILEID_INO64_GEN_PARENT = 130,
+	FILEID_LUSTRE = 151,
+	FILEID_BCACHEFS_WITHOUT_PARENT = 177,
+	FILEID_BCACHEFS_WITH_PARENT = 178,
+	FILEID_KERNFS = 254,
+	FILEID_INVALID = 255,
+};
+
+struct fid {
+	union {
+		struct {
+			u32 ino;
+			u32 gen;
+			u32 parent_ino;
+			u32 parent_gen;
+		} i32;
+		struct {
+			u64 ino;
+			u32 gen;
+		} i64;
+		struct {
+			u32 block;
+			u16 partref;
+			u16 parent_partref;
+			u32 generation;
+			u32 parent_block;
+			u32 parent_generation;
+		} udf;
+		struct {
+			struct {} __empty_raw;
+			__u32 raw[0];
+		};
+	};
+};
+
+enum {
+	FAN_EVENT_INIT = 0,
+	FAN_EVENT_REPORTED = 1,
+	FAN_EVENT_ANSWERED = 2,
+	FAN_EVENT_CANCELED = 3,
+};
+
+struct fanotify_fh {
+	u8 type;
+	u8 len;
+	u8 flags;
+	u8 pad;
+	unsigned char buf[0];
+};
+
+struct fanotify_info {
+	u8 dir_fh_totlen;
+	u8 dir2_fh_totlen;
+	u8 file_fh_totlen;
+	u8 name_len;
+	u8 name2_len;
+	u8 pad[3];
+	unsigned char buf[0];
+};
+
+enum fanotify_event_type {
+	FANOTIFY_EVENT_TYPE_FID = 0,
+	FANOTIFY_EVENT_TYPE_FID_NAME = 1,
+	FANOTIFY_EVENT_TYPE_PATH = 2,
+	FANOTIFY_EVENT_TYPE_PATH_PERM = 3,
+	FANOTIFY_EVENT_TYPE_OVERFLOW = 4,
+	FANOTIFY_EVENT_TYPE_FS_ERROR = 5,
+	__FANOTIFY_EVENT_TYPE_NUM = 6,
+};
+
+struct fanotify_event {
+	struct fsnotify_event fse;
+	struct hlist_node merge_list;
+	u32 mask;
+	struct {
+		unsigned int type: 3;
+		unsigned int hash: 29;
+	};
+	struct pid *pid;
+};
+
+struct fanotify_fid_event {
+	struct fanotify_event fae;
+	__kernel_fsid_t fsid;
+	struct {
+		struct fanotify_fh object_fh;
+		unsigned char _inline_fh_buf[12];
+	};
+};
+
+struct fanotify_name_event {
+	struct fanotify_event fae;
+	__kernel_fsid_t fsid;
+	struct fanotify_info info;
+};
+
+struct fanotify_error_event {
+	struct fanotify_event fae;
+	s32 error;
+	u32 err_count;
+	__kernel_fsid_t fsid;
+	struct {
+		struct fanotify_fh object_fh;
+		unsigned char _inline_fh_buf[128];
+	};
+};
+
+struct fanotify_path_event {
+	struct fanotify_event fae;
+	struct path path;
+};
+
+struct fanotify_perm_event {
+	struct fanotify_event fae;
+	struct path path;
+	u32 response;
+	short unsigned int state;
+	int fd;
+	union {
+		struct fanotify_response_info_header hdr;
+		struct fanotify_response_info_audit_rule audit_rule;
+	};
+};
+
+struct fanotify_mark {
+	struct fsnotify_mark fsn_mark;
+	__kernel_fsid_t fsid;
+};
+
+enum siginfo_layout {
+	SIL_KILL = 0,
+	SIL_TIMER = 1,
+	SIL_POLL = 2,
+	SIL_FAULT = 3,
+	SIL_FAULT_TRAPNO = 4,
+	SIL_FAULT_MCEERR = 5,
+	SIL_FAULT_BNDERR = 6,
+	SIL_FAULT_PKUERR = 7,
+	SIL_FAULT_PERF_EVENT = 8,
+	SIL_CHLD = 9,
+	SIL_RT = 10,
+	SIL_SYS = 11,
+};
+
+struct signalfd_siginfo {
+	__u32 ssi_signo;
+	__s32 ssi_errno;
+	__s32 ssi_code;
+	__u32 ssi_pid;
+	__u32 ssi_uid;
+	__s32 ssi_fd;
+	__u32 ssi_tid;
+	__u32 ssi_band;
+	__u32 ssi_overrun;
+	__u32 ssi_trapno;
+	__s32 ssi_status;
+	__s32 ssi_int;
+	__u64 ssi_ptr;
+	__u64 ssi_utime;
+	__u64 ssi_stime;
+	__u64 ssi_addr;
+	__u16 ssi_addr_lsb;
+	__u16 __pad2;
+	__s32 ssi_syscall;
+	__u64 ssi_call_addr;
+	__u32 ssi_arch;
+	__u8 __pad[28];
+};
+
+struct signalfd_ctx {
+	sigset_t sigmask;
+};
+
+struct eventfd_ctx {
+	struct kref kref;
+	wait_queue_head_t wqh;
+	__u64 count;
+	unsigned int flags;
+	int id;
+};
+
+typedef void (*exitcall_t)();
+
+typedef __kernel_rwf_t rwf_t;
+
+struct backing_file_ctx {
+	const struct cred *cred;
+	struct file *user_file;
+	void (*accessed)(struct file *);
+	void (*end_write)(struct file *, loff_t, ssize_t);
+};
+
+struct backing_aio {
+	struct kiocb iocb;
+	refcount_t ref;
+	struct kiocb *orig_iocb;
+	void (*end_write)(struct file *, loff_t, ssize_t);
+	struct work_struct work;
+	long int res;
+};
+
+struct xdr_netobj {
+	unsigned int len;
+	u8 *data;
+};
+
+struct xdr_buf {
+	struct kvec head[1];
+	struct kvec tail[1];
+	struct bio_vec *bvec;
+	struct page **pages;
+	unsigned int page_base;
+	unsigned int page_len;
+	unsigned int flags;
+	unsigned int buflen;
+	unsigned int len;
+};
+
+struct rpc_rqst;
+
+struct xdr_stream {
+	__be32 *p;
+	struct xdr_buf *buf;
+	__be32 *end;
+	struct kvec *iov;
+	struct kvec scratch;
+	struct page **page_ptr;
+	void *page_kaddr;
+	unsigned int nwords;
+	struct rpc_rqst *rqst;
+};
+
+struct lwq_node {
+	struct llist_node node;
+};
+
+struct rpc_xprt;
+
+struct rpc_task;
+
+struct rpc_cred;
+
+struct rpc_rqst {
+	struct rpc_xprt *rq_xprt;
+	struct xdr_buf rq_snd_buf;
+	struct xdr_buf rq_rcv_buf;
+	struct rpc_task *rq_task;
+	struct rpc_cred *rq_cred;
+	__be32 rq_xid;
+	int rq_cong;
+	u32 rq_seqno;
+	int rq_enc_pages_num;
+	struct page **rq_enc_pages;
+	void (*rq_release_snd_buf)(struct rpc_rqst *);
+	union {
+		struct list_head rq_list;
+		struct rb_node rq_recv;
+	};
+	struct list_head rq_xmit;
+	struct list_head rq_xmit2;
+	void *rq_buffer;
+	size_t rq_callsize;
+	void *rq_rbuffer;
+	size_t rq_rcvsize;
+	size_t rq_xmit_bytes_sent;
+	size_t rq_reply_bytes_recvd;
+	struct xdr_buf rq_private_buf;
+	long unsigned int rq_majortimeo;
+	long unsigned int rq_minortimeo;
+	long unsigned int rq_timeout;
+	ktime_t rq_rtt;
+	unsigned int rq_retries;
+	unsigned int rq_connect_cookie;
+	atomic_t rq_pin;
+	u32 rq_bytes_sent;
+	ktime_t rq_xtime;
+	int rq_ntrans;
+	struct lwq_node rq_bc_list;
+	long unsigned int rq_bc_pa_state;
+	struct list_head rq_bc_pa_list;
+	long: 32;
+};
+
+typedef void (*kxdreproc_t)(struct rpc_rqst *, struct xdr_stream *, const void *);
+
+typedef int (*kxdrdproc_t)(struct rpc_rqst *, struct xdr_stream *, void *);
+
+struct rpc_procinfo;
+
+struct rpc_message {
+	const struct rpc_procinfo *rpc_proc;
+	void *rpc_argp;
+	void *rpc_resp;
+	const struct cred *rpc_cred;
+};
+
+struct rpc_procinfo {
+	u32 p_proc;
+	kxdreproc_t p_encode;
+	kxdrdproc_t p_decode;
+	unsigned int p_arglen;
+	unsigned int p_replen;
+	unsigned int p_timer;
+	u32 p_statidx;
+	const char *p_name;
+};
+
+struct rpc_wait {
+	struct list_head list;
+	struct list_head links;
+	struct list_head timer_list;
+};
+
+struct rpc_timeout {
+	long unsigned int to_initval;
+	long unsigned int to_maxval;
+	long unsigned int to_increment;
+	unsigned int to_retries;
+	unsigned char to_exponential;
+};
+
+struct rpc_wait_queue;
+
+struct rpc_call_ops;
+
+struct rpc_clnt;
+
+struct rpc_task {
+	atomic_t tk_count;
+	int tk_status;
+	struct list_head tk_task;
+	void (*tk_callback)(struct rpc_task *);
+	void (*tk_action)(struct rpc_task *);
+	long unsigned int tk_timeout;
+	long unsigned int tk_runstate;
+	struct rpc_wait_queue *tk_waitqueue;
+	union {
+		struct work_struct tk_work;
+		struct rpc_wait tk_wait;
+	} u;
+	struct rpc_message tk_msg;
+	void *tk_calldata;
+	const struct rpc_call_ops *tk_ops;
+	struct rpc_clnt *tk_client;
+	struct rpc_xprt *tk_xprt;
+	struct rpc_cred *tk_op_cred;
+	struct rpc_rqst *tk_rqstp;
+	struct workqueue_struct *tk_workqueue;
+	ktime_t tk_start;
+	pid_t tk_owner;
+	int tk_rpc_status;
+	short unsigned int tk_flags;
+	short unsigned int tk_timeouts;
+	short unsigned int tk_pid;
+	unsigned char tk_priority: 2;
+	unsigned char tk_garb_retry: 2;
+	unsigned char tk_cred_retry: 2;
+};
+
+struct rpc_timer {
+	struct list_head list;
+	long unsigned int expires;
+	struct delayed_work dwork;
+};
+
+struct rpc_wait_queue {
+	spinlock_t lock;
+	struct list_head tasks[4];
+	unsigned char maxpriority;
+	unsigned char priority;
+	unsigned char nr;
+	unsigned int qlen;
+	struct rpc_timer timer_list;
+	const char *name;
+};
+
+struct rpc_call_ops {
+	void (*rpc_call_prepare)(struct rpc_task *, void *);
+	void (*rpc_call_done)(struct rpc_task *, void *);
+	void (*rpc_count_stats)(struct rpc_task *, void *);
+	void (*rpc_release)(void *);
+};
+
+struct rpc_iostats;
+
+enum xprtsec_policies {
+	RPC_XPRTSEC_NONE = 0,
+	RPC_XPRTSEC_TLS_ANON = 1,
+	RPC_XPRTSEC_TLS_X509 = 2,
+};
+
+struct xprtsec_parms {
+	enum xprtsec_policies policy;
+	key_serial_t cert_serial;
+	key_serial_t privkey_serial;
+};
+
+struct rpc_pipe_dir_head {
+	struct list_head pdh_entries;
+	struct dentry *pdh_dentry;
+};
+
+struct rpc_rtt {
+	long unsigned int timeo;
+	long unsigned int srtt[5];
+	long unsigned int sdrtt[5];
+	int ntimeouts[5];
+};
+
+struct rpc_xprt_switch;
+
+struct rpc_xprt_iter_ops;
+
+struct rpc_xprt_iter {
+	struct rpc_xprt_switch *xpi_xpswitch;
+	struct rpc_xprt *xpi_cursor;
+	const struct rpc_xprt_iter_ops *xpi_ops;
+};
+
+struct rpc_auth;
+
+struct rpc_stat;
+
+struct rpc_program;
+
+struct rpc_sysfs_client;
+
+struct rpc_clnt {
+	refcount_t cl_count;
+	unsigned int cl_clid;
+	struct list_head cl_clients;
+	struct list_head cl_tasks;
+	atomic_t cl_pid;
+	spinlock_t cl_lock;
+	struct rpc_xprt *cl_xprt;
+	const struct rpc_procinfo *cl_procinfo;
+	u32 cl_prog;
+	u32 cl_vers;
+	u32 cl_maxproc;
+	struct rpc_auth *cl_auth;
+	struct rpc_stat *cl_stats;
+	struct rpc_iostats *cl_metrics;
+	unsigned int cl_softrtry: 1;
+	unsigned int cl_softerr: 1;
+	unsigned int cl_discrtry: 1;
+	unsigned int cl_noretranstimeo: 1;
+	unsigned int cl_autobind: 1;
+	unsigned int cl_chatty: 1;
+	unsigned int cl_shutdown: 1;
+	struct xprtsec_parms cl_xprtsec;
+	struct rpc_rtt *cl_rtt;
+	const struct rpc_timeout *cl_timeout;
+	atomic_t cl_swapper;
+	int cl_nodelen;
+	char cl_nodename[65];
+	struct rpc_pipe_dir_head cl_pipedir_objects;
+	struct rpc_clnt *cl_parent;
+	struct rpc_rtt cl_rtt_default;
+	struct rpc_timeout cl_timeout_default;
+	const struct rpc_program *cl_program;
+	const char *cl_principal;
+	struct rpc_sysfs_client *cl_sysfs;
+	union {
+		struct rpc_xprt_iter cl_xpi;
+		struct work_struct cl_work;
+	};
+	const struct cred *cl_cred;
+	unsigned int cl_max_connect;
+	struct super_block *pipefs_sb;
+};
+
+struct svc_xprt;
+
+struct rpc_sysfs_xprt;
+
+struct rpc_xprt_ops;
+
+struct svc_serv;
+
+struct xprt_class;
+
+struct rpc_xprt {
+	struct kref kref;
+	const struct rpc_xprt_ops *ops;
+	unsigned int id;
+	const struct rpc_timeout *timeout;
+	struct __kernel_sockaddr_storage addr;
+	size_t addrlen;
+	int prot;
+	long unsigned int cong;
+	long unsigned int cwnd;
+	size_t max_payload;
+	struct rpc_wait_queue binding;
+	struct rpc_wait_queue sending;
+	struct rpc_wait_queue pending;
+	struct rpc_wait_queue backlog;
+	struct list_head free;
+	unsigned int max_reqs;
+	unsigned int min_reqs;
+	unsigned int num_reqs;
+	long unsigned int state;
+	unsigned char resvport: 1;
+	unsigned char reuseport: 1;
+	atomic_t swapper;
+	unsigned int bind_index;
+	struct list_head xprt_switch;
+	long unsigned int bind_timeout;
+	long unsigned int reestablish_timeout;
+	struct xprtsec_parms xprtsec;
+	unsigned int connect_cookie;
+	struct work_struct task_cleanup;
+	struct timer_list timer;
+	long unsigned int last_used;
+	long unsigned int idle_timeout;
+	long unsigned int connect_timeout;
+	long unsigned int max_reconnect_timeout;
+	atomic_long_t queuelen;
+	spinlock_t transport_lock;
+	spinlock_t reserve_lock;
+	spinlock_t queue_lock;
+	u32 xid;
+	struct rpc_task *snd_task;
+	struct list_head xmit_queue;
+	atomic_long_t xmit_queuelen;
+	struct svc_xprt *bc_xprt;
+	struct svc_serv *bc_serv;
+	unsigned int bc_alloc_max;
+	unsigned int bc_alloc_count;
+	atomic_t bc_slot_count;
+	spinlock_t bc_pa_lock;
+	struct list_head bc_pa_list;
+	struct rb_root recv_queue;
+	long: 32;
+	struct {
+		long unsigned int bind_count;
+		long unsigned int connect_count;
+		long unsigned int connect_start;
+		long unsigned int connect_time;
+		long unsigned int sends;
+		long unsigned int recvs;
+		long unsigned int bad_xids;
+		long unsigned int max_slots;
+		long long unsigned int req_u;
+		long long unsigned int bklog_u;
+		long long unsigned int sending_u;
+		long long unsigned int pending_u;
+	} stat;
+	struct net *xprt_net;
+	netns_tracker ns_tracker;
+	const char *servername;
+	const char *address_strings[6];
+	struct callback_head rcu;
+	const struct xprt_class *xprt_class;
+	struct rpc_sysfs_xprt *xprt_sysfs;
+	bool main;
+	long: 32;
+};
+
+struct rpc_credops;
+
+struct rpc_cred {
+	struct hlist_node cr_hash;
+	struct list_head cr_lru;
+	struct callback_head cr_rcu;
+	struct rpc_auth *cr_auth;
+	const struct rpc_credops *cr_ops;
+	long unsigned int cr_expire;
+	long unsigned int cr_flags;
+	refcount_t cr_count;
+	const struct cred *cr_cred;
+};
+
+typedef u32 rpc_authflavor_t;
+
+struct auth_cred {
+	const struct cred *cred;
+	const char *principal;
+};
+
+struct rpc_cred_cache;
+
+struct rpc_authops;
+
+struct rpc_auth {
+	unsigned int au_cslack;
+	unsigned int au_rslack;
+	unsigned int au_verfsize;
+	unsigned int au_ralign;
+	long unsigned int au_flags;
+	const struct rpc_authops *au_ops;
+	rpc_authflavor_t au_flavor;
+	refcount_t au_count;
+	struct rpc_cred_cache *au_credcache;
+};
+
+struct rpc_credops {
+	const char *cr_name;
+	int (*cr_init)(struct rpc_auth *, struct rpc_cred *);
+	void (*crdestroy)(struct rpc_cred *);
+	int (*crmatch)(struct auth_cred *, struct rpc_cred *, int);
+	int (*crmarshal)(struct rpc_task *, struct xdr_stream *);
+	int (*crrefresh)(struct rpc_task *);
+	int (*crvalidate)(struct rpc_task *, struct xdr_stream *);
+	int (*crwrap_req)(struct rpc_task *, struct xdr_stream *);
+	int (*crunwrap_resp)(struct rpc_task *, struct xdr_stream *);
+	int (*crkey_timeout)(struct rpc_cred *);
+	char * (*crstringify_acceptor)(struct rpc_cred *);
+	bool (*crneed_reencode)(struct rpc_task *);
+};
+
+struct rpc_auth_create_args;
+
+struct rpcsec_gss_info;
+
+struct rpc_authops {
+	struct module *owner;
+	rpc_authflavor_t au_flavor;
+	char *au_name;
+	struct rpc_auth * (*create)(const struct rpc_auth_create_args *, struct rpc_clnt *);
+	void (*destroy)(struct rpc_auth *);
+	int (*hash_cred)(struct auth_cred *, unsigned int);
+	struct rpc_cred * (*lookup_cred)(struct rpc_auth *, struct auth_cred *, int);
+	struct rpc_cred * (*crcreate)(struct rpc_auth *, struct auth_cred *, int, gfp_t);
+	rpc_authflavor_t (*info2flavor)(struct rpcsec_gss_info *);
+	int (*flavor2info)(rpc_authflavor_t, struct rpcsec_gss_info *);
+	int (*key_timeout)(struct rpc_auth *, struct rpc_cred *);
+	int (*ping)(struct rpc_clnt *);
+};
+
+struct rpc_auth_create_args {
+	rpc_authflavor_t pseudoflavor;
+	const char *target_name;
+};
+
+struct rpcsec_gss_oid {
+	unsigned int len;
+	u8 data[32];
+};
+
+struct rpcsec_gss_info {
+	struct rpcsec_gss_oid oid;
+	u32 qop;
+	u32 service;
+};
+
+struct lwq {
+	spinlock_t lock;
+	struct llist_node *ready;
+	struct llist_head new;
+};
+
+struct rpc_xprt_ops {
+	void (*set_buffer_size)(struct rpc_xprt *, size_t, size_t);
+	int (*reserve_xprt)(struct rpc_xprt *, struct rpc_task *);
+	void (*release_xprt)(struct rpc_xprt *, struct rpc_task *);
+	void (*alloc_slot)(struct rpc_xprt *, struct rpc_task *);
+	void (*free_slot)(struct rpc_xprt *, struct rpc_rqst *);
+	void (*rpcbind)(struct rpc_task *);
+	void (*set_port)(struct rpc_xprt *, short unsigned int);
+	void (*connect)(struct rpc_xprt *, struct rpc_task *);
+	int (*get_srcaddr)(struct rpc_xprt *, char *, size_t);
+	short unsigned int (*get_srcport)(struct rpc_xprt *);
+	int (*buf_alloc)(struct rpc_task *);
+	void (*buf_free)(struct rpc_task *);
+	int (*prepare_request)(struct rpc_rqst *, struct xdr_buf *);
+	int (*send_request)(struct rpc_rqst *);
+	void (*abort_send_request)(struct rpc_rqst *);
+	void (*wait_for_reply_request)(struct rpc_task *);
+	void (*timer)(struct rpc_xprt *, struct rpc_task *);
+	void (*release_request)(struct rpc_task *);
+	void (*close)(struct rpc_xprt *);
+	void (*destroy)(struct rpc_xprt *);
+	void (*set_connect_timeout)(struct rpc_xprt *, long unsigned int, long unsigned int);
+	void (*print_stats)(struct rpc_xprt *, struct seq_file *);
+	int (*enable_swap)(struct rpc_xprt *);
+	void (*disable_swap)(struct rpc_xprt *);
+	void (*inject_disconnect)(struct rpc_xprt *);
+	int (*bc_setup)(struct rpc_xprt *, unsigned int);
+	size_t (*bc_maxpayload)(struct rpc_xprt *);
+	unsigned int (*bc_num_slots)(struct rpc_xprt *);
+	void (*bc_free_rqst)(struct rpc_rqst *);
+	void (*bc_destroy)(struct rpc_xprt *, unsigned int);
+};
+
+struct svc_program;
+
+struct svc_stat;
+
+struct svc_pool;
+
+struct svc_serv {
+	struct svc_program *sv_programs;
+	struct svc_stat *sv_stats;
+	spinlock_t sv_lock;
+	unsigned int sv_nprogs;
+	unsigned int sv_nrthreads;
+	unsigned int sv_maxconn;
+	unsigned int sv_max_payload;
+	unsigned int sv_max_mesg;
+	unsigned int sv_xdrsize;
+	struct list_head sv_permsocks;
+	struct list_head sv_tempsocks;
+	int sv_tmpcnt;
+	struct timer_list sv_temptimer;
+	char *sv_name;
+	unsigned int sv_nrpools;
+	bool sv_is_pooled;
+	struct svc_pool *sv_pools;
+	int (*sv_threadfn)(void *);
+	struct lwq sv_cb_list;
+	bool sv_bc_enabled;
+};
+
+struct xprt_create;
+
+struct xprt_class {
+	struct list_head list;
+	int ident;
+	struct rpc_xprt * (*setup)(struct xprt_create *);
+	struct module *owner;
+	char name[32];
+	const char *netid[0];
+};
+
+struct xprt_create {
+	int ident;
+	struct net *net;
+	struct sockaddr *srcaddr;
+	struct sockaddr *dstaddr;
+	size_t addrlen;
+	const char *servername;
+	struct svc_xprt *bc_xprt;
+	struct rpc_xprt_switch *bc_xps;
+	unsigned int flags;
+	struct xprtsec_parms xprtsec;
+	long unsigned int connect_timeout;
+	long unsigned int reconnect_timeout;
+};
+
+struct rpc_sysfs_xprt_switch;
+
+struct rpc_xprt_switch {
+	spinlock_t xps_lock;
+	struct kref xps_kref;
+	unsigned int xps_id;
+	unsigned int xps_nxprts;
+	unsigned int xps_nactive;
+	unsigned int xps_nunique_destaddr_xprts;
+	atomic_long_t xps_queuelen;
+	struct list_head xps_xprt_list;
+	struct net *xps_net;
+	const struct rpc_xprt_iter_ops *xps_iter_ops;
+	struct rpc_sysfs_xprt_switch *xps_sysfs;
+	struct callback_head xps_rcu;
+};
+
+struct rpc_stat {
+	const struct rpc_program *program;
+	unsigned int netcnt;
+	unsigned int netudpcnt;
+	unsigned int nettcpcnt;
+	unsigned int nettcpconn;
+	unsigned int netreconn;
+	unsigned int rpccnt;
+	unsigned int rpcretrans;
+	unsigned int rpcauthrefresh;
+	unsigned int rpcgarbage;
+};
+
+struct rpc_version;
+
+struct rpc_program {
+	const char *name;
+	u32 number;
+	unsigned int nrvers;
+	const struct rpc_version **version;
+	struct rpc_stat *stats;
+	const char *pipe_dir_name;
+};
+
+struct svc_stat {
+	struct svc_program *program;
+	unsigned int netcnt;
+	unsigned int netudpcnt;
+	unsigned int nettcpcnt;
+	unsigned int nettcpconn;
+	unsigned int rpccnt;
+	unsigned int rpcbadfmt;
+	unsigned int rpcbadauth;
+	unsigned int rpcbadclnt;
+};
+
+enum svc_auth_status {
+	SVC_GARBAGE = 1,
+	SVC_SYSERR = 2,
+	SVC_VALID = 3,
+	SVC_NEGATIVE = 4,
+	SVC_OK = 5,
+	SVC_DROP = 6,
+	SVC_CLOSE = 7,
+	SVC_DENIED = 8,
+	SVC_PENDING = 9,
+	SVC_COMPLETE = 10,
+};
+
+struct svc_version;
+
+struct svc_rqst;
+
+struct svc_process_info;
+
+struct svc_program {
+	u32 pg_prog;
+	unsigned int pg_lovers;
+	unsigned int pg_hivers;
+	unsigned int pg_nvers;
+	const struct svc_version **pg_vers;
+	char *pg_name;
+	char *pg_class;
+	enum svc_auth_status (*pg_authenticate)(struct svc_rqst *);
+	__be32 (*pg_init_request)(struct svc_rqst *, const struct svc_program *, struct svc_process_info *);
+	int (*pg_rpcbind_set)(struct net *, const struct svc_program *, u32, int, short unsigned int, short unsigned int);
+};
+
+enum {
+	NAPI_STATE_SCHED = 0,
+	NAPI_STATE_MISSED = 1,
+	NAPI_STATE_DISABLE = 2,
+	NAPI_STATE_NPSVC = 3,
+	NAPI_STATE_LISTED = 4,
+	NAPI_STATE_NO_BUSY_POLL = 5,
+	NAPI_STATE_IN_BUSY_POLL = 6,
+	NAPI_STATE_PREFER_BUSY_POLL = 7,
+	NAPI_STATE_THREADED = 8,
+	NAPI_STATE_SCHED_THREADED = 9,
+};
+
+enum xps_map_type {
+	XPS_CPUS = 0,
+	XPS_RXQS = 1,
+	XPS_MAPS_MAX = 2,
+};
+
+enum bpf_xdp_mode {
+	XDP_MODE_SKB = 0,
+	XDP_MODE_DRV = 1,
+	XDP_MODE_HW = 2,
+	__MAX_XDP_MODE = 3,
+};
+
+enum {
+	NETIF_MSG_DRV_BIT = 0,
+	NETIF_MSG_PROBE_BIT = 1,
+	NETIF_MSG_LINK_BIT = 2,
+	NETIF_MSG_TIMER_BIT = 3,
+	NETIF_MSG_IFDOWN_BIT = 4,
+	NETIF_MSG_IFUP_BIT = 5,
+	NETIF_MSG_RX_ERR_BIT = 6,
+	NETIF_MSG_TX_ERR_BIT = 7,
+	NETIF_MSG_TX_QUEUED_BIT = 8,
+	NETIF_MSG_INTR_BIT = 9,
+	NETIF_MSG_TX_DONE_BIT = 10,
+	NETIF_MSG_RX_STATUS_BIT = 11,
+	NETIF_MSG_PKTDATA_BIT = 12,
+	NETIF_MSG_HW_BIT = 13,
+	NETIF_MSG_WOL_BIT = 14,
+	NETIF_MSG_CLASS_COUNT = 15,
+};
+
+struct rpc_xprt_iter_ops {
+	void (*xpi_rewind)(struct rpc_xprt_iter *);
+	struct rpc_xprt * (*xpi_xprt)(struct rpc_xprt_iter *);
+	struct rpc_xprt * (*xpi_next)(struct rpc_xprt_iter *);
+};
+
+struct rpc_sysfs_client {
+	struct kobject kobject;
+	struct net *net;
+	struct rpc_clnt *clnt;
+	struct rpc_xprt_switch *xprt_switch;
+};
+
+struct rpc_version {
+	u32 number;
+	unsigned int nrprocs;
+	const struct rpc_procinfo *procs;
+	unsigned int *counts;
+};
+
+struct nfs_fh {
+	short unsigned int size;
+	unsigned char data[128];
+};
+
+enum nfs3_stable_how {
+	NFS_UNSTABLE = 0,
+	NFS_DATA_SYNC = 1,
+	NFS_FILE_SYNC = 2,
+	NFS_INVALID_STABLE_HOW = -1,
+};
+
+struct nfs4_label {
+	uint32_t lfs;
+	uint32_t pi;
+	u32 len;
+	char *label;
+};
+
+typedef struct {
+	char data[8];
+} nfs4_verifier;
+
+struct nfs4_stateid_struct {
+	union {
+		char data[16];
+		struct {
+			__be32 seqid;
+			char other[12];
+		};
+	};
+	enum {
+		NFS4_INVALID_STATEID_TYPE = 0,
+		NFS4_SPECIAL_STATEID_TYPE = 1,
+		NFS4_OPEN_STATEID_TYPE = 2,
+		NFS4_LOCK_STATEID_TYPE = 3,
+		NFS4_DELEGATION_STATEID_TYPE = 4,
+		NFS4_LAYOUT_STATEID_TYPE = 5,
+		NFS4_PNFS_DS_STATEID_TYPE = 6,
+		NFS4_REVOKED_STATEID_TYPE = 7,
+	} type;
+};
+
+typedef struct nfs4_stateid_struct nfs4_stateid;
+
+enum nfs4_change_attr_type {
+	NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR = 0,
+	NFS4_CHANGE_TYPE_IS_VERSION_COUNTER = 1,
+	NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS = 2,
+	NFS4_CHANGE_TYPE_IS_TIME_METADATA = 3,
+	NFS4_CHANGE_TYPE_IS_UNDEFINED = 4,
+};
+
+struct gss_api_mech;
+
+struct gss_ctx {
+	struct gss_api_mech *mech_type;
+	void *internal_ctx_id;
+	unsigned int slack;
+	unsigned int align;
+};
+
+struct gss_api_ops;
+
+struct pf_desc;
+
+struct gss_api_mech {
+	struct list_head gm_list;
+	struct module *gm_owner;
+	struct rpcsec_gss_oid gm_oid;
+	char *gm_name;
+	const struct gss_api_ops *gm_ops;
+	int gm_pf_num;
+	struct pf_desc *gm_pfs;
+	const char *gm_upcall_enctypes;
+};
+
+struct auth_domain;
+
+struct pf_desc {
+	u32 pseudoflavor;
+	u32 qop;
+	u32 service;
+	char *name;
+	char *auth_domain_name;
+	struct auth_domain *domain;
+	bool datatouch;
+};
+
+struct auth_ops;
+
+struct auth_domain {
+	struct kref ref;
+	struct hlist_node hash;
+	char *name;
+	struct auth_ops *flavour;
+	struct callback_head callback_head;
+};
+
+struct gss_api_ops {
+	int (*gss_import_sec_context)(const void *, size_t, struct gss_ctx *, time64_t *, gfp_t);
+	u32 (*gss_get_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
+	u32 (*gss_verify_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
+	u32 (*gss_wrap)(struct gss_ctx *, int, struct xdr_buf *, struct page **);
+	u32 (*gss_unwrap)(struct gss_ctx *, int, int, struct xdr_buf *);
+	void (*gss_delete_sec_context)(void *);
+};
+
+struct nfs4_string {
+	unsigned int len;
+	char *data;
+};
+
+struct nfs_fsid {
+	uint64_t major;
+	uint64_t minor;
+};
+
+struct nfs4_threshold {
+	__u32 bm;
+	__u32 l_type;
+	__u64 rd_sz;
+	__u64 wr_sz;
+	__u64 rd_io_sz;
+	__u64 wr_io_sz;
+};
+
+struct nfs_fattr {
+	unsigned int valid;
+	umode_t mode;
+	__u32 nlink;
+	kuid_t uid;
+	kgid_t gid;
+	dev_t rdev;
+	__u64 size;
+	union {
+		struct {
+			__u32 blocksize;
+			__u32 blocks;
+		} nfs2;
+		struct {
+			__u64 used;
+		} nfs3;
+	} du;
+	struct nfs_fsid fsid;
+	__u64 fileid;
+	__u64 mounted_on_fileid;
+	struct timespec64 atime;
+	struct timespec64 mtime;
+	struct timespec64 ctime;
+	__u64 change_attr;
+	__u64 pre_change_attr;
+	__u64 pre_size;
+	struct timespec64 pre_mtime;
+	struct timespec64 pre_ctime;
+	long unsigned int time_start;
+	long unsigned int gencount;
+	struct nfs4_string *owner_name;
+	struct nfs4_string *group_name;
+	struct nfs4_threshold *mdsthreshold;
+	struct nfs4_label *label;
+};
+
+struct nfs_fsinfo {
+	struct nfs_fattr *fattr;
+	__u32 rtmax;
+	__u32 rtpref;
+	__u32 rtmult;
+	__u32 wtmax;
+	__u32 wtpref;
+	__u32 wtmult;
+	__u32 dtpref;
+	__u64 maxfilesize;
+	struct timespec64 time_delta;
+	__u32 lease_time;
+	__u32 nlayouttypes;
+	__u32 layouttype[8];
+	__u32 blksize;
+	__u32 clone_blksize;
+	enum nfs4_change_attr_type change_attr_type;
+	__u32 xattr_support;
+};
+
+struct nfs_fsstat {
+	struct nfs_fattr *fattr;
+	long: 32;
+	__u64 tbytes;
+	__u64 fbytes;
+	__u64 abytes;
+	__u64 tfiles;
+	__u64 ffiles;
+	__u64 afiles;
+};
+
+struct nfs_pathconf {
+	struct nfs_fattr *fattr;
+	__u32 max_link;
+	__u32 max_namelen;
+};
+
+struct nfs4_change_info {
+	u32 atomic;
+	long: 32;
+	u64 before;
+	u64 after;
+};
+
+struct nfs4_slot;
+
+struct nfs4_sequence_args {
+	struct nfs4_slot *sa_slot;
+	u8 sa_cache_this: 1;
+	u8 sa_privileged: 1;
+};
+
+struct nfs4_sequence_res {
+	struct nfs4_slot *sr_slot;
+	long unsigned int sr_timestamp;
+	int sr_status;
+	u32 sr_status_flags;
+	u32 sr_highest_slotid;
+	u32 sr_target_highest_slotid;
+};
+
+struct nfs_open_context;
+
+struct nfs_lock_context {
+	refcount_t count;
+	struct list_head list;
+	struct nfs_open_context *open_context;
+	fl_owner_t lockowner;
+	atomic_t io_count;
+	struct callback_head callback_head;
+};
+
+struct nfs4_state;
+
+struct nfs_open_context {
+	struct nfs_lock_context lock_context;
+	fl_owner_t flock_owner;
+	struct dentry *dentry;
+	const struct cred *cred;
+	struct rpc_cred *ll_cred;
+	struct nfs4_state *state;
+	fmode_t mode;
+	long unsigned int flags;
+	int error;
+	struct list_head list;
+	struct nfs4_threshold *mdsthreshold;
+	struct callback_head callback_head;
+};
+
+struct nlm_host;
+
+struct nfs_iostats;
+
+struct nfs_auth_info {
+	unsigned int flavor_len;
+	rpc_authflavor_t flavors[12];
+};
+
+struct pnfs_layoutdriver_type;
+
+struct nfs_client;
+
+struct nfs_server {
+	struct nfs_client *nfs_client;
+	struct list_head client_link;
+	struct list_head master_link;
+	struct rpc_clnt *client;
+	struct rpc_clnt *client_acl;
+	struct nlm_host *nlm_host;
+	struct nfs_iostats *io_stats;
+	wait_queue_head_t write_congestion_wait;
+	atomic_long_t writeback;
+	unsigned int write_congested;
+	unsigned int flags;
+	unsigned int fattr_valid;
+	unsigned int caps;
+	unsigned int rsize;
+	unsigned int rpages;
+	unsigned int wsize;
+	unsigned int wpages;
+	unsigned int wtmult;
+	unsigned int dtsize;
+	short unsigned int port;
+	unsigned int bsize;
+	unsigned int gxasize;
+	unsigned int sxasize;
+	unsigned int lxasize;
+	unsigned int acregmin;
+	unsigned int acregmax;
+	unsigned int acdirmin;
+	unsigned int acdirmax;
+	unsigned int namelen;
+	unsigned int options;
+	unsigned int clone_blksize;
+	enum nfs4_change_attr_type change_attr_type;
+	struct nfs_fsid fsid;
+	int s_sysfs_id;
+	long: 32;
+	__u64 maxfilesize;
+	struct timespec64 time_delta;
+	long unsigned int mount_time;
+	struct super_block *super;
+	dev_t s_dev;
+	struct nfs_auth_info auth_info;
+	u32 pnfs_blksize;
+	u32 attr_bitmask[3];
+	u32 attr_bitmask_nl[3];
+	u32 exclcreat_bitmask[3];
+	u32 cache_consistency_bitmask[3];
+	u32 acl_bitmask;
+	u32 fh_expire_type;
+	struct pnfs_layoutdriver_type *pnfs_curr_ld;
+	struct rpc_wait_queue roc_rpcwaitq;
+	void *pnfs_ld_data;
+	struct rb_root state_owners;
+	atomic64_t owner_ctr;
+	struct list_head state_owners_lru;
+	struct list_head layouts;
+	struct list_head delegations;
+	struct list_head ss_copies;
+	struct list_head ss_src_copies;
+	long unsigned int delegation_gen;
+	long unsigned int mig_gen;
+	long unsigned int mig_status;
+	void (*destroy)(struct nfs_server *);
+	atomic_t active;
+	struct __kernel_sockaddr_storage mountd_address;
+	size_t mountd_addrlen;
+	u32 mountd_version;
+	short unsigned int mountd_port;
+	short unsigned int mountd_protocol;
+	struct rpc_wait_queue uoc_rpcwaitq;
+	unsigned int read_hdrsize;
+	const struct cred *cred;
+	bool has_sec_mnt_opts;
+	struct kobject kobj;
+	struct callback_head rcu;
+};
+
+struct nfs_subversion;
+
+struct idmap;
+
+struct nfs4_slot_table;
+
+struct nfs4_session;
+
+struct nfs_rpc_ops;
+
+struct nfs4_minor_version_ops;
+
+struct nfs41_server_owner;
+
+struct nfs41_server_scope;
+
+struct nfs41_impl_id;
+
+struct nfs_client {
+	refcount_t cl_count;
+	atomic_t cl_mds_count;
+	int cl_cons_state;
+	long unsigned int cl_res_state;
+	long unsigned int cl_flags;
+	struct __kernel_sockaddr_storage cl_addr;
+	size_t cl_addrlen;
+	char *cl_hostname;
+	char *cl_acceptor;
+	struct list_head cl_share_link;
+	struct list_head cl_superblocks;
+	struct rpc_clnt *cl_rpcclient;
+	const struct nfs_rpc_ops *rpc_ops;
+	int cl_proto;
+	struct nfs_subversion *cl_nfs_mod;
+	u32 cl_minorversion;
+	unsigned int cl_nconnect;
+	unsigned int cl_max_connect;
+	const char *cl_principal;
+	struct xprtsec_parms cl_xprtsec;
+	struct list_head cl_ds_clients;
+	long: 32;
+	u64 cl_clientid;
+	nfs4_verifier cl_confirm;
+	long unsigned int cl_state;
+	spinlock_t cl_lock;
+	long unsigned int cl_lease_time;
+	long unsigned int cl_last_renewal;
+	struct delayed_work cl_renewd;
+	struct rpc_wait_queue cl_rpcwaitq;
+	struct idmap *cl_idmap;
+	const char *cl_owner_id;
+	u32 cl_cb_ident;
+	const struct nfs4_minor_version_ops *cl_mvops;
+	long unsigned int cl_mig_gen;
+	struct nfs4_slot_table *cl_slot_tbl;
+	u32 cl_seqid;
+	u32 cl_exchange_flags;
+	struct nfs4_session *cl_session;
+	bool cl_preserve_clid;
+	struct nfs41_server_owner *cl_serverowner;
+	struct nfs41_server_scope *cl_serverscope;
+	struct nfs41_impl_id *cl_implid;
+	long unsigned int cl_sp4_flags;
+	wait_queue_head_t cl_lock_waitq;
+	char cl_ipaddr[48];
+	struct net *cl_net;
+	struct list_head pending_cb_stateids;
+	struct callback_head rcu;
+	long: 32;
+};
+
+struct pnfs_layout_segment;
+
+struct nfs_seqid_counter;
+
+struct nfs_seqid {
+	struct nfs_seqid_counter *sequence;
+	struct list_head list;
+	struct rpc_task *task;
+};
+
+struct nfs_write_verifier {
+	char data[8];
+};
+
+struct nfs_writeverf {
+	struct nfs_write_verifier verifier;
+	enum nfs3_stable_how committed;
+};
+
+struct nfs_pgio_args {
+	struct nfs4_sequence_args seq_args;
+	struct nfs_fh *fh;
+	struct nfs_open_context *context;
+	struct nfs_lock_context *lock_context;
+	nfs4_stateid stateid;
+	__u64 offset;
+	__u32 count;
+	unsigned int pgbase;
+	struct page **pages;
+	union {
+		unsigned int replen;
+		struct {
+			const u32 *bitmask;
+			u32 bitmask_store[3];
+			enum nfs3_stable_how stable;
+		};
+	};
+};
+
+struct nfs_pgio_res {
+	struct nfs4_sequence_res seq_res;
+	struct nfs_fattr *fattr;
+	long: 32;
+	__u64 count;
+	__u32 op_status;
+	union {
+		struct {
+			unsigned int replen;
+			int eof;
+			void *scratch;
+		};
+		struct {
+			struct nfs_writeverf *verf;
+			const struct nfs_server *server;
+		};
+	};
+};
+
+struct nfs_commitargs {
+	struct nfs4_sequence_args seq_args;
+	struct nfs_fh *fh;
+	long: 32;
+	__u64 offset;
+	__u32 count;
+	const u32 *bitmask;
+};
+
+struct nfs_commitres {
+	struct nfs4_sequence_res seq_res;
+	__u32 op_status;
+	struct nfs_fattr *fattr;
+	struct nfs_writeverf *verf;
+	const struct nfs_server *server;
+};
+
+struct nfs_removeargs {
+	struct nfs4_sequence_args seq_args;
+	const struct nfs_fh *fh;
+	long: 32;
+	struct qstr name;
+};
+
+struct nfs_removeres {
+	struct nfs4_sequence_res seq_res;
+	struct nfs_server *server;
+	struct nfs_fattr *dir_attr;
+	struct nfs4_change_info cinfo;
+};
+
+struct nfs_renameargs {
+	struct nfs4_sequence_args seq_args;
+	const struct nfs_fh *old_dir;
+	const struct nfs_fh *new_dir;
+	const struct qstr *old_name;
+	const struct qstr *new_name;
+};
+
+struct nfs_renameres {
+	struct nfs4_sequence_res seq_res;
+	struct nfs_server *server;
+	long: 32;
+	struct nfs4_change_info old_cinfo;
+	struct nfs_fattr *old_fattr;
+	long: 32;
+	struct nfs4_change_info new_cinfo;
+	struct nfs_fattr *new_fattr;
+	long: 32;
+};
+
+struct nfs_entry {
+	__u64 ino;
+	__u64 cookie;
+	const char *name;
+	unsigned int len;
+	int eof;
+	struct nfs_fh *fh;
+	struct nfs_fattr *fattr;
+	unsigned char d_type;
+	struct nfs_server *server;
+	long: 32;
+};
+
+struct nfs_readdir_arg {
+	struct dentry *dentry;
+	const struct cred *cred;
+	__be32 *verf;
+	long: 32;
+	u64 cookie;
+	struct page **pages;
+	unsigned int page_len;
+	bool plus;
+	long: 32;
+};
+
+struct nfs_readdir_res {
+	__be32 *verf;
+};
+
+struct nfs4_pathname {
+	unsigned int ncomponents;
+	struct nfs4_string components[512];
+};
+
+struct nfs4_fs_location {
+	unsigned int nservers;
+	struct nfs4_string servers[10];
+	struct nfs4_pathname rootpath;
+};
+
+struct nfs4_fs_locations {
+	struct nfs_fattr *fattr;
+	const struct nfs_server *server;
+	struct nfs4_pathname fs_path;
+	int nlocations;
+	struct nfs4_fs_location locations[10];
+};
+
+struct nfstime4 {
+	u64 seconds;
+	u32 nseconds;
+	long: 32;
+};
+
+struct pnfs_commit_ops;
+
+struct pnfs_ds_commit_info {
+	struct list_head commits;
+	unsigned int nwritten;
+	unsigned int ncommitting;
+	const struct pnfs_commit_ops *ops;
+};
+
+struct nfs41_server_owner {
+	uint64_t minor_id;
+	uint32_t major_id_sz;
+	char major_id[1024];
+	long: 32;
+};
+
+struct nfs41_server_scope {
+	uint32_t server_scope_sz;
+	char server_scope[1024];
+};
+
+struct nfs41_impl_id {
+	char domain[1025];
+	char name[1025];
+	long: 32;
+	struct nfstime4 date;
+};
+
+struct nfs_page_array {
+	struct page **pagevec;
+	unsigned int npages;
+	struct page *page_array[8];
+};
+
+struct nfs_page;
+
+struct nfs_rw_ops;
+
+struct nfs_io_completion;
+
+struct nfs_direct_req;
+
+struct nfs_pgio_completion_ops;
+
+struct nfs_pgio_header {
+	struct inode *inode;
+	const struct cred *cred;
+	struct list_head pages;
+	struct nfs_page *req;
+	struct nfs_writeverf verf;
+	fmode_t rw_mode;
+	struct pnfs_layout_segment *lseg;
+	loff_t io_start;
+	const struct rpc_call_ops *mds_ops;
+	void (*release)(struct nfs_pgio_header *);
+	const struct nfs_pgio_completion_ops *completion_ops;
+	const struct nfs_rw_ops *rw_ops;
+	struct nfs_io_completion *io_completion;
+	struct nfs_direct_req *dreq;
+	int pnfs_error;
+	int error;
+	unsigned int good_bytes;
+	long unsigned int flags;
+	struct rpc_task task;
+	struct nfs_fattr fattr;
+	struct nfs_pgio_args args;
+	struct nfs_pgio_res res;
+	long unsigned int timestamp;
+	int (*pgio_done_cb)(struct rpc_task *, struct nfs_pgio_header *);
+	__u64 mds_offset;
+	struct nfs_page_array page_array;
+	struct nfs_client *ds_clp;
+	u32 ds_commit_idx;
+	u32 pgio_mirror_idx;
+	long: 32;
+};
+
+struct nfs_pgio_completion_ops {
+	void (*error_cleanup)(struct list_head *, int);
+	void (*init_hdr)(struct nfs_pgio_header *);
+	void (*completion)(struct nfs_pgio_header *);
+	void (*reschedule_io)(struct nfs_pgio_header *);
+};
+
+struct nfs_mds_commit_info {
+	atomic_t rpcs_out;
+	atomic_long_t ncommit;
+	struct list_head list;
+};
+
+struct nfs_commit_data;
+
+struct nfs_commit_info;
+
+struct nfs_commit_completion_ops {
+	void (*completion)(struct nfs_commit_data *);
+	void (*resched_write)(struct nfs_commit_info *, struct nfs_page *);
+};
+
+struct nfs_commit_data {
+	struct rpc_task task;
+	struct inode *inode;
+	const struct cred *cred;
+	struct nfs_fattr fattr;
+	struct nfs_writeverf verf;
+	struct list_head pages;
+	struct list_head list;
+	struct nfs_direct_req *dreq;
+	struct nfs_commitargs args;
+	struct nfs_commitres res;
+	struct nfs_open_context *context;
+	struct pnfs_layout_segment *lseg;
+	struct nfs_client *ds_clp;
+	int ds_commit_index;
+	loff_t lwb;
+	const struct rpc_call_ops *mds_ops;
+	const struct nfs_commit_completion_ops *completion_ops;
+	int (*commit_done_cb)(struct rpc_task *, struct nfs_commit_data *);
+	long unsigned int flags;
+};
+
+struct nfs_commit_info {
+	struct inode *inode;
+	struct nfs_mds_commit_info *mds;
+	struct pnfs_ds_commit_info *ds;
+	struct nfs_direct_req *dreq;
+	const struct nfs_commit_completion_ops *completion_ops;
+};
+
+struct nfs_unlinkdata {
+	struct nfs_removeargs args;
+	struct nfs_removeres res;
+	struct dentry *dentry;
+	wait_queue_head_t wq;
+	const struct cred *cred;
+	long: 32;
+	struct nfs_fattr dir_attr;
+	long int timeout;
+	long: 32;
+};
+
+struct nfs_renamedata {
+	struct nfs_renameargs args;
+	struct nfs_renameres res;
+	struct rpc_task task;
+	const struct cred *cred;
+	struct inode *old_dir;
+	struct dentry *old_dentry;
+	long: 32;
+	struct nfs_fattr old_fattr;
+	struct inode *new_dir;
+	struct dentry *new_dentry;
+	struct nfs_fattr new_fattr;
+	void (*complete)(struct rpc_task *, struct nfs_renamedata *);
+	long int timeout;
+	bool cancelled;
+	long: 32;
+};
+
+struct nlmclnt_operations;
+
+struct nfs_client_initdata;
+
+struct nfs_access_entry;
+
+struct nfs_rpc_ops {
+	u32 version;
+	const struct dentry_operations *dentry_ops;
+	const struct inode_operations *dir_inode_ops;
+	const struct inode_operations *file_inode_ops;
+	const struct file_operations *file_ops;
+	const struct nlmclnt_operations *nlmclnt_ops;
+	int (*getroot)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
+	int (*submount)(struct fs_context *, struct nfs_server *);
+	int (*try_get_tree)(struct fs_context *);
+	int (*getattr)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, struct inode *);
+	int (*setattr)(struct dentry *, struct nfs_fattr *, struct iattr *);
+	int (*lookup)(struct inode *, struct dentry *, struct nfs_fh *, struct nfs_fattr *);
+	int (*lookupp)(struct inode *, struct nfs_fh *, struct nfs_fattr *);
+	int (*access)(struct inode *, struct nfs_access_entry *, const struct cred *);
+	int (*readlink)(struct inode *, struct page *, unsigned int, unsigned int);
+	int (*create)(struct inode *, struct dentry *, struct iattr *, int);
+	int (*remove)(struct inode *, struct dentry *);
+	void (*unlink_setup)(struct rpc_message *, struct dentry *, struct inode *);
+	void (*unlink_rpc_prepare)(struct rpc_task *, struct nfs_unlinkdata *);
+	int (*unlink_done)(struct rpc_task *, struct inode *);
+	void (*rename_setup)(struct rpc_message *, struct dentry *, struct dentry *);
+	void (*rename_rpc_prepare)(struct rpc_task *, struct nfs_renamedata *);
+	int (*rename_done)(struct rpc_task *, struct inode *, struct inode *);
+	int (*link)(struct inode *, struct inode *, const struct qstr *);
+	int (*symlink)(struct inode *, struct dentry *, struct folio *, unsigned int, struct iattr *);
+	int (*mkdir)(struct inode *, struct dentry *, struct iattr *);
+	int (*rmdir)(struct inode *, const struct qstr *);
+	int (*readdir)(struct nfs_readdir_arg *, struct nfs_readdir_res *);
+	int (*mknod)(struct inode *, struct dentry *, struct iattr *, dev_t);
+	int (*statfs)(struct nfs_server *, struct nfs_fh *, struct nfs_fsstat *);
+	int (*fsinfo)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
+	int (*pathconf)(struct nfs_server *, struct nfs_fh *, struct nfs_pathconf *);
+	int (*set_capabilities)(struct nfs_server *, struct nfs_fh *);
+	int (*decode_dirent)(struct xdr_stream *, struct nfs_entry *, bool);
+	int (*pgio_rpc_prepare)(struct rpc_task *, struct nfs_pgio_header *);
+	void (*read_setup)(struct nfs_pgio_header *, struct rpc_message *);
+	int (*read_done)(struct rpc_task *, struct nfs_pgio_header *);
+	void (*write_setup)(struct nfs_pgio_header *, struct rpc_message *, struct rpc_clnt **);
+	int (*write_done)(struct rpc_task *, struct nfs_pgio_header *);
+	void (*commit_setup)(struct nfs_commit_data *, struct rpc_message *, struct rpc_clnt **);
+	void (*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
+	int (*commit_done)(struct rpc_task *, struct nfs_commit_data *);
+	int (*lock)(struct file *, int, struct file_lock *);
+	int (*lock_check_bounds)(const struct file_lock *);
+	void (*clear_acl_cache)(struct inode *);
+	void (*close_context)(struct nfs_open_context *, int);
+	struct inode * (*open_context)(struct inode *, struct nfs_open_context *, int, struct iattr *, int *);
+	int (*have_delegation)(struct inode *, fmode_t, int);
+	int (*return_delegation)(struct inode *);
+	struct nfs_client * (*alloc_client)(const struct nfs_client_initdata *);
+	struct nfs_client * (*init_client)(struct nfs_client *, const struct nfs_client_initdata *);
+	void (*free_client)(struct nfs_client *);
+	struct nfs_server * (*create_server)(struct fs_context *);
+	struct nfs_server * (*clone_server)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, rpc_authflavor_t);
+	int (*discover_trunking)(struct nfs_server *, struct nfs_fh *);
+	void (*enable_swap)(struct inode *);
+	void (*disable_swap)(struct inode *);
+};
+
+struct nfs_access_entry {
+	struct rb_node rb_node;
+	struct list_head lru;
+	kuid_t fsuid;
+	kgid_t fsgid;
+	struct group_info *group_info;
+	u64 timestamp;
+	__u32 mask;
+	struct callback_head callback_head;
+	long: 32;
+};
+
+struct nfs4_state_recovery_ops;
+
+struct nfs4_state_maintenance_ops;
+
+struct nfs4_mig_recovery_ops;
+
+struct nfs4_minor_version_ops {
+	u32 minor_version;
+	unsigned int init_caps;
+	int (*init_client)(struct nfs_client *);
+	void (*shutdown_client)(struct nfs_client *);
+	bool (*match_stateid)(const nfs4_stateid *, const nfs4_stateid *);
+	int (*find_root_sec)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
+	void (*free_lock_state)(struct nfs_server *, struct nfs4_lock_state *);
+	int (*test_and_free_expired)(struct nfs_server *, const nfs4_stateid *, const struct cred *);
+	struct nfs_seqid * (*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);
+	void (*session_trunk)(struct rpc_clnt *, struct rpc_xprt *, void *);
+	const struct rpc_call_ops *call_sync_ops;
+	const struct nfs4_state_recovery_ops *reboot_recovery_ops;
+	const struct nfs4_state_recovery_ops *nograce_recovery_ops;
+	const struct nfs4_state_maintenance_ops *state_renewal_ops;
+	const struct nfs4_mig_recovery_ops *mig_recovery_ops;
+};
+
+struct nfs4_state_owner;
+
+struct nfs4_state {
+	struct list_head open_states;
+	struct list_head inode_states;
+	struct list_head lock_states;
+	struct nfs4_state_owner *owner;
+	struct inode *inode;
+	long unsigned int flags;
+	spinlock_t state_lock;
+	seqlock_t seqlock;
+	nfs4_stateid stateid;
+	nfs4_stateid open_stateid;
+	unsigned int n_rdonly;
+	unsigned int n_wronly;
+	unsigned int n_rdwr;
+	fmode_t state;
+	refcount_t count;
+	wait_queue_head_t waitq;
+	struct callback_head callback_head;
+};
+
+struct cache_head {
+	struct hlist_node cache_list;
+	time64_t expiry_time;
+	time64_t last_refresh;
+	struct kref ref;
+	long unsigned int flags;
+};
+
+struct cache_deferred_req;
+
+struct cache_req {
+	struct cache_deferred_req * (*defer)(struct cache_req *);
+	long unsigned int thread_wait;
+};
+
+struct cache_deferred_req {
+	struct hlist_node hash;
+	struct list_head recent;
+	struct cache_head *item;
+	void *owner;
+	void (*revisit)(struct cache_deferred_req *, int);
+};
+
+struct svc_cred {
+	kuid_t cr_uid;
+	kgid_t cr_gid;
+	struct group_info *cr_group_info;
+	u32 cr_flavor;
+	char *cr_raw_principal;
+	char *cr_principal;
+	char *cr_targ_princ;
+	struct gss_api_mech *cr_gss_mech;
+};
+
+struct auth_ops {
+	char *name;
+	struct module *owner;
+	int flavour;
+	enum svc_auth_status (*accept)(struct svc_rqst *);
+	int (*release)(struct svc_rqst *);
+	void (*domain_release)(struct auth_domain *);
+	enum svc_auth_status (*set_client)(struct svc_rqst *);
+	rpc_authflavor_t (*pseudoflavor)(struct svc_rqst *);
+};
+
+struct svc_procedure;
+
+struct svc_deferred_req;
+
+struct svc_rqst {
+	struct list_head rq_all;
+	struct llist_node rq_idle;
+	struct callback_head rq_rcu_head;
+	struct svc_xprt *rq_xprt;
+	struct __kernel_sockaddr_storage rq_addr;
+	size_t rq_addrlen;
+	struct __kernel_sockaddr_storage rq_daddr;
+	size_t rq_daddrlen;
+	struct svc_serv *rq_server;
+	struct svc_pool *rq_pool;
+	const struct svc_procedure *rq_procinfo;
+	struct auth_ops *rq_authop;
+	struct svc_cred rq_cred;
+	void *rq_xprt_ctxt;
+	struct svc_deferred_req *rq_deferred;
+	struct xdr_buf rq_arg;
+	struct xdr_stream rq_arg_stream;
+	struct xdr_stream rq_res_stream;
+	struct page *rq_scratch_page;
+	struct xdr_buf rq_res;
+	struct page *rq_pages[260];
+	struct page **rq_respages;
+	struct page **rq_next_page;
+	struct page **rq_page_end;
+	struct folio_batch rq_fbatch;
+	struct kvec rq_vec[259];
+	struct bio_vec rq_bvec[259];
+	__be32 rq_xid;
+	u32 rq_prog;
+	u32 rq_vers;
+	u32 rq_proc;
+	u32 rq_prot;
+	int rq_cachetype;
+	long unsigned int rq_flags;
+	ktime_t rq_qtime;
+	void *rq_argp;
+	void *rq_resp;
+	__be32 *rq_accept_statp;
+	void *rq_auth_data;
+	__be32 rq_auth_stat;
+	int rq_auth_slack;
+	int rq_reserved;
+	long: 32;
+	ktime_t rq_stime;
+	struct cache_req rq_chandle;
+	struct auth_domain *rq_client;
+	struct auth_domain *rq_gssclient;
+	struct task_struct *rq_task;
+	struct net *rq_bc_net;
+	int rq_err;
+	long unsigned int bc_to_initval;
+	unsigned int bc_to_retries;
+	void **rq_lease_breaker;
+	unsigned int rq_status_counter;
+	long: 32;
+};
+
+struct svc_pool {
+	unsigned int sp_id;
+	struct lwq sp_xprts;
+	unsigned int sp_nrthreads;
+	struct list_head sp_all_threads;
+	struct llist_head sp_idle_threads;
+	struct percpu_counter sp_messages_arrived;
+	struct percpu_counter sp_sockets_queued;
+	struct percpu_counter sp_threads_woken;
+	long unsigned int sp_flags;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct svc_procedure {
+	__be32 (*pc_func)(struct svc_rqst *);
+	bool (*pc_decode)(struct svc_rqst *, struct xdr_stream *);
+	bool (*pc_encode)(struct svc_rqst *, struct xdr_stream *);
+	void (*pc_release)(struct svc_rqst *);
+	unsigned int pc_argsize;
+	unsigned int pc_argzero;
+	unsigned int pc_ressize;
+	unsigned int pc_cachetype;
+	unsigned int pc_xdrressize;
+	const char *pc_name;
+};
+
+struct svc_deferred_req {
+	u32 prot;
+	struct svc_xprt *xprt;
+	struct __kernel_sockaddr_storage addr;
+	size_t addrlen;
+	struct __kernel_sockaddr_storage daddr;
+	size_t daddrlen;
+	void *xprt_ctxt;
+	struct cache_deferred_req handle;
+	int argslen;
+	__be32 args[0];
+};
+
+struct svc_process_info {
+	union {
+		int (*dispatch)(struct svc_rqst *);
+		struct {
+			unsigned int lovers;
+			unsigned int hivers;
+		} mismatch;
+	};
+};
+
+struct svc_version {
+	u32 vs_vers;
+	u32 vs_nproc;
+	const struct svc_procedure *vs_proc;
+	long unsigned int *vs_count;
+	u32 vs_xdrsize;
+	bool vs_hidden;
+	bool vs_rpcb_optnl;
+	bool vs_need_cong_ctrl;
+	int (*vs_dispatch)(struct svc_rqst *);
+};
+
+struct nfs4_ssc_client_ops;
+
+struct nfs_ssc_client_ops;
+
+struct nfs_ssc_client_ops_tbl {
+	const struct nfs4_ssc_client_ops *ssc_nfs4_ops;
+	const struct nfs_ssc_client_ops *ssc_nfs_ops;
+};
+
+struct nfs4_ssc_client_ops {
+	struct file * (*sco_open)(struct vfsmount *, struct nfs_fh *, nfs4_stateid *);
+	void (*sco_close)(struct file *);
+};
+
+struct nfs_ssc_client_ops {
+	void (*sco_sb_deactive)(struct super_block *);
+};
+
+struct nfs_seqid_counter {
+	ktime_t create_time;
+	u64 owner_id;
+	int flags;
+	u32 counter;
+	spinlock_t lock;
+	struct list_head list;
+	struct rpc_wait_queue wait;
+	long: 32;
+};
+
+struct nfs4_lock_state {
+	struct list_head ls_locks;
+	struct nfs4_state *ls_state;
+	long unsigned int ls_flags;
+	struct nfs_seqid_counter ls_seqid;
+	nfs4_stateid ls_stateid;
+	refcount_t ls_count;
+	fl_owner_t ls_owner;
+	long: 32;
+};
+
+struct nfs4_state_recovery_ops {
+	int owner_flag_bit;
+	int state_flag_bit;
+	int (*recover_open)(struct nfs4_state_owner *, struct nfs4_state *);
+	int (*recover_lock)(struct nfs4_state *, struct file_lock *);
+	int (*establish_clid)(struct nfs_client *, const struct cred *);
+	int (*reclaim_complete)(struct nfs_client *, const struct cred *);
+	int (*detect_trunking)(struct nfs_client *, struct nfs_client **, const struct cred *);
+};
+
+struct nfs4_state_maintenance_ops {
+	int (*sched_state_renewal)(struct nfs_client *, const struct cred *, unsigned int);
+	const struct cred * (*get_state_renewal_cred)(struct nfs_client *);
+	int (*renew_lease)(struct nfs_client *, const struct cred *);
+};
+
+struct nfs4_mig_recovery_ops {
+	int (*get_locations)(struct nfs_server *, struct nfs_fh *, struct nfs4_fs_locations *, struct page *, const struct cred *);
+	int (*fsid_present)(struct inode *, const struct cred *);
+};
+
+struct nfs4_state_owner {
+	struct nfs_server *so_server;
+	struct list_head so_lru;
+	long unsigned int so_expires;
+	struct rb_node so_server_node;
+	const struct cred *so_cred;
+	spinlock_t so_lock;
+	atomic_t so_count;
+	long unsigned int so_flags;
+	struct list_head so_states;
+	long: 32;
+	struct nfs_seqid_counter so_seqid;
+	struct mutex so_delegreturn_mutex;
+	long: 32;
+};
+
+struct folio_iter {
+	struct folio *folio;
+	size_t offset;
+	size_t length;
+	struct folio *_next;
+	size_t _seg_count;
+	int _i;
+};
+
+enum {
+	BIOSET_NEED_BVECS = 1,
+	BIOSET_NEED_RESCUER = 2,
+	BIOSET_PERCPU_CACHE = 4,
+};
+
+struct dax_device;
+
+struct iomap_folio_ops;
+
+struct iomap {
+	u64 addr;
+	loff_t offset;
+	u64 length;
+	u16 type;
+	u16 flags;
+	struct block_device *bdev;
+	struct dax_device *dax_dev;
+	void *inline_data;
+	void *private;
+	const struct iomap_folio_ops *folio_ops;
+	u64 validity_cookie;
+};
+
+struct iomap_iter;
+
+struct iomap_folio_ops {
+	struct folio * (*get_folio)(struct iomap_iter *, loff_t, unsigned int);
+	void (*put_folio)(struct inode *, loff_t, unsigned int, struct folio *);
+	bool (*iomap_valid)(struct inode *, const struct iomap *);
+};
+
+struct iomap_iter {
+	struct inode *inode;
+	long: 32;
+	loff_t pos;
+	u64 len;
+	s64 processed;
+	unsigned int flags;
+	long: 32;
+	struct iomap iomap;
+	struct iomap srcmap;
+	void *private;
+	long: 32;
+};
+
+typedef void (*iomap_punch_t)(struct inode *, loff_t, loff_t, struct iomap *);
+
+struct iomap_ioend {
+	struct list_head io_list;
+	u16 io_type;
+	u16 io_flags;
+	struct inode *io_inode;
+	size_t io_size;
+	long: 32;
+	loff_t io_offset;
+	sector_t io_sector;
+	struct bio io_bio;
+};
+
+struct iomap_writepage_ctx;
+
+struct iomap_writeback_ops {
+	int (*map_blocks)(struct iomap_writepage_ctx *, struct inode *, loff_t, unsigned int);
+	int (*prepare_ioend)(struct iomap_ioend *, int);
+	void (*discard_folio)(struct folio *, loff_t);
+};
+
+struct iomap_writepage_ctx {
+	struct iomap iomap;
+	struct iomap_ioend *ioend;
+	const struct iomap_writeback_ops *ops;
+	u32 nr_folios;
+	long: 32;
+};
+
+typedef int (*list_cmp_func_t)(void *, const struct list_head *, const struct list_head *);
+
+struct iomap_folio_state {
+	spinlock_t state_lock;
+	unsigned int read_bytes_pending;
+	atomic_t write_bytes_pending;
+	long unsigned int state[0];
+};
+
+struct iomap_readpage_ctx {
+	struct folio *cur_folio;
+	bool cur_folio_in_bio;
+	struct bio *bio;
+	struct readahead_control *rac;
+};
+
+enum {
+	PROC_ENTRY_PERMANENT = 1,
+};
+
+enum proc_hidepid {
+	HIDEPID_OFF = 0,
+	HIDEPID_NO_ACCESS = 1,
+	HIDEPID_INVISIBLE = 2,
+	HIDEPID_NOT_PTRACEABLE = 4,
+};
+
+enum proc_pidonly {
+	PROC_PIDONLY_OFF = 0,
+	PROC_PIDONLY_ON = 1,
+};
+
+struct proc_fs_info {
+	struct pid_namespace *pid_ns;
+	struct dentry *proc_self;
+	struct dentry *proc_thread_self;
+	kgid_t pid_gid;
+	enum proc_hidepid hide_pid;
+	enum proc_pidonly pidonly;
+	struct callback_head rcu;
+};
+
+struct pde_opener {
+	struct list_head lh;
+	struct file *file;
+	bool closing;
+	struct completion *c;
+};
+
+enum {
+	BIAS = 2147483648,
+};
+
+typedef __kernel_off_t off_t;
+
+struct va_format {
+	const char *fmt;
+	va_list *va;
+};
+
+typedef int (*parse_unknown_fn)(char *, char *, const char *, void *);
+
+struct sysctl_alias {
+	const char *kernel_param;
+	const char *sysctl_param;
+};
+
+enum kernfs_node_type {
+	KERNFS_DIR = 1,
+	KERNFS_FILE = 2,
+	KERNFS_LINK = 4,
+};
+
+enum kernfs_node_flag {
+	KERNFS_ACTIVATED = 16,
+	KERNFS_NS = 32,
+	KERNFS_HAS_SEQ_SHOW = 64,
+	KERNFS_HAS_MMAP = 128,
+	KERNFS_LOCKDEP = 256,
+	KERNFS_HIDDEN = 512,
+	KERNFS_SUICIDAL = 1024,
+	KERNFS_SUICIDED = 2048,
+	KERNFS_EMPTY_DIR = 4096,
+	KERNFS_HAS_RELEASE = 8192,
+	KERNFS_REMOVING = 16384,
+};
+
+struct meta_entry {
+	u64 data_block;
+	unsigned int index_block;
+	short unsigned int offset;
+	short unsigned int pad;
+};
+
+struct meta_index {
+	unsigned int inode_number;
+	unsigned int offset;
+	short unsigned int entries;
+	short unsigned int skip;
+	short unsigned int locked;
+	short unsigned int pad;
+	struct meta_entry meta_entry[127];
+};
+
+struct squashfs_cache_entry;
+
+struct squashfs_cache {
+	char *name;
+	int entries;
+	int curr_blk;
+	int next_blk;
+	int num_waiters;
+	int unused;
+	int block_size;
+	int pages;
+	spinlock_t lock;
+	wait_queue_head_t wait_queue;
+	struct squashfs_cache_entry *entry;
+};
+
+struct squashfs_page_actor;
+
+struct squashfs_cache_entry {
+	u64 block;
+	int length;
+	int refcount;
+	u64 next_index;
+	int pending;
+	int error;
+	int num_waiters;
+	wait_queue_head_t wait_queue;
+	struct squashfs_cache *cache;
+	void **data;
+	struct squashfs_page_actor *actor;
+	long: 32;
+};
+
+struct squashfs_page_actor {
+	union {
+		void **buffer;
+		struct page **page;
+	};
+	void *pageaddr;
+	void *tmp_buffer;
+	void * (*squashfs_first_page)(struct squashfs_page_actor *);
+	void * (*squashfs_next_page)(struct squashfs_page_actor *);
+	void (*squashfs_finish_page)(struct squashfs_page_actor *);
+	struct page *last_page;
+	int pages;
+	int length;
+	int next_page;
+	int alloc_buffer;
+	int returned_pages;
+	long unsigned int next_index;
+};
+
+struct squashfs_decompressor;
+
+struct squashfs_decompressor_thread_ops;
+
+struct squashfs_sb_info {
+	const struct squashfs_decompressor *decompressor;
+	int devblksize;
+	int devblksize_log2;
+	struct squashfs_cache *block_cache;
+	struct squashfs_cache *fragment_cache;
+	struct squashfs_cache *read_page;
+	struct address_space *cache_mapping;
+	int next_meta_index;
+	__le64 *id_table;
+	__le64 *fragment_index;
+	__le64 *xattr_id_table;
+	struct mutex meta_index_mutex;
+	struct meta_index *meta_index;
+	void *stream;
+	__le64 *inode_lookup_table;
+	long: 32;
+	u64 inode_table;
+	u64 directory_table;
+	u64 xattr_table;
+	unsigned int block_size;
+	short unsigned int block_log;
+	long long int bytes_used;
+	unsigned int inodes;
+	unsigned int fragments;
+	unsigned int xattr_ids;
+	unsigned int ids;
+	bool panic_on_errors;
+	const struct squashfs_decompressor_thread_ops *thread_ops;
+	int max_thread_num;
+	long: 32;
+};
+
+struct squashfs_decompressor {
+	void * (*init)(struct squashfs_sb_info *, void *);
+	void * (*comp_opts)(struct squashfs_sb_info *, void *, int);
+	void (*free)(void *);
+	int (*decompress)(struct squashfs_sb_info *, void *, struct bio *, int, int, struct squashfs_page_actor *);
+	int id;
+	char *name;
+	int alloc_buffer;
+	int supported;
+};
+
+struct squashfs_decompressor_thread_ops {
+	void * (*create)(struct squashfs_sb_info *, void *);
+	void (*destroy)(struct squashfs_sb_info *);
+	int (*decompress)(struct squashfs_sb_info *, struct bio *, int, int, struct squashfs_page_actor *);
+	int (*max_decompressors)();
+};
+
+struct squashfs_inode_info {
+	u64 start;
+	int offset;
+	long: 32;
+	u64 xattr;
+	unsigned int xattr_size;
+	int xattr_count;
+	union {
+		struct {
+			u64 fragment_block;
+			int fragment_size;
+			int fragment_offset;
+			u64 block_list_start;
+		};
+		struct {
+			u64 dir_idx_start;
+			int dir_idx_offset;
+			int dir_idx_cnt;
+			int parent;
+			long: 32;
+		};
+	};
+	struct inode vfs_inode;
+};
+
+struct squashfs_dir_index {
+	__le32 index;
+	__le32 start_block;
+	__le32 size;
+	unsigned char name[0];
+};
+
+struct squashfs_dir_entry {
+	__le16 offset;
+	__le16 inode_number;
+	__le16 type;
+	__le16 size;
+	char name[0];
+};
+
+struct squashfs_dir_header {
+	__le32 count;
+	__le32 start_block;
+	__le32 inode_number;
+};
+
+typedef u8 uint8_t;
+
+typedef u16 uint16_t;
+
+typedef struct {
+	__u32 v32;
+} jint32_t;
+
+typedef struct {
+	__u32 m;
+} jmode_t;
+
+typedef struct {
+	__u16 v16;
+} jint16_t;
+
+struct jffs2_raw_dirent {
+	jint16_t magic;
+	jint16_t nodetype;
+	jint32_t totlen;
+	jint32_t hdr_crc;
+	jint32_t pino;
+	jint32_t version;
+	jint32_t ino;
+	jint32_t mctime;
+	__u8 nsize;
+	__u8 type;
+	__u8 unused[2];
+	jint32_t node_crc;
+	jint32_t name_crc;
+	__u8 name[0];
+};
+
+struct jffs2_raw_inode {
+	jint16_t magic;
+	jint16_t nodetype;
+	jint32_t totlen;
+	jint32_t hdr_crc;
+	jint32_t ino;
+	jint32_t version;
+	jmode_t mode;
+	jint16_t uid;
+	jint16_t gid;
+	jint32_t isize;
+	jint32_t atime;
+	jint32_t mtime;
+	jint32_t ctime;
+	jint32_t offset;
+	jint32_t csize;
+	jint32_t dsize;
+	__u8 compr;
+	__u8 usercompr;
+	jint16_t flags;
+	jint32_t data_crc;
+	jint32_t node_crc;
+	__u8 data[0];
+};
+
+union jffs2_device_node {
+	jint16_t old_id;
+	jint32_t new_id;
+};
+
+struct jffs2_full_dnode;
+
+struct jffs2_full_dirent;
+
+struct jffs2_inode_cache;
+
+struct jffs2_inode_info {
+	struct mutex sem;
+	uint32_t highest_version;
+	struct rb_root fragtree;
+	struct jffs2_full_dnode *metadata;
+	struct jffs2_full_dirent *dents;
+	unsigned char *target;
+	struct jffs2_inode_cache *inocache;
+	uint16_t flags;
+	uint8_t usercompr;
+	struct inode vfs_inode;
+};
+
+struct jffs2_raw_node_ref;
+
+struct jffs2_full_dnode {
+	struct jffs2_raw_node_ref *raw;
+	uint32_t ofs;
+	uint32_t size;
+	uint32_t frags;
+};
+
+struct jffs2_full_dirent {
+	union {
+		struct jffs2_raw_node_ref *raw;
+		struct jffs2_inode_cache *ic;
+	};
+	struct jffs2_full_dirent *next;
+	uint32_t version;
+	uint32_t ino;
+	unsigned int nhash;
+	unsigned char type;
+	unsigned char name[0];
+};
+
+struct jffs2_xattr_ref;
+
+struct jffs2_inode_cache {
+	struct jffs2_full_dirent *scan_dents;
+	struct jffs2_raw_node_ref *nodes;
+	uint8_t class;
+	uint8_t flags;
+	uint16_t state;
+	uint32_t ino;
+	struct jffs2_inode_cache *next;
+	struct jffs2_xattr_ref *xref;
+	uint32_t pino_nlink;
+};
+
+struct jffs2_mount_opts {
+	bool override_compr;
+	unsigned int compr;
+	bool set_rp_size;
+	unsigned int rp_size;
+};
+
+struct jffs2_eraseblock;
+
+struct jffs2_inodirty;
+
+struct jffs2_summary;
+
+struct jffs2_sb_info {
+	struct mtd_info *mtd;
+	uint32_t highest_ino;
+	uint32_t check_ino;
+	unsigned int flags;
+	struct task_struct *gc_task;
+	struct completion gc_thread_start;
+	struct completion gc_thread_exit;
+	struct mutex alloc_sem;
+	uint32_t cleanmarker_size;
+	uint32_t flash_size;
+	uint32_t used_size;
+	uint32_t dirty_size;
+	uint32_t wasted_size;
+	uint32_t free_size;
+	uint32_t erasing_size;
+	uint32_t bad_size;
+	uint32_t sector_size;
+	uint32_t unchecked_size;
+	uint32_t nr_free_blocks;
+	uint32_t nr_erasing_blocks;
+	uint8_t resv_blocks_write;
+	uint8_t resv_blocks_deletion;
+	uint8_t resv_blocks_gctrigger;
+	uint8_t resv_blocks_gcbad;
+	uint8_t resv_blocks_gcmerge;
+	uint8_t vdirty_blocks_gctrigger;
+	uint32_t nospc_dirty_size;
+	uint32_t nr_blocks;
+	struct jffs2_eraseblock *blocks;
+	struct jffs2_eraseblock *nextblock;
+	struct jffs2_eraseblock *gcblock;
+	struct list_head clean_list;
+	struct list_head very_dirty_list;
+	struct list_head dirty_list;
+	struct list_head erasable_list;
+	struct list_head erasable_pending_wbuf_list;
+	struct list_head erasing_list;
+	struct list_head erase_checking_list;
+	struct list_head erase_pending_list;
+	struct list_head erase_complete_list;
+	struct list_head free_list;
+	struct list_head bad_list;
+	struct list_head bad_used_list;
+	spinlock_t erase_completion_lock;
+	wait_queue_head_t erase_wait;
+	wait_queue_head_t inocache_wq;
+	int inocache_hashsize;
+	struct jffs2_inode_cache **inocache_list;
+	spinlock_t inocache_lock;
+	struct mutex erase_free_sem;
+	uint32_t wbuf_pagesize;
+	unsigned char *wbuf;
+	uint32_t wbuf_ofs;
+	uint32_t wbuf_len;
+	struct jffs2_inodirty *wbuf_inodes;
+	struct rw_semaphore wbuf_sem;
+	struct delayed_work wbuf_dwork;
+	unsigned char *oobbuf;
+	int oobavail;
+	struct jffs2_summary *summary;
+	struct jffs2_mount_opts mount_opts;
+	uint32_t highest_xid;
+	uint32_t highest_xseqno;
+	struct list_head xattrindex[57];
+	struct list_head xattr_unchecked;
+	struct list_head xattr_dead_list;
+	struct jffs2_xattr_ref *xref_dead_list;
+	struct jffs2_xattr_ref *xref_temp;
+	struct rw_semaphore xattr_sem;
+	uint32_t xdatum_mem_usage;
+	uint32_t xdatum_mem_threshold;
+	void *os_priv;
+};
+
+struct jffs2_eraseblock {
+	struct list_head list;
+	int bad_count;
+	uint32_t offset;
+	uint32_t unchecked_size;
+	uint32_t used_size;
+	uint32_t dirty_size;
+	uint32_t wasted_size;
+	uint32_t free_size;
+	uint32_t allocated_refs;
+	struct jffs2_raw_node_ref *first_node;
+	struct jffs2_raw_node_ref *last_node;
+	struct jffs2_raw_node_ref *gc_node;
+};
+
+union jffs2_sum_mem;
+
+struct jffs2_summary {
+	uint32_t sum_size;
+	uint32_t sum_num;
+	uint32_t sum_padded;
+	union jffs2_sum_mem *sum_list_head;
+	union jffs2_sum_mem *sum_list_tail;
+	jint32_t *sum_buf;
+};
+
+struct jffs2_xattr_datum;
+
+struct jffs2_xattr_ref {
+	void *always_null;
+	struct jffs2_raw_node_ref *node;
+	uint8_t class;
+	uint8_t flags;
+	u16 unused;
+	uint32_t xseqno;
+	union {
+		struct jffs2_inode_cache *ic;
+		uint32_t ino;
+	};
+	union {
+		struct jffs2_xattr_datum *xd;
+		uint32_t xid;
+	};
+	struct jffs2_xattr_ref *next;
+};
+
+struct jffs2_xattr_datum {
+	void *always_null;
+	struct jffs2_raw_node_ref *node;
+	uint8_t class;
+	uint8_t flags;
+	uint16_t xprefix;
+	struct list_head xindex;
+	atomic_t refcnt;
+	uint32_t xid;
+	uint32_t version;
+	uint32_t data_crc;
+	uint32_t hashkey;
+	char *xname;
+	uint32_t name_len;
+	char *xvalue;
+	uint32_t value_len;
+};
+
+struct jffs2_raw_node_ref {
+	struct jffs2_raw_node_ref *next_in_ino;
+	uint32_t flash_offset;
+};
+
+struct jffs2_sum_unknown_mem {
+	union jffs2_sum_mem *next;
+	jint16_t nodetype;
+};
+
+struct jffs2_sum_inode_mem {
+	union jffs2_sum_mem *next;
+	jint16_t nodetype;
+	jint32_t inode;
+	jint32_t version;
+	jint32_t offset;
+	jint32_t totlen;
+} __attribute__((packed));
+
+struct jffs2_sum_dirent_mem {
+	union jffs2_sum_mem *next;
+	jint16_t nodetype;
+	jint32_t totlen;
+	jint32_t offset;
+	jint32_t pino;
+	jint32_t version;
+	jint32_t ino;
+	uint8_t nsize;
+	uint8_t type;
+	uint8_t name[0];
+} __attribute__((packed));
+
+struct jffs2_sum_xattr_mem {
+	union jffs2_sum_mem *next;
+	jint16_t nodetype;
+	jint32_t xid;
+	jint32_t version;
+	jint32_t offset;
+	jint32_t totlen;
+} __attribute__((packed));
+
+struct jffs2_sum_xref_mem {
+	union jffs2_sum_mem *next;
+	jint16_t nodetype;
+	jint32_t offset;
+} __attribute__((packed));
+
+union jffs2_sum_mem {
+	struct jffs2_sum_unknown_mem u;
+	struct jffs2_sum_inode_mem i;
+	struct jffs2_sum_dirent_mem d;
+	struct jffs2_sum_xattr_mem x;
+	struct jffs2_sum_xref_mem r;
+};
+
+typedef unsigned char u_char;
+
+struct otp_info {
+	__u32 start;
+	__u32 length;
+	__u32 locked;
+};
+
+struct mtd_ecc_stats {
+	__u32 corrected;
+	__u32 failed;
+	__u32 badblocks;
+	__u32 bbtblocks;
+};
+
+struct erase_info {
+	uint64_t addr;
+	uint64_t len;
+	uint64_t fail_addr;
+};
+
+struct mtd_erase_region_info {
+	uint64_t offset;
+	uint32_t erasesize;
+	uint32_t numblocks;
+	long unsigned int *lockmap;
+	long: 32;
+};
+
+struct mtd_req_stats {
+	unsigned int uncorrectable_errors;
+	unsigned int corrected_bitflips;
+	unsigned int max_bitflips;
+};
+
+struct mtd_oob_ops {
+	unsigned int mode;
+	size_t len;
+	size_t retlen;
+	size_t ooblen;
+	size_t oobretlen;
+	uint32_t ooboffs;
+	uint8_t *datbuf;
+	uint8_t *oobbuf;
+	struct mtd_req_stats *stats;
+};
+
+struct mtd_oob_region {
+	u32 offset;
+	u32 length;
+};
+
+struct mtd_ooblayout_ops {
+	int (*ecc)(struct mtd_info *, int, struct mtd_oob_region *);
+	int (*free)(struct mtd_info *, int, struct mtd_oob_region *);
+};
+
+struct mtd_debug_info {
+	struct dentry *dfs_dir;
+};
+
+struct mtd_part {
+	struct list_head node;
+	u64 offset;
+	u64 size;
+	u32 flags;
+	long: 32;
+};
+
+struct mtd_master {
+	struct mutex partitions_lock;
+	struct mutex chrdev_lock;
+	unsigned int suspended: 1;
+};
+
+struct mtd_pairing_scheme;
+
+struct nvmem_device;
+
+struct mtd_info {
+	u_char type;
+	uint32_t flags;
+	uint64_t size;
+	uint32_t erasesize;
+	uint32_t erasesize_minor;
+	uint32_t writesize;
+	uint32_t writebufsize;
+	uint32_t oobsize;
+	uint32_t oobavail;
+	unsigned int erasesize_shift;
+	unsigned int writesize_shift;
+	unsigned int erasesize_mask;
+	unsigned int writesize_mask;
+	unsigned int bitflip_threshold;
+	const char *name;
+	int index;
+	const struct mtd_ooblayout_ops *ooblayout;
+	const struct mtd_pairing_scheme *pairing;
+	unsigned int ecc_step_size;
+	unsigned int ecc_strength;
+	int numeraseregions;
+	struct mtd_erase_region_info *eraseregions;
+	int (*_erase)(struct mtd_info *, struct erase_info *);
+	int (*_point)(struct mtd_info *, loff_t, size_t, size_t *, void **, resource_size_t *);
+	int (*_unpoint)(struct mtd_info *, loff_t, size_t);
+	int (*_read)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+	int (*_write)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+	int (*_panic_write)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+	int (*_read_oob)(struct mtd_info *, loff_t, struct mtd_oob_ops *);
+	int (*_write_oob)(struct mtd_info *, loff_t, struct mtd_oob_ops *);
+	int (*_get_fact_prot_info)(struct mtd_info *, size_t, size_t *, struct otp_info *);
+	int (*_read_fact_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+	int (*_get_user_prot_info)(struct mtd_info *, size_t, size_t *, struct otp_info *);
+	int (*_read_user_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
+	int (*_write_user_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
+	int (*_lock_user_prot_reg)(struct mtd_info *, loff_t, size_t);
+	int (*_erase_user_prot_reg)(struct mtd_info *, loff_t, size_t);
+	int (*_writev)(struct mtd_info *, const struct kvec *, long unsigned int, loff_t, size_t *);
+	void (*_sync)(struct mtd_info *);
+	int (*_lock)(struct mtd_info *, loff_t, uint64_t);
+	int (*_unlock)(struct mtd_info *, loff_t, uint64_t);
+	int (*_is_locked)(struct mtd_info *, loff_t, uint64_t);
+	int (*_block_isreserved)(struct mtd_info *, loff_t);
+	int (*_block_isbad)(struct mtd_info *, loff_t);
+	int (*_block_markbad)(struct mtd_info *, loff_t);
+	int (*_max_bad_blocks)(struct mtd_info *, loff_t, size_t);
+	int (*_suspend)(struct mtd_info *);
+	void (*_resume)(struct mtd_info *);
+	void (*_reboot)(struct mtd_info *);
+	int (*_get_device)(struct mtd_info *);
+	void (*_put_device)(struct mtd_info *);
+	bool oops_panic_write;
+	struct notifier_block reboot_notifier;
+	struct mtd_ecc_stats ecc_stats;
+	int subpage_sft;
+	void *priv;
+	struct module *owner;
+	long: 32;
+	struct device dev;
+	struct kref refcnt;
+	struct mtd_debug_info dbg;
+	struct nvmem_device *nvmem;
+	struct nvmem_device *otp_user_nvmem;
+	struct nvmem_device *otp_factory_nvmem;
+	struct mtd_info *parent;
+	struct list_head partitions;
+	struct mtd_part part;
+	struct mtd_master master;
+	long: 32;
+};
+
+struct mtd_pairing_info {
+	int pair;
+	int group;
+};
+
+struct mtd_pairing_scheme {
+	int ngroups;
+	int (*get_info)(struct mtd_info *, int, struct mtd_pairing_info *);
+	int (*get_wunit)(struct mtd_info *, const struct mtd_pairing_info *);
+};
+
+struct jffs2_unknown_node {
+	jint16_t magic;
+	jint16_t nodetype;
+	jint32_t totlen;
+	jint32_t hdr_crc;
+};
+
+struct jffs2_raw_xattr {
+	jint16_t magic;
+	jint16_t nodetype;
+	jint32_t totlen;
+	jint32_t hdr_crc;
+	jint32_t xid;
+	jint32_t version;
+	__u8 xprefix;
+	__u8 name_len;
+	jint16_t value_len;
+	jint32_t data_crc;
+	jint32_t node_crc;
+	__u8 data[0];
+};
+
+struct jffs2_raw_xref {
+	jint16_t magic;
+	jint16_t nodetype;
+	jint32_t totlen;
+	jint32_t hdr_crc;
+	jint32_t ino;
+	jint32_t xid;
+	jint32_t xseqno;
+	jint32_t node_crc;
+};
+
+struct jffs2_raw_summary {
+	jint16_t magic;
+	jint16_t nodetype;
+	jint32_t totlen;
+	jint32_t hdr_crc;
+	jint32_t sum_num;
+	jint32_t cln_mkr;
+	jint32_t padded;
+	jint32_t sum_crc;
+	jint32_t node_crc;
+	jint32_t sum[0];
+};
+
+union jffs2_node_union {
+	struct jffs2_raw_inode i;
+	struct jffs2_raw_dirent d;
+	struct jffs2_raw_xattr x;
+	struct jffs2_raw_xref r;
+	struct jffs2_raw_summary s;
+	struct jffs2_unknown_node u;
+};
+
+struct jffs2_node_frag {
+	struct rb_node rb;
+	struct jffs2_full_dnode *node;
+	uint32_t size;
+	uint32_t ofs;
+};
+
+struct jffs2_compressor {
+	struct list_head list;
+	int priority;
+	char *name;
+	char compr;
+	int (*compress)(unsigned char *, unsigned char *, uint32_t *, uint32_t *);
+	int (*decompress)(unsigned char *, unsigned char *, uint32_t, uint32_t);
+	int usecount;
+	int disabled;
+	unsigned char *compr_buf;
+	uint32_t compr_buf_size;
+	uint32_t stat_compr_orig_size;
+	uint32_t stat_compr_new_size;
+	uint32_t stat_compr_blocks;
+	uint32_t stat_decompr_blocks;
+};
+
+typedef int SRes;
+
+typedef unsigned char Byte;
+
+typedef unsigned int UInt32;
+
+typedef long long unsigned int UInt64;
+
+typedef size_t SizeT;
+
+typedef struct {
+	SRes (*Progress)(void *, UInt64, UInt64);
+} ICompressProgress;
+
+typedef struct {
+	void * (*Alloc)(void *, size_t);
+	void (*Free)(void *, void *);
+} ISzAlloc;
+
+typedef enum {
+	LZMA_FINISH_ANY = 0,
+	LZMA_FINISH_END = 1,
+} ELzmaFinishMode;
+
+typedef enum {
+	LZMA_STATUS_NOT_SPECIFIED = 0,
+	LZMA_STATUS_FINISHED_WITH_MARK = 1,
+	LZMA_STATUS_NOT_FINISHED = 2,
+	LZMA_STATUS_NEEDS_MORE_INPUT = 3,
+	LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK = 4,
+} ELzmaStatus;
+
+struct _CLzmaEncProps {
+	int level;
+	UInt32 dictSize;
+	int lc;
+	int lp;
+	int pb;
+	int algo;
+	int fb;
+	int btMode;
+	int numHashBytes;
+	UInt32 mc;
+	unsigned int writeEndMark;
+	int numThreads;
+};
+
+typedef struct _CLzmaEncProps CLzmaEncProps;
+
+typedef void *CLzmaEncHandle;
+
+struct jffs2_sum_unknown_flash {
+	jint16_t nodetype;
+};
+
+struct jffs2_sum_inode_flash {
+	jint16_t nodetype;
+	jint32_t inode;
+	jint32_t version;
+	jint32_t offset;
+	jint32_t totlen;
+} __attribute__((packed));
+
+struct jffs2_sum_dirent_flash {
+	jint16_t nodetype;
+	jint32_t totlen;
+	jint32_t offset;
+	jint32_t pino;
+	jint32_t version;
+	jint32_t ino;
+	uint8_t nsize;
+	uint8_t type;
+	uint8_t name[0];
+} __attribute__((packed));
+
+struct jffs2_sum_xattr_flash {
+	jint16_t nodetype;
+	jint32_t xid;
+	jint32_t version;
+	jint32_t offset;
+	jint32_t totlen;
+} __attribute__((packed));
+
+struct jffs2_sum_xref_flash {
+	jint16_t nodetype;
+	jint32_t offset;
+} __attribute__((packed));
+
+struct jffs2_sum_marker {
+	jint32_t offset;
+	jint32_t magic;
+};
+
+struct ubi_volume_info {
+	int ubi_num;
+	int vol_id;
+	int size;
+	long: 32;
+	long long int used_bytes;
+	int used_ebs;
+	int vol_type;
+	int corrupted;
+	int upd_marker;
+	int alignment;
+	int usable_leb_size;
+	int name_len;
+	const char *name;
+	dev_t cdev;
+	struct device *dev;
+};
+
+struct ubi_device_info {
+	int ubi_num;
+	int leb_size;
+	int leb_start;
+	int min_io_size;
+	int max_write_size;
+	int ro_mode;
+	dev_t cdev;
+};
+
+enum hash_algo {
+	HASH_ALGO_MD4 = 0,
+	HASH_ALGO_MD5 = 1,
+	HASH_ALGO_SHA1 = 2,
+	HASH_ALGO_RIPE_MD_160 = 3,
+	HASH_ALGO_SHA256 = 4,
+	HASH_ALGO_SHA384 = 5,
+	HASH_ALGO_SHA512 = 6,
+	HASH_ALGO_SHA224 = 7,
+	HASH_ALGO_RIPE_MD_128 = 8,
+	HASH_ALGO_RIPE_MD_256 = 9,
+	HASH_ALGO_RIPE_MD_320 = 10,
+	HASH_ALGO_WP_256 = 11,
+	HASH_ALGO_WP_384 = 12,
+	HASH_ALGO_WP_512 = 13,
+	HASH_ALGO_TGR_128 = 14,
+	HASH_ALGO_TGR_160 = 15,
+	HASH_ALGO_TGR_192 = 16,
+	HASH_ALGO_SM3_256 = 17,
+	HASH_ALGO_STREEBOG_256 = 18,
+	HASH_ALGO_STREEBOG_512 = 19,
+	HASH_ALGO_SHA3_256 = 20,
+	HASH_ALGO_SHA3_384 = 21,
+	HASH_ALGO_SHA3_512 = 22,
+	HASH_ALGO__LAST = 23,
+};
+
+struct crypto_alg;
+
+struct crypto_tfm {
+	refcount_t refcnt;
+	u32 crt_flags;
+	int node;
+	void (*exit)(struct crypto_tfm *);
+	struct crypto_alg *__crt_alg;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	void *__crt_ctx[0];
+};
+
+struct cipher_alg {
+	unsigned int cia_min_keysize;
+	unsigned int cia_max_keysize;
+	int (*cia_setkey)(struct crypto_tfm *, const u8 *, unsigned int);
+	void (*cia_encrypt)(struct crypto_tfm *, u8 *, const u8 *);
+	void (*cia_decrypt)(struct crypto_tfm *, u8 *, const u8 *);
+};
+
+struct compress_alg {
+	int (*coa_compress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
+	int (*coa_decompress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
+};
+
+struct crypto_type;
+
+struct crypto_alg {
+	struct list_head cra_list;
+	struct list_head cra_users;
+	u32 cra_flags;
+	unsigned int cra_blocksize;
+	unsigned int cra_ctxsize;
+	unsigned int cra_alignmask;
+	int cra_priority;
+	refcount_t cra_refcnt;
+	char cra_name[128];
+	char cra_driver_name[128];
+	const struct crypto_type *cra_type;
+	union {
+		struct cipher_alg cipher;
+		struct compress_alg compress;
+	} cra_u;
+	int (*cra_init)(struct crypto_tfm *);
+	void (*cra_exit)(struct crypto_tfm *);
+	void (*cra_destroy)(struct crypto_alg *);
+	struct module *cra_module;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct crypto_instance;
+
+struct crypto_type {
+	unsigned int (*ctxsize)(struct crypto_alg *, u32, u32);
+	unsigned int (*extsize)(struct crypto_alg *);
+	int (*init_tfm)(struct crypto_tfm *);
+	void (*show)(struct seq_file *, struct crypto_alg *);
+	int (*report)(struct sk_buff *, struct crypto_alg *);
+	void (*free)(struct crypto_instance *);
+	unsigned int type;
+	unsigned int maskclear;
+	unsigned int maskset;
+	unsigned int tfmsize;
+};
+
+struct crypto_shash;
+
+struct shash_desc {
+	struct crypto_shash *tfm;
+	long: 32;
+	void *__ctx[0];
+};
+
+struct crypto_shash {
+	unsigned int descsize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_tfm base;
+};
+
+struct fscrypt_str {
+	unsigned char *name;
+	u32 len;
+};
+
+struct fscrypt_name {
+	const struct qstr *usr_fname;
+	struct fscrypt_str disk_name;
+	u32 hash;
+	u32 minor_hash;
+	struct fscrypt_str crypto_buf;
+	bool is_nokey_name;
+};
+
+enum {
+	UBIFS_ITYPE_REG = 0,
+	UBIFS_ITYPE_DIR = 1,
+	UBIFS_ITYPE_LNK = 2,
+	UBIFS_ITYPE_BLK = 3,
+	UBIFS_ITYPE_CHR = 4,
+	UBIFS_ITYPE_FIFO = 5,
+	UBIFS_ITYPE_SOCK = 6,
+	UBIFS_ITYPES_CNT = 7,
+};
+
+enum {
+	UBIFS_INO_KEY = 0,
+	UBIFS_DATA_KEY = 1,
+	UBIFS_DENT_KEY = 2,
+	UBIFS_XENT_KEY = 3,
+	UBIFS_KEY_TYPES_CNT = 4,
+};
+
+enum {
+	UBIFS_COMPR_FL = 1,
+	UBIFS_SYNC_FL = 2,
+	UBIFS_IMMUTABLE_FL = 4,
+	UBIFS_APPEND_FL = 8,
+	UBIFS_DIRSYNC_FL = 16,
+	UBIFS_XATTR_FL = 32,
+	UBIFS_CRYPT_FL = 64,
+};
+
+enum {
+	UBIFS_COMPR_NONE = 0,
+	UBIFS_COMPR_LZO = 1,
+	UBIFS_COMPR_ZLIB = 2,
+	UBIFS_COMPR_ZSTD = 3,
+	UBIFS_COMPR_TYPES_CNT = 4,
+};
+
+enum {
+	UBIFS_INO_NODE = 0,
+	UBIFS_DATA_NODE = 1,
+	UBIFS_DENT_NODE = 2,
+	UBIFS_XENT_NODE = 3,
+	UBIFS_TRUN_NODE = 4,
+	UBIFS_PAD_NODE = 5,
+	UBIFS_SB_NODE = 6,
+	UBIFS_MST_NODE = 7,
+	UBIFS_REF_NODE = 8,
+	UBIFS_IDX_NODE = 9,
+	UBIFS_CS_NODE = 10,
+	UBIFS_ORPH_NODE = 11,
+	UBIFS_AUTH_NODE = 12,
+	UBIFS_SIG_NODE = 13,
+	UBIFS_NODE_TYPES_CNT = 14,
+};
+
+struct ubifs_ch {
+	__le32 magic;
+	__le32 crc;
+	__le64 sqnum;
+	__le32 len;
+	__u8 node_type;
+	__u8 group_type;
+	__u8 padding[2];
+};
+
+union ubifs_dev_desc {
+	__le32 new;
+	__le64 huge;
+};
+
+struct ubifs_dent_node {
+	struct ubifs_ch ch;
+	__u8 key[16];
+	__le64 inum;
+	__u8 padding1;
+	__u8 type;
+	__le16 nlen;
+	__le32 cookie;
+	__u8 name[0];
+};
+
+struct ubifs_sb_node {
+	struct ubifs_ch ch;
+	__u8 padding[2];
+	__u8 key_hash;
+	__u8 key_fmt;
+	__le32 flags;
+	__le32 min_io_size;
+	__le32 leb_size;
+	__le32 leb_cnt;
+	__le32 max_leb_cnt;
+	__le64 max_bud_bytes;
+	__le32 log_lebs;
+	__le32 lpt_lebs;
+	__le32 orph_lebs;
+	__le32 jhead_cnt;
+	__le32 fanout;
+	__le32 lsave_cnt;
+	__le32 fmt_version;
+	__le16 default_compr;
+	__u8 padding1[2];
+	__le32 rp_uid;
+	__le32 rp_gid;
+	__le64 rp_size;
+	__le32 time_gran;
+	__u8 uuid[16];
+	__le32 ro_compat_version;
+	__u8 hmac[64];
+	__u8 hmac_wkm[64];
+	__le16 hash_algo;
+	__u8 hash_mst[64];
+	__u8 padding2[3774];
+};
+
+struct ubifs_mst_node {
+	struct ubifs_ch ch;
+	__le64 highest_inum;
+	__le64 cmt_no;
+	__le32 flags;
+	__le32 log_lnum;
+	__le32 root_lnum;
+	__le32 root_offs;
+	__le32 root_len;
+	__le32 gc_lnum;
+	__le32 ihead_lnum;
+	__le32 ihead_offs;
+	__le64 index_size;
+	__le64 total_free;
+	__le64 total_dirty;
+	__le64 total_used;
+	__le64 total_dead;
+	__le64 total_dark;
+	__le32 lpt_lnum;
+	__le32 lpt_offs;
+	__le32 nhead_lnum;
+	__le32 nhead_offs;
+	__le32 ltab_lnum;
+	__le32 ltab_offs;
+	__le32 lsave_lnum;
+	__le32 lsave_offs;
+	__le32 lscan_lnum;
+	__le32 empty_lebs;
+	__le32 idx_lebs;
+	__le32 leb_cnt;
+	__u8 hash_root_idx[64];
+	__u8 hash_lpt[64];
+	__u8 hmac[64];
+	__u8 padding[152];
+};
+
+union ubifs_key {
+	uint8_t u8[8];
+	uint32_t u32[2];
+	uint64_t u64[1];
+	__le32 j32[2];
+};
+
+struct ubifs_inode {
+	struct inode vfs_inode;
+	long long unsigned int creat_sqnum;
+	long long unsigned int del_cmtno;
+	unsigned int xattr_size;
+	unsigned int xattr_cnt;
+	unsigned int xattr_names;
+	unsigned int dirty: 1;
+	unsigned int xattr: 1;
+	unsigned int bulk_read: 1;
+	unsigned int compr_type: 2;
+	struct mutex ui_mutex;
+	struct rw_semaphore xattr_sem;
+	spinlock_t ui_lock;
+	loff_t synced_i_size;
+	loff_t ui_size;
+	int flags;
+	long unsigned int last_page_read;
+	long unsigned int read_in_a_row;
+	int data_len;
+	void *data;
+	long: 32;
+};
+
+enum {
+	LPROPS_UNCAT = 0,
+	LPROPS_DIRTY = 1,
+	LPROPS_DIRTY_IDX = 2,
+	LPROPS_FREE = 3,
+	LPROPS_HEAP_CNT = 3,
+	LPROPS_EMPTY = 4,
+	LPROPS_FREEABLE = 5,
+	LPROPS_FRDI_IDX = 6,
+	LPROPS_CAT_MASK = 15,
+	LPROPS_TAKEN = 16,
+	LPROPS_INDEX = 32,
+};
+
+struct ubifs_lprops {
+	int free;
+	int dirty;
+	int flags;
+	int lnum;
+	union {
+		struct list_head list;
+		int hpos;
+	};
+};
+
+struct ubifs_lpt_lprops {
+	int free;
+	int dirty;
+	unsigned int tgc: 1;
+	unsigned int cmt: 1;
+};
+
+struct ubifs_lp_stats {
+	int empty_lebs;
+	int taken_empty_lebs;
+	int idx_lebs;
+	long: 32;
+	long long int total_free;
+	long long int total_dirty;
+	long long int total_used;
+	long long int total_dead;
+	long long int total_dark;
+};
+
+struct ubifs_nnode;
+
+struct ubifs_cnode {
+	struct ubifs_nnode *parent;
+	struct ubifs_cnode *cnext;
+	long unsigned int flags;
+	int iip;
+	int level;
+	int num;
+};
+
+struct ubifs_pnode;
+
+struct ubifs_nbranch {
+	int lnum;
+	int offs;
+	union {
+		struct ubifs_nnode *nnode;
+		struct ubifs_pnode *pnode;
+		struct ubifs_cnode *cnode;
+	};
+};
+
+struct ubifs_nnode {
+	struct ubifs_nnode *parent;
+	struct ubifs_cnode *cnext;
+	long unsigned int flags;
+	int iip;
+	int level;
+	int num;
+	struct ubifs_nbranch nbranch[4];
+};
+
+struct ubifs_pnode {
+	struct ubifs_nnode *parent;
+	struct ubifs_cnode *cnext;
+	long unsigned int flags;
+	int iip;
+	int level;
+	int num;
+	struct ubifs_lprops lprops[4];
+};
+
+struct ubifs_lpt_heap {
+	struct ubifs_lprops **arr;
+	int cnt;
+	int max_cnt;
+};
+
+struct ubifs_znode;
+
+struct ubifs_zbranch {
+	union ubifs_key key;
+	union {
+		struct ubifs_znode *znode;
+		void *leaf;
+	};
+	int lnum;
+	int offs;
+	int len;
+	u8 hash[0];
+};
+
+struct bu_info {
+	union ubifs_key key;
+	struct ubifs_zbranch zbranch[32];
+	void *buf;
+	int buf_len;
+	int gc_seq;
+	int cnt;
+	int blk_cnt;
+	int eof;
+};
+
+struct ubifs_budg_info {
+	long long int idx_growth;
+	long long int data_growth;
+	long long int dd_growth;
+	long long int uncommitted_idx;
+	long long unsigned int old_idx_sz;
+	int min_idx_lebs;
+	unsigned int nospace: 1;
+	unsigned int nospace_rp: 1;
+	int page_budget;
+	int inode_budget;
+	int dent_budget;
+	long: 32;
+};
+
+struct ubifs_node_range {
+	union {
+		int len;
+		int min_len;
+	};
+	int max_len;
+};
+
+struct ubifs_mount_opts {
+	unsigned int unmount_mode: 2;
+	unsigned int bulk_read: 2;
+	unsigned int chk_data_crc: 2;
+	unsigned int override_compr: 1;
+	unsigned int compr_type: 2;
+};
+
+struct ubifs_jhead;
+
+struct ubi_volume_desc;
+
+struct ubifs_orphan;
+
+struct ubifs_debug_info;
+
+struct ubifs_stats_info;
+
+struct ubifs_info {
+	struct super_block *vfs_sb;
+	struct ubifs_sb_node *sup_node;
+	ino_t highest_inum;
+	long: 32;
+	long long unsigned int max_sqnum;
+	long long unsigned int cmt_no;
+	spinlock_t cnt_lock;
+	int fmt_version;
+	int ro_compat_version;
+	unsigned char uuid[16];
+	int lhead_lnum;
+	int lhead_offs;
+	int ltail_lnum;
+	struct mutex log_mutex;
+	int min_log_bytes;
+	long long int cmt_bud_bytes;
+	struct rb_root buds;
+	long: 32;
+	long long int bud_bytes;
+	spinlock_t buds_lock;
+	int jhead_cnt;
+	struct ubifs_jhead *jheads;
+	long: 32;
+	long long int max_bud_bytes;
+	long long int bg_bud_bytes;
+	struct list_head old_buds;
+	int max_bud_cnt;
+	atomic_t need_wait_space;
+	wait_queue_head_t reserve_space_wq;
+	struct rw_semaphore commit_sem;
+	int cmt_state;
+	spinlock_t cs_lock;
+	wait_queue_head_t cmt_wq;
+	struct kobject kobj;
+	struct completion kobj_unregister;
+	unsigned int big_lpt: 1;
+	unsigned int space_fixup: 1;
+	unsigned int double_hash: 1;
+	unsigned int encrypted: 1;
+	unsigned int no_chk_data_crc: 1;
+	unsigned int bulk_read: 1;
+	unsigned int default_compr: 2;
+	unsigned int rw_incompat: 1;
+	unsigned int assert_action: 2;
+	unsigned int authenticated: 1;
+	unsigned int superblock_need_write: 1;
+	struct mutex tnc_mutex;
+	long: 32;
+	struct ubifs_zbranch zroot;
+	struct ubifs_znode *cnext;
+	struct ubifs_znode *enext;
+	int *gap_lebs;
+	void *cbuf;
+	void *ileb_buf;
+	int ileb_len;
+	int ihead_lnum;
+	int ihead_offs;
+	int *ilebs;
+	int ileb_cnt;
+	int ileb_nxt;
+	struct rb_root old_idx;
+	int *bottom_up_buf;
+	struct ubifs_mst_node *mst_node;
+	int mst_offs;
+	int max_bu_buf_len;
+	struct mutex bu_mutex;
+	long: 32;
+	struct bu_info bu;
+	struct mutex write_reserve_mutex;
+	void *write_reserve_buf;
+	int log_lebs;
+	long: 32;
+	long long int log_bytes;
+	int log_last;
+	int lpt_lebs;
+	int lpt_first;
+	int lpt_last;
+	int orph_lebs;
+	int orph_first;
+	int orph_last;
+	int main_lebs;
+	int main_first;
+	long: 32;
+	long long int main_bytes;
+	uint8_t key_hash_type;
+	uint32_t (*key_hash)(const char *, int);
+	int key_fmt;
+	int key_len;
+	int hash_len;
+	int fanout;
+	int min_io_size;
+	int min_io_shift;
+	int max_write_size;
+	int max_write_shift;
+	int leb_size;
+	int leb_start;
+	int half_leb_size;
+	int idx_leb_size;
+	int leb_cnt;
+	int max_leb_cnt;
+	unsigned int ro_media: 1;
+	unsigned int ro_mount: 1;
+	unsigned int ro_error: 1;
+	atomic_long_t dirty_pg_cnt;
+	atomic_long_t dirty_zn_cnt;
+	atomic_long_t clean_zn_cnt;
+	spinlock_t space_lock;
+	long: 32;
+	struct ubifs_lp_stats lst;
+	struct ubifs_budg_info bi;
+	long long unsigned int calc_idx_sz;
+	int ref_node_alsz;
+	int mst_node_alsz;
+	int min_idx_node_sz;
+	int max_idx_node_sz;
+	long long int max_inode_sz;
+	int max_znode_sz;
+	int leb_overhead;
+	int dead_wm;
+	int dark_wm;
+	int block_cnt;
+	struct ubifs_node_range ranges[14];
+	struct ubi_volume_desc *ubi;
+	struct ubi_device_info di;
+	long: 32;
+	struct ubi_volume_info vi;
+	struct rb_root orph_tree;
+	struct list_head orph_list;
+	struct list_head orph_new;
+	struct ubifs_orphan *orph_cnext;
+	struct ubifs_orphan *orph_dnext;
+	spinlock_t orphan_lock;
+	void *orph_buf;
+	int new_orphans;
+	int cmt_orphans;
+	int tot_orphans;
+	int max_orphans;
+	int ohead_lnum;
+	int ohead_offs;
+	int no_orphs;
+	struct task_struct *bgt;
+	char bgt_name[24];
+	int need_bgt;
+	int need_wbuf_sync;
+	int gc_lnum;
+	void *sbuf;
+	struct list_head idx_gc;
+	int idx_gc_cnt;
+	int gc_seq;
+	int gced_lnum;
+	struct list_head infos_list;
+	struct mutex umount_mutex;
+	unsigned int shrinker_run_no;
+	int space_bits;
+	int lpt_lnum_bits;
+	int lpt_offs_bits;
+	int lpt_spc_bits;
+	int pcnt_bits;
+	int lnum_bits;
+	int nnode_sz;
+	int pnode_sz;
+	int ltab_sz;
+	int lsave_sz;
+	int pnode_cnt;
+	int nnode_cnt;
+	int lpt_hght;
+	int pnodes_have;
+	struct mutex lp_mutex;
+	int lpt_lnum;
+	int lpt_offs;
+	int nhead_lnum;
+	int nhead_offs;
+	int lpt_drty_flgs;
+	int dirty_nn_cnt;
+	int dirty_pn_cnt;
+	int check_lpt_free;
+	long: 32;
+	long long int lpt_sz;
+	void *lpt_nod_buf;
+	void *lpt_buf;
+	struct ubifs_nnode *nroot;
+	struct ubifs_cnode *lpt_cnext;
+	struct ubifs_lpt_heap lpt_heap[3];
+	struct ubifs_lpt_heap dirty_idx;
+	struct list_head uncat_list;
+	struct list_head empty_list;
+	struct list_head freeable_list;
+	struct list_head frdi_idx_list;
+	int freeable_cnt;
+	int in_a_category_cnt;
+	int ltab_lnum;
+	int ltab_offs;
+	struct ubifs_lpt_lprops *ltab;
+	struct ubifs_lpt_lprops *ltab_cmt;
+	int lsave_cnt;
+	int lsave_lnum;
+	int lsave_offs;
+	int *lsave;
+	int lscan_lnum;
+	long: 32;
+	long long int rp_size;
+	long long int report_rp_size;
+	kuid_t rp_uid;
+	kgid_t rp_gid;
+	struct crypto_shash *hash_tfm;
+	struct crypto_shash *hmac_tfm;
+	int hmac_desc_len;
+	char *auth_key_name;
+	char *auth_hash_name;
+	enum hash_algo auth_hash_algo;
+	struct shash_desc *log_hash;
+	unsigned int empty: 1;
+	unsigned int need_recovery: 1;
+	unsigned int replaying: 1;
+	unsigned int mounting: 1;
+	unsigned int remounting_rw: 1;
+	unsigned int probing: 1;
+	struct list_head replay_list;
+	struct list_head replay_buds;
+	long long unsigned int cs_sqnum;
+	struct list_head unclean_leb_list;
+	struct ubifs_mst_node *rcvrd_mst_node;
+	struct rb_root size_tree;
+	struct ubifs_mount_opts mount_opts;
+	struct ubifs_debug_info *dbg;
+	struct ubifs_stats_info *stats;
+	long: 32;
+};
+
+struct ubifs_wbuf {
+	struct ubifs_info *c;
+	void *buf;
+	int lnum;
+	int offs;
+	int avail;
+	int used;
+	int size;
+	int jhead;
+	int (*sync_callback)(struct ubifs_info *, int, int, int);
+	struct mutex io_mutex;
+	spinlock_t lock;
+	long: 32;
+	struct hrtimer timer;
+	unsigned int no_timer: 1;
+	unsigned int need_sync: 1;
+	int next_ino;
+	ino_t *inodes;
+	long: 32;
+};
+
+struct ubifs_jhead {
+	struct ubifs_wbuf wbuf;
+	struct list_head buds_list;
+	unsigned int grouped: 1;
+	struct shash_desc *log_hash;
+};
+
+struct ubifs_znode {
+	struct ubifs_znode *parent;
+	struct ubifs_znode *cnext;
+	struct ubifs_znode *cparent;
+	int ciip;
+	long unsigned int flags;
+	long: 32;
+	time64_t time;
+	int level;
+	int child_cnt;
+	int iip;
+	int alt;
+	int lnum;
+	int offs;
+	int len;
+	long: 32;
+	struct ubifs_zbranch zbranch[0];
+};
+
+struct ubifs_budget_req {
+	unsigned int fast: 1;
+	unsigned int recalculate: 1;
+	unsigned int new_page: 1;
+	unsigned int dirtied_page: 1;
+	unsigned int new_dent: 1;
+	unsigned int mod_dent: 1;
+	unsigned int new_ino: 1;
+	unsigned int new_ino_d: 13;
+	unsigned int dirtied_ino: 4;
+	long: 8;
+	unsigned int dirtied_ino_d: 15;
+	int idx_growth;
+	int data_growth;
+	int dd_growth;
+};
+
+struct ubifs_orphan {
+	struct rb_node rb;
+	struct list_head list;
+	struct list_head new_list;
+	struct ubifs_orphan *cnext;
+	struct ubifs_orphan *dnext;
+	ino_t inum;
+	unsigned int new: 1;
+	unsigned int cmt: 1;
+	unsigned int del: 1;
+};
+
+struct ubifs_stats_info {
+	unsigned int magic_errors;
+	unsigned int node_errors;
+	unsigned int crc_errors;
+};
+
+struct ubifs_debug_info {
+	struct ubifs_zbranch old_zroot;
+	int old_zroot_level;
+	long: 32;
+	long long unsigned int old_zroot_sqnum;
+	int pc_happened;
+	int pc_delay;
+	long unsigned int pc_timeout;
+	unsigned int pc_cnt;
+	unsigned int pc_cnt_max;
+	long: 32;
+	long long int chk_lpt_sz;
+	long long int chk_lpt_sz2;
+	long long int chk_lpt_wastage;
+	int chk_lpt_lebs;
+	int new_nhead_offs;
+	int new_ihead_lnum;
+	int new_ihead_offs;
+	struct ubifs_lp_stats saved_lst;
+	struct ubifs_budg_info saved_bi;
+	long long int saved_free;
+	int saved_idx_gc_cnt;
+	unsigned int chk_gen: 1;
+	unsigned int chk_index: 1;
+	unsigned int chk_orph: 1;
+	unsigned int chk_lprops: 1;
+	unsigned int chk_fs: 1;
+	unsigned int tst_rcvry: 1;
+	char dfs_dir_name[10];
+	struct dentry *dfs_dir;
+	struct dentry *dfs_dump_lprops;
+	struct dentry *dfs_dump_budg;
+	struct dentry *dfs_dump_tnc;
+	struct dentry *dfs_chk_gen;
+	struct dentry *dfs_chk_index;
+	struct dentry *dfs_chk_orph;
+	struct dentry *dfs_chk_lprops;
+	struct dentry *dfs_chk_fs;
+	struct dentry *dfs_tst_rcvry;
+	struct dentry *dfs_ro_error;
+	long: 32;
+};
+
+struct ubifs_global_debug_info {
+	unsigned int chk_gen: 1;
+	unsigned int chk_index: 1;
+	unsigned int chk_orph: 1;
+	unsigned int chk_lprops: 1;
+	unsigned int chk_fs: 1;
+	unsigned int tst_rcvry: 1;
+};
+
+struct ubifs_dir_data {
+	struct ubifs_dent_node *dent;
+	long: 32;
+	u64 cookie;
+};
+
+enum {
+	DIRTY_ZNODE = 0,
+	COW_ZNODE = 1,
+	OBSOLETE_ZNODE = 2,
+};
+
+enum {
+	COMMIT_RESTING = 0,
+	COMMIT_BACKGROUND = 1,
+	COMMIT_REQUIRED = 2,
+	COMMIT_RUNNING_BACKGROUND = 3,
+	COMMIT_RUNNING_REQUIRED = 4,
+	COMMIT_BROKEN = 5,
+};
+
+struct ubifs_old_idx {
+	struct rb_node rb;
+	int lnum;
+	int offs;
+};
+
+enum {
+	NAME_LESS = 0,
+	NAME_MATCHES = 1,
+	NAME_GREATER = 2,
+	NOT_ON_MEDIA = 3,
+};
+
+struct hash_alg_common {
+	unsigned int digestsize;
+	unsigned int statesize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_alg base;
+};
+
+struct shash_alg {
+	int (*init)(struct shash_desc *);
+	int (*update)(struct shash_desc *, const u8 *, unsigned int);
+	int (*final)(struct shash_desc *, u8 *);
+	int (*finup)(struct shash_desc *, const u8 *, unsigned int, u8 *);
+	int (*digest)(struct shash_desc *, const u8 *, unsigned int, u8 *);
+	int (*export)(struct shash_desc *, void *);
+	int (*import)(struct shash_desc *, const void *);
+	int (*setkey)(struct crypto_shash *, const u8 *, unsigned int);
+	int (*init_tfm)(struct crypto_shash *);
+	void (*exit_tfm)(struct crypto_shash *);
+	int (*clone_tfm)(struct crypto_shash *, struct crypto_shash *);
+	unsigned int descsize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct {
+			unsigned int digestsize;
+			unsigned int statesize;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			struct crypto_alg base;
+		};
+		struct hash_alg_common halg;
+	};
+};
+
+struct ubifs_ref_node {
+	struct ubifs_ch ch;
+	__le32 lnum;
+	__le32 offs;
+	__le32 jhead;
+	__u8 padding[28];
+};
+
+struct ubifs_cs_node {
+	struct ubifs_ch ch;
+	__le64 cmt_no;
+};
+
+struct ubifs_scan_node {
+	struct list_head list;
+	union ubifs_key key;
+	long long unsigned int sqnum;
+	int type;
+	int offs;
+	int len;
+	void *node;
+};
+
+struct ubifs_scan_leb {
+	int lnum;
+	int nodes_cnt;
+	struct list_head nodes;
+	int endpt;
+	void *buf;
+};
+
+struct ubifs_bud {
+	int lnum;
+	int start;
+	int jhead;
+	struct list_head list;
+	struct rb_node rb;
+	struct shash_desc *log_hash;
+};
+
+struct done_ref {
+	struct rb_node rb;
+	int lnum;
+};
+
+enum {
+	UBIFS_LPT_PNODE = 0,
+	UBIFS_LPT_NNODE = 1,
+	UBIFS_LPT_LTAB = 2,
+	UBIFS_LPT_LSAVE = 3,
+	UBIFS_LPT_NODE_CNT = 4,
+	UBIFS_LPT_NOT_A_NODE = 15,
+};
+
+enum {
+	DIRTY_CNODE = 0,
+	OBSOLETE_CNODE = 1,
+	COW_CNODE = 2,
+};
+
+enum {
+	LTAB_DIRTY = 1,
+	LSAVE_DIRTY = 2,
+};
+
+enum {
+	LPT_SCAN_CONTINUE = 0,
+	LPT_SCAN_ADD = 1,
+	LPT_SCAN_STOP = 2,
+};
+
+typedef int (*ubifs_lpt_scan_callback)(struct ubifs_info *, const struct ubifs_lprops *, int, void *);
+
+struct lpt_scan_node {
+	union {
+		struct ubifs_nnode nnode;
+		struct ubifs_pnode pnode;
+		struct ubifs_cnode cnode;
+	};
+	int in_tree;
+	union {
+		struct ubifs_nnode *nnode;
+		struct ubifs_pnode *pnode;
+		struct ubifs_cnode *cnode;
+	} ptr;
+};
+
+struct ubifs_branch {
+	__le32 lnum;
+	__le32 offs;
+	__le32 len;
+	__u8 key[0];
+};
+
+struct ubifs_idx_node {
+	struct ubifs_ch ch;
+	__le16 child_cnt;
+	__le16 level;
+	__u8 branches[0];
+};
+
+enum attr_id_t {
+	attr_errors_magic = 0,
+	attr_errors_node = 1,
+	attr_errors_crc = 2,
+};
+
+struct ubifs_attr {
+	struct attribute attr;
+	enum attr_id_t attr_id;
+};
+
+enum inode_i_mutex_lock_class {
+	I_MUTEX_NORMAL = 0,
+	I_MUTEX_PARENT = 1,
+	I_MUTEX_CHILD = 2,
+	I_MUTEX_XATTR = 3,
+	I_MUTEX_NONDIR2 = 4,
+	I_MUTEX_PARENT2 = 5,
+};
+
+struct fileattr {
+	u32 flags;
+	u32 fsx_xflags;
+	u32 fsx_extsize;
+	u32 fsx_nextents;
+	u32 fsx_projid;
+	u32 fsx_cowextsize;
+	bool flags_valid: 1;
+	bool fsx_valid: 1;
+};
+
+struct ovl_config {
+	char *upperdir;
+	char *workdir;
+	char **lowerdirs;
+	bool default_permissions;
+	int redirect_mode;
+	int verity_mode;
+	bool index;
+	int uuid;
+	bool nfs_export;
+	int xino;
+	bool metacopy;
+	bool userxattr;
+	bool ovl_volatile;
+};
+
+struct ovl_sb {
+	struct super_block *sb;
+	dev_t pseudo_dev;
+	bool bad_uuid;
+	bool is_lower;
+};
+
+struct ovl_layer {
+	struct vfsmount *mnt;
+	struct inode *trap;
+	struct ovl_sb *fs;
+	int idx;
+	int fsid;
+	bool has_xwhiteouts;
+};
+
+struct ovl_path {
+	const struct ovl_layer *layer;
+	struct dentry *dentry;
+};
+
+struct ovl_entry {
+	unsigned int __numlower;
+	struct ovl_path __lowerstack[0];
+};
+
+struct ovl_fs {
+	unsigned int numlayer;
+	unsigned int numfs;
+	unsigned int numdatalayer;
+	struct ovl_layer *layers;
+	struct ovl_sb *fs;
+	struct dentry *workbasedir;
+	struct dentry *workdir;
+	long int namelen;
+	struct ovl_config config;
+	const struct cred *creator_cred;
+	bool tmpfile;
+	bool noxattr;
+	bool nofh;
+	bool upperdir_locked;
+	bool workdir_locked;
+	struct inode *workbasedir_trap;
+	struct inode *workdir_trap;
+	int xino_mode;
+	atomic_long_t last_ino;
+	struct dentry *whiteout;
+	bool no_shared_whiteout;
+	errseq_t errseq;
+};
+
+struct ovl_dir_cache;
+
+struct ovl_inode {
+	union {
+		struct ovl_dir_cache *cache;
+		const char *lowerdata_redirect;
+	};
+	const char *redirect;
+	u64 version;
+	long unsigned int flags;
+	long: 32;
+	struct inode vfs_inode;
+	struct dentry *__upperdentry;
+	struct ovl_entry *oe;
+	struct mutex lock;
+	long: 32;
+};
+
+enum ovl_path_type {
+	__OVL_PATH_UPPER = 1,
+	__OVL_PATH_MERGE = 2,
+	__OVL_PATH_ORIGIN = 4,
+};
+
+enum ovl_xattr {
+	OVL_XATTR_OPAQUE = 0,
+	OVL_XATTR_REDIRECT = 1,
+	OVL_XATTR_ORIGIN = 2,
+	OVL_XATTR_IMPURE = 3,
+	OVL_XATTR_NLINK = 4,
+	OVL_XATTR_UPPER = 5,
+	OVL_XATTR_UUID = 6,
+	OVL_XATTR_METACOPY = 7,
+	OVL_XATTR_PROTATTR = 8,
+	OVL_XATTR_XWHITEOUT = 9,
+};
+
+enum ovl_inode_flag {
+	OVL_IMPURE = 0,
+	OVL_WHITEOUTS = 1,
+	OVL_INDEX = 2,
+	OVL_UPPERDATA = 3,
+	OVL_CONST_INO = 4,
+	OVL_HAS_DIGEST = 5,
+	OVL_VERIFIED_DIGEST = 6,
+};
+
+enum ovl_entry_flag {
+	OVL_E_UPPER_ALIAS = 0,
+	OVL_E_OPAQUE = 1,
+	OVL_E_CONNECTED = 2,
+	OVL_E_XWHITEOUTS = 3,
+};
+
+enum {
+	OVL_UUID_OFF = 0,
+	OVL_UUID_NULL = 1,
+	OVL_UUID_AUTO = 2,
+	OVL_UUID_ON = 3,
+};
+
+enum {
+	OVL_VERITY_OFF = 0,
+	OVL_VERITY_ON = 1,
+	OVL_VERITY_REQUIRE = 2,
+};
+
+struct ovl_metacopy {
+	u8 version;
+	u8 len;
+	u8 flags;
+	u8 digest_algo;
+	u8 digest[64];
+};
+
+struct fsverity_info;
+
+struct ovl_dir_cache {
+	long int refcount;
+	long: 32;
+	u64 version;
+	struct list_head entries;
+	struct rb_root root;
+	long: 32;
+};
+
+enum {
+	OVL_XINO_OFF = 0,
+	OVL_XINO_AUTO = 1,
+	OVL_XINO_ON = 2,
+};
+
+struct ovl_cache_entry {
+	unsigned int len;
+	unsigned int type;
+	u64 real_ino;
+	u64 ino;
+	struct list_head l_node;
+	struct rb_node node;
+	struct ovl_cache_entry *next_maybe_whiteout;
+	bool is_upper;
+	bool is_whiteout;
+	bool check_xwhiteout;
+	char name[0];
+	long: 32;
+};
+
+struct ovl_readdir_data {
+	struct dir_context ctx;
+	struct dentry *dentry;
+	bool is_lowest;
+	struct rb_root *root;
+	struct list_head *list;
+	struct list_head middle;
+	struct ovl_cache_entry *first_maybe_whiteout;
+	int count;
+	int err;
+	bool is_upper;
+	bool d_type_supported;
+	bool in_xwhiteouts_dir;
+};
+
+struct ovl_dir_file {
+	bool is_real;
+	bool is_upper;
+	struct ovl_dir_cache *cache;
+	struct list_head *cursor;
+	struct file *realfile;
+	struct file *upperfile;
+};
+
+struct ovl_readdir_translate {
+	struct dir_context *orig_ctx;
+	struct ovl_dir_cache *cache;
+	struct dir_context ctx;
+	u64 parent_ino;
+	int fsid;
+	int xinobits;
+	bool xinowarn;
+	long: 32;
+};
+
+struct tree_descr {
+	const char *name;
+	const struct file_operations *ops;
+	int mode;
+};
+
+typedef struct vfsmount * (*debugfs_automount_t)(struct dentry *, void *);
+
+struct debugfs_cancellation {
+	struct list_head list;
+	void (*cancel)(struct dentry *, void *);
+	void *cancel_data;
+};
+
+struct debugfs_fsdata {
+	const struct file_operations *real_fops;
+	union {
+		debugfs_automount_t automount;
+		struct {
+			refcount_t active_users;
+			struct completion active_users_drained;
+			struct mutex cancellations_mtx;
+			struct list_head cancellations;
+		};
+	};
+};
+
+struct debugfs_fs_info {
+	kuid_t uid;
+	kgid_t gid;
+	umode_t mode;
+	unsigned int opts;
+};
+
+enum {
+	Opt_uid = 0,
+	Opt_gid = 1,
+	Opt_mode = 2,
+	Opt_source = 3,
+};
+
+typedef int __kernel_key_t;
+
+typedef short unsigned int __kernel_mode_t;
+
+typedef __kernel_key_t key_t;
+
+typedef struct {} local_lock_t;
+
+struct radix_tree_preload {
+	local_lock_t lock;
+	unsigned int nr;
+	struct xa_node *nodes;
+};
+
+struct ipc_perm {
+	__kernel_key_t key;
+	__kernel_uid_t uid;
+	__kernel_gid_t gid;
+	__kernel_uid_t cuid;
+	__kernel_gid_t cgid;
+	__kernel_mode_t mode;
+	short unsigned int seq;
+};
+
+struct ipc64_perm {
+	__kernel_key_t key;
+	__kernel_uid32_t uid;
+	__kernel_gid32_t gid;
+	__kernel_uid32_t cuid;
+	__kernel_gid32_t cgid;
+	__kernel_mode_t mode;
+	unsigned char __pad1[2];
+	short unsigned int seq;
+	short unsigned int __pad2;
+	__kernel_ulong_t __unused1;
+	__kernel_ulong_t __unused2;
+};
+
+struct kern_ipc_perm {
+	spinlock_t lock;
+	bool deleted;
+	int id;
+	key_t key;
+	kuid_t uid;
+	kgid_t gid;
+	kuid_t cuid;
+	kgid_t cgid;
+	umode_t mode;
+	long unsigned int seq;
+	void *security;
+	struct rhash_head khtnode;
+	struct callback_head rcu;
+	refcount_t refcount;
+	long: 32;
+};
+
+struct ipc_ids {
+	int in_use;
+	short unsigned int seq;
+	struct rw_semaphore rwsem;
+	struct idr ipcs_idr;
+	int max_idx;
+	int last_idx;
+	struct rhashtable key_ht;
+};
+
+struct ipc_namespace {
+	struct ipc_ids ids[3];
+	int sem_ctls[4];
+	int used_sems;
+	unsigned int msg_ctlmax;
+	unsigned int msg_ctlmnb;
+	unsigned int msg_ctlmni;
+	long: 32;
+	struct percpu_counter percpu_msg_bytes;
+	struct percpu_counter percpu_msg_hdrs;
+	size_t shm_ctlmax;
+	size_t shm_ctlall;
+	long unsigned int shm_tot;
+	int shm_ctlmni;
+	int shm_rmid_forced;
+	struct notifier_block ipcns_nb;
+	struct vfsmount *mq_mnt;
+	unsigned int mq_queues_count;
+	unsigned int mq_queues_max;
+	unsigned int mq_msg_max;
+	unsigned int mq_msgsize_max;
+	unsigned int mq_msg_default;
+	unsigned int mq_msgsize_default;
+	struct ctl_table_set mq_set;
+	struct ctl_table_header *mq_sysctls;
+	struct ctl_table_set ipc_set;
+	struct ctl_table_header *ipc_sysctls;
+	struct user_namespace *user_ns;
+	struct ucounts *ucounts;
+	struct llist_node mnt_llist;
+	struct ns_common ns;
+};
+
+struct ipc_params {
+	key_t key;
+	int flg;
+	union {
+		size_t size;
+		int nsems;
+	} u;
+};
+
+struct ipc_ops {
+	int (*getnew)(struct ipc_namespace *, struct ipc_params *);
+	int (*associate)(struct kern_ipc_perm *, int);
+	int (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);
+};
+
+struct ipc_proc_iface {
+	const char *path;
+	const char *header;
+	int ids;
+	int (*show)(struct seq_file *, void *);
+};
+
+struct ipc_proc_iter {
+	struct ipc_namespace *ns;
+	struct pid_namespace *pid_ns;
+	struct ipc_proc_iface *iface;
+};
+
+typedef short unsigned int __kernel_ipc_pid_t;
+
+typedef __kernel_long_t __kernel_old_time_t;
+
+struct shmid_ds {
+	struct ipc_perm shm_perm;
+	int shm_segsz;
+	__kernel_old_time_t shm_atime;
+	__kernel_old_time_t shm_dtime;
+	__kernel_old_time_t shm_ctime;
+	__kernel_ipc_pid_t shm_cpid;
+	__kernel_ipc_pid_t shm_lpid;
+	short unsigned int shm_nattch;
+	short unsigned int shm_unused;
+	void *shm_unused2;
+	void *shm_unused3;
+};
+
+struct shmid64_ds {
+	struct ipc64_perm shm_perm;
+	__kernel_size_t shm_segsz;
+	long unsigned int shm_atime;
+	long unsigned int shm_atime_high;
+	long unsigned int shm_dtime;
+	long unsigned int shm_dtime_high;
+	long unsigned int shm_ctime;
+	long unsigned int shm_ctime_high;
+	__kernel_pid_t shm_cpid;
+	__kernel_pid_t shm_lpid;
+	long unsigned int shm_nattch;
+	long unsigned int __unused4;
+	long unsigned int __unused5;
+};
+
+struct shminfo64 {
+	long unsigned int shmmax;
+	long unsigned int shmmin;
+	long unsigned int shmmni;
+	long unsigned int shmseg;
+	long unsigned int shmall;
+	long unsigned int __unused1;
+	long unsigned int __unused2;
+	long unsigned int __unused3;
+	long unsigned int __unused4;
+};
+
+struct shminfo {
+	int shmmax;
+	int shmmin;
+	int shmmni;
+	int shmseg;
+	int shmall;
+};
+
+struct shm_info {
+	int used_ids;
+	__kernel_ulong_t shm_tot;
+	__kernel_ulong_t shm_rss;
+	__kernel_ulong_t shm_swp;
+	__kernel_ulong_t swap_attempts;
+	__kernel_ulong_t swap_successes;
+};
+
+struct shared_policy {};
+
+struct shmem_inode_info {
+	spinlock_t lock;
+	unsigned int seals;
+	long unsigned int flags;
+	long unsigned int alloced;
+	long unsigned int swapped;
+	union {
+		struct offset_ctx dir_offsets;
+		struct {
+			struct list_head shrinklist;
+			struct list_head swaplist;
+		};
+	};
+	long: 32;
+	struct timespec64 i_crtime;
+	struct shared_policy policy;
+	struct simple_xattrs xattrs;
+	long unsigned int fallocend;
+	unsigned int fsflags;
+	atomic_t stop_eviction;
+	long: 32;
+	struct inode vfs_inode;
+};
+
+struct shmid_kernel {
+	struct kern_ipc_perm shm_perm;
+	struct file *shm_file;
+	long unsigned int shm_nattch;
+	long unsigned int shm_segsz;
+	long: 32;
+	time64_t shm_atim;
+	time64_t shm_dtim;
+	time64_t shm_ctim;
+	struct pid *shm_cprid;
+	struct pid *shm_lprid;
+	struct ucounts *mlock_ucounts;
+	struct task_struct *shm_creator;
+	struct list_head shm_clist;
+	struct ipc_namespace *ns;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct shm_file_data {
+	int id;
+	struct ipc_namespace *ns;
+	struct file *file;
+	const struct vm_operations_struct *vm_ops;
+};
+
+struct assoc_array_ops {
+	long unsigned int (*get_key_chunk)(const void *, int);
+	long unsigned int (*get_object_key_chunk)(const void *, int);
+	bool (*compare_object)(const void *, const void *);
+	int (*diff_objects)(const void *, const void *);
+	void (*free_object)(void *);
+};
+
+enum key_state {
+	KEY_IS_UNINSTANTIATED = 0,
+	KEY_IS_POSITIVE = 1,
+};
+
+struct key_user {
+	struct rb_node node;
+	struct mutex cons_lock;
+	spinlock_t lock;
+	refcount_t usage;
+	atomic_t nkeys;
+	atomic_t nikeys;
+	kuid_t uid;
+	int qnkeys;
+	int qnbytes;
+};
+
+struct assoc_array_node {
+	struct assoc_array_ptr *back_pointer;
+	u8 parent_slot;
+	struct assoc_array_ptr *slots[16];
+	long unsigned int nr_leaves_on_branch;
+};
+
+struct assoc_array_shortcut {
+	struct assoc_array_ptr *back_pointer;
+	int parent_slot;
+	int skip_to_level;
+	struct assoc_array_ptr *next_node;
+	long unsigned int index_key[0];
+};
+
+struct assoc_array_edit {
+	struct callback_head rcu;
+	struct assoc_array *array;
+	const struct assoc_array_ops *ops;
+	const struct assoc_array_ops *ops_for_excised_subtree;
+	struct assoc_array_ptr *leaf;
+	struct assoc_array_ptr **leaf_p;
+	struct assoc_array_ptr *dead_leaf;
+	struct assoc_array_ptr *new_meta[3];
+	struct assoc_array_ptr *excised_meta[1];
+	struct assoc_array_ptr *excised_subtree;
+	struct assoc_array_ptr **set_backpointers[16];
+	struct assoc_array_ptr *set_backpointers_to;
+	struct assoc_array_node *adjust_count_on;
+	long int adjust_count_by;
+	struct {
+		struct assoc_array_ptr **ptr;
+		struct assoc_array_ptr *to;
+	} set[2];
+	struct {
+		u8 *p;
+		u8 to;
+	} set_parent_slot[1];
+	u8 segment_cache[17];
+};
+
+struct key_preparsed_payload {
+	const char *orig_description;
+	char *description;
+	union key_payload payload;
+	const void *data;
+	size_t datalen;
+	size_t quotalen;
+	long: 32;
+	time64_t expiry;
+};
+
+struct key_match_data {
+	bool (*cmp)(const struct key *, const struct key_match_data *);
+	const void *raw_data;
+	void *preparsed;
+	unsigned int lookup_type;
+};
+
+enum kernel_pkey_operation {
+	kernel_pkey_encrypt = 0,
+	kernel_pkey_decrypt = 1,
+	kernel_pkey_sign = 2,
+	kernel_pkey_verify = 3,
+};
+
+struct kernel_pkey_params {
+	struct key *key;
+	const char *encoding;
+	const char *hash_algo;
+	char *info;
+	__u32 in_len;
+	union {
+		__u32 out_len;
+		__u32 in2_len;
+	};
+	enum kernel_pkey_operation op: 8;
+};
+
+struct kernel_pkey_query {
+	__u32 supported_ops;
+	__u32 key_size;
+	__u16 max_data_size;
+	__u16 max_sig_size;
+	__u16 max_enc_size;
+	__u16 max_dec_size;
+};
+
+enum key_notification_subtype {
+	NOTIFY_KEY_INSTANTIATED = 0,
+	NOTIFY_KEY_UPDATED = 1,
+	NOTIFY_KEY_LINKED = 2,
+	NOTIFY_KEY_UNLINKED = 3,
+	NOTIFY_KEY_CLEARED = 4,
+	NOTIFY_KEY_REVOKED = 5,
+	NOTIFY_KEY_INVALIDATED = 6,
+	NOTIFY_KEY_SETATTR = 7,
+};
+
+struct keyring_search_context {
+	struct keyring_index_key index_key;
+	const struct cred *cred;
+	struct key_match_data match_data;
+	unsigned int flags;
+	int (*iterator)(const void *, void *);
+	int skipped_ret;
+	bool possessed;
+	key_ref_t result;
+	long: 32;
+	time64_t now;
+};
+
+struct keyring_read_iterator_context {
+	size_t buflen;
+	size_t count;
+	key_serial_t *buffer;
+};
+
+typedef int wait_bit_action_f(struct wait_bit_key *, int);
+
+struct request_key_auth {
+	struct callback_head rcu;
+	struct key *target_key;
+	struct key *dest_keyring;
+	const struct cred *cred;
+	void *callout_info;
+	size_t callout_len;
+	pid_t pid;
+	char op[8];
+};
+
+struct crypto_comp {
+	struct crypto_tfm base;
+};
+
+struct crypto_template;
+
+struct crypto_spawn;
+
+struct crypto_instance {
+	struct crypto_alg alg;
+	struct crypto_template *tmpl;
+	union {
+		struct hlist_node list;
+		struct crypto_spawn *spawns;
+	};
+	struct work_struct free_work;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	void *__ctx[0];
+};
+
+struct crypto_spawn {
+	struct list_head list;
+	struct crypto_alg *alg;
+	union {
+		struct crypto_instance *inst;
+		struct crypto_spawn *next;
+	};
+	const struct crypto_type *frontend;
+	u32 mask;
+	bool dead;
+	bool registered;
+};
+
+struct rtattr;
+
+struct crypto_template {
+	struct list_head list;
+	struct hlist_head instances;
+	struct module *module;
+	int (*create)(struct crypto_template *, struct rtattr **);
+	char name[128];
+};
+
+typedef void (*crypto_completion_t)(void *, int);
+
+struct crypto_async_request {
+	struct list_head list;
+	crypto_completion_t complete;
+	void *data;
+	struct crypto_tfm *tfm;
+	u32 flags;
+};
+
+struct aead_request {
+	struct crypto_async_request base;
+	unsigned int assoclen;
+	unsigned int cryptlen;
+	u8 *iv;
+	struct scatterlist *src;
+	struct scatterlist *dst;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	void *__ctx[0];
+};
+
+struct crypto_aead;
+
+struct aead_alg {
+	int (*setkey)(struct crypto_aead *, const u8 *, unsigned int);
+	int (*setauthsize)(struct crypto_aead *, unsigned int);
+	int (*encrypt)(struct aead_request *);
+	int (*decrypt)(struct aead_request *);
+	int (*init)(struct crypto_aead *);
+	void (*exit)(struct crypto_aead *);
+	unsigned int ivsize;
+	unsigned int maxauthsize;
+	unsigned int chunksize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_alg base;
+};
+
+struct crypto_aead {
+	unsigned int authsize;
+	unsigned int reqsize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_tfm base;
+};
+
+struct scatter_walk {
+	struct scatterlist *sg;
+	unsigned int offset;
+};
+
+struct crypto_cipher {
+	struct crypto_tfm base;
+};
+
+struct crypto_cipher_spawn {
+	struct crypto_spawn base;
+};
+
+struct skcipher_request {
+	unsigned int cryptlen;
+	u8 *iv;
+	struct scatterlist *src;
+	struct scatterlist *dst;
+	struct crypto_async_request base;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	void *__ctx[0];
+};
+
+struct crypto_skcipher {
+	unsigned int reqsize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_tfm base;
+};
+
+struct crypto_sync_skcipher {
+	struct crypto_skcipher base;
+};
+
+struct crypto_lskcipher {
+	struct crypto_tfm base;
+};
+
+struct skcipher_alg_common {
+	unsigned int min_keysize;
+	unsigned int max_keysize;
+	unsigned int ivsize;
+	unsigned int chunksize;
+	unsigned int statesize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_alg base;
+};
+
+struct skcipher_alg {
+	int (*setkey)(struct crypto_skcipher *, const u8 *, unsigned int);
+	int (*encrypt)(struct skcipher_request *);
+	int (*decrypt)(struct skcipher_request *);
+	int (*export)(struct skcipher_request *, void *);
+	int (*import)(struct skcipher_request *, const void *);
+	int (*init)(struct crypto_skcipher *);
+	void (*exit)(struct crypto_skcipher *);
+	unsigned int walksize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct {
+			unsigned int min_keysize;
+			unsigned int max_keysize;
+			unsigned int ivsize;
+			unsigned int chunksize;
+			unsigned int statesize;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			long: 32;
+			struct crypto_alg base;
+		};
+		struct skcipher_alg_common co;
+	};
+};
+
+struct skcipher_instance {
+	void (*free)(struct skcipher_instance *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct {
+			char head[128];
+			struct crypto_instance base;
+		} s;
+		struct skcipher_alg alg;
+	};
+};
+
+struct crypto_skcipher_spawn {
+	struct crypto_spawn base;
+};
+
+struct skcipher_walk {
+	union {
+		struct {
+			struct page *page;
+			long unsigned int offset;
+		} phys;
+		struct {
+			u8 *page;
+			void *addr;
+		} virt;
+	} src;
+	union {
+		struct {
+			struct page *page;
+			long unsigned int offset;
+		} phys;
+		struct {
+			u8 *page;
+			void *addr;
+		} virt;
+	} dst;
+	struct scatter_walk in;
+	unsigned int nbytes;
+	struct scatter_walk out;
+	unsigned int total;
+	struct list_head buffers;
+	u8 *page;
+	u8 *buffer;
+	u8 *oiv;
+	void *iv;
+	unsigned int ivsize;
+	int flags;
+	unsigned int blocksize;
+	unsigned int stride;
+	unsigned int alignmask;
+};
+
+struct skcipher_ctx_simple {
+	struct crypto_cipher *cipher;
+};
+
+enum crypto_attr_type_t {
+	CRYPTOCFGA_UNSPEC = 0,
+	CRYPTOCFGA_PRIORITY_VAL = 1,
+	CRYPTOCFGA_REPORT_LARVAL = 2,
+	CRYPTOCFGA_REPORT_HASH = 3,
+	CRYPTOCFGA_REPORT_BLKCIPHER = 4,
+	CRYPTOCFGA_REPORT_AEAD = 5,
+	CRYPTOCFGA_REPORT_COMPRESS = 6,
+	CRYPTOCFGA_REPORT_RNG = 7,
+	CRYPTOCFGA_REPORT_CIPHER = 8,
+	CRYPTOCFGA_REPORT_AKCIPHER = 9,
+	CRYPTOCFGA_REPORT_KPP = 10,
+	CRYPTOCFGA_REPORT_ACOMP = 11,
+	CRYPTOCFGA_STAT_LARVAL = 12,
+	CRYPTOCFGA_STAT_HASH = 13,
+	CRYPTOCFGA_STAT_BLKCIPHER = 14,
+	CRYPTOCFGA_STAT_AEAD = 15,
+	CRYPTOCFGA_STAT_COMPRESS = 16,
+	CRYPTOCFGA_STAT_RNG = 17,
+	CRYPTOCFGA_STAT_CIPHER = 18,
+	CRYPTOCFGA_STAT_AKCIPHER = 19,
+	CRYPTOCFGA_STAT_KPP = 20,
+	CRYPTOCFGA_STAT_ACOMP = 21,
+	__CRYPTOCFGA_MAX = 22,
+};
+
+struct crypto_report_blkcipher {
+	char type[64];
+	char geniv[64];
+	unsigned int blocksize;
+	unsigned int min_keysize;
+	unsigned int max_keysize;
+	unsigned int ivsize;
+};
+
+enum {
+	SKCIPHER_WALK_PHYS = 1,
+	SKCIPHER_WALK_SLOW = 2,
+	SKCIPHER_WALK_COPY = 4,
+	SKCIPHER_WALK_DIFF = 8,
+	SKCIPHER_WALK_SLEEP = 16,
+};
+
+struct skcipher_walk_buffer {
+	struct list_head entry;
+	struct scatter_walk dst;
+	unsigned int len;
+	u8 *data;
+	u8 buffer[0];
+};
+
+struct crypto_wait {
+	struct completion completion;
+	int err;
+};
+
+struct akcipher_request {
+	struct crypto_async_request base;
+	struct scatterlist *src;
+	struct scatterlist *dst;
+	unsigned int src_len;
+	unsigned int dst_len;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	void *__ctx[0];
+};
+
+struct crypto_akcipher {
+	unsigned int reqsize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_tfm base;
+};
+
+struct akcipher_alg {
+	int (*sign)(struct akcipher_request *);
+	int (*verify)(struct akcipher_request *);
+	int (*encrypt)(struct akcipher_request *);
+	int (*decrypt)(struct akcipher_request *);
+	int (*set_pub_key)(struct crypto_akcipher *, const void *, unsigned int);
+	int (*set_priv_key)(struct crypto_akcipher *, const void *, unsigned int);
+	unsigned int (*max_size)(struct crypto_akcipher *);
+	int (*init)(struct crypto_akcipher *);
+	void (*exit)(struct crypto_akcipher *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_alg base;
+};
+
+struct crypto_sig {
+	struct crypto_tfm base;
+};
+
+struct crypto_report_akcipher {
+	char type[64];
+};
+
+struct crypto_akcipher_sync_data {
+	struct crypto_akcipher *tfm;
+	const void *src;
+	void *dst;
+	unsigned int slen;
+	unsigned int dlen;
+	struct akcipher_request *req;
+	struct crypto_wait cwait;
+	struct scatterlist sg;
+	u8 *buf;
+};
+
+struct acomp_req {
+	struct crypto_async_request base;
+	struct scatterlist *src;
+	struct scatterlist *dst;
+	unsigned int slen;
+	unsigned int dlen;
+	u32 flags;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	void *__ctx[0];
+};
+
+struct crypto_acomp {
+	int (*compress)(struct acomp_req *);
+	int (*decompress)(struct acomp_req *);
+	void (*dst_free)(struct scatterlist *);
+	unsigned int reqsize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_tfm base;
+};
+
+struct comp_alg_common {
+	struct crypto_alg base;
+};
+
+struct crypto_scomp {
+	struct crypto_tfm base;
+};
+
+struct scomp_alg {
+	void * (*alloc_ctx)(struct crypto_scomp *);
+	void (*free_ctx)(struct crypto_scomp *, void *);
+	int (*compress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
+	int (*decompress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct {
+			struct crypto_alg base;
+		};
+		struct comp_alg_common calg;
+	};
+};
+
+struct crypto_report_comp {
+	char type[64];
+};
+
+struct scomp_scratch {
+	spinlock_t lock;
+	void *src;
+	void *dst;
+};
+
+struct sha256_state {
+	u32 state[8];
+	u64 count;
+	u8 buf[64];
+};
+
+typedef struct {
+	__be64 a;
+	__be64 b;
+} be128;
+
+struct aead_instance {
+	void (*free)(struct aead_instance *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct {
+			char head[64];
+			struct crypto_instance base;
+		} s;
+		struct aead_alg alg;
+	};
+};
+
+struct crypto_aead_spawn {
+	struct crypto_spawn base;
+};
+
+struct ahash_request {
+	struct crypto_async_request base;
+	unsigned int nbytes;
+	struct scatterlist *src;
+	u8 *result;
+	void *priv;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	void *__ctx[0];
+};
+
+struct crypto_ahash {
+	bool using_shash;
+	unsigned int statesize;
+	unsigned int reqsize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_tfm base;
+};
+
+struct crypto_ahash_spawn {
+	struct crypto_spawn base;
+};
+
+struct gcm_instance_ctx {
+	struct crypto_skcipher_spawn ctr;
+	struct crypto_ahash_spawn ghash;
+};
+
+struct crypto_gcm_ctx {
+	struct crypto_skcipher *ctr;
+	struct crypto_ahash *ghash;
+};
+
+struct crypto_rfc4106_ctx {
+	struct crypto_aead *child;
+	u8 nonce[4];
+};
+
+struct crypto_rfc4106_req_ctx {
+	struct scatterlist src[3];
+	struct scatterlist dst[3];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct aead_request subreq;
+};
+
+struct crypto_rfc4543_instance_ctx {
+	struct crypto_aead_spawn aead;
+};
+
+struct crypto_rfc4543_ctx {
+	struct crypto_aead *child;
+	struct crypto_sync_skcipher *null;
+	u8 nonce[4];
+};
+
+struct crypto_rfc4543_req_ctx {
+	struct aead_request subreq;
+};
+
+struct crypto_gcm_ghash_ctx {
+	unsigned int cryptlen;
+	struct scatterlist *src;
+	int (*complete)(struct aead_request *, u32);
+};
+
+struct crypto_gcm_req_priv_ctx {
+	u8 iv[16];
+	u8 auth_tag[16];
+	u8 iauth_tag[16];
+	struct scatterlist src[3];
+	struct scatterlist dst[3];
+	struct scatterlist sg;
+	struct crypto_gcm_ghash_ctx ghash_ctx;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct ahash_request ahreq;
+		struct skcipher_request skreq;
+	} u;
+};
+
+struct lzorle_ctx {
+	void *lzorle_comp_mem;
+};
+
+typedef enum {
+	ZSTDcs_created = 0,
+	ZSTDcs_init = 1,
+	ZSTDcs_ongoing = 2,
+	ZSTDcs_ending = 3,
+} ZSTD_compressionStage_e;
+
+typedef enum {
+	ZSTD_f_zstd1 = 0,
+	ZSTD_f_zstd1_magicless = 1,
+} ZSTD_format_e;
+
+typedef enum {
+	ZSTD_fast = 1,
+	ZSTD_dfast = 2,
+	ZSTD_greedy = 3,
+	ZSTD_lazy = 4,
+	ZSTD_lazy2 = 5,
+	ZSTD_btlazy2 = 6,
+	ZSTD_btopt = 7,
+	ZSTD_btultra = 8,
+	ZSTD_btultra2 = 9,
+} ZSTD_strategy;
+
+typedef struct {
+	unsigned int windowLog;
+	unsigned int chainLog;
+	unsigned int hashLog;
+	unsigned int searchLog;
+	unsigned int minMatch;
+	unsigned int targetLength;
+	ZSTD_strategy strategy;
+} ZSTD_compressionParameters;
+
+typedef struct {
+	int contentSizeFlag;
+	int checksumFlag;
+	int noDictIDFlag;
+} ZSTD_frameParameters;
+
+typedef enum {
+	ZSTD_dictDefaultAttach = 0,
+	ZSTD_dictForceAttach = 1,
+	ZSTD_dictForceCopy = 2,
+	ZSTD_dictForceLoad = 3,
+} ZSTD_dictAttachPref_e;
+
+typedef enum {
+	ZSTD_ps_auto = 0,
+	ZSTD_ps_enable = 1,
+	ZSTD_ps_disable = 2,
+} ZSTD_paramSwitch_e;
+
+typedef uint32_t U32;
+
+typedef struct {
+	ZSTD_paramSwitch_e enableLdm;
+	U32 hashLog;
+	U32 bucketSizeLog;
+	U32 minMatchLength;
+	U32 hashRateLog;
+	U32 windowLog;
+} ldmParams_t;
+
+typedef enum {
+	ZSTD_bm_buffered = 0,
+	ZSTD_bm_stable = 1,
+} ZSTD_bufferMode_e;
+
+typedef enum {
+	ZSTD_sf_noBlockDelimiters = 0,
+	ZSTD_sf_explicitBlockDelimiters = 1,
+} ZSTD_sequenceFormat_e;
+
+typedef void * (*ZSTD_allocFunction)(void *, size_t);
+
+typedef void (*ZSTD_freeFunction)(void *, void *);
+
+typedef struct {
+	ZSTD_allocFunction customAlloc;
+	ZSTD_freeFunction customFree;
+	void *opaque;
+} ZSTD_customMem;
+
+typedef struct {
+	unsigned int offset;
+	unsigned int litLength;
+	unsigned int matchLength;
+	unsigned int rep;
+} ZSTD_Sequence;
+
+typedef size_t (*ZSTD_sequenceProducer_F)(void *, ZSTD_Sequence *, size_t, const void *, size_t, const void *, size_t, int, size_t);
+
+struct ZSTD_CCtx_params_s {
+	ZSTD_format_e format;
+	ZSTD_compressionParameters cParams;
+	ZSTD_frameParameters fParams;
+	int compressionLevel;
+	int forceWindow;
+	size_t targetCBlockSize;
+	int srcSizeHint;
+	ZSTD_dictAttachPref_e attachDictPref;
+	ZSTD_paramSwitch_e literalCompressionMode;
+	int nbWorkers;
+	size_t jobSize;
+	int overlapLog;
+	int rsyncable;
+	ldmParams_t ldmParams;
+	int enableDedicatedDictSearch;
+	ZSTD_bufferMode_e inBufferMode;
+	ZSTD_bufferMode_e outBufferMode;
+	ZSTD_sequenceFormat_e blockDelimiters;
+	int validateSequences;
+	ZSTD_paramSwitch_e useBlockSplitter;
+	ZSTD_paramSwitch_e useRowMatchFinder;
+	int deterministicRefPrefix;
+	ZSTD_customMem customMem;
+	ZSTD_paramSwitch_e prefetchCDictTables;
+	int enableMatchFinderFallback;
+	void *extSeqProdState;
+	ZSTD_sequenceProducer_F extSeqProdFunc;
+	size_t maxBlockSize;
+	ZSTD_paramSwitch_e searchForExternalRepcodes;
+};
+
+typedef struct ZSTD_CCtx_params_s ZSTD_CCtx_params;
+
+typedef uint8_t BYTE;
+
+typedef enum {
+	ZSTD_cwksp_alloc_objects = 0,
+	ZSTD_cwksp_alloc_aligned_init_once = 1,
+	ZSTD_cwksp_alloc_aligned = 2,
+	ZSTD_cwksp_alloc_buffers = 3,
+} ZSTD_cwksp_alloc_phase_e;
+
+typedef enum {
+	ZSTD_cwksp_dynamic_alloc = 0,
+	ZSTD_cwksp_static_alloc = 1,
+} ZSTD_cwksp_static_alloc_e;
+
+typedef struct {
+	void *workspace;
+	void *workspaceEnd;
+	void *objectEnd;
+	void *tableEnd;
+	void *tableValidEnd;
+	void *allocStart;
+	void *initOnceStart;
+	BYTE allocFailed;
+	int workspaceOversizedDuration;
+	ZSTD_cwksp_alloc_phase_e phase;
+	ZSTD_cwksp_static_alloc_e isStatic;
+} ZSTD_cwksp;
+
+struct xxh64_state {
+	uint64_t total_len;
+	uint64_t v1;
+	uint64_t v2;
+	uint64_t v3;
+	uint64_t v4;
+	uint64_t mem64[4];
+	uint32_t memsize;
+	long: 32;
+};
+
+struct POOL_ctx_s;
+
+typedef struct POOL_ctx_s ZSTD_threadPool;
+
+typedef struct {
+	int collectSequences;
+	ZSTD_Sequence *seqStart;
+	size_t seqIndex;
+	size_t maxSequences;
+} SeqCollector;
+
+typedef enum {
+	ZSTD_llt_none = 0,
+	ZSTD_llt_literalLength = 1,
+	ZSTD_llt_matchLength = 2,
+} ZSTD_longLengthType_e;
+
+struct seqDef_s;
+
+typedef struct seqDef_s seqDef;
+
+typedef struct {
+	seqDef *sequencesStart;
+	seqDef *sequences;
+	BYTE *litStart;
+	BYTE *lit;
+	BYTE *llCode;
+	BYTE *mlCode;
+	BYTE *ofCode;
+	size_t maxNbSeq;
+	size_t maxNbLit;
+	ZSTD_longLengthType_e longLengthType;
+	U32 longLengthPos;
+} seqStore_t;
+
+typedef struct {
+	const BYTE *nextSrc;
+	const BYTE *base;
+	const BYTE *dictBase;
+	U32 dictLimit;
+	U32 lowLimit;
+	U32 nbOverflowCorrections;
+} ZSTD_window_t;
+
+typedef struct {
+	U32 offset;
+	U32 checksum;
+} ldmEntry_t;
+
+typedef struct {
+	const BYTE *split;
+	U32 hash;
+	U32 checksum;
+	ldmEntry_t *bucket;
+} ldmMatchCandidate_t;
+
+typedef struct {
+	ZSTD_window_t window;
+	ldmEntry_t *hashTable;
+	U32 loadedDictEnd;
+	BYTE *bucketOffsets;
+	size_t splitIndices[64];
+	ldmMatchCandidate_t matchCandidates[64];
+} ldmState_t;
+
+typedef struct {
+	U32 offset;
+	U32 litLength;
+	U32 matchLength;
+} rawSeq;
+
+typedef struct {
+	rawSeq *seq;
+	size_t pos;
+	size_t posInSequence;
+	size_t size;
+	size_t capacity;
+} rawSeqStore_t;
+
+typedef size_t HUF_CElt;
+
+typedef enum {
+	HUF_repeat_none = 0,
+	HUF_repeat_check = 1,
+	HUF_repeat_valid = 2,
+} HUF_repeat;
+
+typedef struct {
+	HUF_CElt CTable[257];
+	HUF_repeat repeatMode;
+} ZSTD_hufCTables_t;
+
+typedef unsigned int FSE_CTable;
+
+typedef enum {
+	FSE_repeat_none = 0,
+	FSE_repeat_check = 1,
+	FSE_repeat_valid = 2,
+} FSE_repeat;
+
+typedef struct {
+	FSE_CTable offcodeCTable[193];
+	FSE_CTable matchlengthCTable[363];
+	FSE_CTable litlengthCTable[329];
+	FSE_repeat offcode_repeatMode;
+	FSE_repeat matchlength_repeatMode;
+	FSE_repeat litlength_repeatMode;
+} ZSTD_fseCTables_t;
+
+typedef struct {
+	ZSTD_hufCTables_t huf;
+	ZSTD_fseCTables_t fse;
+} ZSTD_entropyCTables_t;
+
+typedef struct {
+	ZSTD_entropyCTables_t entropy;
+	U32 rep[3];
+} ZSTD_compressedBlockState_t;
+
+typedef uint64_t U64;
+
+typedef struct {
+	U32 off;
+	U32 len;
+} ZSTD_match_t;
+
+typedef struct {
+	int price;
+	U32 off;
+	U32 mlen;
+	U32 litlen;
+	U32 rep[3];
+} ZSTD_optimal_t;
+
+typedef enum {
+	zop_dynamic = 0,
+	zop_predef = 1,
+} ZSTD_OptPrice_e;
+
+typedef struct {
+	unsigned int *litFreq;
+	unsigned int *litLengthFreq;
+	unsigned int *matchLengthFreq;
+	unsigned int *offCodeFreq;
+	ZSTD_match_t *matchTable;
+	ZSTD_optimal_t *priceTable;
+	U32 litSum;
+	U32 litLengthSum;
+	U32 matchLengthSum;
+	U32 offCodeSum;
+	U32 litSumBasePrice;
+	U32 litLengthSumBasePrice;
+	U32 matchLengthSumBasePrice;
+	U32 offCodeSumBasePrice;
+	ZSTD_OptPrice_e priceType;
+	const ZSTD_entropyCTables_t *symbolCosts;
+	ZSTD_paramSwitch_e literalCompressionMode;
+} optState_t;
+
+struct ZSTD_matchState_t;
+
+typedef struct ZSTD_matchState_t ZSTD_matchState_t;
+
+struct ZSTD_matchState_t {
+	ZSTD_window_t window;
+	U32 loadedDictEnd;
+	U32 nextToUpdate;
+	U32 hashLog3;
+	U32 rowHashLog;
+	BYTE *tagTable;
+	U32 hashCache[8];
+	long: 32;
+	U64 hashSalt;
+	U32 hashSaltEntropy;
+	U32 *hashTable;
+	U32 *hashTable3;
+	U32 *chainTable;
+	U32 forceNonContiguous;
+	int dedicatedDictSearch;
+	optState_t opt;
+	const ZSTD_matchState_t *dictMatchState;
+	ZSTD_compressionParameters cParams;
+	const rawSeqStore_t *ldmSeqStore;
+	int prefetchCDictTables;
+	int lazySkipping;
+};
+
+typedef struct {
+	ZSTD_compressedBlockState_t *prevCBlock;
+	ZSTD_compressedBlockState_t *nextCBlock;
+	ZSTD_matchState_t matchState;
+} ZSTD_blockState_t;
+
+typedef enum {
+	ZSTDb_not_buffered = 0,
+	ZSTDb_buffered = 1,
+} ZSTD_buffered_policy_e;
+
+typedef enum {
+	zcss_init = 0,
+	zcss_load = 1,
+	zcss_flush = 2,
+} ZSTD_cStreamStage;
+
+struct ZSTD_inBuffer_s {
+	const void *src;
+	size_t size;
+	size_t pos;
+};
+
+typedef struct ZSTD_inBuffer_s ZSTD_inBuffer;
+
+typedef enum {
+	ZSTD_dct_auto = 0,
+	ZSTD_dct_rawContent = 1,
+	ZSTD_dct_fullDict = 2,
+} ZSTD_dictContentType_e;
+
+struct ZSTD_CDict_s;
+
+typedef struct ZSTD_CDict_s ZSTD_CDict;
+
+typedef struct {
+	void *dictBuffer;
+	const void *dict;
+	size_t dictSize;
+	ZSTD_dictContentType_e dictContentType;
+	ZSTD_CDict *cdict;
+} ZSTD_localDict;
+
+struct ZSTD_prefixDict_s {
+	const void *dict;
+	size_t dictSize;
+	ZSTD_dictContentType_e dictContentType;
+};
+
+typedef struct ZSTD_prefixDict_s ZSTD_prefixDict;
+
+typedef enum {
+	set_basic = 0,
+	set_rle = 1,
+	set_compressed = 2,
+	set_repeat = 3,
+} symbolEncodingType_e;
+
+typedef struct {
+	symbolEncodingType_e hType;
+	BYTE hufDesBuffer[128];
+	size_t hufDesSize;
+} ZSTD_hufCTablesMetadata_t;
+
+typedef struct {
+	symbolEncodingType_e llType;
+	symbolEncodingType_e ofType;
+	symbolEncodingType_e mlType;
+	BYTE fseTablesBuffer[133];
+	size_t fseTablesSize;
+	size_t lastCountSize;
+} ZSTD_fseCTablesMetadata_t;
+
+typedef struct {
+	ZSTD_hufCTablesMetadata_t hufMetadata;
+	ZSTD_fseCTablesMetadata_t fseMetadata;
+} ZSTD_entropyCTablesMetadata_t;
+
+typedef struct {
+	seqStore_t fullSeqStoreChunk;
+	seqStore_t firstHalfSeqStore;
+	seqStore_t secondHalfSeqStore;
+	seqStore_t currSeqStore;
+	seqStore_t nextSeqStore;
+	U32 partitions[196];
+	ZSTD_entropyCTablesMetadata_t entropyMetadata;
+} ZSTD_blockSplitCtx;
+
+struct ZSTD_CCtx_s {
+	ZSTD_compressionStage_e stage;
+	int cParamsChanged;
+	int bmi2;
+	ZSTD_CCtx_params requestedParams;
+	ZSTD_CCtx_params appliedParams;
+	ZSTD_CCtx_params simpleApiParams;
+	U32 dictID;
+	size_t dictContentSize;
+	ZSTD_cwksp workspace;
+	size_t blockSize;
+	long: 32;
+	long long unsigned int pledgedSrcSizePlusOne;
+	long long unsigned int consumedSrcSize;
+	long long unsigned int producedCSize;
+	struct xxh64_state xxhState;
+	ZSTD_customMem customMem;
+	ZSTD_threadPool *pool;
+	size_t staticSize;
+	SeqCollector seqCollector;
+	int isFirstBlock;
+	int initialized;
+	seqStore_t seqStore;
+	ldmState_t ldmState;
+	rawSeq *ldmSequences;
+	size_t maxNbLdmSequences;
+	rawSeqStore_t externSeqStore;
+	ZSTD_blockState_t blockState;
+	U32 *entropyWorkspace;
+	ZSTD_buffered_policy_e bufferedPolicy;
+	char *inBuff;
+	size_t inBuffSize;
+	size_t inToCompress;
+	size_t inBuffPos;
+	size_t inBuffTarget;
+	char *outBuff;
+	size_t outBuffSize;
+	size_t outBuffContentSize;
+	size_t outBuffFlushedSize;
+	ZSTD_cStreamStage streamStage;
+	U32 frameEnded;
+	ZSTD_inBuffer expectedInBuffer;
+	size_t stableIn_notConsumed;
+	size_t expectedOutBufferSize;
+	ZSTD_localDict localDict;
+	const ZSTD_CDict *cdict;
+	ZSTD_prefixDict prefixDict;
+	ZSTD_blockSplitCtx blockSplitCtx;
+	ZSTD_Sequence *extSeqBuf;
+	size_t extSeqBufCapacity;
+	long: 32;
+};
+
+typedef struct ZSTD_CCtx_s ZSTD_CCtx;
+
+typedef uint16_t U16;
+
+typedef struct {
+	U16 nextState;
+	BYTE nbAdditionalBits;
+	BYTE nbBits;
+	U32 baseValue;
+} ZSTD_seqSymbol;
+
+typedef U32 HUF_DTable;
+
+typedef struct {
+	ZSTD_seqSymbol LLTable[513];
+	ZSTD_seqSymbol OFTable[257];
+	ZSTD_seqSymbol MLTable[513];
+	HUF_DTable hufTable[4097];
+	U32 rep[3];
+	U32 workspace[157];
+} ZSTD_entropyDTables_t;
+
+typedef enum {
+	ZSTD_frame = 0,
+	ZSTD_skippableFrame = 1,
+} ZSTD_frameType_e;
+
+typedef struct {
+	long long unsigned int frameContentSize;
+	long long unsigned int windowSize;
+	unsigned int blockSizeMax;
+	ZSTD_frameType_e frameType;
+	unsigned int headerSize;
+	unsigned int dictID;
+	unsigned int checksumFlag;
+	unsigned int _reserved1;
+	unsigned int _reserved2;
+	long: 32;
+} ZSTD_frameHeader;
+
+typedef enum {
+	bt_raw = 0,
+	bt_rle = 1,
+	bt_compressed = 2,
+	bt_reserved = 3,
+} blockType_e;
+
+typedef enum {
+	ZSTDds_getFrameHeaderSize = 0,
+	ZSTDds_decodeFrameHeader = 1,
+	ZSTDds_decodeBlockHeader = 2,
+	ZSTDds_decompressBlock = 3,
+	ZSTDds_decompressLastBlock = 4,
+	ZSTDds_checkChecksum = 5,
+	ZSTDds_decodeSkippableHeader = 6,
+	ZSTDds_skipFrame = 7,
+} ZSTD_dStage;
+
+typedef enum {
+	ZSTD_d_validateChecksum = 0,
+	ZSTD_d_ignoreChecksum = 1,
+} ZSTD_forceIgnoreChecksum_e;
+
+typedef enum {
+	ZSTD_use_indefinitely = -1,
+	ZSTD_dont_use = 0,
+	ZSTD_use_once = 1,
+} ZSTD_dictUses_e;
+
+struct ZSTD_DDict_s;
+
+typedef struct ZSTD_DDict_s ZSTD_DDict;
+
+typedef struct {
+	const ZSTD_DDict **ddictPtrTable;
+	size_t ddictPtrTableSize;
+	size_t ddictPtrCount;
+} ZSTD_DDictHashSet;
+
+typedef enum {
+	ZSTD_rmd_refSingleDDict = 0,
+	ZSTD_rmd_refMultipleDDicts = 1,
+} ZSTD_refMultipleDDicts_e;
+
+typedef enum {
+	zdss_init = 0,
+	zdss_loadHeader = 1,
+	zdss_read = 2,
+	zdss_load = 3,
+	zdss_flush = 4,
+} ZSTD_dStreamStage;
+
+struct ZSTD_outBuffer_s {
+	void *dst;
+	size_t size;
+	size_t pos;
+};
+
+typedef struct ZSTD_outBuffer_s ZSTD_outBuffer;
+
+typedef enum {
+	ZSTD_not_in_dst = 0,
+	ZSTD_in_dst = 1,
+	ZSTD_split = 2,
+} ZSTD_litLocation_e;
+
+struct ZSTD_DCtx_s {
+	const ZSTD_seqSymbol *LLTptr;
+	const ZSTD_seqSymbol *MLTptr;
+	const ZSTD_seqSymbol *OFTptr;
+	const HUF_DTable *HUFptr;
+	ZSTD_entropyDTables_t entropy;
+	U32 workspace[640];
+	const void *previousDstEnd;
+	const void *prefixStart;
+	const void *virtualStart;
+	const void *dictEnd;
+	size_t expected;
+	ZSTD_frameHeader fParams;
+	U64 processedCSize;
+	U64 decodedSize;
+	blockType_e bType;
+	ZSTD_dStage stage;
+	U32 litEntropy;
+	U32 fseEntropy;
+	struct xxh64_state xxhState;
+	size_t headerSize;
+	ZSTD_format_e format;
+	ZSTD_forceIgnoreChecksum_e forceIgnoreChecksum;
+	U32 validateChecksum;
+	const BYTE *litPtr;
+	ZSTD_customMem customMem;
+	size_t litSize;
+	size_t rleSize;
+	size_t staticSize;
+	int isFrameDecompression;
+	ZSTD_DDict *ddictLocal;
+	const ZSTD_DDict *ddict;
+	U32 dictID;
+	int ddictIsCold;
+	ZSTD_dictUses_e dictUses;
+	ZSTD_DDictHashSet *ddictSet;
+	ZSTD_refMultipleDDicts_e refMultipleDDicts;
+	int disableHufAsm;
+	int maxBlockSizeParam;
+	ZSTD_dStreamStage streamStage;
+	char *inBuff;
+	size_t inBuffSize;
+	size_t inPos;
+	size_t maxWindowSize;
+	char *outBuff;
+	size_t outBuffSize;
+	size_t outStart;
+	size_t outEnd;
+	size_t lhSize;
+	U32 hostageByte;
+	int noForwardProgress;
+	ZSTD_bufferMode_e outBufferMode;
+	ZSTD_outBuffer expectedOutBuffer;
+	BYTE *litBuffer;
+	const BYTE *litBufferEnd;
+	ZSTD_litLocation_e litBufferLocation;
+	BYTE litExtraBuffer[65568];
+	BYTE headerBuffer[18];
+	size_t oversizedDuration;
+};
+
+typedef struct ZSTD_DCtx_s ZSTD_DCtx;
+
+typedef struct {
+	ZSTD_compressionParameters cParams;
+	ZSTD_frameParameters fParams;
+} ZSTD_parameters;
+
+typedef ZSTD_compressionParameters zstd_compression_parameters;
+
+typedef ZSTD_parameters zstd_parameters;
+
+typedef ZSTD_CCtx zstd_cctx;
+
+typedef ZSTD_DCtx zstd_dctx;
+
+struct zstd_ctx {
+	zstd_cctx *cctx;
+	zstd_dctx *dctx;
+	void *cwksp;
+	void *dwksp;
+};
+
+struct blkg_iostat {
+	u64 bytes[3];
+	u64 ios[3];
+};
+
+struct blkg_iostat_set {
+	struct u64_stats_sync sync;
+	struct blkcg_gq *blkg;
+	struct llist_node lnode;
+	int lqueued;
+	struct blkg_iostat cur;
+	struct blkg_iostat last;
+};
+
+struct blkcg;
+
+struct blkg_policy_data;
+
+struct blkcg_gq {
+	struct request_queue *q;
+	struct list_head q_node;
+	struct hlist_node blkcg_node;
+	struct blkcg *blkcg;
+	struct blkcg_gq *parent;
+	struct percpu_ref refcnt;
+	bool online;
+	struct blkg_iostat_set *iostat_cpu;
+	long: 32;
+	struct blkg_iostat_set iostat;
+	struct blkg_policy_data *pd[6];
+	spinlock_t async_bio_lock;
+	struct bio_list async_bios;
+	union {
+		struct work_struct async_bio_work;
+		struct work_struct free_work;
+	};
+	atomic_t use_delay;
+	atomic64_t delay_nsec;
+	atomic64_t delay_start;
+	u64 last_delay;
+	int last_use;
+	struct callback_head callback_head;
+	long: 32;
+};
+
+typedef __u32 blk_mq_req_flags_t;
+
+struct sbitmap_word {
+	long unsigned int word;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long unsigned int cleared;
+	raw_spinlock_t swap_lock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct sbitmap {
+	unsigned int depth;
+	unsigned int shift;
+	unsigned int map_nr;
+	bool round_robin;
+	struct sbitmap_word *map;
+	unsigned int *alloc_hint;
+};
+
+struct sbq_wait_state {
+	wait_queue_head_t wait;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct sbitmap_queue {
+	struct sbitmap sb;
+	unsigned int wake_batch;
+	atomic_t wake_index;
+	struct sbq_wait_state *ws;
+	atomic_t ws_active;
+	unsigned int min_shallow_depth;
+	atomic_t completion_cnt;
+	atomic_t wakeup_cnt;
+};
+
+struct elevator_type;
+
+struct elevator_queue {
+	struct elevator_type *type;
+	void *elevator_data;
+	struct kobject kobj;
+	struct mutex sysfs_lock;
+	long unsigned int flags;
+	struct hlist_head hash[64];
+};
+
+struct blk_mq_ctxs;
+
+struct blk_mq_ctx {
+	struct {
+		spinlock_t lock;
+		struct list_head rq_lists[3];
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+	};
+	unsigned int cpu;
+	short unsigned int index_hw[3];
+	struct blk_mq_hw_ctx *hctxs[3];
+	struct request_queue *queue;
+	struct blk_mq_ctxs *ctxs;
+	struct kobject kobj;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+typedef __u32 req_flags_t;
+
+enum mq_rq_state {
+	MQ_RQ_IDLE = 0,
+	MQ_RQ_IN_FLIGHT = 1,
+	MQ_RQ_COMPLETE = 2,
+};
+
+enum rq_end_io_ret {
+	RQ_END_IO_NONE = 0,
+	RQ_END_IO_FREE = 1,
+};
+
+typedef enum rq_end_io_ret rq_end_io_fn(struct request *, blk_status_t);
+
+struct request {
+	struct request_queue *q;
+	struct blk_mq_ctx *mq_ctx;
+	struct blk_mq_hw_ctx *mq_hctx;
+	blk_opf_t cmd_flags;
+	req_flags_t rq_flags;
+	int tag;
+	int internal_tag;
+	unsigned int timeout;
+	unsigned int __data_len;
+	long: 32;
+	sector_t __sector;
+	struct bio *bio;
+	struct bio *biotail;
+	union {
+		struct list_head queuelist;
+		struct request *rq_next;
+	};
+	struct block_device *part;
+	long: 32;
+	u64 start_time_ns;
+	u64 io_start_time_ns;
+	short unsigned int stats_sectors;
+	short unsigned int nr_phys_segments;
+	short unsigned int nr_integrity_segments;
+	enum rw_hint write_hint;
+	short unsigned int ioprio;
+	enum mq_rq_state state;
+	atomic_t ref;
+	long unsigned int deadline;
+	union {
+		struct hlist_node hash;
+		struct llist_node ipi_list;
+	};
+	union {
+		struct rb_node rb_node;
+		struct bio_vec special_vec;
+	};
+	struct {
+		struct io_cq *icq;
+		void *priv[2];
+	} elv;
+	struct {
+		unsigned int seq;
+		rq_end_io_fn *saved_end_io;
+	} flush;
+	u64 fifo_time;
+	rq_end_io_fn *end_io;
+	void *end_io_data;
+};
+
+struct blk_mq_tags {
+	unsigned int nr_tags;
+	unsigned int nr_reserved_tags;
+	unsigned int active_queues;
+	struct sbitmap_queue bitmap_tags;
+	struct sbitmap_queue breserved_tags;
+	struct request **rqs;
+	struct request **static_rqs;
+	struct list_head page_list;
+	spinlock_t lock;
+};
+
+struct blk_flush_queue {
+	spinlock_t mq_flush_lock;
+	unsigned int flush_pending_idx: 1;
+	unsigned int flush_running_idx: 1;
+	blk_status_t rq_status;
+	long unsigned int flush_pending_since;
+	struct list_head flush_queue[2];
+	long unsigned int flush_data_in_flight;
+	struct request *flush_rq;
+};
+
+struct blk_mq_queue_map {
+	unsigned int *mq_map;
+	unsigned int nr_queues;
+	unsigned int queue_offset;
+};
+
+struct blk_mq_tag_set {
+	const struct blk_mq_ops *ops;
+	struct blk_mq_queue_map map[3];
+	unsigned int nr_maps;
+	unsigned int nr_hw_queues;
+	unsigned int queue_depth;
+	unsigned int reserved_tags;
+	unsigned int cmd_size;
+	int numa_node;
+	unsigned int timeout;
+	unsigned int flags;
+	void *driver_data;
+	struct blk_mq_tags **tags;
+	struct blk_mq_tags *shared_tags;
+	struct mutex tag_list_lock;
+	struct list_head tag_list;
+	struct srcu_struct *srcu;
+};
+
+enum {
+	QUEUE_FLAG_DYING = 0,
+	QUEUE_FLAG_NOMERGES = 1,
+	QUEUE_FLAG_SAME_COMP = 2,
+	QUEUE_FLAG_FAIL_IO = 3,
+	QUEUE_FLAG_NOXMERGES = 4,
+	QUEUE_FLAG_SAME_FORCE = 5,
+	QUEUE_FLAG_INIT_DONE = 6,
+	QUEUE_FLAG_STATS = 7,
+	QUEUE_FLAG_REGISTERED = 8,
+	QUEUE_FLAG_QUIESCED = 9,
+	QUEUE_FLAG_RQ_ALLOC_TIME = 10,
+	QUEUE_FLAG_HCTX_ACTIVE = 11,
+	QUEUE_FLAG_SQ_SCHED = 12,
+	QUEUE_FLAG_MAX = 13,
+};
+
+enum {
+	__RQF_STARTED = 0,
+	__RQF_FLUSH_SEQ = 1,
+	__RQF_MIXED_MERGE = 2,
+	__RQF_DONTPREP = 3,
+	__RQF_SCHED_TAGS = 4,
+	__RQF_USE_SCHED = 5,
+	__RQF_FAILED = 6,
+	__RQF_QUIET = 7,
+	__RQF_IO_STAT = 8,
+	__RQF_PM = 9,
+	__RQF_HASHED = 10,
+	__RQF_STATS = 11,
+	__RQF_SPECIAL_PAYLOAD = 12,
+	__RQF_ZONE_WRITE_PLUGGING = 13,
+	__RQF_TIMED_OUT = 14,
+	__RQF_RESV = 15,
+	__RQF_BITS = 16,
+};
+
+struct blk_mq_hw_ctx {
+	struct {
+		spinlock_t lock;
+		struct list_head dispatch;
+		long unsigned int state;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+	};
+	struct delayed_work run_work;
+	cpumask_var_t cpumask;
+	int next_cpu;
+	int next_cpu_batch;
+	long unsigned int flags;
+	void *sched_data;
+	struct request_queue *queue;
+	struct blk_flush_queue *fq;
+	void *driver_data;
+	struct sbitmap ctx_map;
+	struct blk_mq_ctx *dispatch_from;
+	unsigned int dispatch_busy;
+	short unsigned int type;
+	short unsigned int nr_ctx;
+	struct blk_mq_ctx **ctxs;
+	spinlock_t dispatch_wait_lock;
+	wait_queue_entry_t dispatch_wait;
+	atomic_t wait_index;
+	struct blk_mq_tags *tags;
+	struct blk_mq_tags *sched_tags;
+	unsigned int numa_node;
+	unsigned int queue_num;
+	atomic_t nr_active;
+	struct hlist_node cpuhp_online;
+	struct hlist_node cpuhp_dead;
+	struct kobject kobj;
+	struct list_head hctx_list;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+enum hctx_type {
+	HCTX_TYPE_DEFAULT = 0,
+	HCTX_TYPE_READ = 1,
+	HCTX_TYPE_POLL = 2,
+	HCTX_MAX_TYPES = 3,
+};
+
+struct blk_mq_queue_data {
+	struct request *rq;
+	bool last;
+};
+
+enum {
+	BLK_MQ_F_SHOULD_MERGE = 1,
+	BLK_MQ_F_TAG_QUEUE_SHARED = 2,
+	BLK_MQ_F_STACKING = 4,
+	BLK_MQ_F_TAG_HCTX_SHARED = 8,
+	BLK_MQ_F_BLOCKING = 16,
+	BLK_MQ_F_NO_SCHED = 32,
+	BLK_MQ_F_NO_SCHED_BY_DEFAULT = 64,
+	BLK_MQ_F_ALLOC_POLICY_START_BIT = 7,
+	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
+};
+
+enum blktrace_act {
+	__BLK_TA_QUEUE = 1,
+	__BLK_TA_BACKMERGE = 2,
+	__BLK_TA_FRONTMERGE = 3,
+	__BLK_TA_GETRQ = 4,
+	__BLK_TA_SLEEPRQ = 5,
+	__BLK_TA_REQUEUE = 6,
+	__BLK_TA_ISSUE = 7,
+	__BLK_TA_COMPLETE = 8,
+	__BLK_TA_PLUG = 9,
+	__BLK_TA_UNPLUG_IO = 10,
+	__BLK_TA_UNPLUG_TIMER = 11,
+	__BLK_TA_INSERT = 12,
+	__BLK_TA_SPLIT = 13,
+	__BLK_TA_BOUNCE = 14,
+	__BLK_TA_REMAP = 15,
+	__BLK_TA_ABORT = 16,
+	__BLK_TA_DRV_DATA = 17,
+	__BLK_TA_CGROUP = 256,
+};
+
+struct blk_mq_ctxs {
+	struct kobject kobj;
+	struct blk_mq_ctx *queue_ctx;
+};
+
+typedef unsigned int blk_insert_t;
+
+struct blk_mq_alloc_data {
+	struct request_queue *q;
+	blk_mq_req_flags_t flags;
+	unsigned int shallow_depth;
+	blk_opf_t cmd_flags;
+	req_flags_t rq_flags;
+	unsigned int nr_tags;
+	struct request **cached_rq;
+	struct blk_mq_ctx *ctx;
+	struct blk_mq_hw_ctx *hctx;
+};
+
+enum elv_merge {
+	ELEVATOR_NO_MERGE = 0,
+	ELEVATOR_FRONT_MERGE = 1,
+	ELEVATOR_BACK_MERGE = 2,
+	ELEVATOR_DISCARD_MERGE = 3,
+};
+
+struct elevator_mq_ops {
+	int (*init_sched)(struct request_queue *, struct elevator_type *);
+	void (*exit_sched)(struct elevator_queue *);
+	int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);
+	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
+	void (*depth_updated)(struct blk_mq_hw_ctx *);
+	bool (*allow_merge)(struct request_queue *, struct request *, struct bio *);
+	bool (*bio_merge)(struct request_queue *, struct bio *, unsigned int);
+	int (*request_merge)(struct request_queue *, struct request **, struct bio *);
+	void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);
+	void (*requests_merged)(struct request_queue *, struct request *, struct request *);
+	void (*limit_depth)(blk_opf_t, struct blk_mq_alloc_data *);
+	void (*prepare_request)(struct request *);
+	void (*finish_request)(struct request *);
+	void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, blk_insert_t);
+	struct request * (*dispatch_request)(struct blk_mq_hw_ctx *);
+	bool (*has_work)(struct blk_mq_hw_ctx *);
+	void (*completed_request)(struct request *, u64);
+	void (*requeue_request)(struct request *);
+	struct request * (*former_request)(struct request_queue *, struct request *);
+	struct request * (*next_request)(struct request_queue *, struct request *);
+	void (*init_icq)(struct io_cq *);
+	void (*exit_icq)(struct io_cq *);
+};
+
+struct elv_fs_entry;
+
+struct elevator_type {
+	struct kmem_cache *icq_cache;
+	struct elevator_mq_ops ops;
+	size_t icq_size;
+	size_t icq_align;
+	struct elv_fs_entry *elevator_attrs;
+	const char *elevator_name;
+	const char *elevator_alias;
+	struct module *elevator_owner;
+	char icq_cache_name[22];
+	struct list_head list;
+};
+
+struct elv_fs_entry {
+	struct attribute attr;
+	ssize_t (*show)(struct elevator_queue *, char *);
+	ssize_t (*store)(struct elevator_queue *, const char *, size_t);
+};
+
+enum blkg_iostat_type {
+	BLKG_IOSTAT_READ = 0,
+	BLKG_IOSTAT_WRITE = 1,
+	BLKG_IOSTAT_DISCARD = 2,
+	BLKG_IOSTAT_NR = 3,
+};
+
+struct blkcg_policy_data;
+
+struct blkcg {
+	struct cgroup_subsys_state css;
+	spinlock_t lock;
+	refcount_t online_pin;
+	atomic_t congestion_count;
+	struct xarray blkg_tree;
+	struct blkcg_gq *blkg_hint;
+	struct hlist_head blkg_list;
+	struct blkcg_policy_data *cpd[6];
+	struct list_head all_blkcgs_node;
+	struct llist_head *lhead;
+	struct list_head cgwb_list;
+	long: 32;
+};
+
+struct blkg_policy_data {
+	struct blkcg_gq *blkg;
+	int plid;
+	bool online;
+};
+
+struct blkcg_policy_data {
+	struct blkcg *blkcg;
+	int plid;
+};
+
+enum {
+	ICQ_EXITED = 4,
+	ICQ_DESTROYED = 8,
+};
+
+struct bvec_iter_all {
+	struct bio_vec bv;
+	int idx;
+	unsigned int done;
+};
+
+struct bio_integrity_payload {
+	struct bio *bip_bio;
+	struct bvec_iter bip_iter;
+	short unsigned int bip_vcnt;
+	short unsigned int bip_max_vcnt;
+	short unsigned int bip_flags;
+	struct bvec_iter bio_iter;
+	struct work_struct bip_work;
+	struct bio_vec *bip_vec;
+	struct bio_vec bip_inline_vecs[0];
+};
+
+enum {
+	PERCPU_REF_INIT_ATOMIC = 1,
+	PERCPU_REF_INIT_DEAD = 2,
+	PERCPU_REF_ALLOW_REINIT = 4,
+};
+
+struct rhltable {
+	struct rhashtable ht;
+};
+
+struct rhashtable_walker {
+	struct list_head list;
+	struct bucket_table *tbl;
+};
+
+struct rhashtable_iter {
+	struct rhashtable *ht;
+	struct rhash_head *p;
+	struct rhlist_head *list;
+	struct rhashtable_walker walker;
+	unsigned int slot;
+	unsigned int skip;
+	bool end_of_table;
+};
+
+union nested_table {
+	union nested_table *table;
+	struct rhash_lock_head *bucket;
+};
+
+struct once_work {
+	struct work_struct work;
+	struct static_key_true *key;
+	struct module *module;
+};
+
+struct genradix_root;
+
+struct __genradix {
+	struct genradix_root *root;
+};
+
+struct genradix_node {
+	union {
+		struct genradix_node *children[128];
+		u8 data[512];
+	};
+};
+
+struct genradix_iter {
+	size_t offset;
+	size_t pos;
+};
+
+enum string_size_units {
+	STRING_UNITS_10 = 0,
+	STRING_UNITS_2 = 1,
+	STRING_UNITS_MASK = 1,
+	STRING_UNITS_NO_SPACE = 1073741824,
+	STRING_UNITS_NO_BYTES = 2147483648,
+};
+
+struct strarray {
+	char **array;
+	size_t n;
+};
+
+enum assoc_array_walk_status {
+	assoc_array_walk_tree_empty = 0,
+	assoc_array_walk_found_terminal_node = 1,
+	assoc_array_walk_found_wrong_shortcut = 2,
+};
+
+struct assoc_array_walk_result {
+	struct {
+		struct assoc_array_node *node;
+		int level;
+		int slot;
+	} terminal_node;
+	struct {
+		struct assoc_array_shortcut *shortcut;
+		int level;
+		int sc_level;
+		long unsigned int sc_segments;
+		long unsigned int dissimilarity;
+	} wrong_shortcut;
+};
+
+struct assoc_array_delete_collapse_context {
+	struct assoc_array_node *node;
+	const void *skip_leaf;
+	int slot;
+};
+
+typedef long unsigned int uLong;
+
+struct internal_state;
+
+struct z_stream_s {
+	const Byte *next_in;
+	uLong avail_in;
+	uLong total_in;
+	Byte *next_out;
+	uLong avail_out;
+	uLong total_out;
+	char *msg;
+	struct internal_state *state;
+	void *workspace;
+	int data_type;
+	uLong adler;
+	uLong reserved;
+};
+
+typedef struct z_stream_s z_stream;
+
+typedef z_stream *z_streamp;
+
+typedef struct {
+	unsigned char op;
+	unsigned char bits;
+	short unsigned int val;
+} code;
+
+typedef enum {
+	HEAD = 0,
+	FLAGS = 1,
+	TIME = 2,
+	OS = 3,
+	EXLEN = 4,
+	EXTRA = 5,
+	NAME = 6,
+	COMMENT = 7,
+	HCRC = 8,
+	DICTID = 9,
+	DICT = 10,
+	TYPE = 11,
+	TYPEDO = 12,
+	STORED = 13,
+	COPY = 14,
+	TABLE = 15,
+	LENLENS = 16,
+	CODELENS = 17,
+	LEN = 18,
+	LENEXT = 19,
+	DIST = 20,
+	DISTEXT = 21,
+	MATCH = 22,
+	LIT = 23,
+	CHECK = 24,
+	LENGTH = 25,
+	DONE = 26,
+	BAD = 27,
+	MEM = 28,
+	SYNC = 29,
+} inflate_mode;
+
+struct inflate_state {
+	inflate_mode mode;
+	int last;
+	int wrap;
+	int havedict;
+	int flags;
+	unsigned int dmax;
+	long unsigned int check;
+	long unsigned int total;
+	unsigned int wbits;
+	unsigned int wsize;
+	unsigned int whave;
+	unsigned int write;
+	unsigned char *window;
+	long unsigned int hold;
+	unsigned int bits;
+	unsigned int length;
+	unsigned int offset;
+	unsigned int extra;
+	const code *lencode;
+	const code *distcode;
+	unsigned int lenbits;
+	unsigned int distbits;
+	unsigned int ncode;
+	unsigned int nlen;
+	unsigned int ndist;
+	unsigned int have;
+	code *next;
+	short unsigned int lens[320];
+	short unsigned int work[288];
+	code codes[2048];
+};
+
+union uu {
+	short unsigned int us;
+	unsigned char b[2];
+};
+
+typedef unsigned int uInt;
+
+typedef unsigned char uch;
+
+typedef short unsigned int ush;
+
+typedef long unsigned int ulg;
+
+struct ct_data_s {
+	union {
+		ush freq;
+		ush code;
+	} fc;
+	union {
+		ush dad;
+		ush len;
+	} dl;
+};
+
+typedef struct ct_data_s ct_data;
+
+struct static_tree_desc_s {
+	const ct_data *static_tree;
+	const int *extra_bits;
+	int extra_base;
+	int elems;
+	int max_length;
+};
+
+typedef struct static_tree_desc_s static_tree_desc;
+
+struct tree_desc_s {
+	ct_data *dyn_tree;
+	int max_code;
+	static_tree_desc *stat_desc;
+};
+
+typedef ush Pos;
+
+typedef unsigned int IPos;
+
+struct deflate_state {
+	z_streamp strm;
+	int status;
+	Byte *pending_buf;
+	ulg pending_buf_size;
+	Byte *pending_out;
+	int pending;
+	int noheader;
+	Byte data_type;
+	Byte method;
+	int last_flush;
+	uInt w_size;
+	uInt w_bits;
+	uInt w_mask;
+	Byte *window;
+	ulg window_size;
+	Pos *prev;
+	Pos *head;
+	uInt ins_h;
+	uInt hash_size;
+	uInt hash_bits;
+	uInt hash_mask;
+	uInt hash_shift;
+	long int block_start;
+	uInt match_length;
+	IPos prev_match;
+	int match_available;
+	uInt strstart;
+	uInt match_start;
+	uInt lookahead;
+	uInt prev_length;
+	uInt max_chain_length;
+	uInt max_lazy_match;
+	int level;
+	int strategy;
+	uInt good_match;
+	int nice_match;
+	struct ct_data_s dyn_ltree[573];
+	struct ct_data_s dyn_dtree[61];
+	struct ct_data_s bl_tree[39];
+	struct tree_desc_s l_desc;
+	struct tree_desc_s d_desc;
+	struct tree_desc_s bl_desc;
+	ush bl_count[16];
+	int heap[573];
+	int heap_len;
+	int heap_max;
+	uch depth[573];
+	uch *l_buf;
+	uInt lit_bufsize;
+	uInt last_lit;
+	ush *d_buf;
+	ulg opt_len;
+	ulg static_len;
+	ulg compressed_len;
+	uInt matches;
+	int last_eob_len;
+	ush bi_buf;
+	int bi_valid;
+};
+
+typedef struct deflate_state deflate_state;
+
+typedef enum {
+	need_more = 0,
+	block_done = 1,
+	finish_started = 2,
+	finish_done = 3,
+} block_state;
+
+typedef block_state (*compress_func)(deflate_state *, int);
+
+struct deflate_workspace {
+	deflate_state deflate_memory;
+	Byte *window_memory;
+	Pos *prev_memory;
+	Pos *head_memory;
+	char *overlay_memory;
+};
+
+typedef struct deflate_workspace deflate_workspace;
+
+struct config_s {
+	ush good_length;
+	ush max_lazy;
+	ush nice_length;
+	ush max_chain;
+	compress_func func;
+};
+
+typedef struct config_s config;
+
+typedef enum {
+	trustInput = 0,
+	checkMaxSymbolValue = 1,
+} HIST_checkInput_e;
+
+typedef int __kernel_ptrdiff_t;
+
+typedef __kernel_ptrdiff_t ptrdiff_t;
+
+typedef s16 int16_t;
+
+typedef enum {
+	ZSTD_c_compressionLevel = 100,
+	ZSTD_c_windowLog = 101,
+	ZSTD_c_hashLog = 102,
+	ZSTD_c_chainLog = 103,
+	ZSTD_c_searchLog = 104,
+	ZSTD_c_minMatch = 105,
+	ZSTD_c_targetLength = 106,
+	ZSTD_c_strategy = 107,
+	ZSTD_c_targetCBlockSize = 130,
+	ZSTD_c_enableLongDistanceMatching = 160,
+	ZSTD_c_ldmHashLog = 161,
+	ZSTD_c_ldmMinMatch = 162,
+	ZSTD_c_ldmBucketSizeLog = 163,
+	ZSTD_c_ldmHashRateLog = 164,
+	ZSTD_c_contentSizeFlag = 200,
+	ZSTD_c_checksumFlag = 201,
+	ZSTD_c_dictIDFlag = 202,
+	ZSTD_c_nbWorkers = 400,
+	ZSTD_c_jobSize = 401,
+	ZSTD_c_overlapLog = 402,
+	ZSTD_c_experimentalParam1 = 500,
+	ZSTD_c_experimentalParam2 = 10,
+	ZSTD_c_experimentalParam3 = 1000,
+	ZSTD_c_experimentalParam4 = 1001,
+	ZSTD_c_experimentalParam5 = 1002,
+	ZSTD_c_experimentalParam7 = 1004,
+	ZSTD_c_experimentalParam8 = 1005,
+	ZSTD_c_experimentalParam9 = 1006,
+	ZSTD_c_experimentalParam10 = 1007,
+	ZSTD_c_experimentalParam11 = 1008,
+	ZSTD_c_experimentalParam12 = 1009,
+	ZSTD_c_experimentalParam13 = 1010,
+	ZSTD_c_experimentalParam14 = 1011,
+	ZSTD_c_experimentalParam15 = 1012,
+	ZSTD_c_experimentalParam16 = 1013,
+	ZSTD_c_experimentalParam17 = 1014,
+	ZSTD_c_experimentalParam18 = 1015,
+	ZSTD_c_experimentalParam19 = 1016,
+} ZSTD_cParameter;
+
+typedef struct {
+	size_t error;
+	int lowerBound;
+	int upperBound;
+} ZSTD_bounds;
+
+typedef enum {
+	ZSTD_reset_session_only = 1,
+	ZSTD_reset_parameters = 2,
+	ZSTD_reset_session_and_parameters = 3,
+} ZSTD_ResetDirective;
+
+typedef ZSTD_CCtx ZSTD_CStream;
+
+typedef enum {
+	ZSTD_e_continue = 0,
+	ZSTD_e_flush = 1,
+	ZSTD_e_end = 2,
+} ZSTD_EndDirective;
+
+struct ZSTD_CDict_s {
+	const void *dictContent;
+	size_t dictContentSize;
+	ZSTD_dictContentType_e dictContentType;
+	U32 *entropyWorkspace;
+	ZSTD_cwksp workspace;
+	long: 32;
+	ZSTD_matchState_t matchState;
+	ZSTD_compressedBlockState_t cBlockState;
+	ZSTD_customMem customMem;
+	U32 dictID;
+	int compressionLevel;
+	ZSTD_paramSwitch_e useRowMatchFinder;
+	long: 32;
+};
+
+typedef enum {
+	ZSTD_dlm_byCopy = 0,
+	ZSTD_dlm_byRef = 1,
+} ZSTD_dictLoadMethod_e;
+
+typedef struct {
+	long long unsigned int ingested;
+	long long unsigned int consumed;
+	long long unsigned int produced;
+	long long unsigned int flushed;
+	unsigned int currentJobID;
+	unsigned int nbActiveWorkers;
+} ZSTD_frameProgression;
+
+typedef uint8_t U8;
+
+typedef int16_t S16;
+
+enum {
+	HUF_flags_bmi2 = 1,
+	HUF_flags_optimalDepth = 2,
+	HUF_flags_preferRepeat = 4,
+	HUF_flags_suspectUncompressible = 8,
+	HUF_flags_disableAsm = 16,
+	HUF_flags_disableFast = 32,
+};
+
+typedef struct {
+	U32 f1c;
+	U32 f1d;
+	U32 f7b;
+	U32 f7c;
+} ZSTD_cpuid_t;
+
+typedef enum {
+	ZSTD_no_overlap = 0,
+	ZSTD_overlap_src_before_dst = 1,
+} ZSTD_overlap_e;
+
+struct seqDef_s {
+	U32 offBase;
+	U16 litLength;
+	U16 mlBase;
+};
+
+typedef struct {
+	U32 idx;
+	U32 posInSequence;
+	size_t posInSrc;
+} ZSTD_sequencePosition;
+
+typedef enum {
+	ZSTD_dtlm_fast = 0,
+	ZSTD_dtlm_full = 1,
+} ZSTD_dictTableLoadMethod_e;
+
+typedef enum {
+	ZSTD_tfp_forCCtx = 0,
+	ZSTD_tfp_forCDict = 1,
+} ZSTD_tableFillPurpose_e;
+
+typedef enum {
+	ZSTD_noDict = 0,
+	ZSTD_extDict = 1,
+	ZSTD_dictMatchState = 2,
+	ZSTD_dedicatedDictSearch = 3,
+} ZSTD_dictMode_e;
+
+typedef enum {
+	ZSTD_cpm_noAttachDict = 0,
+	ZSTD_cpm_attachDict = 1,
+	ZSTD_cpm_createCDict = 2,
+	ZSTD_cpm_unknown = 3,
+} ZSTD_cParamMode_e;
+
+typedef size_t (*ZSTD_blockCompressor)(ZSTD_matchState_t *, seqStore_t *, U32 *, const void *, size_t);
+
+struct repcodes_s {
+	U32 rep[3];
+};
+
+typedef struct repcodes_s repcodes_t;
+
+typedef enum {
+	ZSTD_defaultDisallowed = 0,
+	ZSTD_defaultAllowed = 1,
+} ZSTD_defaultPolicy_e;
+
+typedef enum {
+	ZSTDcrp_makeClean = 0,
+	ZSTDcrp_leaveDirty = 1,
+} ZSTD_compResetPolicy_e;
+
+typedef enum {
+	ZSTDirp_continue = 0,
+	ZSTDirp_reset = 1,
+} ZSTD_indexResetPolicy_e;
+
+typedef enum {
+	ZSTD_resetTarget_CDict = 0,
+	ZSTD_resetTarget_CCtx = 1,
+} ZSTD_resetTarget_e;
+
+typedef struct {
+	U32 LLtype;
+	U32 Offtype;
+	U32 MLtype;
+	size_t size;
+	size_t lastCountSize;
+	int longOffsets;
+} ZSTD_symbolEncodingTypeStats_t;
+
+enum {
+	ZSTDbss_compress = 0,
+	ZSTDbss_noCompress = 1,
+};
+
+typedef struct {
+	U32 *splitLocations;
+	size_t idx;
+} seqStoreSplits;
+
+typedef size_t (*ZSTD_sequenceCopier)(ZSTD_CCtx *, ZSTD_sequencePosition *, const ZSTD_Sequence * const, size_t, const void *, size_t, ZSTD_paramSwitch_e);
+
+typedef enum {
+	ZSTD_error_no_error = 0,
+	ZSTD_error_GENERIC = 1,
+	ZSTD_error_prefix_unknown = 10,
+	ZSTD_error_version_unsupported = 12,
+	ZSTD_error_frameParameter_unsupported = 14,
+	ZSTD_error_frameParameter_windowTooLarge = 16,
+	ZSTD_error_corruption_detected = 20,
+	ZSTD_error_checksum_wrong = 22,
+	ZSTD_error_literals_headerWrong = 24,
+	ZSTD_error_dictionary_corrupted = 30,
+	ZSTD_error_dictionary_wrong = 32,
+	ZSTD_error_dictionaryCreation_failed = 34,
+	ZSTD_error_parameter_unsupported = 40,
+	ZSTD_error_parameter_combination_unsupported = 41,
+	ZSTD_error_parameter_outOfBound = 42,
+	ZSTD_error_tableLog_tooLarge = 44,
+	ZSTD_error_maxSymbolValue_tooLarge = 46,
+	ZSTD_error_maxSymbolValue_tooSmall = 48,
+	ZSTD_error_stabilityCondition_notRespected = 50,
+	ZSTD_error_stage_wrong = 60,
+	ZSTD_error_init_missing = 62,
+	ZSTD_error_memory_allocation = 64,
+	ZSTD_error_workSpace_tooSmall = 66,
+	ZSTD_error_dstSize_tooSmall = 70,
+	ZSTD_error_srcSize_wrong = 72,
+	ZSTD_error_dstBuffer_null = 74,
+	ZSTD_error_noForwardProgress_destFull = 80,
+	ZSTD_error_noForwardProgress_inputEmpty = 82,
+	ZSTD_error_frameIndex_tooLarge = 100,
+	ZSTD_error_seekableIO = 102,
+	ZSTD_error_dstBuffer_wrong = 104,
+	ZSTD_error_srcBuffer_wrong = 105,
+	ZSTD_error_sequenceProducer_failed = 106,
+	ZSTD_error_externalSequences_invalid = 107,
+	ZSTD_error_maxCode = 120,
+} ZSTD_ErrorCode;
+
+typedef ZSTD_DCtx ZSTD_DStream;
+
+struct ZSTD_DDict_s {
+	void *dictBuffer;
+	const void *dictContent;
+	size_t dictSize;
+	ZSTD_entropyDTables_t entropy;
+	U32 dictID;
+	U32 entropyPresent;
+	ZSTD_customMem cMem;
+};
+
+typedef ZSTD_ErrorCode zstd_error_code;
+
+typedef ZSTD_customMem zstd_custom_mem;
+
+typedef ZSTD_DDict zstd_ddict;
+
+typedef ZSTD_inBuffer zstd_in_buffer;
+
+typedef ZSTD_outBuffer zstd_out_buffer;
+
+typedef ZSTD_DStream zstd_dstream;
+
+typedef ZSTD_frameHeader zstd_frame_header;
+
+typedef enum {
+	ZSTD_d_windowLogMax = 100,
+	ZSTD_d_experimentalParam1 = 1000,
+	ZSTD_d_experimentalParam2 = 1001,
+	ZSTD_d_experimentalParam3 = 1002,
+	ZSTD_d_experimentalParam4 = 1003,
+	ZSTD_d_experimentalParam5 = 1004,
+	ZSTD_d_experimentalParam6 = 1005,
+} ZSTD_dParameter;
+
+typedef enum {
+	ZSTDnit_frameHeader = 0,
+	ZSTDnit_blockHeader = 1,
+	ZSTDnit_block = 2,
+	ZSTDnit_lastBlock = 3,
+	ZSTDnit_checksum = 4,
+	ZSTDnit_skippableFrame = 5,
+} ZSTD_nextInputType_e;
+
+typedef struct {
+	size_t nbBlocks;
+	size_t compressedSize;
+	long long unsigned int decompressedBound;
+} ZSTD_frameSizeInfo;
+
+typedef struct {
+	blockType_e blockType;
+	U32 lastBlock;
+	U32 origSize;
+} blockProperties_t;
+
+typedef enum {
+	not_streaming = 0,
+	is_streaming = 1,
+} streaming_operation;
+
+typedef size_t BitContainerType;
+
+typedef struct {
+	BitContainerType bitContainer;
+	unsigned int bitsConsumed;
+	const char *ptr;
+	const char *start;
+	const char *limitPtr;
+} BIT_DStream_t;
+
+typedef enum {
+	BIT_DStream_unfinished = 0,
+	BIT_DStream_endOfBuffer = 1,
+	BIT_DStream_completed = 2,
+	BIT_DStream_overflow = 3,
+} BIT_DStream_status;
+
+typedef struct {
+	U32 fastMode;
+	U32 tableLog;
+} ZSTD_seqSymbol_header;
+
+typedef struct {
+	size_t litLength;
+	size_t matchLength;
+	size_t offset;
+} seq_t;
+
+typedef struct {
+	size_t state;
+	const ZSTD_seqSymbol *table;
+} ZSTD_fseState;
+
+typedef struct {
+	BIT_DStream_t DStream;
+	ZSTD_fseState stateLL;
+	ZSTD_fseState stateOffb;
+	ZSTD_fseState stateML;
+	size_t prevOffset[3];
+} seqState_t;
+
+typedef enum {
+	ZSTD_lo_isRegularOffset = 0,
+	ZSTD_lo_isLongOffset = 1,
+} ZSTD_longOffset_e;
+
+typedef struct {
+	unsigned int longOffsetShare;
+	unsigned int maxNbAdditionalBits;
+} ZSTD_OffsetInfo;
+
+enum xz_mode {
+	XZ_SINGLE = 0,
+	XZ_PREALLOC = 1,
+	XZ_DYNALLOC = 2,
+};
+
+enum xz_ret {
+	XZ_OK = 0,
+	XZ_STREAM_END = 1,
+	XZ_UNSUPPORTED_CHECK = 2,
+	XZ_MEM_ERROR = 3,
+	XZ_MEMLIMIT_ERROR = 4,
+	XZ_FORMAT_ERROR = 5,
+	XZ_OPTIONS_ERROR = 6,
+	XZ_DATA_ERROR = 7,
+	XZ_BUF_ERROR = 8,
+};
+
+struct xz_buf {
+	const uint8_t *in;
+	size_t in_pos;
+	size_t in_size;
+	uint8_t *out;
+	size_t out_pos;
+	size_t out_size;
+};
+
+enum lzma_state {
+	STATE_LIT_LIT = 0,
+	STATE_MATCH_LIT_LIT = 1,
+	STATE_REP_LIT_LIT = 2,
+	STATE_SHORTREP_LIT_LIT = 3,
+	STATE_MATCH_LIT = 4,
+	STATE_REP_LIT = 5,
+	STATE_SHORTREP_LIT = 6,
+	STATE_LIT_MATCH = 7,
+	STATE_LIT_LONGREP = 8,
+	STATE_LIT_SHORTREP = 9,
+	STATE_NONLIT_MATCH = 10,
+	STATE_NONLIT_REP = 11,
+};
+
+struct dictionary {
+	uint8_t *buf;
+	size_t start;
+	size_t pos;
+	size_t full;
+	size_t limit;
+	size_t end;
+	uint32_t size;
+	uint32_t size_max;
+	uint32_t allocated;
+	enum xz_mode mode;
+};
+
+struct rc_dec {
+	uint32_t range;
+	uint32_t code;
+	uint32_t init_bytes_left;
+	const uint8_t *in;
+	size_t in_pos;
+	size_t in_limit;
+};
+
+struct lzma_len_dec {
+	uint16_t choice;
+	uint16_t choice2;
+	uint16_t low[128];
+	uint16_t mid[128];
+	uint16_t high[256];
+};
+
+struct lzma_dec {
+	uint32_t rep0;
+	uint32_t rep1;
+	uint32_t rep2;
+	uint32_t rep3;
+	enum lzma_state state;
+	uint32_t len;
+	uint32_t lc;
+	uint32_t literal_pos_mask;
+	uint32_t pos_mask;
+	uint16_t is_match[192];
+	uint16_t is_rep[12];
+	uint16_t is_rep0[12];
+	uint16_t is_rep1[12];
+	uint16_t is_rep2[12];
+	uint16_t is_rep0_long[192];
+	uint16_t dist_slot[256];
+	uint16_t dist_special[114];
+	uint16_t dist_align[16];
+	struct lzma_len_dec match_len_dec;
+	struct lzma_len_dec rep_len_dec;
+	uint16_t literal[12288];
+};
+
+enum lzma2_seq {
+	SEQ_CONTROL = 0,
+	SEQ_UNCOMPRESSED_1 = 1,
+	SEQ_UNCOMPRESSED_2 = 2,
+	SEQ_COMPRESSED_0 = 3,
+	SEQ_COMPRESSED_1 = 4,
+	SEQ_PROPERTIES = 5,
+	SEQ_LZMA_PREPARE = 6,
+	SEQ_LZMA_RUN = 7,
+	SEQ_COPY = 8,
+};
+
+struct lzma2_dec {
+	enum lzma2_seq sequence;
+	enum lzma2_seq next_sequence;
+	uint32_t uncompressed;
+	uint32_t compressed;
+	bool need_dict_reset;
+	bool need_props;
+};
+
+struct xz_dec_lzma2 {
+	struct rc_dec rc;
+	struct dictionary dict;
+	struct lzma2_dec lzma2;
+	struct lzma_dec lzma;
+	struct {
+		uint32_t size;
+		uint8_t buf[63];
+	} temp;
+};
+
+typedef int Int32;
+
+typedef struct {
+	SRes (*Read)(void *, void *, size_t *);
+} ISeqInStream;
+
+typedef UInt32 CLzRef;
+
+struct _CMatchFinder {
+	Byte *buffer;
+	UInt32 pos;
+	UInt32 posLimit;
+	UInt32 streamPos;
+	UInt32 lenLimit;
+	UInt32 cyclicBufferPos;
+	UInt32 cyclicBufferSize;
+	UInt32 matchMaxLen;
+	CLzRef *hash;
+	CLzRef *son;
+	UInt32 hashMask;
+	UInt32 cutValue;
+	Byte *bufferBase;
+	ISeqInStream *stream;
+	int streamEndWasReached;
+	UInt32 blockSize;
+	UInt32 keepSizeBefore;
+	UInt32 keepSizeAfter;
+	UInt32 numHashBytes;
+	int directInput;
+	size_t directInputRem;
+	int btMode;
+	int bigHash;
+	UInt32 historySize;
+	UInt32 fixedHashSize;
+	UInt32 hashSizeSum;
+	UInt32 numSons;
+	SRes result;
+	UInt32 crc[256];
+};
+
+typedef struct _CMatchFinder CMatchFinder;
+
+typedef void (*Mf_Init_Func)(void *);
+
+typedef Byte (*Mf_GetIndexByte_Func)(void *, Int32);
+
+typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *);
+
+typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *);
+
+typedef UInt32 (*Mf_GetMatches_Func)(void *, UInt32 *);
+
+typedef void (*Mf_Skip_Func)(void *, UInt32);
+
+struct _IMatchFinder {
+	Mf_Init_Func Init;
+	Mf_GetIndexByte_Func GetIndexByte;
+	Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
+	Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
+	Mf_GetMatches_Func GetMatches;
+	Mf_Skip_Func Skip;
+};
+
+typedef struct _IMatchFinder IMatchFinder;
+
+typedef short unsigned int UInt16;
+
+typedef int Bool;
+
+struct _CLzmaProps {
+	unsigned int lc;
+	unsigned int lp;
+	unsigned int pb;
+	UInt32 dicSize;
+};
+
+typedef struct _CLzmaProps CLzmaProps;
+
+typedef struct {
+	CLzmaProps prop;
+	UInt16 *probs;
+	Byte *dic;
+	const Byte *buf;
+	UInt32 range;
+	UInt32 code;
+	SizeT dicPos;
+	SizeT dicBufSize;
+	UInt32 processedPos;
+	UInt32 checkDicSize;
+	unsigned int state;
+	UInt32 reps[4];
+	unsigned int remainLen;
+	int needFlush;
+	int needInitState;
+	UInt32 numProbs;
+	unsigned int tempBufSize;
+	Byte tempBuf[20];
+} CLzmaDec;
+
+typedef enum {
+	DUMMY_ERROR = 0,
+	DUMMY_LIT = 1,
+	DUMMY_MATCH = 2,
+	DUMMY_REP = 3,
+} ELzmaDummy;
+
+struct ts_state {
+	unsigned int offset;
+	char cb[48];
+};
+
+struct ts_config;
+
+struct ts_ops {
+	const char *name;
+	struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
+	unsigned int (*find)(struct ts_config *, struct ts_state *);
+	void (*destroy)(struct ts_config *);
+	void * (*get_pattern)(struct ts_config *);
+	unsigned int (*get_pattern_len)(struct ts_config *);
+	struct module *owner;
+	struct list_head list;
+};
+
+struct ts_config {
+	struct ts_ops *ops;
+	int flags;
+	unsigned int (*get_next_block)(unsigned int, const u8 **, struct ts_config *, struct ts_state *);
+	void (*finish)(struct ts_config *, struct ts_state *);
+};
+
+struct ts_linear_state {
+	unsigned int len;
+	const void *data;
+};
+
+struct cpu_topology {
+	int thread_id;
+	int core_id;
+	int cluster_id;
+	int package_id;
+	cpumask_t thread_sibling;
+	cpumask_t core_sibling;
+	cpumask_t cluster_sibling;
+	cpumask_t llc_sibling;
+};
+
+struct cpu_rmap {
+	struct kref refcount;
+	u16 size;
+	void **obj;
+	struct {
+		u16 index;
+		u16 dist;
+	} near[0];
+};
+
+struct irq_glue {
+	struct irq_affinity_notify notify;
+	struct cpu_rmap *rmap;
+	u16 index;
+};
+
+typedef int (*of_irq_init_cb_t)(struct device_node *, struct device_node *);
+
+struct clk;
+
+struct clk_bulk_data {
+	const char *id;
+	struct clk *clk;
+};
+
+struct of_dev_auxdata {
+	char *compatible;
+	resource_size_t phys_addr;
+	char *name;
+	void *platform_data;
+};
+
+struct simple_pm_bus {
+	struct clk_bulk_data *clks;
+	int num_clks;
+};
+
+struct radix_tree_iter {
+	long unsigned int index;
+	long unsigned int next_index;
+	long unsigned int tags;
+	struct xa_node *node;
+};
+
+enum {
+	RADIX_TREE_ITER_TAG_MASK = 15,
+	RADIX_TREE_ITER_TAGGED = 16,
+	RADIX_TREE_ITER_CONTIG = 32,
+};
+
+enum device_link_state {
+	DL_STATE_NONE = -1,
+	DL_STATE_DORMANT = 0,
+	DL_STATE_AVAILABLE = 1,
+	DL_STATE_CONSUMER_PROBE = 2,
+	DL_STATE_ACTIVE = 3,
+	DL_STATE_SUPPLIER_UNBIND = 4,
+};
+
+struct pinctrl;
+
+struct pinctrl_state;
+
+struct dev_pin_info {
+	struct pinctrl *p;
+	struct pinctrl_state *default_state;
+	struct pinctrl_state *init_state;
+};
+
+struct device_link {
+	struct device *supplier;
+	struct list_head s_node;
+	struct device *consumer;
+	struct list_head c_node;
+	struct device link_dev;
+	enum device_link_state status;
+	u32 flags;
+	refcount_t rpm_active;
+	struct kref kref;
+	struct work_struct rm_work;
+	bool supplier_preactivated;
+	long: 32;
+};
+
+struct of_phandle_args {
+	struct device_node *np;
+	int args_count;
+	uint32_t args[16];
+};
+
+enum pinctrl_map_type {
+	PIN_MAP_TYPE_INVALID = 0,
+	PIN_MAP_TYPE_DUMMY_STATE = 1,
+	PIN_MAP_TYPE_MUX_GROUP = 2,
+	PIN_MAP_TYPE_CONFIGS_PIN = 3,
+	PIN_MAP_TYPE_CONFIGS_GROUP = 4,
+};
+
+struct pinctrl_map_mux {
+	const char *group;
+	const char *function;
+};
+
+struct pinctrl_map_configs {
+	const char *group_or_pin;
+	long unsigned int *configs;
+	unsigned int num_configs;
+};
+
+struct pinctrl_map {
+	const char *dev_name;
+	const char *name;
+	enum pinctrl_map_type type;
+	const char *ctrl_dev_name;
+	union {
+		struct pinctrl_map_mux mux;
+		struct pinctrl_map_configs configs;
+	} data;
+};
+
+enum pin_config_param {
+	PIN_CONFIG_BIAS_BUS_HOLD = 0,
+	PIN_CONFIG_BIAS_DISABLE = 1,
+	PIN_CONFIG_BIAS_HIGH_IMPEDANCE = 2,
+	PIN_CONFIG_BIAS_PULL_DOWN = 3,
+	PIN_CONFIG_BIAS_PULL_PIN_DEFAULT = 4,
+	PIN_CONFIG_BIAS_PULL_UP = 5,
+	PIN_CONFIG_DRIVE_OPEN_DRAIN = 6,
+	PIN_CONFIG_DRIVE_OPEN_SOURCE = 7,
+	PIN_CONFIG_DRIVE_PUSH_PULL = 8,
+	PIN_CONFIG_DRIVE_STRENGTH = 9,
+	PIN_CONFIG_DRIVE_STRENGTH_UA = 10,
+	PIN_CONFIG_INPUT_DEBOUNCE = 11,
+	PIN_CONFIG_INPUT_ENABLE = 12,
+	PIN_CONFIG_INPUT_SCHMITT = 13,
+	PIN_CONFIG_INPUT_SCHMITT_ENABLE = 14,
+	PIN_CONFIG_INPUT_SCHMITT_UV = 15,
+	PIN_CONFIG_MODE_LOW_POWER = 16,
+	PIN_CONFIG_MODE_PWM = 17,
+	PIN_CONFIG_OUTPUT = 18,
+	PIN_CONFIG_OUTPUT_ENABLE = 19,
+	PIN_CONFIG_OUTPUT_IMPEDANCE_OHMS = 20,
+	PIN_CONFIG_PERSIST_STATE = 21,
+	PIN_CONFIG_POWER_SOURCE = 22,
+	PIN_CONFIG_SKEW_DELAY = 23,
+	PIN_CONFIG_SLEEP_HARDWARE_STATE = 24,
+	PIN_CONFIG_SLEW_RATE = 25,
+	PIN_CONFIG_END = 127,
+	PIN_CONFIG_MAX = 255,
+};
+
+struct pin_config_item {
+	const enum pin_config_param param;
+	const char * const display;
+	const char * const format;
+	bool has_arg;
+};
+
+struct pinconf_generic_params {
+	const char * const property;
+	enum pin_config_param param;
+	u32 default_value;
+};
+
+struct pingroup {
+	const char *name;
+	const unsigned int *pins;
+	size_t npins;
+};
+
+struct pinctrl_pin_desc {
+	unsigned int number;
+	const char *name;
+	void *drv_data;
+};
+
+struct gpio_chip;
+
+struct pinctrl_gpio_range {
+	struct list_head node;
+	const char *name;
+	unsigned int id;
+	unsigned int base;
+	unsigned int pin_base;
+	unsigned int npins;
+	const unsigned int *pins;
+	struct gpio_chip *gc;
+};
+
+union gpio_irq_fwspec;
+
+struct gpio_irq_chip {
+	struct irq_chip *chip;
+	struct irq_domain *domain;
+	struct fwnode_handle *fwnode;
+	struct irq_domain *parent_domain;
+	int (*child_to_parent_hwirq)(struct gpio_chip *, unsigned int, unsigned int, unsigned int *, unsigned int *);
+	int (*populate_parent_alloc_arg)(struct gpio_chip *, union gpio_irq_fwspec *, unsigned int, unsigned int);
+	unsigned int (*child_offset_to_irq)(struct gpio_chip *, unsigned int);
+	struct irq_domain_ops child_irq_domain_ops;
+	irq_flow_handler_t handler;
+	unsigned int default_type;
+	struct lock_class_key *lock_key;
+	struct lock_class_key *request_key;
+	irq_flow_handler_t parent_handler;
+	union {
+		void *parent_handler_data;
+		void **parent_handler_data_array;
+	};
+	unsigned int num_parents;
+	unsigned int *parents;
+	unsigned int *map;
+	bool threaded;
+	bool per_parent_data;
+	bool initialized;
+	bool domain_is_allocated_externally;
+	int (*init_hw)(struct gpio_chip *);
+	void (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
+	long unsigned int *valid_mask;
+	unsigned int first;
+	void (*irq_enable)(struct irq_data *);
+	void (*irq_disable)(struct irq_data *);
+	void (*irq_unmask)(struct irq_data *);
+	void (*irq_mask)(struct irq_data *);
+};
+
+struct gpio_device;
+
+struct gpio_chip {
+	const char *label;
+	struct gpio_device *gpiodev;
+	struct device *parent;
+	struct fwnode_handle *fwnode;
+	struct module *owner;
+	int (*request)(struct gpio_chip *, unsigned int);
+	void (*free)(struct gpio_chip *, unsigned int);
+	int (*get_direction)(struct gpio_chip *, unsigned int);
+	int (*direction_input)(struct gpio_chip *, unsigned int);
+	int (*direction_output)(struct gpio_chip *, unsigned int, int);
+	int (*get)(struct gpio_chip *, unsigned int);
+	int (*get_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
+	void (*set)(struct gpio_chip *, unsigned int, int);
+	void (*set_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
+	int (*set_config)(struct gpio_chip *, unsigned int, long unsigned int);
+	int (*to_irq)(struct gpio_chip *, unsigned int);
+	void (*dbg_show)(struct seq_file *, struct gpio_chip *);
+	int (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
+	int (*add_pin_ranges)(struct gpio_chip *);
+	int (*en_hw_timestamp)(struct gpio_chip *, u32, long unsigned int);
+	int (*dis_hw_timestamp)(struct gpio_chip *, u32, long unsigned int);
+	int base;
+	u16 ngpio;
+	u16 offset;
+	const char * const *names;
+	bool can_sleep;
+	long unsigned int (*read_reg)(void *);
+	void (*write_reg)(void *, long unsigned int);
+	bool be_bits;
+	void *reg_dat;
+	void *reg_set;
+	void *reg_clr;
+	void *reg_dir_out;
+	void *reg_dir_in;
+	bool bgpio_dir_unreadable;
+	int bgpio_bits;
+	raw_spinlock_t bgpio_lock;
+	long unsigned int bgpio_data;
+	long unsigned int bgpio_dir;
+	struct gpio_irq_chip irq;
+	long unsigned int *valid_mask;
+	unsigned int of_gpio_n_cells;
+	int (*of_xlate)(struct gpio_chip *, const struct of_phandle_args *, u32 *);
+};
+
+struct pinctrl_dev;
+
+struct pinctrl_ops {
+	int (*get_groups_count)(struct pinctrl_dev *);
+	const char * (*get_group_name)(struct pinctrl_dev *, unsigned int);
+	int (*get_group_pins)(struct pinctrl_dev *, unsigned int, const unsigned int **, unsigned int *);
+	void (*pin_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
+	int (*dt_node_to_map)(struct pinctrl_dev *, struct device_node *, struct pinctrl_map **, unsigned int *);
+	void (*dt_free_map)(struct pinctrl_dev *, struct pinctrl_map *, unsigned int);
+};
+
+struct pinctrl_desc;
+
+struct pinctrl_dev {
+	struct list_head node;
+	struct pinctrl_desc *desc;
+	struct xarray pin_desc_tree;
+	struct xarray pin_group_tree;
+	unsigned int num_groups;
+	struct xarray pin_function_tree;
+	unsigned int num_functions;
+	struct list_head gpio_ranges;
+	struct device *dev;
+	struct module *owner;
+	void *driver_data;
+	struct pinctrl *p;
+	struct pinctrl_state *hog_default;
+	struct pinctrl_state *hog_sleep;
+	struct mutex mutex;
+	struct dentry *device_root;
+};
+
+struct pinmux_ops;
+
+struct pinconf_ops;
+
+struct pinctrl_desc {
+	const char *name;
+	const struct pinctrl_pin_desc *pins;
+	unsigned int npins;
+	const struct pinctrl_ops *pctlops;
+	const struct pinmux_ops *pmxops;
+	const struct pinconf_ops *confops;
+	struct module *owner;
+	unsigned int num_custom_params;
+	const struct pinconf_generic_params *custom_params;
+	const struct pin_config_item *custom_conf_items;
+	bool link_consumers;
+};
+
+struct pinmux_ops {
+	int (*request)(struct pinctrl_dev *, unsigned int);
+	int (*free)(struct pinctrl_dev *, unsigned int);
+	int (*get_functions_count)(struct pinctrl_dev *);
+	const char * (*get_function_name)(struct pinctrl_dev *, unsigned int);
+	int (*get_function_groups)(struct pinctrl_dev *, unsigned int, const char * const **, unsigned int *);
+	int (*set_mux)(struct pinctrl_dev *, unsigned int, unsigned int);
+	int (*gpio_request_enable)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int);
+	void (*gpio_disable_free)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int);
+	int (*gpio_set_direction)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int, bool);
+	bool strict;
+};
+
+struct pinconf_ops {
+	bool is_generic;
+	int (*pin_config_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
+	int (*pin_config_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
+	int (*pin_config_group_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
+	int (*pin_config_group_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
+	void (*pin_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
+	void (*pin_config_group_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
+	void (*pin_config_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, long unsigned int);
+};
+
+union gpio_irq_fwspec {
+	struct irq_fwspec fwspec;
+};
+
+struct pinctrl {
+	struct list_head node;
+	struct device *dev;
+	struct list_head states;
+	struct pinctrl_state *state;
+	struct list_head dt_maps;
+	struct kref users;
+};
+
+struct pinctrl_state {
+	struct list_head node;
+	const char *name;
+	struct list_head settings;
+};
+
+struct pinctrl_setting_mux {
+	unsigned int group;
+	unsigned int func;
+};
+
+struct pinctrl_setting_configs {
+	unsigned int group_or_pin;
+	long unsigned int *configs;
+	unsigned int num_configs;
+};
+
+struct pinctrl_setting {
+	struct list_head node;
+	enum pinctrl_map_type type;
+	struct pinctrl_dev *pctldev;
+	const char *dev_name;
+	union {
+		struct pinctrl_setting_mux mux;
+		struct pinctrl_setting_configs configs;
+	} data;
+};
+
+struct pin_desc {
+	struct pinctrl_dev *pctldev;
+	const char *name;
+	bool dynamic_name;
+	void *drv_data;
+	unsigned int mux_usecount;
+	const char *mux_owner;
+	const struct pinctrl_setting_mux *mux_setting;
+	const char *gpio_owner;
+};
+
+struct pinctrl_maps {
+	struct list_head node;
+	const struct pinctrl_map *maps;
+	unsigned int num_maps;
+};
+
+struct group_desc {
+	struct pingroup grp;
+	void *data;
+};
+
+struct pctldev;
+
+struct pinctrl_dt_map {
+	struct list_head node;
+	struct pinctrl_dev *pctldev;
+	struct pinctrl_map *map;
+	unsigned int num_maps;
+};
+
+typedef struct {
+	struct srcu_struct *lock;
+	int idx;
+} class_srcu_t;
+
+enum {
+	IRQCHIP_SET_TYPE_MASKED = 1,
+	IRQCHIP_EOI_IF_HANDLED = 2,
+	IRQCHIP_MASK_ON_SUSPEND = 4,
+	IRQCHIP_ONOFFLINE_ENABLED = 8,
+	IRQCHIP_SKIP_SET_WAKE = 16,
+	IRQCHIP_ONESHOT_SAFE = 32,
+	IRQCHIP_EOI_THREADED = 64,
+	IRQCHIP_SUPPORTS_LEVEL_MSI = 128,
+	IRQCHIP_SUPPORTS_NMI = 256,
+	IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND = 512,
+	IRQCHIP_AFFINITY_PRE_STARTUP = 1024,
+	IRQCHIP_IMMUTABLE = 2048,
+};
+
+struct gpio_array;
+
+struct gpio_desc;
+
+struct gpio_descs {
+	struct gpio_array *info;
+	unsigned int ndescs;
+	struct gpio_desc *desc[0];
+};
+
+struct gpio_array {
+	struct gpio_desc **desc;
+	unsigned int size;
+	struct gpio_chip *chip;
+	long unsigned int *get_mask;
+	long unsigned int *set_mask;
+	long unsigned int invert_mask[0];
+};
+
+struct gpio_desc_label;
+
+struct gpio_desc {
+	struct gpio_device *gdev;
+	long unsigned int flags;
+	struct gpio_desc_label *label;
+	const char *name;
+};
+
+enum gpiod_flags {
+	GPIOD_ASIS = 0,
+	GPIOD_IN = 1,
+	GPIOD_OUT_LOW = 3,
+	GPIOD_OUT_HIGH = 7,
+	GPIOD_OUT_LOW_OPEN_DRAIN = 11,
+	GPIOD_OUT_HIGH_OPEN_DRAIN = 15,
+};
+
+struct gpio_device {
+	struct device dev;
+	struct cdev chrdev;
+	int id;
+	struct device *mockdev;
+	struct module *owner;
+	struct gpio_chip *chip;
+	struct gpio_desc *descs;
+	struct srcu_struct desc_srcu;
+	unsigned int base;
+	u16 ngpio;
+	bool can_sleep;
+	const char *label;
+	void *data;
+	struct list_head list;
+	struct blocking_notifier_head line_state_notifier;
+	struct blocking_notifier_head device_notifier;
+	struct srcu_struct srcu;
+	struct list_head pin_ranges;
+};
+
+struct gpio_pin_range {
+	struct list_head node;
+	struct pinctrl_dev *pctldev;
+	struct pinctrl_gpio_range range;
+};
+
+enum gpio_lookup_flags {
+	GPIO_ACTIVE_HIGH = 0,
+	GPIO_ACTIVE_LOW = 1,
+	GPIO_OPEN_DRAIN = 2,
+	GPIO_OPEN_SOURCE = 4,
+	GPIO_PERSISTENT = 0,
+	GPIO_TRANSITORY = 8,
+	GPIO_PULL_UP = 16,
+	GPIO_PULL_DOWN = 32,
+	GPIO_PULL_DISABLE = 64,
+	GPIO_LOOKUP_FLAGS_DEFAULT = 0,
+};
+
+struct gpiod_lookup {
+	const char *key;
+	u16 chip_hwnum;
+	const char *con_id;
+	unsigned int idx;
+	long unsigned int flags;
+};
+
+struct gpiod_lookup_table {
+	struct list_head list;
+	const char *dev_id;
+	struct gpiod_lookup table[0];
+};
+
+struct gpiod_hog {
+	struct list_head list;
+	const char *chip_label;
+	u16 chip_hwnum;
+	const char *line_name;
+	long unsigned int lflags;
+	int dflags;
+};
+
+enum {
+	GPIOLINE_CHANGED_REQUESTED = 1,
+	GPIOLINE_CHANGED_RELEASED = 2,
+	GPIOLINE_CHANGED_CONFIG = 3,
+};
+
+struct gpio_desc_label {
+	struct callback_head rh;
+	char str[0];
+};
+
+struct gpio_chip_guard {
+	struct gpio_device *gdev;
+	struct gpio_chip *gc;
+	int idx;
+};
+
+typedef struct gpio_chip_guard class_gpio_chip_guard_t;
+
+struct trace_event_raw_gpio_direction {
+	struct trace_entry ent;
+	unsigned int gpio;
+	int in;
+	int err;
+	char __data[0];
+};
+
+struct trace_event_raw_gpio_value {
+	struct trace_entry ent;
+	unsigned int gpio;
+	int get;
+	int value;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_gpio_direction {};
+
+struct trace_event_data_offsets_gpio_value {};
+
+typedef void (*btf_trace_gpio_direction)(void *, unsigned int, int, int);
+
+typedef void (*btf_trace_gpio_value)(void *, unsigned int, int, int);
+
+struct gpiolib_seq_priv {
+	bool newline;
+	int idx;
+};
+
+enum pwm_polarity {
+	PWM_POLARITY_NORMAL = 0,
+	PWM_POLARITY_INVERSED = 1,
+};
+
+struct pwm_args {
+	u64 period;
+	enum pwm_polarity polarity;
+	long: 32;
+};
+
+struct pwm_state {
+	u64 period;
+	u64 duty_cycle;
+	enum pwm_polarity polarity;
+	bool enabled;
+	bool usage_power;
+};
+
+struct pwm_chip;
+
+struct pwm_device {
+	const char *label;
+	long unsigned int flags;
+	unsigned int hwpwm;
+	struct pwm_chip *chip;
+	struct pwm_args args;
+	struct pwm_state state;
+	struct pwm_state last;
+};
+
+struct pwm_ops;
+
+struct pwm_chip {
+	struct device dev;
+	const struct pwm_ops *ops;
+	struct module *owner;
+	unsigned int id;
+	unsigned int npwm;
+	struct pwm_device * (*of_xlate)(struct pwm_chip *, const struct of_phandle_args *);
+	bool atomic;
+	bool uses_pwmchip_alloc;
+	struct pwm_device pwms[0];
+};
+
+struct pwm_capture {
+	unsigned int period;
+	unsigned int duty_cycle;
+};
+
+struct pwm_ops {
+	int (*request)(struct pwm_chip *, struct pwm_device *);
+	void (*free)(struct pwm_chip *, struct pwm_device *);
+	int (*capture)(struct pwm_chip *, struct pwm_device *, struct pwm_capture *, long unsigned int);
+	int (*apply)(struct pwm_chip *, struct pwm_device *, const struct pwm_state *);
+	int (*get_state)(struct pwm_chip *, struct pwm_device *, struct pwm_state *);
+};
+
+struct iproc_pwmc {
+	void *base;
+	struct clk *clk;
+};
+
+typedef int (*device_match_t)(struct device *, const void *);
+
+enum led_brightness {
+	LED_OFF = 0,
+	LED_ON = 1,
+	LED_HALF = 127,
+	LED_FULL = 255,
+};
+
+struct led_lookup_data {
+	struct list_head list;
+	const char *provider;
+	const char *dev_id;
+	const char *con_id;
+};
+
+struct led_init_data {
+	struct fwnode_handle *fwnode;
+	const char *default_label;
+	const char *devicename;
+	bool devname_mandatory;
+};
+
+struct led_hw_trigger_type {
+	int dummy;
+};
+
+struct led_pattern;
+
+struct led_trigger;
+
+struct led_classdev {
+	const char *name;
+	unsigned int brightness;
+	unsigned int max_brightness;
+	unsigned int color;
+	int flags;
+	long unsigned int work_flags;
+	void (*brightness_set)(struct led_classdev *, enum led_brightness);
+	int (*brightness_set_blocking)(struct led_classdev *, enum led_brightness);
+	enum led_brightness (*brightness_get)(struct led_classdev *);
+	int (*blink_set)(struct led_classdev *, long unsigned int *, long unsigned int *);
+	int (*pattern_set)(struct led_classdev *, struct led_pattern *, u32, int);
+	int (*pattern_clear)(struct led_classdev *);
+	struct device *dev;
+	const struct attribute_group **groups;
+	struct list_head node;
+	const char *default_trigger;
+	long unsigned int blink_delay_on;
+	long unsigned int blink_delay_off;
+	struct timer_list blink_timer;
+	int blink_brightness;
+	int new_blink_brightness;
+	void (*flash_resume)(struct led_classdev *);
+	struct work_struct set_brightness_work;
+	int delayed_set_value;
+	long unsigned int delayed_delay_on;
+	long unsigned int delayed_delay_off;
+	struct rw_semaphore trigger_lock;
+	struct led_trigger *trigger;
+	struct list_head trig_list;
+	void *trigger_data;
+	bool activated;
+	struct led_hw_trigger_type *trigger_type;
+	const char *hw_control_trigger;
+	int (*hw_control_is_supported)(struct led_classdev *, long unsigned int);
+	int (*hw_control_set)(struct led_classdev *, long unsigned int);
+	int (*hw_control_get)(struct led_classdev *, long unsigned int *);
+	struct device * (*hw_control_get_device)(struct led_classdev *);
+	int brightness_hw_changed;
+	struct kernfs_node *brightness_hw_changed_kn;
+	struct mutex led_access;
+};
+
+struct led_pattern {
+	u32 delta_t;
+	int brightness;
+};
+
+struct led_trigger {
+	const char *name;
+	int (*activate)(struct led_classdev *);
+	void (*deactivate)(struct led_classdev *);
+	enum led_brightness brightness;
+	struct led_hw_trigger_type *trigger_type;
+	spinlock_t leddev_list_lock;
+	struct list_head led_cdevs;
+	struct list_head next_trig;
+	const struct attribute_group **groups;
+};
+
+struct heartbeat_trig_data {
+	struct led_classdev *led_cdev;
+	unsigned int phase;
+	unsigned int period;
+	struct timer_list timer;
+	unsigned int invert;
+};
+
+enum {
+	pci_channel_io_normal = 1,
+	pci_channel_io_frozen = 2,
+	pci_channel_io_perm_failure = 3,
+};
+
+typedef u32 pci_bus_addr_t;
+
+struct pci_bus_region {
+	pci_bus_addr_t start;
+	pci_bus_addr_t end;
+};
+
+struct driver_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct device_driver *, char *);
+	ssize_t (*store)(struct device_driver *, const char *, size_t);
+};
+
+struct iommu_fault_param;
+
+struct iommu_fwspec;
+
+struct iommu_device;
+
+struct dev_iommu {
+	struct mutex lock;
+	struct iommu_fault_param *fault_param;
+	struct iommu_fwspec *fwspec;
+	struct iommu_device *iommu_dev;
+	void *priv;
+	u32 max_pasids;
+	u32 attach_deferred: 1;
+	u32 pci_32bit_workaround: 1;
+	u32 require_direct: 1;
+	u32 shadow_on_flush: 1;
+};
+
+struct iova_bitmap;
+
+struct iommu_fault_page_request {
+	u32 flags;
+	u32 pasid;
+	u32 grpid;
+	u32 perm;
+	u64 addr;
+	u64 private_data[2];
+};
+
+struct iommu_fault {
+	u32 type;
+	long: 32;
+	struct iommu_fault_page_request prm;
+};
+
+struct iommu_page_response {
+	u32 pasid;
+	u32 grpid;
+	u32 code;
+};
+
+struct iopf_fault {
+	struct iommu_fault fault;
+	struct list_head list;
+};
+
+struct iommu_attach_handle;
+
+struct iopf_group {
+	struct iopf_fault last_fault;
+	struct list_head faults;
+	size_t fault_count;
+	struct list_head pending_node;
+	struct work_struct work;
+	struct iommu_attach_handle *attach_handle;
+	struct iommu_fault_param *fault_param;
+	struct list_head node;
+	u32 cookie;
+};
+
+struct iommu_domain;
+
+struct iommu_attach_handle {
+	struct iommu_domain *domain;
+};
+
+struct iopf_queue;
+
+struct iommu_fault_param {
+	struct mutex lock;
+	refcount_t users;
+	struct callback_head rcu;
+	struct device *dev;
+	struct iopf_queue *queue;
+	struct list_head queue_list;
+	struct list_head partial;
+	struct list_head faults;
+};
+
+struct iopf_queue {
+	struct workqueue_struct *wq;
+	struct list_head devices;
+	struct mutex lock;
+};
+
+typedef int (*iommu_fault_handler_t)(struct iommu_domain *, struct device *, long unsigned int, int, void *);
+
+struct iommu_domain_geometry {
+	dma_addr_t aperture_start;
+	dma_addr_t aperture_end;
+	bool force_aperture;
+};
+
+struct iommu_dma_cookie;
+
+struct iommu_domain_ops;
+
+struct iommu_dirty_ops;
+
+struct iommu_ops;
+
+struct iommu_domain {
+	unsigned int type;
+	const struct iommu_domain_ops *ops;
+	const struct iommu_dirty_ops *dirty_ops;
+	const struct iommu_ops *owner;
+	long unsigned int pgsize_bitmap;
+	struct iommu_domain_geometry geometry;
+	struct iommu_dma_cookie *iova_cookie;
+	int (*iopf_handler)(struct iopf_group *);
+	void *fault_data;
+	union {
+		struct {
+			iommu_fault_handler_t handler;
+			void *handler_token;
+		};
+		struct {
+			struct mm_struct *mm;
+			int users;
+			struct list_head next;
+		};
+	};
+};
+
+typedef unsigned int ioasid_t;
+
+struct iommu_iotlb_gather;
+
+struct iommu_user_data_array;
+
+struct iommu_domain_ops {
+	int (*attach_dev)(struct iommu_domain *, struct device *);
+	int (*set_dev_pasid)(struct iommu_domain *, struct device *, ioasid_t);
+	int (*map_pages)(struct iommu_domain *, long unsigned int, phys_addr_t, size_t, size_t, int, gfp_t, size_t *);
+	size_t (*unmap_pages)(struct iommu_domain *, long unsigned int, size_t, size_t, struct iommu_iotlb_gather *);
+	void (*flush_iotlb_all)(struct iommu_domain *);
+	int (*iotlb_sync_map)(struct iommu_domain *, long unsigned int, size_t);
+	void (*iotlb_sync)(struct iommu_domain *, struct iommu_iotlb_gather *);
+	int (*cache_invalidate_user)(struct iommu_domain *, struct iommu_user_data_array *);
+	phys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t);
+	bool (*enforce_cache_coherency)(struct iommu_domain *);
+	int (*enable_nesting)(struct iommu_domain *);
+	int (*set_pgtable_quirks)(struct iommu_domain *, long unsigned int);
+	void (*free)(struct iommu_domain *);
+};
+
+struct iommu_dirty_bitmap;
+
+struct iommu_dirty_ops {
+	int (*set_dirty_tracking)(struct iommu_domain *, bool);
+	int (*read_and_clear_dirty)(struct iommu_domain *, long unsigned int, size_t, long unsigned int, struct iommu_dirty_bitmap *);
+};
+
+enum iommu_cap {
+	IOMMU_CAP_CACHE_COHERENCY = 0,
+	IOMMU_CAP_NOEXEC = 1,
+	IOMMU_CAP_PRE_BOOT_PROTECTION = 2,
+	IOMMU_CAP_ENFORCE_CACHE_COHERENCY = 3,
+	IOMMU_CAP_DEFERRED_FLUSH = 4,
+	IOMMU_CAP_DIRTY_TRACKING = 5,
+};
+
+enum iommu_dev_features {
+	IOMMU_DEV_FEAT_SVA = 0,
+	IOMMU_DEV_FEAT_IOPF = 1,
+};
+
+struct iommu_user_data;
+
+struct iommu_ops {
+	bool (*capable)(struct device *, enum iommu_cap);
+	void * (*hw_info)(struct device *, u32 *, u32 *);
+	struct iommu_domain * (*domain_alloc)(unsigned int);
+	struct iommu_domain * (*domain_alloc_user)(struct device *, u32, struct iommu_domain *, const struct iommu_user_data *);
+	struct iommu_domain * (*domain_alloc_paging)(struct device *);
+	struct iommu_domain * (*domain_alloc_sva)(struct device *, struct mm_struct *);
+	struct iommu_device * (*probe_device)(struct device *);
+	void (*release_device)(struct device *);
+	void (*probe_finalize)(struct device *);
+	struct iommu_group * (*device_group)(struct device *);
+	void (*get_resv_regions)(struct device *, struct list_head *);
+	int (*of_xlate)(struct device *, const struct of_phandle_args *);
+	bool (*is_attach_deferred)(struct device *);
+	int (*dev_enable_feat)(struct device *, enum iommu_dev_features);
+	int (*dev_disable_feat)(struct device *, enum iommu_dev_features);
+	void (*page_response)(struct device *, struct iopf_fault *, struct iommu_page_response *);
+	int (*def_domain_type)(struct device *);
+	void (*remove_dev_pasid)(struct device *, ioasid_t, struct iommu_domain *);
+	const struct iommu_domain_ops *default_domain_ops;
+	long unsigned int pgsize_bitmap;
+	struct module *owner;
+	struct iommu_domain *identity_domain;
+	struct iommu_domain *blocked_domain;
+	struct iommu_domain *release_domain;
+	struct iommu_domain *default_domain;
+	u8 user_pasid_table: 1;
+};
+
+struct iommu_iotlb_gather {
+	long unsigned int start;
+	long unsigned int end;
+	size_t pgsize;
+	struct list_head freelist;
+	bool queued;
+};
+
+struct iommu_dirty_bitmap {
+	struct iova_bitmap *bitmap;
+	struct iommu_iotlb_gather *gather;
+};
+
+struct iommu_user_data {
+	unsigned int type;
+	void *uptr;
+	size_t len;
+};
+
+struct iommu_user_data_array {
+	unsigned int type;
+	void *uptr;
+	size_t entry_len;
+	u32 entry_num;
+};
+
+struct iommu_device {
+	struct list_head list;
+	const struct iommu_ops *ops;
+	struct fwnode_handle *fwnode;
+	struct device *dev;
+	struct iommu_group *singleton_group;
+	u32 max_pasids;
+};
+
+struct iommu_fwspec {
+	struct fwnode_handle *iommu_fwnode;
+	u32 flags;
+	unsigned int num_ids;
+	u32 ids[0];
+};
+
+struct pci_dynid {
+	struct list_head node;
+	struct pci_device_id id;
+};
+
+struct drv_dev_and_id {
+	struct pci_driver *drv;
+	struct pci_dev *dev;
+	const struct pci_device_id *id;
+};
+
+struct acpi_device;
+
+enum pci_mmap_state {
+	pci_mmap_io = 0,
+	pci_mmap_mem = 1,
+};
+
+enum pci_mmap_api {
+	PCI_MMAP_SYSFS = 0,
+	PCI_MMAP_PROCFS = 1,
+};
+
+struct pci_filp_private {
+	enum pci_mmap_state mmap_state;
+	int write_combine;
+};
+
+struct of_bus;
+
+struct of_pci_range_parser {
+	struct device_node *node;
+	struct of_bus *bus;
+	const __be32 *range;
+	const __be32 *end;
+	int na;
+	int ns;
+	int pna;
+	bool dma;
+};
+
+struct of_pci_range {
+	union {
+		u64 pci_addr;
+		u64 bus_addr;
+	};
+	u64 cpu_addr;
+	u64 size;
+	u32 flags;
+	long: 32;
+};
+
+struct bcma_device_id {
+	__u16 manuf;
+	__u16 id;
+	__u8 rev;
+	__u8 class;
+};
+
+struct regulator;
+
+struct phy_configure_opts_dp {
+	unsigned int link_rate;
+	unsigned int lanes;
+	unsigned int voltage[4];
+	unsigned int pre[4];
+	u8 ssc: 1;
+	u8 set_rate: 1;
+	u8 set_lanes: 1;
+	u8 set_voltages: 1;
+};
+
+struct phy_configure_opts_lvds {
+	unsigned int bits_per_lane_and_dclk_cycle;
+	long unsigned int differential_clk_rate;
+	unsigned int lanes;
+	bool is_slave;
+};
+
+struct phy_configure_opts_mipi_dphy {
+	unsigned int clk_miss;
+	unsigned int clk_post;
+	unsigned int clk_pre;
+	unsigned int clk_prepare;
+	unsigned int clk_settle;
+	unsigned int clk_term_en;
+	unsigned int clk_trail;
+	unsigned int clk_zero;
+	unsigned int d_term_en;
+	unsigned int eot;
+	unsigned int hs_exit;
+	unsigned int hs_prepare;
+	unsigned int hs_settle;
+	unsigned int hs_skip;
+	unsigned int hs_trail;
+	unsigned int hs_zero;
+	unsigned int init;
+	unsigned int lpx;
+	unsigned int ta_get;
+	unsigned int ta_go;
+	unsigned int ta_sure;
+	unsigned int wakeup;
+	long unsigned int hs_clk_rate;
+	long unsigned int lp_clk_rate;
+	unsigned char lanes;
+};
+
+enum phy_mode {
+	PHY_MODE_INVALID = 0,
+	PHY_MODE_USB_HOST = 1,
+	PHY_MODE_USB_HOST_LS = 2,
+	PHY_MODE_USB_HOST_FS = 3,
+	PHY_MODE_USB_HOST_HS = 4,
+	PHY_MODE_USB_HOST_SS = 5,
+	PHY_MODE_USB_DEVICE = 6,
+	PHY_MODE_USB_DEVICE_LS = 7,
+	PHY_MODE_USB_DEVICE_FS = 8,
+	PHY_MODE_USB_DEVICE_HS = 9,
+	PHY_MODE_USB_DEVICE_SS = 10,
+	PHY_MODE_USB_OTG = 11,
+	PHY_MODE_UFS_HS_A = 12,
+	PHY_MODE_UFS_HS_B = 13,
+	PHY_MODE_PCIE = 14,
+	PHY_MODE_ETHERNET = 15,
+	PHY_MODE_MIPI_DPHY = 16,
+	PHY_MODE_SATA = 17,
+	PHY_MODE_LVDS = 18,
+	PHY_MODE_DP = 19,
+};
+
+enum phy_media {
+	PHY_MEDIA_DEFAULT = 0,
+	PHY_MEDIA_SR = 1,
+	PHY_MEDIA_DAC = 2,
+};
+
+union phy_configure_opts {
+	struct phy_configure_opts_mipi_dphy mipi_dphy;
+	struct phy_configure_opts_dp dp;
+	struct phy_configure_opts_lvds lvds;
+};
+
+struct phy;
+
+struct phy_ops {
+	int (*init)(struct phy *);
+	int (*exit)(struct phy *);
+	int (*power_on)(struct phy *);
+	int (*power_off)(struct phy *);
+	int (*set_mode)(struct phy *, enum phy_mode, int);
+	int (*set_media)(struct phy *, enum phy_media);
+	int (*set_speed)(struct phy *, int);
+	int (*configure)(struct phy *, union phy_configure_opts *);
+	int (*validate)(struct phy *, enum phy_mode, int, union phy_configure_opts *);
+	int (*reset)(struct phy *);
+	int (*calibrate)(struct phy *);
+	int (*connect)(struct phy *, int);
+	int (*disconnect)(struct phy *, int);
+	void (*release)(struct phy *);
+	struct module *owner;
+};
+
+struct phy_attrs {
+	u32 bus_width;
+	u32 max_link_rate;
+	enum phy_mode mode;
+};
+
+struct phy {
+	struct device dev;
+	int id;
+	const struct phy_ops *ops;
+	struct mutex mutex;
+	int init_count;
+	int power_count;
+	struct phy_attrs attrs;
+	struct regulator *pwr;
+	struct dentry *debugfs;
+};
+
+struct bcma_device;
+
+struct bcma_chipcommon_pmu {
+	struct bcma_device *core;
+	u8 rev;
+	u32 crystalfreq;
+};
+
+struct bcma_bus;
+
+struct bcma_device {
+	struct bcma_bus *bus;
+	struct bcma_device_id id;
+	long: 32;
+	struct device dev;
+	struct device *dma_dev;
+	unsigned int irq;
+	bool dev_registered;
+	u8 core_index;
+	u8 core_unit;
+	u32 addr;
+	u32 addr_s[8];
+	u32 wrap;
+	void *io_addr;
+	void *io_wrap;
+	void *drvdata;
+	struct list_head list;
+};
+
+struct bcma_sflash {
+	bool present;
+	u32 blocksize;
+	u16 numblocks;
+	u32 size;
+};
+
+struct bcma_drv_cc {
+	struct bcma_device *core;
+	u32 status;
+	u32 capabilities;
+	u32 capabilities_ext;
+	u8 setup_done: 1;
+	u8 early_setup_done: 1;
+	u16 fast_pwrup_delay;
+	struct bcma_chipcommon_pmu pmu;
+	struct bcma_sflash sflash;
+	u32 ticks_per_ms;
+	struct platform_device *watchdog;
+	spinlock_t gpio_lock;
+	struct gpio_chip gpio;
+};
+
+struct bcma_drv_cc_b {
+	struct bcma_device *core;
+	u8 setup_done: 1;
+	void *mii;
+};
+
+struct bcma_drv_pci {
+	struct bcma_device *core;
+	u8 early_setup_done: 1;
+	u8 setup_done: 1;
+	u8 hostmode: 1;
+};
+
+struct bcma_drv_pcie2 {
+	struct bcma_device *core;
+	u16 reqsize;
+};
+
+struct bcma_drv_mips {
+	struct bcma_device *core;
+	u8 setup_done: 1;
+	u8 early_setup_done: 1;
+};
+
+struct bcma_drv_gmac_cmn {
+	struct bcma_device *core;
+	struct mutex phy_mutex;
+};
+
+struct ssb_sprom_core_pwr_info {
+	u8 itssi_2g;
+	u8 itssi_5g;
+	u8 maxpwr_2g;
+	u8 maxpwr_5gl;
+	u8 maxpwr_5g;
+	u8 maxpwr_5gh;
+	u16 pa_2g[4];
+	u16 pa_5gl[4];
+	u16 pa_5g[4];
+	u16 pa_5gh[4];
+};
+
+struct ssb_sprom {
+	u8 revision;
+	short: 0;
+	u8 il0mac[6];
+	u8 et0mac[6];
+	u8 et1mac[6];
+	u8 et2mac[6];
+	u8 et0phyaddr;
+	u8 et1phyaddr;
+	u8 et2phyaddr;
+	u8 et0mdcport;
+	u8 et1mdcport;
+	u8 et2mdcport;
+	u16 dev_id;
+	u16 board_rev;
+	u16 board_num;
+	u16 board_type;
+	u8 country_code;
+	char alpha2[2];
+	u8 leddc_on_time;
+	u8 leddc_off_time;
+	u8 ant_available_a;
+	u8 ant_available_bg;
+	u16 pa0b0;
+	u16 pa0b1;
+	u16 pa0b2;
+	u16 pa1b0;
+	u16 pa1b1;
+	u16 pa1b2;
+	u16 pa1lob0;
+	u16 pa1lob1;
+	u16 pa1lob2;
+	u16 pa1hib0;
+	u16 pa1hib1;
+	u16 pa1hib2;
+	u8 gpio0;
+	u8 gpio1;
+	u8 gpio2;
+	u8 gpio3;
+	u8 maxpwr_bg;
+	u8 maxpwr_al;
+	u8 maxpwr_a;
+	u8 maxpwr_ah;
+	u8 itssi_a;
+	u8 itssi_bg;
+	u8 tri2g;
+	u8 tri5gl;
+	u8 tri5g;
+	u8 tri5gh;
+	u8 txpid2g[4];
+	u8 txpid5gl[4];
+	u8 txpid5g[4];
+	u8 txpid5gh[4];
+	s8 rxpo2g;
+	s8 rxpo5g;
+	u8 rssisav2g;
+	u8 rssismc2g;
+	u8 rssismf2g;
+	u8 bxa2g;
+	u8 rssisav5g;
+	u8 rssismc5g;
+	u8 rssismf5g;
+	u8 bxa5g;
+	u16 cck2gpo;
+	u32 ofdm2gpo;
+	u32 ofdm5glpo;
+	u32 ofdm5gpo;
+	u32 ofdm5ghpo;
+	u32 boardflags;
+	u32 boardflags2;
+	u32 boardflags3;
+	u16 boardflags_lo;
+	u16 boardflags_hi;
+	u16 boardflags2_lo;
+	u16 boardflags2_hi;
+	struct ssb_sprom_core_pwr_info core_pwr_info[4];
+	struct {
+		s8 a0;
+		s8 a1;
+		s8 a2;
+		s8 a3;
+	} antenna_gain;
+	struct {
+		struct {
+			u8 tssipos;
+			u8 extpa_gain;
+			u8 pdet_range;
+			u8 tr_iso;
+			u8 antswlut;
+		} ghz2;
+		struct {
+			u8 tssipos;
+			u8 extpa_gain;
+			u8 pdet_range;
+			u8 tr_iso;
+			u8 antswlut;
+		} ghz5;
+	} fem;
+	u16 mcs2gpo[8];
+	u16 mcs5gpo[8];
+	u16 mcs5glpo[8];
+	u16 mcs5ghpo[8];
+	u8 opo;
+	u8 rxgainerr2ga[3];
+	u8 rxgainerr5gla[3];
+	u8 rxgainerr5gma[3];
+	u8 rxgainerr5gha[3];
+	u8 rxgainerr5gua[3];
+	u8 noiselvl2ga[3];
+	u8 noiselvl5gla[3];
+	u8 noiselvl5gma[3];
+	u8 noiselvl5gha[3];
+	u8 noiselvl5gua[3];
+	u8 regrev;
+	u8 txchain;
+	u8 rxchain;
+	u8 antswitch;
+	u16 cddpo;
+	u16 stbcpo;
+	u16 bw40po;
+	u16 bwduppo;
+	u8 tempthresh;
+	u8 tempoffset;
+	u16 rawtempsense;
+	u8 measpower;
+	u8 tempsense_slope;
+	u8 tempcorrx;
+	u8 tempsense_option;
+	u8 freqoffset_corr;
+	u8 iqcal_swp_dis;
+	u8 hw_iqcal_en;
+	u8 elna2g;
+	u8 elna5g;
+	u8 phycal_tempdelta;
+	u8 temps_period;
+	u8 temps_hysteresis;
+	u8 measpower1;
+	u8 measpower2;
+	u8 pcieingress_war;
+	u16 cckbw202gpo;
+	u16 cckbw20ul2gpo;
+	u32 legofdmbw202gpo;
+	u32 legofdmbw20ul2gpo;
+	u32 legofdmbw205glpo;
+	u32 legofdmbw20ul5glpo;
+	u32 legofdmbw205gmpo;
+	u32 legofdmbw20ul5gmpo;
+	u32 legofdmbw205ghpo;
+	u32 legofdmbw20ul5ghpo;
+	u32 mcsbw202gpo;
+	u32 mcsbw20ul2gpo;
+	u32 mcsbw402gpo;
+	u32 mcsbw205glpo;
+	u32 mcsbw20ul5glpo;
+	u32 mcsbw405glpo;
+	u32 mcsbw205gmpo;
+	u32 mcsbw20ul5gmpo;
+	u32 mcsbw405gmpo;
+	u32 mcsbw205ghpo;
+	u32 mcsbw20ul5ghpo;
+	u32 mcsbw405ghpo;
+	u16 mcs32po;
+	u16 legofdm40duppo;
+	u8 sar2g;
+	u8 sar5g;
+};
+
+enum bcma_hosttype {
+	BCMA_HOSTTYPE_PCI = 0,
+	BCMA_HOSTTYPE_SDIO = 1,
+	BCMA_HOSTTYPE_SOC = 2,
+};
+
+struct bcma_chipinfo {
+	u16 id;
+	u8 rev;
+	u8 pkg;
+};
+
+struct bcma_boardinfo {
+	u16 vendor;
+	u16 type;
+};
+
+struct bcma_host_ops {
+	u8 (*read8)(struct bcma_device *, u16);
+	u16 (*read16)(struct bcma_device *, u16);
+	u32 (*read32)(struct bcma_device *, u16);
+	void (*write8)(struct bcma_device *, u16, u8);
+	void (*write16)(struct bcma_device *, u16, u16);
+	void (*write32)(struct bcma_device *, u16, u32);
+	void (*block_read)(struct bcma_device *, void *, size_t, u16, u8);
+	void (*block_write)(struct bcma_device *, const void *, size_t, u16, u8);
+	u32 (*aread32)(struct bcma_device *, u16);
+	void (*awrite32)(struct bcma_device *, u16, u32);
+};
+
+struct bcma_bus {
+	struct device *dev;
+	void *mmio;
+	const struct bcma_host_ops *ops;
+	enum bcma_hosttype hosttype;
+	bool host_is_pcie2;
+	struct pci_dev *host_pci;
+	struct bcma_chipinfo chipinfo;
+	struct bcma_boardinfo boardinfo;
+	struct bcma_device *mapped_core;
+	struct list_head cores;
+	u8 nr_cores;
+	u8 num;
+	struct bcma_drv_cc drv_cc;
+	struct bcma_drv_cc_b drv_cc_b;
+	struct bcma_drv_pci drv_pci[2];
+	struct bcma_drv_pcie2 drv_pcie2;
+	struct bcma_drv_mips drv_mips;
+	struct bcma_drv_gmac_cmn drv_gmac_cmn;
+	struct ssb_sprom sprom;
+};
+
+struct bcma_driver {
+	const char *name;
+	const struct bcma_device_id *id_table;
+	int (*probe)(struct bcma_device *);
+	void (*remove)(struct bcma_device *);
+	int (*suspend)(struct bcma_device *);
+	int (*resume)(struct bcma_device *);
+	void (*shutdown)(struct bcma_device *);
+	struct device_driver drv;
+};
+
+enum iproc_pcie_type {
+	IPROC_PCIE_PAXB_BCMA = 0,
+	IPROC_PCIE_PAXB = 1,
+	IPROC_PCIE_PAXB_V2 = 2,
+	IPROC_PCIE_PAXC = 3,
+	IPROC_PCIE_PAXC_V2 = 4,
+};
+
+struct iproc_pcie_ob {
+	resource_size_t axi_offset;
+	unsigned int nr_windows;
+};
+
+struct iproc_pcie_ib {
+	unsigned int nr_regions;
+};
+
+struct iproc_msi;
+
+struct iproc_pcie_ob_map;
+
+struct iproc_pcie_ib_map;
+
+struct iproc_pcie {
+	struct device *dev;
+	enum iproc_pcie_type type;
+	u16 *reg_offsets;
+	void *base;
+	phys_addr_t base_addr;
+	struct resource mem;
+	struct phy *phy;
+	int (*map_irq)(const struct pci_dev *, u8, u8);
+	bool ep_is_internal;
+	bool iproc_cfg_read;
+	bool rej_unconfig_pf;
+	bool has_apb_err_disable;
+	bool fix_paxc_cap;
+	bool need_ob_cfg;
+	struct iproc_pcie_ob ob;
+	const struct iproc_pcie_ob_map *ob_map;
+	bool need_ib_cfg;
+	struct iproc_pcie_ib ib;
+	const struct iproc_pcie_ib_map *ib_map;
+	bool need_msi_steer;
+	struct iproc_msi *msi;
+};
+
+struct iproc_pcie_ob_map {
+	resource_size_t window_sizes[4];
+	unsigned int nr_sizes;
+};
+
+enum iproc_pcie_ib_map_type {
+	IPROC_PCIE_IB_MAP_MEM = 0,
+	IPROC_PCIE_IB_MAP_IO = 1,
+	IPROC_PCIE_IB_MAP_INVALID = 2,
+};
+
+struct iproc_pcie_ib_map {
+	enum iproc_pcie_ib_map_type type;
+	unsigned int size_unit;
+	resource_size_t region_sizes[9];
+	unsigned int nr_sizes;
+	unsigned int nr_windows;
+	u16 imap_addr_offset;
+	u16 imap_window_offset;
+};
+
+struct clk_core;
+
+struct clk_hw;
+
+struct clk_rate_request {
+	struct clk_core *core;
+	long unsigned int rate;
+	long unsigned int min_rate;
+	long unsigned int max_rate;
+	long unsigned int best_parent_rate;
+	struct clk_hw *best_parent_hw;
+};
+
+struct clk_init_data;
+
+struct clk_hw {
+	struct clk_core *core;
+	struct clk *clk;
+	const struct clk_init_data *init;
+};
+
+struct clk_duty {
+	unsigned int num;
+	unsigned int den;
+};
+
+struct clk_ops {
+	int (*prepare)(struct clk_hw *);
+	void (*unprepare)(struct clk_hw *);
+	int (*is_prepared)(struct clk_hw *);
+	void (*unprepare_unused)(struct clk_hw *);
+	int (*enable)(struct clk_hw *);
+	void (*disable)(struct clk_hw *);
+	int (*is_enabled)(struct clk_hw *);
+	void (*disable_unused)(struct clk_hw *);
+	int (*save_context)(struct clk_hw *);
+	void (*restore_context)(struct clk_hw *);
+	long unsigned int (*recalc_rate)(struct clk_hw *, long unsigned int);
+	long int (*round_rate)(struct clk_hw *, long unsigned int, long unsigned int *);
+	int (*determine_rate)(struct clk_hw *, struct clk_rate_request *);
+	int (*set_parent)(struct clk_hw *, u8);
+	u8 (*get_parent)(struct clk_hw *);
+	int (*set_rate)(struct clk_hw *, long unsigned int, long unsigned int);
+	int (*set_rate_and_parent)(struct clk_hw *, long unsigned int, long unsigned int, u8);
+	long unsigned int (*recalc_accuracy)(struct clk_hw *, long unsigned int);
+	int (*get_phase)(struct clk_hw *);
+	int (*set_phase)(struct clk_hw *, int);
+	int (*get_duty_cycle)(struct clk_hw *, struct clk_duty *);
+	int (*set_duty_cycle)(struct clk_hw *, struct clk_duty *);
+	int (*init)(struct clk_hw *);
+	void (*terminate)(struct clk_hw *);
+	void (*debug_init)(struct clk_hw *, struct dentry *);
+};
+
+struct clk_parent_data {
+	const struct clk_hw *hw;
+	const char *fw_name;
+	const char *name;
+	int index;
+};
+
+struct clk_init_data {
+	const char *name;
+	const struct clk_ops *ops;
+	const char * const *parent_names;
+	const struct clk_parent_data *parent_data;
+	const struct clk_hw **parent_hws;
+	u8 num_parents;
+	long unsigned int flags;
+};
+
+struct clk_div_table {
+	unsigned int val;
+	unsigned int div;
+};
+
+struct clk_divider {
+	struct clk_hw hw;
+	void *reg;
+	u8 shift;
+	u8 width;
+	u8 flags;
+	const struct clk_div_table *table;
+	spinlock_t *lock;
+};
+
+struct clk_gate {
+	struct clk_hw hw;
+	void *reg;
+	u8 bit_idx;
+	u8 flags;
+	spinlock_t *lock;
+};
+
+struct clk_composite {
+	struct clk_hw hw;
+	struct clk_ops ops;
+	struct clk_hw *mux_hw;
+	struct clk_hw *rate_hw;
+	struct clk_hw *gate_hw;
+	const struct clk_ops *mux_ops;
+	const struct clk_ops *rate_ops;
+	const struct clk_ops *gate_ops;
+};
+
+struct clk {
+	struct clk_core *core;
+	struct device *dev;
+	const char *dev_id;
+	const char *con_id;
+	long unsigned int min_rate;
+	long unsigned int max_rate;
+	unsigned int exclusive_count;
+	struct hlist_node clks_node;
+};
+
+struct clk_hw_onecell_data {
+	unsigned int num;
+	struct clk_hw *hws[0];
+};
+
+struct iproc_asiu_gate {
+	unsigned int offset;
+	unsigned int en_shift;
+};
+
+struct iproc_asiu_div {
+	unsigned int offset;
+	unsigned int en_shift;
+	unsigned int high_shift;
+	unsigned int high_width;
+	unsigned int low_shift;
+	unsigned int low_width;
+};
+
+struct iproc_asiu;
+
+struct iproc_asiu_clk {
+	struct clk_hw hw;
+	const char *name;
+	struct iproc_asiu *asiu;
+	long unsigned int rate;
+	struct iproc_asiu_div div;
+	struct iproc_asiu_gate gate;
+};
+
+struct iproc_asiu {
+	void *div_base;
+	void *gate_base;
+	struct clk_hw_onecell_data *clk_data;
+	struct iproc_asiu_clk *clks;
+};
+
+typedef void (*of_init_fn_1)(struct device_node *);
+
+struct iproc_pll_vco_param {
+	long unsigned int rate;
+	unsigned int ndiv_int;
+	unsigned int ndiv_frac;
+	unsigned int pdiv;
+};
+
+struct iproc_clk_reg_op {
+	unsigned int offset;
+	unsigned int shift;
+	unsigned int width;
+};
+
+struct iproc_pll_aon_pwr_ctrl {
+	unsigned int offset;
+	unsigned int pwr_width;
+	unsigned int pwr_shift;
+	unsigned int iso_shift;
+};
+
+struct iproc_pll_reset_ctrl {
+	unsigned int offset;
+	unsigned int reset_shift;
+	unsigned int p_reset_shift;
+};
+
+struct iproc_pll_dig_filter_ctrl {
+	unsigned int offset;
+	unsigned int ki_shift;
+	unsigned int ki_width;
+	unsigned int kp_shift;
+	unsigned int kp_width;
+	unsigned int ka_shift;
+	unsigned int ka_width;
+};
+
+struct iproc_pll_sw_ctrl {
+	unsigned int offset;
+	unsigned int shift;
+};
+
+struct iproc_pll_vco_ctrl {
+	unsigned int u_offset;
+	unsigned int l_offset;
+};
+
+struct iproc_pll_ctrl {
+	long unsigned int flags;
+	struct iproc_pll_aon_pwr_ctrl aon;
+	struct iproc_asiu_gate asiu;
+	struct iproc_pll_reset_ctrl reset;
+	struct iproc_pll_dig_filter_ctrl dig_filter;
+	struct iproc_pll_sw_ctrl sw_ctrl;
+	struct iproc_clk_reg_op ndiv_int;
+	struct iproc_clk_reg_op ndiv_frac;
+	struct iproc_clk_reg_op pdiv;
+	struct iproc_pll_vco_ctrl vco_ctrl;
+	struct iproc_clk_reg_op status;
+	struct iproc_clk_reg_op macro_mode;
+};
+
+struct iproc_clk_enable_ctrl {
+	unsigned int offset;
+	unsigned int enable_shift;
+	unsigned int hold_shift;
+	unsigned int bypass_shift;
+};
+
+struct iproc_clk_ctrl {
+	unsigned int channel;
+	long unsigned int flags;
+	struct iproc_clk_enable_ctrl enable;
+	struct iproc_clk_reg_op mdiv;
+};
+
+struct serial_icounter_struct {
+	int cts;
+	int dsr;
+	int rng;
+	int dcd;
+	int rx;
+	int tx;
+	int frame;
+	int overrun;
+	int parity;
+	int brk;
+	int buf_overrun;
+	int reserved[9];
+};
+
+struct serial_struct {
+	int type;
+	int line;
+	unsigned int port;
+	int irq;
+	int flags;
+	int xmit_fifo_size;
+	int custom_divisor;
+	int baud_base;
+	short unsigned int close_delay;
+	char io_type;
+	char reserved_char[1];
+	int hub6;
+	short unsigned int closing_wait;
+	short unsigned int closing_wait2;
+	unsigned char *iomem_base;
+	short unsigned int iomem_reg_shift;
+	unsigned int port_high;
+	long unsigned int iomap_base;
+};
+
+struct serial_rs485 {
+	__u32 flags;
+	__u32 delay_rts_before_send;
+	__u32 delay_rts_after_send;
+	union {
+		__u32 padding[5];
+		struct {
+			__u8 addr_recv;
+			__u8 addr_dest;
+			__u8 padding0[2];
+			__u32 padding1[4];
+		};
+	};
+};
+
+struct serial_iso7816 {
+	__u32 flags;
+	__u32 tg;
+	__u32 sc_fi;
+	__u32 sc_di;
+	__u32 clk;
+	__u32 reserved[5];
+};
+
+struct uart_port;
+
+struct uart_ops {
+	unsigned int (*tx_empty)(struct uart_port *);
+	void (*set_mctrl)(struct uart_port *, unsigned int);
+	unsigned int (*get_mctrl)(struct uart_port *);
+	void (*stop_tx)(struct uart_port *);
+	void (*start_tx)(struct uart_port *);
+	void (*throttle)(struct uart_port *);
+	void (*unthrottle)(struct uart_port *);
+	void (*send_xchar)(struct uart_port *, char);
+	void (*stop_rx)(struct uart_port *);
+	void (*start_rx)(struct uart_port *);
+	void (*enable_ms)(struct uart_port *);
+	void (*break_ctl)(struct uart_port *, int);
+	int (*startup)(struct uart_port *);
+	void (*shutdown)(struct uart_port *);
+	void (*flush_buffer)(struct uart_port *);
+	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
+	void (*set_ldisc)(struct uart_port *, struct ktermios *);
+	void (*pm)(struct uart_port *, unsigned int, unsigned int);
+	const char * (*type)(struct uart_port *);
+	void (*release_port)(struct uart_port *);
+	int (*request_port)(struct uart_port *);
+	void (*config_port)(struct uart_port *, int);
+	int (*verify_port)(struct uart_port *, struct serial_struct *);
+	int (*ioctl)(struct uart_port *, unsigned int, long unsigned int);
+};
+
+struct uart_icount {
+	__u32 cts;
+	__u32 dsr;
+	__u32 rng;
+	__u32 dcd;
+	__u32 rx;
+	__u32 tx;
+	__u32 frame;
+	__u32 overrun;
+	__u32 parity;
+	__u32 brk;
+	__u32 buf_overrun;
+};
+
+typedef u64 upf_t;
+
+typedef unsigned int upstat_t;
+
+struct uart_state;
+
+struct serial_port_device;
+
+struct uart_port {
+	spinlock_t lock;
+	long unsigned int iobase;
+	unsigned char *membase;
+	unsigned int (*serial_in)(struct uart_port *, int);
+	void (*serial_out)(struct uart_port *, int, int);
+	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
+	void (*set_ldisc)(struct uart_port *, struct ktermios *);
+	unsigned int (*get_mctrl)(struct uart_port *);
+	void (*set_mctrl)(struct uart_port *, unsigned int);
+	unsigned int (*get_divisor)(struct uart_port *, unsigned int, unsigned int *);
+	void (*set_divisor)(struct uart_port *, unsigned int, unsigned int, unsigned int);
+	int (*startup)(struct uart_port *);
+	void (*shutdown)(struct uart_port *);
+	void (*throttle)(struct uart_port *);
+	void (*unthrottle)(struct uart_port *);
+	int (*handle_irq)(struct uart_port *);
+	void (*pm)(struct uart_port *, unsigned int, unsigned int);
+	void (*handle_break)(struct uart_port *);
+	int (*rs485_config)(struct uart_port *, struct ktermios *, struct serial_rs485 *);
+	int (*iso7816_config)(struct uart_port *, struct serial_iso7816 *);
+	unsigned int ctrl_id;
+	unsigned int port_id;
+	unsigned int irq;
+	long unsigned int irqflags;
+	unsigned int uartclk;
+	unsigned int fifosize;
+	unsigned char x_char;
+	unsigned char regshift;
+	unsigned char iotype;
+	unsigned char quirks;
+	unsigned int read_status_mask;
+	unsigned int ignore_status_mask;
+	struct uart_state *state;
+	struct uart_icount icount;
+	struct console *cons;
+	upf_t flags;
+	upstat_t status;
+	bool hw_stopped;
+	unsigned int mctrl;
+	unsigned int frame_time;
+	unsigned int type;
+	const struct uart_ops *ops;
+	unsigned int custom_divisor;
+	unsigned int line;
+	unsigned int minor;
+	resource_size_t mapbase;
+	resource_size_t mapsize;
+	struct device *dev;
+	struct serial_port_device *port_dev;
+	long unsigned int sysrq;
+	u8 sysrq_ch;
+	unsigned char has_sysrq;
+	unsigned char sysrq_seq;
+	unsigned char hub6;
+	unsigned char suspended;
+	unsigned char console_reinit;
+	const char *name;
+	struct attribute_group *attr_group;
+	const struct attribute_group **tty_groups;
+	struct serial_rs485 rs485;
+	struct serial_rs485 rs485_supported;
+	struct gpio_desc *rs485_term_gpio;
+	struct gpio_desc *rs485_rx_during_tx_gpio;
+	struct serial_iso7816 iso7816;
+	void *private_data;
+};
+
+enum uart_pm_state {
+	UART_PM_STATE_ON = 0,
+	UART_PM_STATE_OFF = 3,
+	UART_PM_STATE_UNDEFINED = 4,
+};
+
+struct uart_state {
+	struct tty_port port;
+	enum uart_pm_state pm_state;
+	atomic_t refcount;
+	wait_queue_head_t remove_wait;
+	struct uart_port *uart_port;
+};
+
+struct serial_port_device {
+	struct device dev;
+	struct uart_port *port;
+	unsigned int tx_enabled: 1;
+};
+
+struct uart_driver {
+	struct module *owner;
+	const char *driver_name;
+	const char *dev_name;
+	int major;
+	int minor;
+	int nr;
+	struct console *cons;
+	struct uart_state *state;
+	struct tty_driver *tty_driver;
+};
+
+struct serial_ctrl_device {
+	struct device dev;
+	struct ida port_ida;
+	long: 32;
+};
+
+struct pnp_device_id {
+	__u8 id[8];
+	kernel_ulong_t driver_data;
+};
+
+struct pnp_card_device_id {
+	__u8 id[8];
+	kernel_ulong_t driver_data;
+	struct {
+		__u8 id[8];
+	} devs[8];
+};
+
+struct pnp_protocol;
+
+struct pnp_id;
+
+struct pnp_card {
+	struct device dev;
+	unsigned char number;
+	struct list_head global_list;
+	struct list_head protocol_list;
+	struct list_head devices;
+	struct pnp_protocol *protocol;
+	struct pnp_id *id;
+	char name[50];
+	unsigned char pnpver;
+	unsigned char productver;
+	unsigned int serial;
+	unsigned char checksum;
+	struct proc_dir_entry *procdir;
+	long: 32;
+};
+
+struct pnp_dev;
+
+struct pnp_protocol {
+	struct list_head protocol_list;
+	char *name;
+	int (*get)(struct pnp_dev *);
+	int (*set)(struct pnp_dev *);
+	int (*disable)(struct pnp_dev *);
+	bool (*can_wakeup)(struct pnp_dev *);
+	int (*suspend)(struct pnp_dev *, pm_message_t);
+	int (*resume)(struct pnp_dev *);
+	unsigned char number;
+	struct device dev;
+	struct list_head cards;
+	struct list_head devices;
+};
+
+struct pnp_id {
+	char id[8];
+	struct pnp_id *next;
+};
+
+struct pnp_card_driver;
+
+struct pnp_card_link {
+	struct pnp_card *card;
+	struct pnp_card_driver *driver;
+	void *driver_data;
+	pm_message_t pm_state;
+};
+
+struct pnp_driver {
+	const char *name;
+	const struct pnp_device_id *id_table;
+	unsigned int flags;
+	int (*probe)(struct pnp_dev *, const struct pnp_device_id *);
+	void (*remove)(struct pnp_dev *);
+	void (*shutdown)(struct pnp_dev *);
+	int (*suspend)(struct pnp_dev *, pm_message_t);
+	int (*resume)(struct pnp_dev *);
+	struct device_driver driver;
+};
+
+struct pnp_card_driver {
+	struct list_head global_list;
+	char *name;
+	const struct pnp_card_device_id *id_table;
+	unsigned int flags;
+	int (*probe)(struct pnp_card_link *, const struct pnp_card_device_id *);
+	void (*remove)(struct pnp_card_link *);
+	int (*suspend)(struct pnp_card_link *, pm_message_t);
+	int (*resume)(struct pnp_card_link *);
+	struct pnp_driver link;
+};
+
+struct pnp_dev {
+	struct device dev;
+	u64 dma_mask;
+	unsigned int number;
+	int status;
+	struct list_head global_list;
+	struct list_head protocol_list;
+	struct list_head card_list;
+	struct list_head rdev_list;
+	struct pnp_protocol *protocol;
+	struct pnp_card *card;
+	struct pnp_driver *driver;
+	struct pnp_card_link *card_link;
+	struct pnp_id *id;
+	int active;
+	int capabilities;
+	unsigned int num_dependent_sets;
+	struct list_head resources;
+	struct list_head options;
+	char name[50];
+	int flags;
+	struct proc_dir_entry *procent;
+	void *data;
+};
+
+enum {
+	KERNEL_PARAM_FL_UNSAFE = 1,
+	KERNEL_PARAM_FL_HWPARAM = 2,
+};
+
+enum hwparam_type {
+	hwparam_ioport = 0,
+	hwparam_iomem = 1,
+	hwparam_ioport_or_iomem = 2,
+	hwparam_irq = 3,
+	hwparam_dma = 4,
+	hwparam_dma_addr = 5,
+	hwparam_other = 6,
+};
+
+struct uart_8250_port;
+
+struct plat_serial8250_port {
+	long unsigned int iobase;
+	void *membase;
+	resource_size_t mapbase;
+	resource_size_t mapsize;
+	unsigned int uartclk;
+	unsigned int irq;
+	long unsigned int irqflags;
+	void *private_data;
+	unsigned char regshift;
+	unsigned char iotype;
+	unsigned char hub6;
+	unsigned char has_sysrq;
+	unsigned int type;
+	upf_t flags;
+	u16 bugs;
+	unsigned int (*serial_in)(struct uart_port *, int);
+	void (*serial_out)(struct uart_port *, int, int);
+	u32 (*dl_read)(struct uart_8250_port *);
+	void (*dl_write)(struct uart_8250_port *, u32);
+	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
+	void (*set_ldisc)(struct uart_port *, struct ktermios *);
+	unsigned int (*get_mctrl)(struct uart_port *);
+	int (*handle_irq)(struct uart_port *);
+	void (*pm)(struct uart_port *, unsigned int, unsigned int);
+	void (*handle_break)(struct uart_port *);
+	long: 32;
+};
+
+struct mctrl_gpios;
+
+struct uart_8250_dma;
+
+struct uart_8250_ops;
+
+struct uart_8250_em485;
+
+struct uart_8250_port {
+	struct uart_port port;
+	struct timer_list timer;
+	struct list_head list;
+	u32 capabilities;
+	u16 bugs;
+	unsigned int tx_loadsz;
+	unsigned char acr;
+	unsigned char fcr;
+	unsigned char ier;
+	unsigned char lcr;
+	unsigned char mcr;
+	unsigned char cur_iotype;
+	unsigned int rpm_tx_active;
+	unsigned char canary;
+	unsigned char probe;
+	struct mctrl_gpios *gpios;
+	u16 lsr_saved_flags;
+	u16 lsr_save_mask;
+	unsigned char msr_saved_flags;
+	struct uart_8250_dma *dma;
+	const struct uart_8250_ops *ops;
+	u32 (*dl_read)(struct uart_8250_port *);
+	void (*dl_write)(struct uart_8250_port *, u32);
+	struct uart_8250_em485 *em485;
+	void (*rs485_start_tx)(struct uart_8250_port *);
+	void (*rs485_stop_tx)(struct uart_8250_port *);
+	struct delayed_work overrun_backoff;
+	u32 overrun_backoff_time_ms;
+};
+
+enum {
+	PLAT8250_DEV_LEGACY = -1,
+	PLAT8250_DEV_PLATFORM = 0,
+	PLAT8250_DEV_PLATFORM1 = 1,
+	PLAT8250_DEV_PLATFORM2 = 2,
+	PLAT8250_DEV_FOURPORT = 3,
+	PLAT8250_DEV_ACCENT = 4,
+	PLAT8250_DEV_BOCA = 5,
+	PLAT8250_DEV_EXAR_ST16C554 = 6,
+	PLAT8250_DEV_HUB6 = 7,
+	PLAT8250_DEV_AU1X00 = 8,
+	PLAT8250_DEV_SM501 = 9,
+};
+
+struct uart_8250_ops {
+	int (*setup_irq)(struct uart_8250_port *);
+	void (*release_irq)(struct uart_8250_port *);
+	void (*setup_timer)(struct uart_8250_port *);
+};
+
+struct uart_8250_em485 {
+	struct hrtimer start_tx_timer;
+	struct hrtimer stop_tx_timer;
+	struct hrtimer *active_timer;
+	struct uart_8250_port *port;
+	unsigned int tx_stopped: 1;
+	long: 32;
+};
+
+struct dma_chan;
+
+typedef bool (*dma_filter_fn)(struct dma_chan *, void *);
+
+enum dma_transfer_direction {
+	DMA_MEM_TO_MEM = 0,
+	DMA_MEM_TO_DEV = 1,
+	DMA_DEV_TO_MEM = 2,
+	DMA_DEV_TO_DEV = 3,
+	DMA_TRANS_NONE = 4,
+};
+
+enum dma_slave_buswidth {
+	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
+	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
+	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
+	DMA_SLAVE_BUSWIDTH_3_BYTES = 3,
+	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
+	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
+	DMA_SLAVE_BUSWIDTH_16_BYTES = 16,
+	DMA_SLAVE_BUSWIDTH_32_BYTES = 32,
+	DMA_SLAVE_BUSWIDTH_64_BYTES = 64,
+	DMA_SLAVE_BUSWIDTH_128_BYTES = 128,
+};
+
+struct dma_slave_config {
+	enum dma_transfer_direction direction;
+	phys_addr_t src_addr;
+	phys_addr_t dst_addr;
+	enum dma_slave_buswidth src_addr_width;
+	enum dma_slave_buswidth dst_addr_width;
+	u32 src_maxburst;
+	u32 dst_maxburst;
+	u32 src_port_window_size;
+	u32 dst_port_window_size;
+	bool device_fc;
+	void *peripheral_config;
+	size_t peripheral_size;
+};
+
+typedef s32 dma_cookie_t;
+
+struct uart_8250_dma {
+	int (*tx_dma)(struct uart_8250_port *);
+	int (*rx_dma)(struct uart_8250_port *);
+	void (*prepare_tx_dma)(struct uart_8250_port *);
+	void (*prepare_rx_dma)(struct uart_8250_port *);
+	dma_filter_fn fn;
+	void *rx_param;
+	void *tx_param;
+	struct dma_slave_config rxconf;
+	struct dma_slave_config txconf;
+	struct dma_chan *rxchan;
+	struct dma_chan *txchan;
+	phys_addr_t rx_dma_addr;
+	phys_addr_t tx_dma_addr;
+	dma_addr_t rx_addr;
+	dma_addr_t tx_addr;
+	dma_cookie_t rx_cookie;
+	dma_cookie_t tx_cookie;
+	void *rx_buf;
+	size_t rx_size;
+	size_t tx_size;
+	unsigned char tx_running;
+	unsigned char tx_err;
+	unsigned char rx_running;
+};
+
+enum dma_status {
+	DMA_COMPLETE = 0,
+	DMA_IN_PROGRESS = 1,
+	DMA_PAUSED = 2,
+	DMA_ERROR = 3,
+	DMA_OUT_OF_ORDER = 4,
+};
+
+enum dma_transaction_type {
+	DMA_MEMCPY = 0,
+	DMA_XOR = 1,
+	DMA_PQ = 2,
+	DMA_XOR_VAL = 3,
+	DMA_PQ_VAL = 4,
+	DMA_MEMSET = 5,
+	DMA_MEMSET_SG = 6,
+	DMA_INTERRUPT = 7,
+	DMA_PRIVATE = 8,
+	DMA_ASYNC_TX = 9,
+	DMA_SLAVE = 10,
+	DMA_CYCLIC = 11,
+	DMA_INTERLEAVE = 12,
+	DMA_COMPLETION_NO_ORDER = 13,
+	DMA_REPEAT = 14,
+	DMA_LOAD_EOT = 15,
+	DMA_TX_TYPE_END = 16,
+};
+
+struct data_chunk {
+	size_t size;
+	size_t icg;
+	size_t dst_icg;
+	size_t src_icg;
+};
+
+struct dma_interleaved_template {
+	dma_addr_t src_start;
+	dma_addr_t dst_start;
+	enum dma_transfer_direction dir;
+	bool src_inc;
+	bool dst_inc;
+	bool src_sgl;
+	bool dst_sgl;
+	size_t numf;
+	size_t frame_size;
+	struct data_chunk sgl[0];
+};
+
+struct dma_vec {
+	dma_addr_t addr;
+	size_t len;
+};
+
+enum dma_ctrl_flags {
+	DMA_PREP_INTERRUPT = 1,
+	DMA_CTRL_ACK = 2,
+	DMA_PREP_PQ_DISABLE_P = 4,
+	DMA_PREP_PQ_DISABLE_Q = 8,
+	DMA_PREP_CONTINUE = 16,
+	DMA_PREP_FENCE = 32,
+	DMA_CTRL_REUSE = 64,
+	DMA_PREP_CMD = 128,
+	DMA_PREP_REPEAT = 256,
+	DMA_PREP_LOAD_EOT = 512,
+};
+
+enum sum_check_bits {
+	SUM_CHECK_P = 0,
+	SUM_CHECK_Q = 1,
+};
+
+enum sum_check_flags {
+	SUM_CHECK_P_RESULT = 1,
+	SUM_CHECK_Q_RESULT = 2,
+};
+
+typedef struct {
+	long unsigned int bits[1];
+} dma_cap_mask_t;
+
+enum dma_desc_metadata_mode {
+	DESC_METADATA_NONE = 0,
+	DESC_METADATA_CLIENT = 1,
+	DESC_METADATA_ENGINE = 2,
+};
+
+struct dma_chan_percpu {
+	long unsigned int memcpy_count;
+	long unsigned int bytes_transferred;
+};
+
+struct dma_router {
+	struct device *dev;
+	void (*route_free)(struct device *, void *);
+};
+
+struct dma_device;
+
+struct dma_chan_dev;
+
+struct dma_chan {
+	struct dma_device *device;
+	struct device *slave;
+	dma_cookie_t cookie;
+	dma_cookie_t completed_cookie;
+	int chan_id;
+	struct dma_chan_dev *dev;
+	const char *name;
+	char *dbg_client_name;
+	struct list_head device_node;
+	struct dma_chan_percpu *local;
+	int client_count;
+	int table_count;
+	struct dma_router *router;
+	void *route_data;
+	void *private;
+};
+
+struct dma_slave_map;
+
+struct dma_filter {
+	dma_filter_fn fn;
+	int mapcnt;
+	const struct dma_slave_map *map;
+};
+
+enum dmaengine_alignment {
+	DMAENGINE_ALIGN_1_BYTE = 0,
+	DMAENGINE_ALIGN_2_BYTES = 1,
+	DMAENGINE_ALIGN_4_BYTES = 2,
+	DMAENGINE_ALIGN_8_BYTES = 3,
+	DMAENGINE_ALIGN_16_BYTES = 4,
+	DMAENGINE_ALIGN_32_BYTES = 5,
+	DMAENGINE_ALIGN_64_BYTES = 6,
+	DMAENGINE_ALIGN_128_BYTES = 7,
+	DMAENGINE_ALIGN_256_BYTES = 8,
+};
+
+enum dma_residue_granularity {
+	DMA_RESIDUE_GRANULARITY_DESCRIPTOR = 0,
+	DMA_RESIDUE_GRANULARITY_SEGMENT = 1,
+	DMA_RESIDUE_GRANULARITY_BURST = 2,
+};
+
+struct dma_async_tx_descriptor;
+
+struct dma_slave_caps;
+
+struct dma_tx_state;
+
+struct dma_device {
+	struct kref ref;
+	unsigned int chancnt;
+	unsigned int privatecnt;
+	struct list_head channels;
+	struct list_head global_node;
+	struct dma_filter filter;
+	dma_cap_mask_t cap_mask;
+	enum dma_desc_metadata_mode desc_metadata_modes;
+	short unsigned int max_xor;
+	short unsigned int max_pq;
+	enum dmaengine_alignment copy_align;
+	enum dmaengine_alignment xor_align;
+	enum dmaengine_alignment pq_align;
+	enum dmaengine_alignment fill_align;
+	int dev_id;
+	struct device *dev;
+	struct module *owner;
+	struct ida chan_ida;
+	u32 src_addr_widths;
+	u32 dst_addr_widths;
+	u32 directions;
+	u32 min_burst;
+	u32 max_burst;
+	u32 max_sg_burst;
+	bool descriptor_reuse;
+	enum dma_residue_granularity residue_granularity;
+	int (*device_alloc_chan_resources)(struct dma_chan *);
+	int (*device_router_config)(struct dma_chan *);
+	void (*device_free_chan_resources)(struct dma_chan *);
+	struct dma_async_tx_descriptor * (*device_prep_dma_memcpy)(struct dma_chan *, dma_addr_t, dma_addr_t, size_t, long unsigned int);
+	struct dma_async_tx_descriptor * (*device_prep_dma_xor)(struct dma_chan *, dma_addr_t, dma_addr_t *, unsigned int, size_t, long unsigned int);
+	struct dma_async_tx_descriptor * (*device_prep_dma_xor_val)(struct dma_chan *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, long unsigned int);
+	struct dma_async_tx_descriptor * (*device_prep_dma_pq)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, long unsigned int);
+	struct dma_async_tx_descriptor * (*device_prep_dma_pq_val)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, long unsigned int);
+	struct dma_async_tx_descriptor * (*device_prep_dma_memset)(struct dma_chan *, dma_addr_t, int, size_t, long unsigned int);
+	struct dma_async_tx_descriptor * (*device_prep_dma_memset_sg)(struct dma_chan *, struct scatterlist *, unsigned int, int, long unsigned int);
+	struct dma_async_tx_descriptor * (*device_prep_dma_interrupt)(struct dma_chan *, long unsigned int);
+	struct dma_async_tx_descriptor * (*device_prep_peripheral_dma_vec)(struct dma_chan *, const struct dma_vec *, size_t, enum dma_transfer_direction, long unsigned int);
+	struct dma_async_tx_descriptor * (*device_prep_slave_sg)(struct dma_chan *, struct scatterlist *, unsigned int, enum dma_transfer_direction, long unsigned int, void *);
+	struct dma_async_tx_descriptor * (*device_prep_dma_cyclic)(struct dma_chan *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, long unsigned int);
+	struct dma_async_tx_descriptor * (*device_prep_interleaved_dma)(struct dma_chan *, struct dma_interleaved_template *, long unsigned int);
+	struct dma_async_tx_descriptor * (*device_prep_dma_imm_data)(struct dma_chan *, dma_addr_t, u64, long unsigned int);
+	void (*device_caps)(struct dma_chan *, struct dma_slave_caps *);
+	int (*device_config)(struct dma_chan *, struct dma_slave_config *);
+	int (*device_pause)(struct dma_chan *);
+	int (*device_resume)(struct dma_chan *);
+	int (*device_terminate_all)(struct dma_chan *);
+	void (*device_synchronize)(struct dma_chan *);
+	enum dma_status (*device_tx_status)(struct dma_chan *, dma_cookie_t, struct dma_tx_state *);
+	void (*device_issue_pending)(struct dma_chan *);
+	void (*device_release)(struct dma_device *);
+	void (*dbg_summary_show)(struct seq_file *, struct dma_device *);
+	struct dentry *dbg_dev_root;
+};
+
+struct dma_chan_dev {
+	struct dma_chan *chan;
+	long: 32;
+	struct device device;
+	int dev_id;
+	bool chan_dma_dev;
+};
+
+struct dma_slave_caps {
+	u32 src_addr_widths;
+	u32 dst_addr_widths;
+	u32 directions;
+	u32 min_burst;
+	u32 max_burst;
+	u32 max_sg_burst;
+	bool cmd_pause;
+	bool cmd_resume;
+	bool cmd_terminate;
+	enum dma_residue_granularity residue_granularity;
+	bool descriptor_reuse;
+};
+
+typedef void (*dma_async_tx_callback)(void *);
+
+enum dmaengine_tx_result {
+	DMA_TRANS_NOERROR = 0,
+	DMA_TRANS_READ_FAILED = 1,
+	DMA_TRANS_WRITE_FAILED = 2,
+	DMA_TRANS_ABORTED = 3,
+};
+
+struct dmaengine_result {
+	enum dmaengine_tx_result result;
+	u32 residue;
+};
+
+typedef void (*dma_async_tx_callback_result)(void *, const struct dmaengine_result *);
+
+struct dmaengine_unmap_data {
+	u8 map_cnt;
+	u8 to_cnt;
+	u8 from_cnt;
+	u8 bidi_cnt;
+	struct device *dev;
+	struct kref kref;
+	size_t len;
+	dma_addr_t addr[0];
+};
+
+struct dma_descriptor_metadata_ops {
+	int (*attach)(struct dma_async_tx_descriptor *, void *, size_t);
+	void * (*get_ptr)(struct dma_async_tx_descriptor *, size_t *, size_t *);
+	int (*set_len)(struct dma_async_tx_descriptor *, size_t);
+};
+
+struct dma_async_tx_descriptor {
+	dma_cookie_t cookie;
+	enum dma_ctrl_flags flags;
+	dma_addr_t phys;
+	struct dma_chan *chan;
+	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *);
+	int (*desc_free)(struct dma_async_tx_descriptor *);
+	dma_async_tx_callback callback;
+	dma_async_tx_callback_result callback_result;
+	void *callback_param;
+	struct dmaengine_unmap_data *unmap;
+	enum dma_desc_metadata_mode desc_metadata_mode;
+	struct dma_descriptor_metadata_ops *metadata_ops;
+};
+
+struct dma_tx_state {
+	dma_cookie_t last;
+	dma_cookie_t used;
+	u32 residue;
+	u32 in_flight_bytes;
+};
+
+struct dma_slave_map {
+	const char *devname;
+	const char *slave;
+	void *param;
+};
+
+struct old_serial_port {
+	unsigned int uart;
+	unsigned int baud_base;
+	unsigned int port;
+	unsigned int irq;
+	upf_t flags;
+	unsigned char io_type;
+	unsigned char *iomem_base;
+	short unsigned int iomem_reg_shift;
+	long: 32;
+};
+
+typedef void (*serial8250_isa_config_fn)(int, struct uart_port *, u32 *);
+
+struct clk_notifier_data {
+	struct clk *clk;
+	long unsigned int old_rate;
+	long unsigned int new_rate;
+};
+
+struct reset_control;
+
+struct of_serial_info {
+	struct clk *clk;
+	struct reset_control *rst;
+	int type;
+	int line;
+	struct notifier_block clk_notifier;
+};
+
+struct hwrng {
+	const char *name;
+	int (*init)(struct hwrng *);
+	void (*cleanup)(struct hwrng *);
+	int (*data_present)(struct hwrng *, int);
+	int (*data_read)(struct hwrng *, u32 *);
+	int (*read)(struct hwrng *, void *, size_t, bool);
+	long unsigned int priv;
+	short unsigned int quality;
+	struct list_head list;
+	struct kref ref;
+	struct completion cleanup_done;
+	struct completion dying;
+};
+
+struct bcm2835_rng_priv {
+	struct hwrng rng;
+	void *base;
+	bool mask_interrupts;
+	struct clk *clk;
+	struct reset_control *reset;
+};
+
+struct bcm2835_rng_of_data {
+	bool mask_interrupts;
+};
+
+typedef long unsigned int cycles_t;
+
+struct lrng_drng_cb {
+	const char * (*drng_name)();
+	void * (*drng_alloc)(u32);
+	void (*drng_dealloc)(void *);
+	int (*drng_seed)(void *, const u8 *, u32);
+	int (*drng_generate)(void *, u8 *, u32);
+};
+
+struct lrng_hash_cb {
+	const char * (*hash_name)();
+	void * (*hash_alloc)();
+	void (*hash_dealloc)(void *);
+	u32 (*hash_digestsize)(void *);
+	int (*hash_init)(struct shash_desc *, void *);
+	int (*hash_update)(struct shash_desc *, const u8 *, u32);
+	int (*hash_final)(struct shash_desc *, u8 *);
+	void (*hash_desc_zero)(struct shash_desc *);
+};
+
+struct lrng_drng {
+	void *drng;
+	void *hash;
+	const struct lrng_drng_cb *drng_cb;
+	const struct lrng_hash_cb *hash_cb;
+	atomic_t requests;
+	atomic_t requests_since_fully_seeded;
+	long unsigned int last_seeded;
+	bool fully_seeded;
+	bool force_reseed;
+	rwlock_t hash_lock;
+	struct mutex lock;
+	spinlock_t spin_lock;
+};
+
+enum lrng_internal_es {
+	lrng_int_es_irq = 0,
+	lrng_int_es_sched = 1,
+	lrng_int_es_last = 2,
+};
+
+enum lrng_external_es {
+	lrng_ext_link = 1,
+	lrng_ext_es_jitter = 2,
+	lrng_ext_es_cpu = 3,
+	lrng_ext_es_aux = 4,
+	lrng_ext_es_last = 5,
+};
+
+struct entropy_buf {
+	u8 e[160];
+	u32 now;
+	u32 e_bits[5];
+};
+
+struct lrng_es_cb {
+	const char *name;
+	void (*get_ent)(struct entropy_buf *, u32, bool);
+	u32 (*curr_entropy)(u32);
+	u32 (*max_entropy)();
+	void (*state)(unsigned char *, size_t);
+	void (*reset)();
+	int (*switch_hash)(struct lrng_drng *, int, const struct lrng_hash_cb *, void *, const struct lrng_hash_cb *);
+};
+
+struct lrng_state {
+	bool can_invalidate;
+	bool perform_seedwork;
+	bool lrng_operational;
+	bool lrng_fully_seeded;
+	bool lrng_min_seeded;
+	bool all_online_numa_node_seeded;
+	atomic_t boot_entropy_thresh;
+	struct mutex reseed_in_progress;
+	struct work_struct lrng_seed_work;
+};
+
+struct seed {
+	long unsigned int data[16];
+	struct new_utsname utsname;
+};
+
+enum lrng_external_noise_source {
+	lrng_noise_source_hw = 0,
+	lrng_noise_source_user = 1,
+};
+
+struct miscdevice {
+	int minor;
+	const char *name;
+	const struct file_operations *fops;
+	struct list_head list;
+	struct device *parent;
+	struct device *this_device;
+	const struct attribute_group **groups;
+	const char *nodename;
+	umode_t mode;
+};
+
+struct component_ops {
+	int (*bind)(struct device *, struct device *, void *);
+	void (*unbind)(struct device *, struct device *, void *);
+};
+
+struct component_master_ops {
+	int (*bind)(struct device *);
+	void (*unbind)(struct device *);
+};
+
+struct component;
+
+struct component_match_array {
+	void *data;
+	int (*compare)(struct device *, void *);
+	int (*compare_typed)(struct device *, int, void *);
+	void (*release)(struct device *, void *);
+	struct component *component;
+	bool duplicate;
+};
+
+struct aggregate_device;
+
+struct component {
+	struct list_head node;
+	struct aggregate_device *adev;
+	bool bound;
+	const struct component_ops *ops;
+	int subcomponent;
+	struct device *dev;
+};
+
+struct component_match {
+	size_t alloc;
+	size_t num;
+	struct component_match_array *compare;
+};
+
+struct aggregate_device {
+	struct list_head node;
+	bool bound;
+	const struct component_master_ops *ops;
+	struct device *parent;
+	struct component_match *match;
+};
+
+struct klist_node;
+
+struct klist {
+	spinlock_t k_lock;
+	struct list_head k_list;
+	void (*get)(struct klist_node *);
+	void (*put)(struct klist_node *);
+};
+
+struct klist_node {
+	void *n_klist;
+	struct list_head n_node;
+	struct kref n_ref;
+};
+
+struct klist_iter {
+	struct klist *i_klist;
+	struct klist_node *i_cur;
+};
+
+struct bus_attribute {
+	struct attribute attr;
+	ssize_t (*show)(const struct bus_type *, char *);
+	ssize_t (*store)(const struct bus_type *, const char *, size_t);
+};
+
+enum bus_notifier_event {
+	BUS_NOTIFY_ADD_DEVICE = 0,
+	BUS_NOTIFY_DEL_DEVICE = 1,
+	BUS_NOTIFY_REMOVED_DEVICE = 2,
+	BUS_NOTIFY_BIND_DRIVER = 3,
+	BUS_NOTIFY_BOUND_DRIVER = 4,
+	BUS_NOTIFY_UNBIND_DRIVER = 5,
+	BUS_NOTIFY_UNBOUND_DRIVER = 6,
+	BUS_NOTIFY_DRIVER_NOT_BOUND = 7,
+};
+
+struct subsys_private {
+	struct kset subsys;
+	struct kset *devices_kset;
+	struct list_head interfaces;
+	struct mutex mutex;
+	struct kset *drivers_kset;
+	struct klist klist_devices;
+	struct klist klist_drivers;
+	struct blocking_notifier_head bus_notifier;
+	unsigned int drivers_autoprobe: 1;
+	const struct bus_type *bus;
+	struct device *dev_root;
+	struct kset glue_dirs;
+	const struct class *class;
+	struct lock_class_key lock_key;
+};
+
+struct driver_private {
+	struct kobject kobj;
+	struct klist klist_devices;
+	struct klist_node knode_bus;
+	struct module_kobject *mkobj;
+	struct device_driver *driver;
+};
+
+struct subsys_interface {
+	const char *name;
+	const struct bus_type *subsys;
+	struct list_head node;
+	int (*add_dev)(struct device *, struct subsys_interface *);
+	void (*remove_dev)(struct device *, struct subsys_interface *);
+};
+
+struct device_private {
+	struct klist klist_children;
+	struct klist_node knode_parent;
+	struct klist_node knode_driver;
+	struct klist_node knode_bus;
+	struct klist_node knode_class;
+	struct list_head deferred_probe;
+	const struct device_driver *async_driver;
+	char *deferred_probe_reason;
+	struct device *device;
+	u8 dead: 1;
+};
+
+struct subsys_dev_iter {
+	struct klist_iter ki;
+	const struct device_type *type;
+};
+
+struct attribute_container {
+	struct list_head node;
+	struct klist containers;
+	struct class *class;
+	const struct attribute_group *grp;
+	struct device_attribute **attrs;
+	int (*match)(struct attribute_container *, struct device *);
+	long unsigned int flags;
+};
+
+struct internal_container {
+	struct klist_node node;
+	struct attribute_container *cont;
+	long: 32;
+	struct device classdev;
+};
+
+struct firmware {
+	size_t size;
+	const u8 *data;
+	void *priv;
+};
+
+struct builtin_fw {
+	char *name;
+	void *data;
+	long unsigned int size;
+};
+
+enum regcache_type {
+	REGCACHE_NONE = 0,
+	REGCACHE_RBTREE = 1,
+	REGCACHE_FLAT = 2,
+	REGCACHE_MAPLE = 3,
+};
+
+struct reg_default {
+	unsigned int reg;
+	unsigned int def;
+};
+
+struct reg_sequence {
+	unsigned int reg;
+	unsigned int def;
+	unsigned int delay_us;
+};
+
+enum regmap_endian {
+	REGMAP_ENDIAN_DEFAULT = 0,
+	REGMAP_ENDIAN_BIG = 1,
+	REGMAP_ENDIAN_LITTLE = 2,
+	REGMAP_ENDIAN_NATIVE = 3,
+};
+
+struct regmap_range {
+	unsigned int range_min;
+	unsigned int range_max;
+};
+
+struct regmap_access_table {
+	const struct regmap_range *yes_ranges;
+	unsigned int n_yes_ranges;
+	const struct regmap_range *no_ranges;
+	unsigned int n_no_ranges;
+};
+
+typedef void (*regmap_lock)(void *);
+
+typedef void (*regmap_unlock)(void *);
+
+typedef int (*regmap_hw_write)(void *, const void *, size_t);
+
+typedef int (*regmap_hw_gather_write)(void *, const void *, size_t, const void *, size_t);
+
+struct regmap_async;
+
+typedef int (*regmap_hw_async_write)(void *, const void *, size_t, const void *, size_t, struct regmap_async *);
+
+struct regmap;
+
+struct regmap_async {
+	struct list_head list;
+	struct regmap *map;
+	void *work_buf;
+};
+
+typedef int (*regmap_hw_read)(void *, const void *, size_t, void *, size_t);
+
+typedef int (*regmap_hw_reg_read)(void *, unsigned int, unsigned int *);
+
+typedef int (*regmap_hw_reg_noinc_read)(void *, unsigned int, void *, size_t);
+
+typedef int (*regmap_hw_reg_write)(void *, unsigned int, unsigned int);
+
+typedef int (*regmap_hw_reg_noinc_write)(void *, unsigned int, const void *, size_t);
+
+typedef int (*regmap_hw_reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
+
+typedef struct regmap_async * (*regmap_hw_async_alloc)();
+
+typedef void (*regmap_hw_free_context)(void *);
+
+struct regmap_bus {
+	bool fast_io;
+	bool free_on_exit;
+	regmap_hw_write write;
+	regmap_hw_gather_write gather_write;
+	regmap_hw_async_write async_write;
+	regmap_hw_reg_write reg_write;
+	regmap_hw_reg_noinc_write reg_noinc_write;
+	regmap_hw_reg_update_bits reg_update_bits;
+	regmap_hw_read read;
+	regmap_hw_reg_read reg_read;
+	regmap_hw_reg_noinc_read reg_noinc_read;
+	regmap_hw_free_context free_context;
+	regmap_hw_async_alloc async_alloc;
+	u8 read_flag_mask;
+	enum regmap_endian reg_format_endian_default;
+	enum regmap_endian val_format_endian_default;
+	size_t max_raw_read;
+	size_t max_raw_write;
+};
+
+struct regmap_irq_type {
+	unsigned int type_reg_offset;
+	unsigned int type_reg_mask;
+	unsigned int type_rising_val;
+	unsigned int type_falling_val;
+	unsigned int type_level_low_val;
+	unsigned int type_level_high_val;
+	unsigned int types_supported;
+};
+
+struct regmap_irq {
+	unsigned int reg_offset;
+	unsigned int mask;
+	struct regmap_irq_type type;
+};
+
+struct regmap_irq_sub_irq_map {
+	unsigned int num_regs;
+	unsigned int *offset;
+};
+
+struct regmap_irq_chip_data;
+
+struct regmap_irq_chip {
+	const char *name;
+	const char *domain_suffix;
+	unsigned int main_status;
+	unsigned int num_main_status_bits;
+	const struct regmap_irq_sub_irq_map *sub_reg_offsets;
+	int num_main_regs;
+	unsigned int status_base;
+	unsigned int mask_base;
+	unsigned int unmask_base;
+	unsigned int ack_base;
+	unsigned int wake_base;
+	const unsigned int *config_base;
+	unsigned int irq_reg_stride;
+	unsigned int init_ack_masked: 1;
+	unsigned int mask_unmask_non_inverted: 1;
+	unsigned int use_ack: 1;
+	unsigned int ack_invert: 1;
+	unsigned int clear_ack: 1;
+	unsigned int status_invert: 1;
+	unsigned int wake_invert: 1;
+	unsigned int type_in_mask: 1;
+	unsigned int clear_on_unmask: 1;
+	unsigned int runtime_pm: 1;
+	unsigned int no_status: 1;
+	int num_regs;
+	const struct regmap_irq *irqs;
+	int num_irqs;
+	int num_config_bases;
+	int num_config_regs;
+	int (*handle_pre_irq)(void *);
+	int (*handle_post_irq)(void *);
+	int (*handle_mask_sync)(int, unsigned int, unsigned int, void *);
+	int (*set_type_config)(unsigned int **, unsigned int, const struct regmap_irq *, int, void *);
+	unsigned int (*get_irq_reg)(struct regmap_irq_chip_data *, unsigned int, int);
+	void *irq_drv_data;
+};
+
+struct regmap_irq_chip_data {
+	struct mutex lock;
+	struct irq_chip irq_chip;
+	struct regmap *map;
+	const struct regmap_irq_chip *chip;
+	int irq_base;
+	struct irq_domain *domain;
+	int irq;
+	int wake_count;
+	void *status_reg_buf;
+	unsigned int *main_status_buf;
+	unsigned int *status_buf;
+	unsigned int *mask_buf;
+	unsigned int *mask_buf_def;
+	unsigned int *wake_buf;
+	unsigned int *type_buf;
+	unsigned int *type_buf_def;
+	unsigned int **config_buf;
+	unsigned int irq_reg_stride;
+	unsigned int (*get_irq_reg)(struct regmap_irq_chip_data *, unsigned int, int);
+	unsigned int clear_status: 1;
+};
+
+struct regmap_format {
+	size_t buf_size;
+	size_t reg_bytes;
+	size_t pad_bytes;
+	size_t val_bytes;
+	s8 reg_shift;
+	void (*format_write)(struct regmap *, unsigned int, unsigned int);
+	void (*format_reg)(void *, unsigned int, unsigned int);
+	void (*format_val)(void *, unsigned int, unsigned int);
+	unsigned int (*parse_val)(const void *);
+	void (*parse_inplace)(void *);
+};
+
+struct hwspinlock;
+
+struct regcache_ops;
+
+struct regmap {
+	union {
+		struct mutex mutex;
+		struct {
+			spinlock_t spinlock;
+			long unsigned int spinlock_flags;
+		};
+		struct {
+			raw_spinlock_t raw_spinlock;
+			long unsigned int raw_spinlock_flags;
+		};
+	};
+	regmap_lock lock;
+	regmap_unlock unlock;
+	void *lock_arg;
+	gfp_t alloc_flags;
+	unsigned int reg_base;
+	struct device *dev;
+	void *work_buf;
+	struct regmap_format format;
+	const struct regmap_bus *bus;
+	void *bus_context;
+	const char *name;
+	bool async;
+	spinlock_t async_lock;
+	wait_queue_head_t async_waitq;
+	struct list_head async_list;
+	struct list_head async_free;
+	int async_ret;
+	bool debugfs_disable;
+	struct dentry *debugfs;
+	const char *debugfs_name;
+	unsigned int debugfs_reg_len;
+	unsigned int debugfs_val_len;
+	unsigned int debugfs_tot_len;
+	struct list_head debugfs_off_cache;
+	struct mutex cache_lock;
+	unsigned int max_register;
+	bool max_register_is_set;
+	bool (*writeable_reg)(struct device *, unsigned int);
+	bool (*readable_reg)(struct device *, unsigned int);
+	bool (*volatile_reg)(struct device *, unsigned int);
+	bool (*precious_reg)(struct device *, unsigned int);
+	bool (*writeable_noinc_reg)(struct device *, unsigned int);
+	bool (*readable_noinc_reg)(struct device *, unsigned int);
+	const struct regmap_access_table *wr_table;
+	const struct regmap_access_table *rd_table;
+	const struct regmap_access_table *volatile_table;
+	const struct regmap_access_table *precious_table;
+	const struct regmap_access_table *wr_noinc_table;
+	const struct regmap_access_table *rd_noinc_table;
+	int (*reg_read)(void *, unsigned int, unsigned int *);
+	int (*reg_write)(void *, unsigned int, unsigned int);
+	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
+	int (*read)(void *, const void *, size_t, void *, size_t);
+	int (*write)(void *, const void *, size_t);
+	bool defer_caching;
+	long unsigned int read_flag_mask;
+	long unsigned int write_flag_mask;
+	int reg_shift;
+	int reg_stride;
+	int reg_stride_order;
+	bool force_write_field;
+	const struct regcache_ops *cache_ops;
+	enum regcache_type cache_type;
+	unsigned int cache_size_raw;
+	unsigned int cache_word_size;
+	unsigned int num_reg_defaults;
+	unsigned int num_reg_defaults_raw;
+	bool cache_only;
+	bool cache_bypass;
+	bool cache_free;
+	struct reg_default *reg_defaults;
+	const void *reg_defaults_raw;
+	void *cache;
+	bool cache_dirty;
+	bool no_sync_defaults;
+	struct reg_sequence *patch;
+	int patch_regs;
+	bool use_single_read;
+	bool use_single_write;
+	bool can_multi_write;
+	size_t max_raw_read;
+	size_t max_raw_write;
+	struct rb_root range_tree;
+	void *selector_work_buf;
+	struct hwspinlock *hwlock;
+	bool can_sleep;
+};
+
+struct regcache_ops {
+	const char *name;
+	enum regcache_type type;
+	int (*init)(struct regmap *);
+	int (*exit)(struct regmap *);
+	void (*debugfs_init)(struct regmap *);
+	int (*read)(struct regmap *, unsigned int, unsigned int *);
+	int (*write)(struct regmap *, unsigned int, unsigned int);
+	int (*sync)(struct regmap *, unsigned int, unsigned int);
+	int (*drop)(struct regmap *, unsigned int, unsigned int);
+};
+
+struct trace_event_raw_devres {
+	struct trace_entry ent;
+	u32 __data_loc_devname;
+	struct device *dev;
+	const char *op;
+	void *node;
+	const char *name;
+	size_t size;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_devres {
+	u32 devname;
+	const void *devname_ptr_;
+};
+
+typedef void (*btf_trace_devres_log)(void *, struct device *, const char *, void *, const char *, size_t);
+
+struct dma_fence_ops;
+
+struct dma_fence {
+	spinlock_t *lock;
+	const struct dma_fence_ops *ops;
+	union {
+		struct list_head cb_list;
+		ktime_t timestamp;
+		struct callback_head rcu;
+	};
+	u64 context;
+	u64 seqno;
+	long unsigned int flags;
+	struct kref refcount;
+	int error;
+	long: 32;
+};
+
+struct dma_fence_ops {
+	bool use_64bit_seqno;
+	const char * (*get_driver_name)(struct dma_fence *);
+	const char * (*get_timeline_name)(struct dma_fence *);
+	bool (*enable_signaling)(struct dma_fence *);
+	bool (*signaled)(struct dma_fence *);
+	long int (*wait)(struct dma_fence *, bool, long int);
+	void (*release)(struct dma_fence *);
+	void (*fence_value_str)(struct dma_fence *, char *, int);
+	void (*timeline_value_str)(struct dma_fence *, char *, int);
+	void (*set_deadline)(struct dma_fence *, ktime_t);
+};
+
+enum dma_fence_flag_bits {
+	DMA_FENCE_FLAG_SIGNALED_BIT = 0,
+	DMA_FENCE_FLAG_TIMESTAMP_BIT = 1,
+	DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT = 2,
+	DMA_FENCE_FLAG_USER_BITS = 3,
+};
+
+struct dma_fence_cb;
+
+typedef void (*dma_fence_func_t)(struct dma_fence *, struct dma_fence_cb *);
+
+struct dma_fence_cb {
+	struct list_head node;
+	dma_fence_func_t func;
+};
+
+struct trace_event_raw_dma_fence {
+	struct trace_entry ent;
+	u32 __data_loc_driver;
+	u32 __data_loc_timeline;
+	unsigned int context;
+	unsigned int seqno;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_dma_fence {
+	u32 driver;
+	const void *driver_ptr_;
+	u32 timeline;
+	const void *timeline_ptr_;
+};
+
+typedef void (*btf_trace_dma_fence_emit)(void *, struct dma_fence *);
+
+typedef void (*btf_trace_dma_fence_init)(void *, struct dma_fence *);
+
+typedef void (*btf_trace_dma_fence_destroy)(void *, struct dma_fence *);
+
+typedef void (*btf_trace_dma_fence_enable_signal)(void *, struct dma_fence *);
+
+typedef void (*btf_trace_dma_fence_signaled)(void *, struct dma_fence *);
+
+typedef void (*btf_trace_dma_fence_wait_start)(void *, struct dma_fence *);
+
+typedef void (*btf_trace_dma_fence_wait_end)(void *, struct dma_fence *);
+
+struct default_wait_cb {
+	struct dma_fence_cb base;
+	struct task_struct *task;
+};
+
+struct mtd_concat {
+	struct mtd_info mtd;
+	int num_subdev;
+	struct mtd_info **subdev;
+};
+
+struct mtd_partition {
+	const char *name;
+	const char * const *types;
+	uint64_t size;
+	uint64_t offset;
+	uint32_t mask_flags;
+	uint32_t add_flags;
+	struct device_node *of_node;
+	long: 32;
+};
+
+struct mtd_part_parser_data {
+	long unsigned int origin;
+};
+
+enum mtd_parser_type {
+	MTD_PARSER_TYPE_DEVICE = 0,
+	MTD_PARSER_TYPE_ROOTFS = 1,
+	MTD_PARSER_TYPE_FIRMWARE = 2,
+};
+
+struct mtd_part_parser {
+	struct list_head list;
+	struct module *owner;
+	const char *name;
+	const struct of_device_id *of_match_table;
+	int (*parse_fn)(struct mtd_info *, const struct mtd_partition **, struct mtd_part_parser_data *);
+	void (*cleanup)(const struct mtd_partition *, int);
+	enum mtd_parser_type type;
+};
+
+struct trx_header {
+	uint32_t magic;
+	uint32_t length;
+	uint32_t crc32;
+	uint16_t flags;
+	uint16_t version;
+	uint32_t offset[3];
+};
+
+struct fixed_partitions_quirks {
+	int (*post_parse)(struct mtd_info *, struct mtd_partition *, int);
+};
+
+struct safeloader_cmn_header {
+	__be32 size;
+	uint32_t unused;
+};
+
+enum mtdsplit_part_type {
+	MTDSPLIT_PART_TYPE_UNK = 0,
+	MTDSPLIT_PART_TYPE_SQUASHFS = 1,
+	MTDSPLIT_PART_TYPE_JFFS2 = 2,
+	MTDSPLIT_PART_TYPE_UBI = 3,
+};
+
+struct seama_header {
+	__be32 magic;
+	__be16 reserved;
+	__be16 metasize;
+	__be32 size;
+	u8 md5[16];
+};
+
+typedef union {
+	long unsigned int x[1];
+} map_word;
+
+struct mtd_chip_driver;
+
+struct map_info {
+	const char *name;
+	long unsigned int size;
+	resource_size_t phys;
+	void *virt;
+	void *cached;
+	int swap;
+	int bankwidth;
+	map_word (*read)(struct map_info *, long unsigned int);
+	void (*copy_from)(struct map_info *, void *, long unsigned int, ssize_t);
+	void (*write)(struct map_info *, const map_word, long unsigned int);
+	void (*copy_to)(struct map_info *, long unsigned int, const void *, ssize_t);
+	void (*inval_cache)(struct map_info *, long unsigned int, ssize_t);
+	void (*set_vpp)(struct map_info *, int);
+	long unsigned int pfow_base;
+	long unsigned int map_priv_1;
+	long unsigned int map_priv_2;
+	struct device_node *device_node;
+	void *fldrv_priv;
+	struct mtd_chip_driver *fldrv;
+};
+
+struct mtd_chip_driver {
+	struct mtd_info * (*probe)(struct map_info *);
+	void (*destroy)(struct mtd_info *);
+	struct module *module;
+	char *name;
+	struct list_head list;
+};
+
+typedef long unsigned int u_long;
+
+typedef enum {
+	FL_READY = 0,
+	FL_STATUS = 1,
+	FL_CFI_QUERY = 2,
+	FL_JEDEC_QUERY = 3,
+	FL_ERASING = 4,
+	FL_ERASE_SUSPENDING = 5,
+	FL_ERASE_SUSPENDED = 6,
+	FL_WRITING = 7,
+	FL_WRITING_TO_BUFFER = 8,
+	FL_OTP_WRITE = 9,
+	FL_WRITE_SUSPENDING = 10,
+	FL_WRITE_SUSPENDED = 11,
+	FL_PM_SUSPENDED = 12,
+	FL_SYNCING = 13,
+	FL_UNLOADING = 14,
+	FL_LOCKING = 15,
+	FL_UNLOCKING = 16,
+	FL_POINT = 17,
+	FL_XIP_WHILE_ERASING = 18,
+	FL_XIP_WHILE_WRITING = 19,
+	FL_SHUTDOWN = 20,
+	FL_READING = 21,
+	FL_CACHEDPRG = 22,
+	FL_RESETTING = 23,
+	FL_OTPING = 24,
+	FL_PREPARING_ERASE = 25,
+	FL_VERIFYING_ERASE = 26,
+	FL_UNKNOWN = 27,
+} flstate_t;
+
+struct flchip {
+	long unsigned int start;
+	int ref_point_counter;
+	flstate_t state;
+	flstate_t oldstate;
+	unsigned int write_suspended: 1;
+	unsigned int erase_suspended: 1;
+	long unsigned int in_progress_block_addr;
+	long unsigned int in_progress_block_mask;
+	struct mutex mutex;
+	wait_queue_head_t wq;
+	int word_write_time;
+	int buffer_write_time;
+	int erase_time;
+	int word_write_time_max;
+	int buffer_write_time_max;
+	int erase_time_max;
+	void *priv;
+};
+
+struct cfi_ident {
+	uint8_t qry[3];
+	uint16_t P_ID;
+	uint16_t P_ADR;
+	uint16_t A_ID;
+	uint16_t A_ADR;
+	uint8_t VccMin;
+	uint8_t VccMax;
+	uint8_t VppMin;
+	uint8_t VppMax;
+	uint8_t WordWriteTimeoutTyp;
+	uint8_t BufWriteTimeoutTyp;
+	uint8_t BlockEraseTimeoutTyp;
+	uint8_t ChipEraseTimeoutTyp;
+	uint8_t WordWriteTimeoutMax;
+	uint8_t BufWriteTimeoutMax;
+	uint8_t BlockEraseTimeoutMax;
+	uint8_t ChipEraseTimeoutMax;
+	uint8_t DevSize;
+	uint16_t InterfaceDesc;
+	uint16_t MaxBufWriteSize;
+	uint8_t NumEraseRegions;
+	uint32_t EraseRegionInfo[0];
+} __attribute__((packed));
+
+struct cfi_extquery {
+	uint8_t pri[3];
+	uint8_t MajorVersion;
+	uint8_t MinorVersion;
+};
+
+struct cfi_private {
+	uint16_t cmdset;
+	void *cmdset_priv;
+	int interleave;
+	int device_type;
+	int cfi_mode;
+	int addr_unlock1;
+	int addr_unlock2;
+	struct mtd_info * (*cmdset_setup)(struct map_info *);
+	struct cfi_ident *cfiq;
+	int mfr;
+	int id;
+	int numchips;
+	map_word sector_erase_cmd;
+	long unsigned int chipshift;
+	const char *im_name;
+	long unsigned int quirks;
+	struct flchip chips[0];
+};
+
+struct cfi_fixup {
+	uint16_t mfr;
+	uint16_t id;
+	void (*fixup)(struct mtd_info *);
+};
+
+typedef int (*varsize_frob_t)(struct map_info *, struct flchip *, long unsigned int, int, void *);
+
+struct nand_memory_organization {
+	unsigned int bits_per_cell;
+	unsigned int pagesize;
+	unsigned int oobsize;
+	unsigned int pages_per_eraseblock;
+	unsigned int eraseblocks_per_lun;
+	unsigned int max_bad_eraseblocks_per_lun;
+	unsigned int planes_per_lun;
+	unsigned int luns_per_target;
+	unsigned int ntargets;
+};
+
+struct nand_row_converter {
+	unsigned int lun_addr_shift;
+	unsigned int eraseblock_addr_shift;
+};
+
+struct nand_pos {
+	unsigned int target;
+	unsigned int lun;
+	unsigned int plane;
+	unsigned int eraseblock;
+	unsigned int page;
+};
+
+enum nand_page_io_req_type {
+	NAND_PAGE_READ = 0,
+	NAND_PAGE_WRITE = 1,
+};
+
+struct nand_page_io_req {
+	enum nand_page_io_req_type type;
+	struct nand_pos pos;
+	unsigned int dataoffs;
+	unsigned int datalen;
+	union {
+		const void *out;
+		void *in;
+	} databuf;
+	unsigned int ooboffs;
+	unsigned int ooblen;
+	union {
+		const void *out;
+		void *in;
+	} oobbuf;
+	int mode;
+	bool continuous;
+};
+
+enum nand_ecc_engine_type {
+	NAND_ECC_ENGINE_TYPE_INVALID = 0,
+	NAND_ECC_ENGINE_TYPE_NONE = 1,
+	NAND_ECC_ENGINE_TYPE_SOFT = 2,
+	NAND_ECC_ENGINE_TYPE_ON_HOST = 3,
+	NAND_ECC_ENGINE_TYPE_ON_DIE = 4,
+};
+
+enum nand_ecc_placement {
+	NAND_ECC_PLACEMENT_UNKNOWN = 0,
+	NAND_ECC_PLACEMENT_OOB = 1,
+	NAND_ECC_PLACEMENT_INTERLEAVED = 2,
+};
+
+enum nand_ecc_algo {
+	NAND_ECC_ALGO_UNKNOWN = 0,
+	NAND_ECC_ALGO_HAMMING = 1,
+	NAND_ECC_ALGO_BCH = 2,
+	NAND_ECC_ALGO_RS = 3,
+};
+
+struct nand_ecc_props {
+	enum nand_ecc_engine_type engine_type;
+	enum nand_ecc_placement placement;
+	enum nand_ecc_algo algo;
+	unsigned int strength;
+	unsigned int step_size;
+	unsigned int flags;
+};
+
+struct nand_bbt {
+	long unsigned int *cache;
+};
+
+struct nand_device;
+
+struct nand_ops {
+	int (*erase)(struct nand_device *, const struct nand_pos *);
+	int (*markbad)(struct nand_device *, const struct nand_pos *);
+	bool (*isbad)(struct nand_device *, const struct nand_pos *);
+};
+
+struct nand_ecc_context {
+	struct nand_ecc_props conf;
+	unsigned int nsteps;
+	unsigned int total;
+	void *priv;
+};
+
+struct nand_ecc_engine;
+
+struct nand_ecc {
+	struct nand_ecc_props defaults;
+	struct nand_ecc_props requirements;
+	struct nand_ecc_props user_conf;
+	struct nand_ecc_context ctx;
+	struct nand_ecc_engine *ondie_engine;
+	struct nand_ecc_engine *engine;
+};
+
+struct nand_device {
+	struct mtd_info mtd;
+	struct nand_memory_organization memorg;
+	struct nand_ecc ecc;
+	struct nand_row_converter rowconv;
+	struct nand_bbt bbt;
+	const struct nand_ops *ops;
+};
+
+struct nand_ecc_engine_ops {
+	int (*init_ctx)(struct nand_device *);
+	void (*cleanup_ctx)(struct nand_device *);
+	int (*prepare_io_req)(struct nand_device *, struct nand_page_io_req *);
+	int (*finish_io_req)(struct nand_device *, struct nand_page_io_req *);
+};
+
+enum nand_ecc_engine_integration {
+	NAND_ECC_ENGINE_INTEGRATION_INVALID = 0,
+	NAND_ECC_ENGINE_INTEGRATION_PIPELINED = 1,
+	NAND_ECC_ENGINE_INTEGRATION_EXTERNAL = 2,
+};
+
+struct nand_ecc_engine {
+	struct device *dev;
+	struct list_head node;
+	struct nand_ecc_engine_ops *ops;
+	enum nand_ecc_engine_integration integration;
+	void *priv;
+};
+
+struct nand_ecc_req_tweak_ctx {
+	struct nand_page_io_req orig_req;
+	struct nand_device *nand;
+	unsigned int page_buffer_size;
+	unsigned int oob_buffer_size;
+	void *spare_databuf;
+	void *spare_oobbuf;
+	bool bounce_data;
+	bool bounce_oob;
+};
+
+struct nand_bbt_descr {
+	int options;
+	int pages[8];
+	int offs;
+	int veroffs;
+	uint8_t version[8];
+	int len;
+	int maxblocks;
+	int reserved_block_code;
+	uint8_t *pattern;
+};
+
+struct nand_onfi_params {
+	u8 sig[4];
+	__le16 revision;
+	__le16 features;
+	__le16 opt_cmd;
+	u8 reserved0[2];
+	__le16 ext_param_page_length;
+	u8 num_of_param_pages;
+	u8 reserved1[17];
+	char manufacturer[12];
+	char model[20];
+	u8 jedec_id;
+	__le16 date_code;
+	u8 reserved2[13];
+	__le32 byte_per_page;
+	__le16 spare_bytes_per_page;
+	__le32 data_bytes_per_ppage;
+	__le16 spare_bytes_per_ppage;
+	__le32 pages_per_block;
+	__le32 blocks_per_lun;
+	u8 lun_count;
+	u8 addr_cycles;
+	u8 bits_per_cell;
+	__le16 bb_per_lun;
+	__le16 block_endurance;
+	u8 guaranteed_good_blocks;
+	__le16 guaranteed_block_endurance;
+	u8 programs_per_page;
+	u8 ppage_attr;
+	u8 ecc_bits;
+	u8 interleaved_bits;
+	u8 interleaved_ops;
+	u8 reserved3[13];
+	u8 io_pin_capacitance_max;
+	__le16 sdr_timing_modes;
+	__le16 program_cache_timing_mode;
+	__le16 t_prog;
+	__le16 t_bers;
+	__le16 t_r;
+	__le16 t_ccs;
+	u8 nvddr_timing_modes;
+	u8 nvddr2_timing_modes;
+	u8 nvddr_nvddr2_features;
+	__le16 clk_pin_capacitance_typ;
+	__le16 io_pin_capacitance_typ;
+	__le16 input_pin_capacitance_typ;
+	u8 input_pin_capacitance_max;
+	u8 driver_strength_support;
+	__le16 t_int_r;
+	__le16 t_adl;
+	u8 reserved4[8];
+	__le16 vendor_revision;
+	u8 vendor[88];
+	__le16 crc;
+} __attribute__((packed));
+
+struct onfi_params {
+	int version;
+	u16 tPROG;
+	u16 tBERS;
+	u16 tR;
+	u16 tCCS;
+	bool fast_tCAD;
+	u16 sdr_timing_modes;
+	u16 nvddr_timing_modes;
+	u16 vendor_revision;
+	u8 vendor[88];
+};
+
+struct nand_parameters {
+	const char *model;
+	bool supports_set_get_features;
+	bool supports_read_cache;
+	long unsigned int set_feature_list[8];
+	long unsigned int get_feature_list[8];
+	struct onfi_params *onfi;
+};
+
+struct nand_id {
+	u8 data[8];
+	int len;
+};
+
+struct nand_chip;
+
+struct nand_ecc_ctrl {
+	enum nand_ecc_engine_type engine_type;
+	enum nand_ecc_placement placement;
+	enum nand_ecc_algo algo;
+	int steps;
+	int size;
+	int bytes;
+	int total;
+	int strength;
+	int prepad;
+	int postpad;
+	unsigned int options;
+	u8 *calc_buf;
+	u8 *code_buf;
+	void (*hwctl)(struct nand_chip *, int);
+	int (*calculate)(struct nand_chip *, const uint8_t *, uint8_t *);
+	int (*correct)(struct nand_chip *, uint8_t *, uint8_t *, uint8_t *);
+	int (*read_page_raw)(struct nand_chip *, uint8_t *, int, int);
+	int (*write_page_raw)(struct nand_chip *, const uint8_t *, int, int);
+	int (*read_page)(struct nand_chip *, uint8_t *, int, int);
+	int (*read_subpage)(struct nand_chip *, uint32_t, uint32_t, uint8_t *, int);
+	int (*write_subpage)(struct nand_chip *, uint32_t, uint32_t, const uint8_t *, int, int);
+	int (*write_page)(struct nand_chip *, const uint8_t *, int, int);
+	int (*write_oob_raw)(struct nand_chip *, int);
+	int (*read_oob_raw)(struct nand_chip *, int);
+	int (*read_oob)(struct nand_chip *, int);
+	int (*write_oob)(struct nand_chip *, int);
+};
+
+struct nand_manufacturer_desc;
+
+struct nand_manufacturer {
+	const struct nand_manufacturer_desc *desc;
+	void *priv;
+};
+
+struct nand_interface_config;
+
+struct nand_chip_ops {
+	int (*suspend)(struct nand_chip *);
+	void (*resume)(struct nand_chip *);
+	int (*lock_area)(struct nand_chip *, loff_t, uint64_t);
+	int (*unlock_area)(struct nand_chip *, loff_t, uint64_t);
+	int (*setup_read_retry)(struct nand_chip *, int);
+	int (*choose_interface_config)(struct nand_chip *, struct nand_interface_config *);
+};
+
+struct nand_controller_ops;
+
+struct nand_controller {
+	struct mutex lock;
+	const struct nand_controller_ops *ops;
+	struct {
+		unsigned int data_only_read: 1;
+		unsigned int cont_read: 1;
+	} supported_op;
+	bool controller_wp;
+};
+
+struct nand_legacy {
+	void *IO_ADDR_R;
+	void *IO_ADDR_W;
+	void (*select_chip)(struct nand_chip *, int);
+	u8 (*read_byte)(struct nand_chip *);
+	void (*write_byte)(struct nand_chip *, u8);
+	void (*write_buf)(struct nand_chip *, const u8 *, int);
+	void (*read_buf)(struct nand_chip *, u8 *, int);
+	void (*cmd_ctrl)(struct nand_chip *, int, unsigned int);
+	void (*cmdfunc)(struct nand_chip *, unsigned int, int, int);
+	int (*dev_ready)(struct nand_chip *);
+	int (*waitfunc)(struct nand_chip *);
+	int (*block_bad)(struct nand_chip *, loff_t);
+	int (*block_markbad)(struct nand_chip *, loff_t);
+	int (*set_features)(struct nand_chip *, int, u8 *);
+	int (*get_features)(struct nand_chip *, int, u8 *);
+	int chip_delay;
+	struct nand_controller dummy_controller;
+};
+
+struct nand_secure_region;
+
+struct nand_chip {
+	struct nand_device base;
+	struct nand_id id;
+	struct nand_parameters parameters;
+	struct nand_manufacturer manufacturer;
+	struct nand_chip_ops ops;
+	struct nand_legacy legacy;
+	unsigned int options;
+	const struct nand_interface_config *current_interface_config;
+	struct nand_interface_config *best_interface_config;
+	unsigned int bbt_erase_shift;
+	unsigned int bbt_options;
+	unsigned int badblockpos;
+	unsigned int badblockbits;
+	struct nand_bbt_descr *bbt_td;
+	struct nand_bbt_descr *bbt_md;
+	struct nand_bbt_descr *badblock_pattern;
+	u8 *bbt;
+	unsigned int page_shift;
+	unsigned int phys_erase_shift;
+	unsigned int chip_shift;
+	unsigned int pagemask;
+	unsigned int subpagesize;
+	u8 *data_buf;
+	u8 *oob_poi;
+	struct {
+		unsigned int bitflips;
+		int page;
+	} pagecache;
+	long unsigned int buf_align;
+	struct mutex lock;
+	unsigned int suspended: 1;
+	wait_queue_head_t resume_wq;
+	int cur_cs;
+	int read_retries;
+	struct nand_secure_region *secure_regions;
+	u8 nr_secure_regions;
+	struct {
+		bool ongoing;
+		unsigned int first_page;
+		unsigned int pause_page;
+		unsigned int last_page;
+	} cont_read;
+	struct nand_controller *controller;
+	struct nand_ecc_ctrl ecc;
+	void *priv;
+};
+
+struct nand_sdr_timings {
+	u64 tBERS_max;
+	u32 tCCS_min;
+	long: 32;
+	u64 tPROG_max;
+	u64 tR_max;
+	u32 tALH_min;
+	u32 tADL_min;
+	u32 tALS_min;
+	u32 tAR_min;
+	u32 tCEA_max;
+	u32 tCEH_min;
+	u32 tCH_min;
+	u32 tCHZ_max;
+	u32 tCLH_min;
+	u32 tCLR_min;
+	u32 tCLS_min;
+	u32 tCOH_min;
+	u32 tCS_min;
+	u32 tDH_min;
+	u32 tDS_min;
+	u32 tFEAT_max;
+	u32 tIR_min;
+	u32 tITC_max;
+	u32 tRC_min;
+	u32 tREA_max;
+	u32 tREH_min;
+	u32 tRHOH_min;
+	u32 tRHW_min;
+	u32 tRHZ_max;
+	u32 tRLOH_min;
+	u32 tRP_min;
+	u32 tRR_min;
+	long: 32;
+	u64 tRST_max;
+	u32 tWB_max;
+	u32 tWC_min;
+	u32 tWH_min;
+	u32 tWHR_min;
+	u32 tWP_min;
+	u32 tWW_min;
+};
+
+struct nand_nvddr_timings {
+	u64 tBERS_max;
+	u32 tCCS_min;
+	long: 32;
+	u64 tPROG_max;
+	u64 tR_max;
+	u32 tAC_min;
+	u32 tAC_max;
+	u32 tADL_min;
+	u32 tCAD_min;
+	u32 tCAH_min;
+	u32 tCALH_min;
+	u32 tCALS_min;
+	u32 tCAS_min;
+	u32 tCEH_min;
+	u32 tCH_min;
+	u32 tCK_min;
+	u32 tCS_min;
+	u32 tDH_min;
+	u32 tDQSCK_min;
+	u32 tDQSCK_max;
+	u32 tDQSD_min;
+	u32 tDQSD_max;
+	u32 tDQSHZ_max;
+	u32 tDQSQ_max;
+	u32 tDS_min;
+	u32 tDSC_min;
+	u32 tFEAT_max;
+	u32 tITC_max;
+	u32 tQHS_max;
+	u32 tRHW_min;
+	u32 tRR_min;
+	u32 tRST_max;
+	u32 tWB_max;
+	u32 tWHR_min;
+	u32 tWRCK_min;
+	u32 tWW_min;
+	long: 32;
+};
+
+enum nand_interface_type {
+	NAND_SDR_IFACE = 0,
+	NAND_NVDDR_IFACE = 1,
+};
+
+struct nand_timings {
+	unsigned int mode;
+	long: 32;
+	union {
+		struct nand_sdr_timings sdr;
+		struct nand_nvddr_timings nvddr;
+	};
+};
+
+struct nand_interface_config {
+	enum nand_interface_type type;
+	long: 32;
+	struct nand_timings timings;
+};
+
+struct nand_op_cmd_instr {
+	u8 opcode;
+};
+
+struct nand_op_addr_instr {
+	unsigned int naddrs;
+	const u8 *addrs;
+};
+
+struct nand_op_data_instr {
+	unsigned int len;
+	union {
+		void *in;
+		const void *out;
+	} buf;
+	bool force_8bit;
+};
+
+struct nand_op_waitrdy_instr {
+	unsigned int timeout_ms;
+};
+
+enum nand_op_instr_type {
+	NAND_OP_CMD_INSTR = 0,
+	NAND_OP_ADDR_INSTR = 1,
+	NAND_OP_DATA_IN_INSTR = 2,
+	NAND_OP_DATA_OUT_INSTR = 3,
+	NAND_OP_WAITRDY_INSTR = 4,
+};
+
+struct nand_op_instr {
+	enum nand_op_instr_type type;
+	union {
+		struct nand_op_cmd_instr cmd;
+		struct nand_op_addr_instr addr;
+		struct nand_op_data_instr data;
+		struct nand_op_waitrdy_instr waitrdy;
+	} ctx;
+	unsigned int delay_ns;
+};
+
+struct nand_operation {
+	unsigned int cs;
+	bool deassert_wp;
+	const struct nand_op_instr *instrs;
+	unsigned int ninstrs;
+};
+
+struct nand_controller_ops {
+	int (*attach_chip)(struct nand_chip *);
+	void (*detach_chip)(struct nand_chip *);
+	int (*exec_op)(struct nand_chip *, const struct nand_operation *, bool);
+	int (*setup_interface)(struct nand_chip *, int, const struct nand_interface_config *);
+};
+
+struct nand_manufacturer_ops;
+
+struct nand_manufacturer_desc {
+	int id;
+	char *name;
+	const struct nand_manufacturer_ops *ops;
+};
+
+struct nand_secure_region {
+	u64 offset;
+	u64 size;
+};
+
+struct nand_manufacturer_ops {
+	void (*detect)(struct nand_chip *);
+	int (*init)(struct nand_chip *);
+	void (*cleanup)(struct nand_chip *);
+	void (*fixup_onfi_param_page)(struct nand_chip *, struct nand_onfi_params *);
+};
+
+struct nand_flash_dev {
+	char *name;
+	union {
+		struct {
+			uint8_t mfr_id;
+			uint8_t dev_id;
+		};
+		uint8_t id[8];
+	};
+	unsigned int pagesize;
+	unsigned int chipsize;
+	unsigned int erasesize;
+	unsigned int options;
+	uint16_t id_len;
+	uint16_t oobsize;
+	struct {
+		uint16_t strength_ds;
+		uint16_t step_ds;
+	} ecc;
+};
+
+struct nand_onfi_vendor_micron {
+	u8 two_plane_read;
+	u8 read_cache;
+	u8 read_unique_id;
+	u8 dq_imped;
+	u8 dq_imped_num_settings;
+	u8 dq_imped_feat_addr;
+	u8 rb_pulldown_strength;
+	u8 rb_pulldown_strength_feat_addr;
+	u8 rb_pulldown_strength_num_settings;
+	u8 otp_mode;
+	u8 otp_page_start;
+	u8 otp_data_prot_addr;
+	u8 otp_num_pages;
+	u8 otp_feat_addr;
+	u8 read_retry_options;
+	u8 reserved[72];
+	u8 param_revision;
+};
+
+struct micron_on_die_ecc {
+	bool forced;
+	bool enabled;
+	void *rawbuf;
+};
+
+struct micron_nand {
+	struct micron_on_die_ecc ecc;
+};
+
+enum {
+	MICRON_ON_DIE_UNSUPPORTED = 0,
+	MICRON_ON_DIE_SUPPORTED = 1,
+	MICRON_ON_DIE_MANDATORY = 2,
+};
+
+struct brcmnand_io_ops;
+
+struct brcmnand_soc {
+	bool (*ctlrdy_ack)(struct brcmnand_soc *);
+	void (*ctlrdy_set_enabled)(struct brcmnand_soc *, bool);
+	void (*prepare_data_bus)(struct brcmnand_soc *, bool, bool);
+	void (*read_data_bus)(struct brcmnand_soc *, void *, u32 *, int);
+	const struct brcmnand_io_ops *ops;
+};
+
+struct brcmnand_io_ops {
+	u32 (*read_reg)(struct brcmnand_soc *, u32);
+	void (*write_reg)(struct brcmnand_soc *, u32, u32);
+};
+
+struct iproc_nand_soc {
+	struct brcmnand_soc soc;
+	void *idm_base;
+	void *ext_base;
+	spinlock_t idm_lock;
+};
+
+struct spi_statistics {
+	struct u64_stats_sync syncp;
+	long: 32;
+	u64_stats_t messages;
+	u64_stats_t transfers;
+	u64_stats_t errors;
+	u64_stats_t timedout;
+	u64_stats_t spi_sync;
+	u64_stats_t spi_sync_immediate;
+	u64_stats_t spi_async;
+	u64_stats_t bytes;
+	u64_stats_t bytes_rx;
+	u64_stats_t bytes_tx;
+	u64_stats_t transfer_bytes_histo[17];
+	u64_stats_t transfers_split_maxsize;
+};
+
+struct spi_delay {
+	u16 value;
+	u8 unit;
+};
+
+struct spi_controller;
+
+struct spi_device {
+	struct device dev;
+	struct spi_controller *controller;
+	u32 max_speed_hz;
+	u8 chip_select[16];
+	u8 bits_per_word;
+	bool rt;
+	u32 mode;
+	int irq;
+	void *controller_state;
+	void *controller_data;
+	char modalias[32];
+	const char *driver_override;
+	struct gpio_desc *cs_gpiod[16];
+	struct spi_delay word_delay;
+	struct spi_delay cs_setup;
+	struct spi_delay cs_hold;
+	struct spi_delay cs_inactive;
+	struct spi_statistics *pcpu_statistics;
+	u32 cs_index_mask: 16;
+};
+
+struct spi_message;
+
+struct spi_transfer;
+
+struct spi_controller_mem_ops;
+
+struct spi_controller_mem_caps;
+
+struct spi_controller {
+	struct device dev;
+	struct list_head list;
+	s16 bus_num;
+	u16 num_chipselect;
+	u16 dma_alignment;
+	u32 mode_bits;
+	u32 buswidth_override_bits;
+	u32 bits_per_word_mask;
+	u32 min_speed_hz;
+	u32 max_speed_hz;
+	u16 flags;
+	bool devm_allocated;
+	union {
+		bool slave;
+		bool target;
+	};
+	size_t (*max_transfer_size)(struct spi_device *);
+	size_t (*max_message_size)(struct spi_device *);
+	struct mutex io_mutex;
+	struct mutex add_lock;
+	spinlock_t bus_lock_spinlock;
+	struct mutex bus_lock_mutex;
+	bool bus_lock_flag;
+	int (*setup)(struct spi_device *);
+	int (*set_cs_timing)(struct spi_device *);
+	int (*transfer)(struct spi_device *, struct spi_message *);
+	void (*cleanup)(struct spi_device *);
+	bool (*can_dma)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
+	struct device *dma_map_dev;
+	struct device *cur_rx_dma_dev;
+	struct device *cur_tx_dma_dev;
+	bool queued;
+	struct kthread_worker *kworker;
+	struct kthread_work pump_messages;
+	spinlock_t queue_lock;
+	struct list_head queue;
+	struct spi_message *cur_msg;
+	struct completion cur_msg_completion;
+	bool cur_msg_incomplete;
+	bool cur_msg_need_completion;
+	bool busy;
+	bool running;
+	bool rt;
+	bool auto_runtime_pm;
+	bool fallback;
+	bool last_cs_mode_high;
+	s8 last_cs[16];
+	u32 last_cs_index_mask: 16;
+	struct completion xfer_completion;
+	size_t max_dma_len;
+	int (*optimize_message)(struct spi_message *);
+	int (*unoptimize_message)(struct spi_message *);
+	int (*prepare_transfer_hardware)(struct spi_controller *);
+	int (*transfer_one_message)(struct spi_controller *, struct spi_message *);
+	int (*unprepare_transfer_hardware)(struct spi_controller *);
+	int (*prepare_message)(struct spi_controller *, struct spi_message *);
+	int (*unprepare_message)(struct spi_controller *, struct spi_message *);
+	int (*target_abort)(struct spi_controller *);
+	void (*set_cs)(struct spi_device *, bool);
+	int (*transfer_one)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
+	void (*handle_err)(struct spi_controller *, struct spi_message *);
+	const struct spi_controller_mem_ops *mem_ops;
+	const struct spi_controller_mem_caps *mem_caps;
+	struct gpio_desc **cs_gpiods;
+	bool use_gpio_descriptors;
+	s8 unused_native_cs;
+	s8 max_native_cs;
+	struct spi_statistics *pcpu_statistics;
+	struct dma_chan *dma_tx;
+	struct dma_chan *dma_rx;
+	void *dummy_rx;
+	void *dummy_tx;
+	int (*fw_translate_cs)(struct spi_controller *, unsigned int);
+	bool ptp_sts_supported;
+	long unsigned int irq_flags;
+	bool queue_empty;
+	bool must_async;
+	bool defer_optimize_message;
+};
+
+struct spi_message {
+	struct list_head transfers;
+	struct spi_device *spi;
+	bool pre_optimized;
+	bool optimized;
+	bool prepared;
+	int status;
+	void (*complete)(void *);
+	void *context;
+	unsigned int frame_length;
+	unsigned int actual_length;
+	struct list_head queue;
+	void *state;
+	void *opt_state;
+	struct list_head resources;
+};
+
+struct ptp_system_timestamp;
+
+struct spi_transfer {
+	const void *tx_buf;
+	void *rx_buf;
+	unsigned int len;
+	u16 error;
+	bool tx_sg_mapped;
+	bool rx_sg_mapped;
+	struct sg_table tx_sg;
+	struct sg_table rx_sg;
+	dma_addr_t tx_dma;
+	dma_addr_t rx_dma;
+	unsigned int dummy_data: 1;
+	unsigned int cs_off: 1;
+	unsigned int cs_change: 1;
+	unsigned int tx_nbits: 4;
+	unsigned int rx_nbits: 4;
+	unsigned int timestamped: 1;
+	u8 bits_per_word;
+	struct spi_delay delay;
+	struct spi_delay cs_change_delay;
+	struct spi_delay word_delay;
+	u32 speed_hz;
+	u32 effective_speed_hz;
+	unsigned int ptp_sts_word_pre;
+	unsigned int ptp_sts_word_post;
+	struct ptp_system_timestamp *ptp_sts;
+	struct list_head transfer_list;
+};
+
+struct spi_mem;
+
+struct spi_mem_op;
+
+struct spi_mem_dirmap_desc;
+
+struct spi_controller_mem_ops {
+	int (*adjust_op_size)(struct spi_mem *, struct spi_mem_op *);
+	bool (*supports_op)(struct spi_mem *, const struct spi_mem_op *);
+	int (*exec_op)(struct spi_mem *, const struct spi_mem_op *);
+	const char * (*get_name)(struct spi_mem *);
+	int (*dirmap_create)(struct spi_mem_dirmap_desc *);
+	void (*dirmap_destroy)(struct spi_mem_dirmap_desc *);
+	ssize_t (*dirmap_read)(struct spi_mem_dirmap_desc *, u64, size_t, void *);
+	ssize_t (*dirmap_write)(struct spi_mem_dirmap_desc *, u64, size_t, const void *);
+	int (*poll_status)(struct spi_mem *, const struct spi_mem_op *, u16, u16, long unsigned int, long unsigned int, long unsigned int);
+};
+
+struct spi_controller_mem_caps {
+	bool dtr;
+	bool ecc;
+};
+
+enum spi_mem_data_dir {
+	SPI_MEM_NO_DATA = 0,
+	SPI_MEM_DATA_IN = 1,
+	SPI_MEM_DATA_OUT = 2,
+};
+
+struct spi_mem_op {
+	struct {
+		u8 nbytes;
+		u8 buswidth;
+		u8 dtr: 1;
+		u8 __pad: 7;
+		u16 opcode;
+	} cmd;
+	struct {
+		u8 nbytes;
+		u8 buswidth;
+		u8 dtr: 1;
+		u8 __pad: 7;
+		long: 32;
+		u64 val;
+	} addr;
+	struct {
+		u8 nbytes;
+		u8 buswidth;
+		u8 dtr: 1;
+		u8 __pad: 7;
+	} dummy;
+	struct {
+		u8 buswidth;
+		u8 dtr: 1;
+		u8 ecc: 1;
+		u8 __pad: 6;
+		enum spi_mem_data_dir dir;
+		unsigned int nbytes;
+		union {
+			void *in;
+			const void *out;
+		} buf;
+	} data;
+	long: 32;
+};
+
+struct spi_mem_dirmap_info {
+	struct spi_mem_op op_tmpl;
+	u64 offset;
+	u64 length;
+};
+
+struct spi_mem_dirmap_desc {
+	struct spi_mem *mem;
+	long: 32;
+	struct spi_mem_dirmap_info info;
+	unsigned int nodirmap;
+	void *priv;
+};
+
+struct spi_mem {
+	struct spi_device *spi;
+	void *drvpriv;
+	const char *name;
+};
+
+enum spi_nor_protocol {
+	SNOR_PROTO_1_1_1 = 65793,
+	SNOR_PROTO_1_1_2 = 65794,
+	SNOR_PROTO_1_1_4 = 65796,
+	SNOR_PROTO_1_1_8 = 65800,
+	SNOR_PROTO_1_2_2 = 66050,
+	SNOR_PROTO_1_4_4 = 66564,
+	SNOR_PROTO_1_8_8 = 67592,
+	SNOR_PROTO_2_2_2 = 131586,
+	SNOR_PROTO_4_4_4 = 263172,
+	SNOR_PROTO_8_8_8 = 526344,
+	SNOR_PROTO_1_1_1_DTR = 16843009,
+	SNOR_PROTO_1_2_2_DTR = 16843266,
+	SNOR_PROTO_1_4_4_DTR = 16843780,
+	SNOR_PROTO_1_8_8_DTR = 16844808,
+	SNOR_PROTO_8_8_8_DTR = 17303560,
+};
+
+struct spi_nor_hwcaps {
+	u32 mask;
+};
+
+struct spi_nor;
+
+struct spi_nor_controller_ops {
+	int (*prepare)(struct spi_nor *);
+	void (*unprepare)(struct spi_nor *);
+	int (*read_reg)(struct spi_nor *, u8, u8 *, size_t);
+	int (*write_reg)(struct spi_nor *, u8, const u8 *, size_t);
+	ssize_t (*read)(struct spi_nor *, loff_t, size_t, u8 *);
+	ssize_t (*write)(struct spi_nor *, loff_t, size_t, const u8 *);
+	int (*erase)(struct spi_nor *, loff_t);
+};
+
+struct spi_nor_rww {
+	wait_queue_head_t wait;
+	bool ongoing_io;
+	bool ongoing_rd;
+	bool ongoing_pe;
+	unsigned int used_banks;
+};
+
+enum spi_nor_cmd_ext {
+	SPI_NOR_EXT_NONE = 0,
+	SPI_NOR_EXT_REPEAT = 1,
+	SPI_NOR_EXT_INVERT = 2,
+	SPI_NOR_EXT_HEX = 3,
+};
+
+struct flash_info;
+
+struct spi_nor_manufacturer;
+
+struct sfdp;
+
+struct spi_nor_flash_parameter;
+
+struct spi_nor {
+	struct mtd_info mtd;
+	struct mutex lock;
+	struct spi_nor_rww rww;
+	struct device *dev;
+	struct spi_mem *spimem;
+	u8 *bouncebuf;
+	size_t bouncebuf_size;
+	u8 *id;
+	const struct flash_info *info;
+	const struct spi_nor_manufacturer *manufacturer;
+	u8 addr_nbytes;
+	u8 erase_opcode;
+	u8 read_opcode;
+	u8 read_dummy;
+	u8 program_opcode;
+	enum spi_nor_protocol read_proto;
+	enum spi_nor_protocol write_proto;
+	enum spi_nor_protocol reg_proto;
+	bool sst_write_second;
+	u32 flags;
+	enum spi_nor_cmd_ext cmd_ext_type;
+	struct sfdp *sfdp;
+	struct dentry *debugfs_root;
+	const struct spi_nor_controller_ops *controller_ops;
+	struct spi_nor_flash_parameter *params;
+	struct {
+		struct spi_mem_dirmap_desc *rdesc;
+		struct spi_mem_dirmap_desc *wdesc;
+	} dirmap;
+	void *priv;
+};
+
+struct spi_nor_id;
+
+struct spi_nor_otp_organization;
+
+struct spi_nor_fixups;
+
+struct flash_info {
+	char *name;
+	const struct spi_nor_id *id;
+	size_t size;
+	unsigned int sector_size;
+	u16 page_size;
+	u8 n_banks;
+	u8 addr_nbytes;
+	u16 flags;
+	u8 no_sfdp_flags;
+	u8 fixup_flags;
+	u8 mfr_flags;
+	const struct spi_nor_otp_organization *otp;
+	const struct spi_nor_fixups *fixups;
+};
+
+struct spi_nor_manufacturer {
+	const char *name;
+	const struct flash_info *parts;
+	unsigned int nparts;
+	const struct spi_nor_fixups *fixups;
+};
+
+struct sfdp {
+	size_t num_dwords;
+	u32 *dwords;
+};
+
+struct spi_nor_read_command {
+	u8 num_mode_clocks;
+	u8 num_wait_states;
+	u8 opcode;
+	enum spi_nor_protocol proto;
+};
+
+struct spi_nor_pp_command {
+	u8 opcode;
+	enum spi_nor_protocol proto;
+};
+
+struct spi_nor_erase_region {
+	u64 offset;
+	u64 size;
+	u8 erase_mask;
+	bool overlaid;
+	long: 32;
+};
+
+struct spi_nor_erase_type {
+	u32 size;
+	u32 size_shift;
+	u32 size_mask;
+	u8 opcode;
+	u8 idx;
+};
+
+struct spi_nor_erase_map {
+	struct spi_nor_erase_region *regions;
+	long: 32;
+	struct spi_nor_erase_region uniform_region;
+	struct spi_nor_erase_type erase_type[4];
+	unsigned int n_regions;
+	long: 32;
+};
+
+struct spi_nor_otp_ops;
+
+struct spi_nor_otp {
+	const struct spi_nor_otp_organization *org;
+	const struct spi_nor_otp_ops *ops;
+};
+
+struct spi_nor_locking_ops;
+
+struct spi_nor_flash_parameter {
+	u64 bank_size;
+	u64 size;
+	u32 writesize;
+	u32 page_size;
+	u8 addr_nbytes;
+	u8 addr_mode_nbytes;
+	u8 rdsr_dummy;
+	u8 rdsr_addr_nbytes;
+	u8 n_banks;
+	u8 n_dice;
+	u8 die_erase_opcode;
+	u32 *vreg_offset;
+	struct spi_nor_hwcaps hwcaps;
+	struct spi_nor_read_command reads[16];
+	struct spi_nor_pp_command page_programs[8];
+	struct spi_nor_erase_map erase_map;
+	struct spi_nor_otp otp;
+	int (*set_octal_dtr)(struct spi_nor *, bool);
+	int (*quad_enable)(struct spi_nor *);
+	int (*set_4byte_addr_mode)(struct spi_nor *, bool);
+	int (*ready)(struct spi_nor *);
+	const struct spi_nor_locking_ops *locking_ops;
+	void *priv;
+};
+
+struct sfdp_bfpt {
+	u32 dwords[20];
+};
+
+struct sfdp_parameter_header {
+	u8 id_lsb;
+	u8 minor;
+	u8 major;
+	u8 length;
+	u8 parameter_table_pointer[3];
+	u8 id_msb;
+};
+
+enum spi_nor_option_flags {
+	SNOR_F_HAS_SR_TB = 1,
+	SNOR_F_NO_OP_CHIP_ERASE = 2,
+	SNOR_F_BROKEN_RESET = 4,
+	SNOR_F_4B_OPCODES = 8,
+	SNOR_F_HAS_4BAIT = 16,
+	SNOR_F_HAS_LOCK = 32,
+	SNOR_F_HAS_16BIT_SR = 64,
+	SNOR_F_NO_READ_CR = 128,
+	SNOR_F_HAS_SR_TB_BIT6 = 256,
+	SNOR_F_HAS_4BIT_BP = 512,
+	SNOR_F_HAS_SR_BP3_BIT6 = 1024,
+	SNOR_F_IO_MODE_EN_VOLATILE = 2048,
+	SNOR_F_SOFT_RESET = 4096,
+	SNOR_F_SWP_IS_VOLATILE = 8192,
+	SNOR_F_RWW = 16384,
+	SNOR_F_ECC = 32768,
+	SNOR_F_NO_WP = 65536,
+};
+
+enum spi_nor_read_command_index {
+	SNOR_CMD_READ = 0,
+	SNOR_CMD_READ_FAST = 1,
+	SNOR_CMD_READ_1_1_1_DTR = 2,
+	SNOR_CMD_READ_1_1_2 = 3,
+	SNOR_CMD_READ_1_2_2 = 4,
+	SNOR_CMD_READ_2_2_2 = 5,
+	SNOR_CMD_READ_1_2_2_DTR = 6,
+	SNOR_CMD_READ_1_1_4 = 7,
+	SNOR_CMD_READ_1_4_4 = 8,
+	SNOR_CMD_READ_4_4_4 = 9,
+	SNOR_CMD_READ_1_4_4_DTR = 10,
+	SNOR_CMD_READ_1_1_8 = 11,
+	SNOR_CMD_READ_1_8_8 = 12,
+	SNOR_CMD_READ_8_8_8 = 13,
+	SNOR_CMD_READ_1_8_8_DTR = 14,
+	SNOR_CMD_READ_8_8_8_DTR = 15,
+	SNOR_CMD_READ_MAX = 16,
+};
+
+enum spi_nor_pp_command_index {
+	SNOR_CMD_PP = 0,
+	SNOR_CMD_PP_1_1_4 = 1,
+	SNOR_CMD_PP_1_4_4 = 2,
+	SNOR_CMD_PP_4_4_4 = 3,
+	SNOR_CMD_PP_1_1_8 = 4,
+	SNOR_CMD_PP_1_8_8 = 5,
+	SNOR_CMD_PP_8_8_8 = 6,
+	SNOR_CMD_PP_8_8_8_DTR = 7,
+	SNOR_CMD_PP_MAX = 8,
+};
+
+struct spi_nor_locking_ops {
+	int (*lock)(struct spi_nor *, loff_t, u64);
+	int (*unlock)(struct spi_nor *, loff_t, u64);
+	int (*is_locked)(struct spi_nor *, loff_t, u64);
+};
+
+struct spi_nor_otp_organization {
+	size_t len;
+	long: 32;
+	loff_t base;
+	loff_t offset;
+	unsigned int n_regions;
+	long: 32;
+};
+
+struct spi_nor_otp_ops {
+	int (*read)(struct spi_nor *, loff_t, size_t, u8 *);
+	int (*write)(struct spi_nor *, loff_t, size_t, const u8 *);
+	int (*lock)(struct spi_nor *, unsigned int);
+	int (*erase)(struct spi_nor *, loff_t);
+	int (*is_locked)(struct spi_nor *, unsigned int);
+};
+
+struct spi_nor_fixups {
+	void (*default_init)(struct spi_nor *);
+	int (*post_bfpt)(struct spi_nor *, const struct sfdp_parameter_header *, const struct sfdp_bfpt *);
+	int (*post_sfdp)(struct spi_nor *);
+	int (*late_init)(struct spi_nor *);
+};
+
+struct spi_nor_id {
+	const u8 *bytes;
+	u8 len;
+};
+
+struct sfdp_header {
+	u32 signature;
+	u8 minor;
+	u8 major;
+	u8 nph;
+	u8 unused;
+	struct sfdp_parameter_header bfpt_header;
+};
+
+struct sfdp_bfpt_read {
+	u32 hwcaps;
+	u32 supported_dword;
+	u32 supported_bit;
+	u32 settings_dword;
+	u32 settings_shift;
+	enum spi_nor_protocol proto;
+};
+
+struct sfdp_bfpt_erase {
+	u32 dword;
+	u32 shift;
+};
+
+struct sfdp_4bait {
+	u32 hwcaps;
+	u32 supported_bit;
+};
+
+enum {
+	UBI_DYNAMIC_VOLUME = 3,
+	UBI_STATIC_VOLUME = 4,
+};
+
+enum {
+	UBI_VOL_SKIP_CRC_CHECK_FLG = 1,
+};
+
+struct ubi_mkvol_req {
+	__s32 vol_id;
+	__s32 alignment;
+	__s64 bytes;
+	__s8 vol_type;
+	__u8 flags;
+	__s16 name_len;
+	__s8 padding2[4];
+	char name[128];
+};
+
+enum {
+	UBI_READONLY = 1,
+	UBI_READWRITE = 2,
+	UBI_EXCLUSIVE = 3,
+	UBI_METAONLY = 4,
+};
+
+enum {
+	UBI_VOLUME_ADDED = 0,
+	UBI_VOLUME_REMOVED = 1,
+	UBI_VOLUME_RESIZED = 2,
+	UBI_VOLUME_RENAMED = 3,
+	UBI_VOLUME_SHUTDOWN = 4,
+	UBI_VOLUME_UPDATED = 5,
+};
+
+enum {
+	UBI_VID_DYNAMIC = 1,
+	UBI_VID_STATIC = 2,
+};
+
+enum {
+	UBI_VTBL_AUTORESIZE_FLG = 1,
+	UBI_VTBL_SKIP_CRC_CHECK_FLG = 2,
+};
+
+struct ubi_vtbl_record {
+	__be32 reserved_pebs;
+	__be32 alignment;
+	__be32 data_pad;
+	__u8 vol_type;
+	__u8 upd_marker;
+	__be16 name_len;
+	__u8 name[128];
+	__u8 flags;
+	__u8 padding[23];
+	__be32 crc;
+};
+
+struct ubi_wl_entry {
+	union {
+		struct rb_node rb;
+		struct list_head list;
+	} u;
+	int ec;
+	int pnum;
+};
+
+struct ubi_rename_entry {
+	int new_name_len;
+	char new_name[128];
+	int remove;
+	struct ubi_volume_desc *desc;
+	struct list_head list;
+};
+
+struct ubi_volume;
+
+struct ubi_volume_desc {
+	struct ubi_volume *vol;
+	int mode;
+};
+
+struct ubi_fastmap_layout {
+	struct ubi_wl_entry *e[32];
+	int to_be_tortured[32];
+	int used_blocks;
+	int max_pool_size;
+	int max_wl_pool_size;
+};
+
+struct ubi_fm_pool {
+	int pebs[256];
+	int used;
+	int size;
+	int max_size;
+};
+
+struct ubi_device;
+
+struct ubi_eba_table;
+
+struct ubi_volume {
+	struct device dev;
+	struct cdev cdev;
+	struct ubi_device *ubi;
+	int vol_id;
+	int ref_count;
+	int readers;
+	int writers;
+	int exclusive;
+	int metaonly;
+	bool is_dead;
+	int reserved_pebs;
+	int vol_type;
+	int usable_leb_size;
+	int used_ebs;
+	int last_eb_bytes;
+	long long int used_bytes;
+	int alignment;
+	int data_pad;
+	int name_len;
+	char name[128];
+	int upd_ebs;
+	int ch_lnum;
+	long: 32;
+	long long int upd_bytes;
+	long long int upd_received;
+	void *upd_buf;
+	struct ubi_eba_table *eba_tbl;
+	unsigned int skip_check: 1;
+	unsigned int checked: 1;
+	unsigned int corrupted: 1;
+	unsigned int upd_marker: 1;
+	unsigned int updating: 1;
+	unsigned int changing_leb: 1;
+	unsigned int direct_writes: 1;
+	long: 32;
+};
+
+struct ubi_debug_info {
+	unsigned int chk_gen: 1;
+	unsigned int chk_io: 1;
+	unsigned int chk_fastmap: 1;
+	unsigned int disable_bgt: 1;
+	unsigned int emulate_bitflips: 1;
+	unsigned int emulate_io_failures: 1;
+	unsigned int emulate_power_cut: 2;
+	unsigned int power_cut_counter;
+	unsigned int power_cut_min;
+	unsigned int power_cut_max;
+	unsigned int emulate_failures;
+	char dfs_dir_name[6];
+	struct dentry *dfs_dir;
+	struct dentry *dfs_chk_gen;
+	struct dentry *dfs_chk_io;
+	struct dentry *dfs_chk_fastmap;
+	struct dentry *dfs_disable_bgt;
+	struct dentry *dfs_emulate_bitflips;
+	struct dentry *dfs_emulate_io_failures;
+	struct dentry *dfs_emulate_power_cut;
+	struct dentry *dfs_power_cut_min;
+	struct dentry *dfs_power_cut_max;
+	struct dentry *dfs_emulate_failures;
+};
+
+struct ubi_device {
+	struct cdev cdev;
+	long: 32;
+	struct device dev;
+	int ubi_num;
+	char ubi_name[9];
+	int vol_count;
+	struct ubi_volume *volumes[129];
+	spinlock_t volumes_lock;
+	int ref_count;
+	int image_seq;
+	bool is_dead;
+	int rsvd_pebs;
+	int avail_pebs;
+	int beb_rsvd_pebs;
+	int beb_rsvd_level;
+	int bad_peb_limit;
+	int autoresize_vol_id;
+	int vtbl_slots;
+	int vtbl_size;
+	struct ubi_vtbl_record *vtbl;
+	struct mutex device_mutex;
+	int max_ec;
+	int mean_ec;
+	long long unsigned int global_sqnum;
+	spinlock_t ltree_lock;
+	struct rb_root ltree;
+	struct mutex alc_mutex;
+	int fm_disabled;
+	struct ubi_fastmap_layout *fm;
+	struct ubi_fm_pool fm_pool;
+	struct ubi_fm_pool fm_wl_pool;
+	struct rw_semaphore fm_eba_sem;
+	struct rw_semaphore fm_protect;
+	void *fm_buf;
+	size_t fm_size;
+	struct work_struct fm_work;
+	int fm_work_scheduled;
+	int fast_attach;
+	struct ubi_wl_entry *fm_anchor;
+	int fm_do_produce_anchor;
+	int fm_pool_rsv_cnt;
+	struct rb_root used;
+	struct rb_root erroneous;
+	struct rb_root free;
+	int free_count;
+	struct rb_root scrub;
+	struct list_head pq[10];
+	int pq_head;
+	spinlock_t wl_lock;
+	struct mutex move_mutex;
+	struct rw_semaphore work_sem;
+	int wl_scheduled;
+	struct ubi_wl_entry **lookuptbl;
+	struct ubi_wl_entry *move_from;
+	struct ubi_wl_entry *move_to;
+	int move_to_put;
+	struct list_head works;
+	int works_count;
+	struct task_struct *bgt_thread;
+	int thread_enabled;
+	char bgt_name[13];
+	long long int flash_size;
+	int peb_count;
+	int peb_size;
+	int bad_peb_count;
+	int good_peb_count;
+	int corr_peb_count;
+	int erroneous_peb_count;
+	int max_erroneous;
+	int min_io_size;
+	int hdrs_min_io_size;
+	int ro_mode;
+	int leb_size;
+	int leb_start;
+	int ec_hdr_alsize;
+	int vid_hdr_alsize;
+	int vid_hdr_offset;
+	int vid_hdr_aloffset;
+	int vid_hdr_shift;
+	unsigned int bad_allowed: 1;
+	unsigned int nor_flash: 1;
+	int max_write_size;
+	struct mtd_info *mtd;
+	void *peb_buf;
+	struct mutex buf_mutex;
+	struct mutex ckvol_mutex;
+	struct ubi_debug_info dbg;
+	long: 32;
+};
+
+struct ubi_sgl {
+	int list_pos;
+	int page_pos;
+	struct scatterlist sg[64];
+};
+
+struct ubi_ec_hdr {
+	__be32 magic;
+	__u8 version;
+	__u8 padding1[3];
+	__be64 ec;
+	__be32 vid_hdr_offset;
+	__be32 data_offset;
+	__be32 image_seq;
+	__u8 padding2[32];
+	__be32 hdr_crc;
+};
+
+struct ubi_vid_hdr {
+	__be32 magic;
+	__u8 version;
+	__u8 vol_type;
+	__u8 copy_flag;
+	__u8 compat;
+	__be32 vol_id;
+	__be32 lnum;
+	__u8 padding1[4];
+	__be32 data_size;
+	__be32 used_ebs;
+	__be32 data_pad;
+	__be32 data_crc;
+	__u8 padding2[4];
+	__be64 sqnum;
+	__u8 padding3[12];
+	__be32 hdr_crc;
+};
+
+enum {
+	UBI_IO_FF = 1,
+	UBI_IO_FF_BITFLIPS = 2,
+	UBI_IO_BAD_HDR = 3,
+	UBI_IO_BAD_HDR_EBADMSG = 4,
+	UBI_IO_BITFLIPS = 5,
+};
+
+enum {
+	MOVE_CANCEL_RACE = 1,
+	MOVE_SOURCE_RD_ERR = 2,
+	MOVE_TARGET_RD_ERR = 3,
+	MOVE_TARGET_WR_ERR = 4,
+	MOVE_TARGET_BITFLIPS = 5,
+	MOVE_RETRY = 6,
+};
+
+struct ubi_vid_io_buf {
+	struct ubi_vid_hdr *hdr;
+	void *buffer;
+};
+
+struct ubi_ainf_peb {
+	int ec;
+	int pnum;
+	int vol_id;
+	int lnum;
+	unsigned int scrub: 1;
+	unsigned int copy_flag: 1;
+	long: 32;
+	long long unsigned int sqnum;
+	union {
+		struct rb_node rb;
+		struct list_head list;
+	} u;
+	long: 32;
+};
+
+struct ubi_ainf_volume {
+	int vol_id;
+	int highest_lnum;
+	int leb_count;
+	int vol_type;
+	int used_ebs;
+	int last_data_size;
+	int data_pad;
+	int compat;
+	struct rb_node rb;
+	struct rb_root root;
+};
+
+struct ubi_attach_info {
+	struct rb_root volumes;
+	struct list_head corr;
+	struct list_head free;
+	struct list_head erase;
+	struct list_head alien;
+	struct list_head fastmap;
+	int corr_peb_count;
+	int empty_peb_count;
+	int alien_peb_count;
+	int bad_peb_count;
+	int maybe_bad_peb_count;
+	int vols_found;
+	int highest_vol_id;
+	int is_empty;
+	int force_full_scan;
+	int min_ec;
+	int max_ec;
+	long long unsigned int max_sqnum;
+	int mean_ec;
+	long: 32;
+	uint64_t ec_sum;
+	int ec_count;
+	bool eof_found;
+	struct kmem_cache *aeb_slab_cache;
+	struct ubi_ec_hdr *ech;
+	struct ubi_vid_io_buf *vidb;
+	long: 32;
+};
+
+struct ubi_work {
+	struct list_head list;
+	int (*func)(struct ubi_device *, struct ubi_work *, int);
+	struct ubi_wl_entry *e;
+	int vol_id;
+	int lnum;
+	int torture;
+};
+
+struct spi_device_id {
+	char name[32];
+	kernel_ulong_t driver_data;
+};
+
+enum dev_prop_type {
+	DEV_PROP_U8 = 0,
+	DEV_PROP_U16 = 1,
+	DEV_PROP_U32 = 2,
+	DEV_PROP_U64 = 3,
+	DEV_PROP_STRING = 4,
+	DEV_PROP_REF = 5,
+};
+
+struct property_entry;
+
+struct software_node {
+	const char *name;
+	const struct software_node *parent;
+	const struct property_entry *properties;
+};
+
+struct property_entry {
+	const char *name;
+	size_t length;
+	bool is_inline;
+	enum dev_prop_type type;
+	union {
+		const void *pointer;
+		union {
+			u8 u8_data[8];
+			u16 u16_data[4];
+			u32 u32_data[2];
+			u64 u64_data[1];
+			const char *str[2];
+		} value;
+	};
+};
+
+struct ptp_system_timestamp {
+	struct timespec64 pre_ts;
+	struct timespec64 post_ts;
+	clockid_t clockid;
+	long: 32;
+};
+
+struct spi_driver {
+	const struct spi_device_id *id_table;
+	int (*probe)(struct spi_device *);
+	void (*remove)(struct spi_device *);
+	void (*shutdown)(struct spi_device *);
+	struct device_driver driver;
+};
+
+typedef void (*spi_res_release_t)(struct spi_controller *, struct spi_message *, void *);
+
+struct spi_res {
+	struct list_head entry;
+	spi_res_release_t release;
+	long: 32;
+	long long unsigned int data[0];
+};
+
+struct spi_replaced_transfers;
+
+typedef void (*spi_replaced_release_t)(struct spi_controller *, struct spi_message *, struct spi_replaced_transfers *);
+
+struct spi_replaced_transfers {
+	spi_replaced_release_t release;
+	void *extradata;
+	struct list_head replaced_transfers;
+	struct list_head *replaced_after;
+	size_t inserted;
+	struct spi_transfer inserted_transfers[0];
+};
+
+struct spi_board_info {
+	char modalias[32];
+	const void *platform_data;
+	const struct software_node *swnode;
+	void *controller_data;
+	int irq;
+	u32 max_speed_hz;
+	u16 bus_num;
+	u16 chip_select;
+	u32 mode;
+};
+
+struct trace_event_raw_spi_controller {
+	struct trace_entry ent;
+	int bus_num;
+	char __data[0];
+};
+
+struct trace_event_raw_spi_setup {
+	struct trace_entry ent;
+	int bus_num;
+	int chip_select;
+	long unsigned int mode;
+	unsigned int bits_per_word;
+	unsigned int max_speed_hz;
+	int status;
+	char __data[0];
+};
+
+struct trace_event_raw_spi_set_cs {
+	struct trace_entry ent;
+	int bus_num;
+	int chip_select;
+	long unsigned int mode;
+	bool enable;
+	char __data[0];
+};
+
+struct trace_event_raw_spi_message {
+	struct trace_entry ent;
+	int bus_num;
+	int chip_select;
+	struct spi_message *msg;
+	char __data[0];
+};
+
+struct trace_event_raw_spi_message_done {
+	struct trace_entry ent;
+	int bus_num;
+	int chip_select;
+	struct spi_message *msg;
+	unsigned int frame;
+	unsigned int actual;
+	char __data[0];
+};
+
+struct trace_event_raw_spi_transfer {
+	struct trace_entry ent;
+	int bus_num;
+	int chip_select;
+	struct spi_transfer *xfer;
+	int len;
+	u32 __data_loc_rx_buf;
+	u32 __data_loc_tx_buf;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_spi_controller {};
+
+struct trace_event_data_offsets_spi_setup {};
+
+struct trace_event_data_offsets_spi_set_cs {};
+
+struct trace_event_data_offsets_spi_message {};
+
+struct trace_event_data_offsets_spi_message_done {};
+
+struct trace_event_data_offsets_spi_transfer {
+	u32 rx_buf;
+	const void *rx_buf_ptr_;
+	u32 tx_buf;
+	const void *tx_buf_ptr_;
+};
+
+typedef void (*btf_trace_spi_controller_idle)(void *, struct spi_controller *);
+
+typedef void (*btf_trace_spi_controller_busy)(void *, struct spi_controller *);
+
+typedef void (*btf_trace_spi_setup)(void *, struct spi_device *, int);
+
+typedef void (*btf_trace_spi_set_cs)(void *, struct spi_device *, bool);
+
+typedef void (*btf_trace_spi_message_submit)(void *, struct spi_message *);
+
+typedef void (*btf_trace_spi_message_start)(void *, struct spi_message *);
+
+typedef void (*btf_trace_spi_message_done)(void *, struct spi_message *);
+
+typedef void (*btf_trace_spi_transfer_start)(void *, struct spi_message *, struct spi_transfer *);
+
+typedef void (*btf_trace_spi_transfer_stop)(void *, struct spi_message *, struct spi_transfer *);
+
+struct boardinfo {
+	struct list_head list;
+	struct spi_board_info board_info;
+};
+
+struct ethhdr {
+	unsigned char h_dest[6];
+	unsigned char h_source[6];
+	__be16 h_proto;
+};
+
+struct ethtool_drvinfo {
+	__u32 cmd;
+	char driver[32];
+	char version[32];
+	char fw_version[32];
+	char bus_info[32];
+	char erom_version[32];
+	char reserved2[12];
+	__u32 n_priv_flags;
+	__u32 n_stats;
+	__u32 testinfo_len;
+	__u32 eedump_len;
+	__u32 regdump_len;
+};
+
+struct ethtool_wolinfo {
+	__u32 cmd;
+	__u32 supported;
+	__u32 wolopts;
+	__u8 sopass[6];
+};
+
+struct ethtool_tunable {
+	__u32 cmd;
+	__u32 id;
+	__u32 type_id;
+	__u32 len;
+	void *data[0];
+};
+
+struct ethtool_regs {
+	__u32 cmd;
+	__u32 version;
+	__u32 len;
+	__u8 data[0];
+};
+
+struct ethtool_eeprom {
+	__u32 cmd;
+	__u32 magic;
+	__u32 offset;
+	__u32 len;
+	__u8 data[0];
+};
+
+struct ethtool_modinfo {
+	__u32 cmd;
+	__u32 type;
+	__u32 eeprom_len;
+	__u32 reserved[8];
+};
+
+struct ethtool_coalesce {
+	__u32 cmd;
+	__u32 rx_coalesce_usecs;
+	__u32 rx_max_coalesced_frames;
+	__u32 rx_coalesce_usecs_irq;
+	__u32 rx_max_coalesced_frames_irq;
+	__u32 tx_coalesce_usecs;
+	__u32 tx_max_coalesced_frames;
+	__u32 tx_coalesce_usecs_irq;
+	__u32 tx_max_coalesced_frames_irq;
+	__u32 stats_block_coalesce_usecs;
+	__u32 use_adaptive_rx_coalesce;
+	__u32 use_adaptive_tx_coalesce;
+	__u32 pkt_rate_low;
+	__u32 rx_coalesce_usecs_low;
+	__u32 rx_max_coalesced_frames_low;
+	__u32 tx_coalesce_usecs_low;
+	__u32 tx_max_coalesced_frames_low;
+	__u32 pkt_rate_high;
+	__u32 rx_coalesce_usecs_high;
+	__u32 rx_max_coalesced_frames_high;
+	__u32 tx_coalesce_usecs_high;
+	__u32 tx_max_coalesced_frames_high;
+	__u32 rate_sample_interval;
+};
+
+struct ethtool_ringparam {
+	__u32 cmd;
+	__u32 rx_max_pending;
+	__u32 rx_mini_max_pending;
+	__u32 rx_jumbo_max_pending;
+	__u32 tx_max_pending;
+	__u32 rx_pending;
+	__u32 rx_mini_pending;
+	__u32 rx_jumbo_pending;
+	__u32 tx_pending;
+};
+
+struct ethtool_channels {
+	__u32 cmd;
+	__u32 max_rx;
+	__u32 max_tx;
+	__u32 max_other;
+	__u32 max_combined;
+	__u32 rx_count;
+	__u32 tx_count;
+	__u32 other_count;
+	__u32 combined_count;
+};
+
+struct ethtool_pauseparam {
+	__u32 cmd;
+	__u32 autoneg;
+	__u32 rx_pause;
+	__u32 tx_pause;
+};
+
+enum ethtool_link_ext_state {
+	ETHTOOL_LINK_EXT_STATE_AUTONEG = 0,
+	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE = 1,
+	ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH = 2,
+	ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY = 3,
+	ETHTOOL_LINK_EXT_STATE_NO_CABLE = 4,
+	ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE = 5,
+	ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE = 6,
+	ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE = 7,
+	ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED = 8,
+	ETHTOOL_LINK_EXT_STATE_OVERHEAT = 9,
+	ETHTOOL_LINK_EXT_STATE_MODULE = 10,
+};
+
+enum ethtool_link_ext_substate_autoneg {
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED = 2,
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED = 3,
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE = 4,
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE = 5,
+	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD = 6,
+};
+
+enum ethtool_link_ext_substate_link_training {
+	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
+	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT = 2,
+	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY = 3,
+	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT = 4,
+};
+
+enum ethtool_link_ext_substate_link_logical_mismatch {
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK = 2,
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS = 3,
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED = 4,
+	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED = 5,
+};
+
+enum ethtool_link_ext_substate_bad_signal_integrity {
+	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
+	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE = 2,
+	ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST = 3,
+	ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS = 4,
+};
+
+enum ethtool_link_ext_substate_cable_issue {
+	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
+	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE = 2,
+};
+
+enum ethtool_link_ext_substate_module {
+	ETHTOOL_LINK_EXT_SUBSTATE_MODULE_CMIS_NOT_READY = 1,
+};
+
+enum ethtool_mac_stats_src {
+	ETHTOOL_MAC_STATS_SRC_AGGREGATE = 0,
+	ETHTOOL_MAC_STATS_SRC_EMAC = 1,
+	ETHTOOL_MAC_STATS_SRC_PMAC = 2,
+};
+
+enum ethtool_module_power_mode_policy {
+	ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH = 1,
+	ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO = 2,
+};
+
+enum ethtool_module_power_mode {
+	ETHTOOL_MODULE_POWER_MODE_LOW = 1,
+	ETHTOOL_MODULE_POWER_MODE_HIGH = 2,
+};
+
+enum ethtool_mm_verify_status {
+	ETHTOOL_MM_VERIFY_STATUS_UNKNOWN = 0,
+	ETHTOOL_MM_VERIFY_STATUS_INITIAL = 1,
+	ETHTOOL_MM_VERIFY_STATUS_VERIFYING = 2,
+	ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED = 3,
+	ETHTOOL_MM_VERIFY_STATUS_FAILED = 4,
+	ETHTOOL_MM_VERIFY_STATUS_DISABLED = 5,
+};
+
+struct ethtool_test {
+	__u32 cmd;
+	__u32 flags;
+	__u32 reserved;
+	__u32 len;
+	__u64 data[0];
+};
+
+struct ethtool_stats {
+	__u32 cmd;
+	__u32 n_stats;
+	__u64 data[0];
+};
+
+struct ethtool_tcpip4_spec {
+	__be32 ip4src;
+	__be32 ip4dst;
+	__be16 psrc;
+	__be16 pdst;
+	__u8 tos;
+};
+
+struct ethtool_ah_espip4_spec {
+	__be32 ip4src;
+	__be32 ip4dst;
+	__be32 spi;
+	__u8 tos;
+};
+
+struct ethtool_usrip4_spec {
+	__be32 ip4src;
+	__be32 ip4dst;
+	__be32 l4_4_bytes;
+	__u8 tos;
+	__u8 ip_ver;
+	__u8 proto;
+};
+
+struct ethtool_tcpip6_spec {
+	__be32 ip6src[4];
+	__be32 ip6dst[4];
+	__be16 psrc;
+	__be16 pdst;
+	__u8 tclass;
+};
+
+struct ethtool_ah_espip6_spec {
+	__be32 ip6src[4];
+	__be32 ip6dst[4];
+	__be32 spi;
+	__u8 tclass;
+};
+
+struct ethtool_usrip6_spec {
+	__be32 ip6src[4];
+	__be32 ip6dst[4];
+	__be32 l4_4_bytes;
+	__u8 tclass;
+	__u8 l4_proto;
+};
+
+union ethtool_flow_union {
+	struct ethtool_tcpip4_spec tcp_ip4_spec;
+	struct ethtool_tcpip4_spec udp_ip4_spec;
+	struct ethtool_tcpip4_spec sctp_ip4_spec;
+	struct ethtool_ah_espip4_spec ah_ip4_spec;
+	struct ethtool_ah_espip4_spec esp_ip4_spec;
+	struct ethtool_usrip4_spec usr_ip4_spec;
+	struct ethtool_tcpip6_spec tcp_ip6_spec;
+	struct ethtool_tcpip6_spec udp_ip6_spec;
+	struct ethtool_tcpip6_spec sctp_ip6_spec;
+	struct ethtool_ah_espip6_spec ah_ip6_spec;
+	struct ethtool_ah_espip6_spec esp_ip6_spec;
+	struct ethtool_usrip6_spec usr_ip6_spec;
+	struct ethhdr ether_spec;
+	__u8 hdata[52];
+};
+
+struct ethtool_flow_ext {
+	__u8 padding[2];
+	unsigned char h_dest[6];
+	__be16 vlan_etype;
+	__be16 vlan_tci;
+	__be32 data[2];
+};
+
+struct ethtool_rx_flow_spec {
+	__u32 flow_type;
+	union ethtool_flow_union h_u;
+	struct ethtool_flow_ext h_ext;
+	union ethtool_flow_union m_u;
+	struct ethtool_flow_ext m_ext;
+	long: 32;
+	__u64 ring_cookie;
+	__u32 location;
+	long: 32;
+};
+
+struct ethtool_rxnfc {
+	__u32 cmd;
+	__u32 flow_type;
+	__u64 data;
+	struct ethtool_rx_flow_spec fs;
+	union {
+		__u32 rule_cnt;
+		__u32 rss_context;
+	};
+	__u32 rule_locs[0];
+	long: 32;
+};
+
+struct ethtool_flash {
+	__u32 cmd;
+	__u32 region;
+	char data[128];
+};
+
+struct ethtool_dump {
+	__u32 cmd;
+	__u32 version;
+	__u32 flag;
+	__u32 len;
+	__u8 data[0];
+};
+
+struct ethtool_fecparam {
+	__u32 cmd;
+	__u32 active_fec;
+	__u32 fec;
+	__u32 reserved;
+};
+
+enum ethtool_link_mode_bit_indices {
+	ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
+	ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
+	ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
+	ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
+	ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
+	ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
+	ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
+	ETHTOOL_LINK_MODE_TP_BIT = 7,
+	ETHTOOL_LINK_MODE_AUI_BIT = 8,
+	ETHTOOL_LINK_MODE_MII_BIT = 9,
+	ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
+	ETHTOOL_LINK_MODE_BNC_BIT = 11,
+	ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
+	ETHTOOL_LINK_MODE_Pause_BIT = 13,
+	ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
+	ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
+	ETHTOOL_LINK_MODE_Backplane_BIT = 16,
+	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
+	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
+	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
+	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
+	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
+	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
+	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
+	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
+	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
+	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
+	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
+	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
+	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
+	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
+	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,
+	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
+	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
+	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
+	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
+	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
+	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
+	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
+	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
+	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
+	ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
+	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
+	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
+	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
+	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
+	ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
+	ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
+	ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,
+	ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
+	ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
+	ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
+	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
+	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
+	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
+	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
+	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
+	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
+	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
+	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
+	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
+	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
+	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
+	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
+	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
+	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
+	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
+	ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
+	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
+	ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT = 69,
+	ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT = 70,
+	ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
+	ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT = 72,
+	ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT = 73,
+	ETHTOOL_LINK_MODE_FEC_LLRS_BIT = 74,
+	ETHTOOL_LINK_MODE_100000baseKR_Full_BIT = 75,
+	ETHTOOL_LINK_MODE_100000baseSR_Full_BIT = 76,
+	ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT = 77,
+	ETHTOOL_LINK_MODE_100000baseCR_Full_BIT = 78,
+	ETHTOOL_LINK_MODE_100000baseDR_Full_BIT = 79,
+	ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT = 80,
+	ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT = 81,
+	ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT = 82,
+	ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT = 83,
+	ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT = 84,
+	ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT = 85,
+	ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT = 86,
+	ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT = 87,
+	ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT = 88,
+	ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT = 89,
+	ETHTOOL_LINK_MODE_100baseFX_Half_BIT = 90,
+	ETHTOOL_LINK_MODE_100baseFX_Full_BIT = 91,
+	ETHTOOL_LINK_MODE_10baseT1L_Full_BIT = 92,
+	ETHTOOL_LINK_MODE_800000baseCR8_Full_BIT = 93,
+	ETHTOOL_LINK_MODE_800000baseKR8_Full_BIT = 94,
+	ETHTOOL_LINK_MODE_800000baseDR8_Full_BIT = 95,
+	ETHTOOL_LINK_MODE_800000baseDR8_2_Full_BIT = 96,
+	ETHTOOL_LINK_MODE_800000baseSR8_Full_BIT = 97,
+	ETHTOOL_LINK_MODE_800000baseVR8_Full_BIT = 98,
+	ETHTOOL_LINK_MODE_10baseT1S_Full_BIT = 99,
+	ETHTOOL_LINK_MODE_10baseT1S_Half_BIT = 100,
+	ETHTOOL_LINK_MODE_10baseT1S_P2MP_Half_BIT = 101,
+	ETHTOOL_LINK_MODE_10baseT1BRR_Full_BIT = 102,
+	__ETHTOOL_LINK_MODE_MASK_NBITS = 103,
+};
+
+struct ethtool_link_settings {
+	__u32 cmd;
+	__u32 speed;
+	__u8 duplex;
+	__u8 port;
+	__u8 phy_address;
+	__u8 autoneg;
+	__u8 mdio_support;
+	__u8 eth_tp_mdix;
+	__u8 eth_tp_mdix_ctrl;
+	__s8 link_mode_masks_nwords;
+	__u8 transceiver;
+	__u8 master_slave_cfg;
+	__u8 master_slave_state;
+	__u8 rate_matching;
+	__u32 reserved[7];
+	__u32 link_mode_masks[0];
+};
+
+enum hwtstamp_tx_types {
+	HWTSTAMP_TX_OFF = 0,
+	HWTSTAMP_TX_ON = 1,
+	HWTSTAMP_TX_ONESTEP_SYNC = 2,
+	HWTSTAMP_TX_ONESTEP_P2P = 3,
+	__HWTSTAMP_TX_CNT = 4,
+};
+
+enum hwtstamp_rx_filters {
+	HWTSTAMP_FILTER_NONE = 0,
+	HWTSTAMP_FILTER_ALL = 1,
+	HWTSTAMP_FILTER_SOME = 2,
+	HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
+	HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
+	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
+	HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
+	HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
+	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
+	HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
+	HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
+	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
+	HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
+	HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
+	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
+	HWTSTAMP_FILTER_NTP_ALL = 15,
+	__HWTSTAMP_FILTER_CNT = 16,
+};
+
+struct kernel_ethtool_ringparam {
+	u32 rx_buf_len;
+	u8 tcp_data_split;
+	u8 tx_push;
+	u8 rx_push;
+	u32 cqe_size;
+	u32 tx_push_buf_len;
+	u32 tx_push_buf_max_len;
+};
+
+struct ethtool_link_ext_state_info {
+	enum ethtool_link_ext_state link_ext_state;
+	union {
+		enum ethtool_link_ext_substate_autoneg autoneg;
+		enum ethtool_link_ext_substate_link_training link_training;
+		enum ethtool_link_ext_substate_link_logical_mismatch link_logical_mismatch;
+		enum ethtool_link_ext_substate_bad_signal_integrity bad_signal_integrity;
+		enum ethtool_link_ext_substate_cable_issue cable_issue;
+		enum ethtool_link_ext_substate_module module;
+		u32 __link_ext_substate;
+	};
+};
+
+struct ethtool_link_ext_stats {
+	u64 link_down_events;
+};
+
+struct ethtool_rxfh_context {
+	u32 indir_size;
+	u32 key_size;
+	u16 priv_size;
+	u8 hfunc;
+	u8 input_xfrm;
+	u8 indir_configured: 1;
+	u8 key_configured: 1;
+	u32 key_off;
+	u8 data[0];
+};
+
+struct ethtool_link_ksettings {
+	struct ethtool_link_settings base;
+	struct {
+		long unsigned int supported[4];
+		long unsigned int advertising[4];
+		long unsigned int lp_advertising[4];
+	} link_modes;
+	u32 lanes;
+};
+
+struct ethtool_keee {
+	long unsigned int supported[4];
+	long unsigned int advertised[4];
+	long unsigned int lp_advertised[4];
+	u32 tx_lpi_timer;
+	bool tx_lpi_enabled;
+	bool eee_active;
+	bool eee_enabled;
+};
+
+struct kernel_ethtool_coalesce {
+	u8 use_cqe_mode_tx;
+	u8 use_cqe_mode_rx;
+	u32 tx_aggr_max_bytes;
+	u32 tx_aggr_max_frames;
+	u32 tx_aggr_time_usecs;
+};
+
+struct ethtool_eth_mac_stats {
+	enum ethtool_mac_stats_src src;
+	long: 32;
+	union {
+		struct {
+			u64 FramesTransmittedOK;
+			u64 SingleCollisionFrames;
+			u64 MultipleCollisionFrames;
+			u64 FramesReceivedOK;
+			u64 FrameCheckSequenceErrors;
+			u64 AlignmentErrors;
+			u64 OctetsTransmittedOK;
+			u64 FramesWithDeferredXmissions;
+			u64 LateCollisions;
+			u64 FramesAbortedDueToXSColls;
+			u64 FramesLostDueToIntMACXmitError;
+			u64 CarrierSenseErrors;
+			u64 OctetsReceivedOK;
+			u64 FramesLostDueToIntMACRcvError;
+			u64 MulticastFramesXmittedOK;
+			u64 BroadcastFramesXmittedOK;
+			u64 FramesWithExcessiveDeferral;
+			u64 MulticastFramesReceivedOK;
+			u64 BroadcastFramesReceivedOK;
+			u64 InRangeLengthErrors;
+			u64 OutOfRangeLengthField;
+			u64 FrameTooLongErrors;
+		};
+		struct {
+			u64 FramesTransmittedOK;
+			u64 SingleCollisionFrames;
+			u64 MultipleCollisionFrames;
+			u64 FramesReceivedOK;
+			u64 FrameCheckSequenceErrors;
+			u64 AlignmentErrors;
+			u64 OctetsTransmittedOK;
+			u64 FramesWithDeferredXmissions;
+			u64 LateCollisions;
+			u64 FramesAbortedDueToXSColls;
+			u64 FramesLostDueToIntMACXmitError;
+			u64 CarrierSenseErrors;
+			u64 OctetsReceivedOK;
+			u64 FramesLostDueToIntMACRcvError;
+			u64 MulticastFramesXmittedOK;
+			u64 BroadcastFramesXmittedOK;
+			u64 FramesWithExcessiveDeferral;
+			u64 MulticastFramesReceivedOK;
+			u64 BroadcastFramesReceivedOK;
+			u64 InRangeLengthErrors;
+			u64 OutOfRangeLengthField;
+			u64 FrameTooLongErrors;
+		} stats;
+	};
+};
+
+struct ethtool_eth_phy_stats {
+	enum ethtool_mac_stats_src src;
+	long: 32;
+	union {
+		struct {
+			u64 SymbolErrorDuringCarrier;
+		};
+		struct {
+			u64 SymbolErrorDuringCarrier;
+		} stats;
+	};
+};
+
+struct ethtool_eth_ctrl_stats {
+	enum ethtool_mac_stats_src src;
+	long: 32;
+	union {
+		struct {
+			u64 MACControlFramesTransmitted;
+			u64 MACControlFramesReceived;
+			u64 UnsupportedOpcodesReceived;
+		};
+		struct {
+			u64 MACControlFramesTransmitted;
+			u64 MACControlFramesReceived;
+			u64 UnsupportedOpcodesReceived;
+		} stats;
+	};
+};
+
+struct ethtool_pause_stats {
+	enum ethtool_mac_stats_src src;
+	long: 32;
+	union {
+		struct {
+			u64 tx_pause_frames;
+			u64 rx_pause_frames;
+		};
+		struct {
+			u64 tx_pause_frames;
+			u64 rx_pause_frames;
+		} stats;
+	};
+};
+
+struct ethtool_fec_stat {
+	u64 total;
+	u64 lanes[8];
+};
+
+struct ethtool_fec_stats {
+	struct ethtool_fec_stat corrected_blocks;
+	struct ethtool_fec_stat uncorrectable_blocks;
+	struct ethtool_fec_stat corrected_bits;
+};
+
+struct ethtool_rmon_hist_range {
+	u16 low;
+	u16 high;
+};
+
+struct ethtool_rmon_stats {
+	enum ethtool_mac_stats_src src;
+	long: 32;
+	union {
+		struct {
+			u64 undersize_pkts;
+			u64 oversize_pkts;
+			u64 fragments;
+			u64 jabbers;
+			u64 hist[10];
+			u64 hist_tx[10];
+		};
+		struct {
+			u64 undersize_pkts;
+			u64 oversize_pkts;
+			u64 fragments;
+			u64 jabbers;
+			u64 hist[10];
+			u64 hist_tx[10];
+		} stats;
+	};
+};
+
+struct ethtool_ts_stats {
+	union {
+		struct {
+			u64 pkts;
+			u64 lost;
+			u64 err;
+		};
+		struct {
+			u64 pkts;
+			u64 lost;
+			u64 err;
+		} tx_stats;
+	};
+};
+
+struct ethtool_module_eeprom {
+	u32 offset;
+	u32 length;
+	u8 page;
+	u8 bank;
+	u8 i2c_address;
+	u8 *data;
+};
+
+struct ethtool_module_power_mode_params {
+	enum ethtool_module_power_mode_policy policy;
+	enum ethtool_module_power_mode mode;
+};
+
+struct ethtool_mm_state {
+	u32 verify_time;
+	u32 max_verify_time;
+	enum ethtool_mm_verify_status verify_status;
+	bool tx_enabled;
+	bool tx_active;
+	bool pmac_enabled;
+	bool verify_enabled;
+	u32 tx_min_frag_size;
+	u32 rx_min_frag_size;
+};
+
+struct ethtool_mm_cfg {
+	u32 verify_time;
+	bool verify_enabled;
+	bool tx_enabled;
+	bool pmac_enabled;
+	u32 tx_min_frag_size;
+};
+
+struct ethtool_mm_stats {
+	u64 MACMergeFrameAssErrorCount;
+	u64 MACMergeFrameSmdErrorCount;
+	u64 MACMergeFrameAssOkCount;
+	u64 MACMergeFragCountRx;
+	u64 MACMergeFragCountTx;
+	u64 MACMergeHoldCount;
+};
+
+struct ethtool_rxfh_param {
+	u8 hfunc;
+	u32 indir_size;
+	u32 *indir;
+	u32 key_size;
+	u8 *key;
+	u32 rss_context;
+	u8 rss_delete;
+	u8 input_xfrm;
+};
+
+struct kernel_ethtool_ts_info {
+	u32 cmd;
+	u32 so_timestamping;
+	int phc_index;
+	enum hwtstamp_tx_types tx_types;
+	enum hwtstamp_rx_filters rx_filters;
+};
+
+struct ethtool_netdev_state {
+	struct xarray rss_ctx;
+	struct mutex rss_lock;
+	unsigned int wol_enabled: 1;
+	unsigned int module_fw_flash_in_progress: 1;
+};
+
+struct mii_bus;
+
+struct mdio_device {
+	struct device dev;
+	struct mii_bus *bus;
+	char modalias[32];
+	int (*bus_match)(struct device *, const struct device_driver *);
+	void (*device_free)(struct mdio_device *);
+	void (*device_remove)(struct mdio_device *);
+	int addr;
+	int flags;
+	int reset_state;
+	struct gpio_desc *reset_gpio;
+	struct reset_control *reset_ctrl;
+	unsigned int reset_assert_delay;
+	unsigned int reset_deassert_delay;
+	long: 32;
+};
+
+struct phy_c45_device_ids {
+	u32 devices_in_package;
+	u32 mmds_present;
+	u32 device_ids[32];
+};
+
+enum phy_state {
+	PHY_DOWN = 0,
+	PHY_READY = 1,
+	PHY_HALTED = 2,
+	PHY_ERROR = 3,
+	PHY_UP = 4,
+	PHY_RUNNING = 5,
+	PHY_NOLINK = 6,
+	PHY_CABLETEST = 7,
+};
+
+typedef enum {
+	PHY_INTERFACE_MODE_NA = 0,
+	PHY_INTERFACE_MODE_INTERNAL = 1,
+	PHY_INTERFACE_MODE_MII = 2,
+	PHY_INTERFACE_MODE_GMII = 3,
+	PHY_INTERFACE_MODE_SGMII = 4,
+	PHY_INTERFACE_MODE_TBI = 5,
+	PHY_INTERFACE_MODE_REVMII = 6,
+	PHY_INTERFACE_MODE_RMII = 7,
+	PHY_INTERFACE_MODE_REVRMII = 8,
+	PHY_INTERFACE_MODE_RGMII = 9,
+	PHY_INTERFACE_MODE_RGMII_ID = 10,
+	PHY_INTERFACE_MODE_RGMII_RXID = 11,
+	PHY_INTERFACE_MODE_RGMII_TXID = 12,
+	PHY_INTERFACE_MODE_RTBI = 13,
+	PHY_INTERFACE_MODE_SMII = 14,
+	PHY_INTERFACE_MODE_XGMII = 15,
+	PHY_INTERFACE_MODE_XLGMII = 16,
+	PHY_INTERFACE_MODE_MOCA = 17,
+	PHY_INTERFACE_MODE_PSGMII = 18,
+	PHY_INTERFACE_MODE_QSGMII = 19,
+	PHY_INTERFACE_MODE_TRGMII = 20,
+	PHY_INTERFACE_MODE_100BASEX = 21,
+	PHY_INTERFACE_MODE_1000BASEX = 22,
+	PHY_INTERFACE_MODE_2500BASEX = 23,
+	PHY_INTERFACE_MODE_5GBASER = 24,
+	PHY_INTERFACE_MODE_RXAUI = 25,
+	PHY_INTERFACE_MODE_XAUI = 26,
+	PHY_INTERFACE_MODE_10GBASER = 27,
+	PHY_INTERFACE_MODE_25GBASER = 28,
+	PHY_INTERFACE_MODE_USXGMII = 29,
+	PHY_INTERFACE_MODE_10GKR = 30,
+	PHY_INTERFACE_MODE_QUSGMII = 31,
+	PHY_INTERFACE_MODE_1000BASEKX = 32,
+	PHY_INTERFACE_MODE_10G_QXGMII = 33,
+	PHY_INTERFACE_MODE_MAX = 34,
+} phy_interface_t;
+
+struct eee_config {
+	u32 tx_lpi_timer;
+	bool tx_lpi_enabled;
+	bool eee_enabled;
+};
+
+struct pse_control;
+
+struct phy_driver;
+
+struct phy_package_shared;
+
+struct phylink;
+
+struct mii_timestamper;
+
+struct phy_device {
+	struct mdio_device mdio;
+	const struct phy_driver *drv;
+	struct device_link *devlink;
+	u32 phyindex;
+	u32 phy_id;
+	struct phy_c45_device_ids c45_ids;
+	unsigned int is_c45: 1;
+	unsigned int is_internal: 1;
+	unsigned int is_pseudo_fixed_link: 1;
+	unsigned int is_gigabit_capable: 1;
+	unsigned int has_fixups: 1;
+	unsigned int suspended: 1;
+	unsigned int suspended_by_mdio_bus: 1;
+	unsigned int sysfs_links: 1;
+	unsigned int loopback_enabled: 1;
+	unsigned int downshifted_rate: 1;
+	unsigned int is_on_sfp_module: 1;
+	unsigned int mac_managed_pm: 1;
+	unsigned int wol_enabled: 1;
+	unsigned int autoneg: 1;
+	unsigned int link: 1;
+	unsigned int autoneg_complete: 1;
+	unsigned int interrupts: 1;
+	unsigned int irq_suspended: 1;
+	unsigned int irq_rerun: 1;
+	unsigned int default_timestamp: 1;
+	int rate_matching;
+	enum phy_state state;
+	u32 dev_flags;
+	phy_interface_t interface;
+	long unsigned int possible_interfaces[2];
+	int speed;
+	int duplex;
+	int port;
+	int pause;
+	int asym_pause;
+	u8 master_slave_get;
+	u8 master_slave_set;
+	u8 master_slave_state;
+	long unsigned int supported[4];
+	long unsigned int advertising[4];
+	long unsigned int lp_advertising[4];
+	long unsigned int adv_old[4];
+	long unsigned int supported_eee[4];
+	long unsigned int advertising_eee[4];
+	bool eee_enabled;
+	long unsigned int host_interfaces[2];
+	u32 eee_broken_modes;
+	bool enable_tx_lpi;
+	struct eee_config eee_cfg;
+	struct list_head leds;
+	int irq;
+	void *priv;
+	struct phy_package_shared *shared;
+	struct sk_buff *skb;
+	void *ehdr;
+	struct nlattr *nest;
+	struct delayed_work state_queue;
+	struct mutex lock;
+	bool sfp_bus_attached;
+	struct sfp_bus *sfp_bus;
+	struct phylink *phylink;
+	struct net_device *attached_dev;
+	struct mii_timestamper *mii_ts;
+	struct pse_control *psec;
+	u8 mdix;
+	u8 mdix_ctrl;
+	int pma_extable;
+	unsigned int link_down_events;
+	void (*phy_link_change)(struct phy_device *, bool);
+	void (*adjust_link)(struct net_device *);
+	const struct macsec_ops *macsec_ops;
+};
+
+struct phy_plca_cfg {
+	int version;
+	int enabled;
+	int node_id;
+	int node_cnt;
+	int to_tmr;
+	int burst_cnt;
+	int burst_tmr;
+};
+
+struct phy_plca_status {
+	bool pst;
+};
+
+struct phy_tdr_config {
+	u32 first;
+	u32 last;
+	u32 step;
+	s8 pair;
+};
+
+enum netdev_state_t {
+	__LINK_STATE_START = 0,
+	__LINK_STATE_PRESENT = 1,
+	__LINK_STATE_NOCARRIER = 2,
+	__LINK_STATE_LINKWATCH_PENDING = 3,
+	__LINK_STATE_DORMANT = 4,
+	__LINK_STATE_TESTING = 5,
+};
+
+struct mii_ioctl_data {
+	__u16 phy_id;
+	__u16 reg_num;
+	__u16 val_in;
+	__u16 val_out;
+};
+
+struct mdio_bus_stats {
+	u64_stats_t transfers;
+	u64_stats_t errors;
+	u64_stats_t writes;
+	u64_stats_t reads;
+	struct u64_stats_sync syncp;
+	long: 32;
+};
+
+struct mii_bus {
+	struct module *owner;
+	const char *name;
+	char id[61];
+	void *priv;
+	int (*read)(struct mii_bus *, int, int);
+	int (*write)(struct mii_bus *, int, int, u16);
+	int (*read_c45)(struct mii_bus *, int, int, int);
+	int (*write_c45)(struct mii_bus *, int, int, int, u16);
+	int (*reset)(struct mii_bus *);
+	struct mdio_bus_stats stats[32];
+	struct mutex mdio_lock;
+	struct device *parent;
+	enum {
+		MDIOBUS_ALLOCATED = 1,
+		MDIOBUS_REGISTERED = 2,
+		MDIOBUS_UNREGISTERED = 3,
+		MDIOBUS_RELEASED = 4,
+	} state;
+	long: 32;
+	struct device dev;
+	struct mdio_device *mdio_map[32];
+	u32 phy_mask;
+	u32 phy_ignore_ta_mask;
+	int irq[32];
+	int reset_delay_us;
+	int reset_post_delay_us;
+	struct gpio_desc *reset_gpiod;
+	struct mutex shared_lock;
+	struct phy_package_shared *shared[32];
+};
+
+struct mdio_driver_common {
+	struct device_driver driver;
+	int flags;
+};
+
+struct mii_timestamper {
+	bool (*rxtstamp)(struct mii_timestamper *, struct sk_buff *, int);
+	void (*txtstamp)(struct mii_timestamper *, struct sk_buff *, int);
+	int (*hwtstamp)(struct mii_timestamper *, struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
+	void (*link_state)(struct mii_timestamper *, struct phy_device *);
+	int (*ts_info)(struct mii_timestamper *, struct kernel_ethtool_ts_info *);
+	struct device *device;
+};
+
+struct phy_package_shared {
+	u8 base_addr;
+	struct device_node *np;
+	refcount_t refcnt;
+	long unsigned int flags;
+	size_t priv_size;
+	void *priv;
+};
+
+struct phy_driver {
+	struct mdio_driver_common mdiodrv;
+	u32 phy_id;
+	char *name;
+	u32 phy_id_mask;
+	const long unsigned int * const features;
+	u32 flags;
+	const void *driver_data;
+	int (*soft_reset)(struct phy_device *);
+	int (*config_init)(struct phy_device *);
+	int (*probe)(struct phy_device *);
+	int (*get_features)(struct phy_device *);
+	int (*get_rate_matching)(struct phy_device *, phy_interface_t);
+	int (*suspend)(struct phy_device *);
+	int (*resume)(struct phy_device *);
+	int (*config_aneg)(struct phy_device *);
+	int (*aneg_done)(struct phy_device *);
+	int (*read_status)(struct phy_device *);
+	int (*config_intr)(struct phy_device *);
+	irqreturn_t (*handle_interrupt)(struct phy_device *);
+	void (*detach)(struct phy_device *);
+	void (*remove)(struct phy_device *);
+	int (*match_phy_device)(struct phy_device *);
+	int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *);
+	void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *);
+	void (*link_change_notify)(struct phy_device *);
+	int (*read_mmd)(struct phy_device *, int, u16);
+	int (*write_mmd)(struct phy_device *, int, u16, u16);
+	int (*read_page)(struct phy_device *);
+	int (*write_page)(struct phy_device *, int);
+	int (*module_info)(struct phy_device *, struct ethtool_modinfo *);
+	int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *);
+	int (*cable_test_start)(struct phy_device *);
+	int (*cable_test_tdr_start)(struct phy_device *, const struct phy_tdr_config *);
+	int (*cable_test_get_status)(struct phy_device *, bool *);
+	int (*get_sset_count)(struct phy_device *);
+	void (*get_strings)(struct phy_device *, u8 *);
+	void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
+	int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *);
+	int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, const void *);
+	int (*set_loopback)(struct phy_device *, bool);
+	int (*get_sqi)(struct phy_device *);
+	int (*get_sqi_max)(struct phy_device *);
+	int (*get_plca_cfg)(struct phy_device *, struct phy_plca_cfg *);
+	int (*set_plca_cfg)(struct phy_device *, const struct phy_plca_cfg *);
+	int (*get_plca_status)(struct phy_device *, struct phy_plca_status *);
+	int (*led_brightness_set)(struct phy_device *, u8, enum led_brightness);
+	int (*led_blink_set)(struct phy_device *, u8, long unsigned int *, long unsigned int *);
+	int (*led_hw_is_supported)(struct phy_device *, u8, long unsigned int);
+	int (*led_hw_control_set)(struct phy_device *, u8, long unsigned int);
+	int (*led_hw_control_get)(struct phy_device *, u8, long unsigned int *);
+	int (*led_polarity_set)(struct phy_device *, int, long unsigned int);
+};
+
+struct phylink_link_state {
+	long unsigned int advertising[4];
+	long unsigned int lp_advertising[4];
+	phy_interface_t interface;
+	int speed;
+	int duplex;
+	int pause;
+	int rate_matching;
+	unsigned int link: 1;
+	unsigned int an_complete: 1;
+};
+
+struct phylink_mac_ops;
+
+struct phylink_config;
+
+struct phylink_pcs;
+
+struct phylink {
+	struct net_device *netdev;
+	const struct phylink_mac_ops *mac_ops;
+	struct phylink_config *config;
+	struct phylink_pcs *pcs;
+	struct device *dev;
+	unsigned int old_link_state: 1;
+	long unsigned int phylink_disable_state;
+	struct phy_device *phydev;
+	phy_interface_t link_interface;
+	u8 cfg_link_an_mode;
+	u8 cur_link_an_mode;
+	u8 link_port;
+	long unsigned int supported[4];
+	struct phylink_link_state link_config;
+	phy_interface_t cur_interface;
+	struct gpio_desc *link_gpio;
+	unsigned int link_irq;
+	struct timer_list link_poll;
+	void (*get_fixed_state)(struct net_device *, struct phylink_link_state *);
+	struct mutex state_mutex;
+	struct phylink_link_state phy_state;
+	struct work_struct resolve;
+	unsigned int pcs_neg_mode;
+	unsigned int pcs_state;
+	bool link_failed;
+	bool using_mac_select_pcs;
+	struct sfp_bus *sfp_bus;
+	bool sfp_may_have_phy;
+	long unsigned int sfp_interfaces[2];
+	long unsigned int sfp_support[4];
+	u8 sfp_port;
+};
+
+struct phy_setting {
+	u32 speed;
+	u8 duplex;
+	u8 bit;
+};
+
+struct fixed_phy_status {
+	int link;
+	int speed;
+	int duplex;
+	int pause;
+	int asym_pause;
+};
+
+enum {
+	MLO_PAUSE_NONE = 0,
+	MLO_PAUSE_RX = 1,
+	MLO_PAUSE_TX = 2,
+	MLO_PAUSE_TXRX_MASK = 3,
+	MLO_PAUSE_AN = 4,
+	MLO_AN_PHY = 0,
+	MLO_AN_FIXED = 1,
+	MLO_AN_INBAND = 2,
+	PHYLINK_PCS_NEG_NONE = 0,
+	PHYLINK_PCS_NEG_ENABLED = 16,
+	PHYLINK_PCS_NEG_OUTBAND = 32,
+	PHYLINK_PCS_NEG_INBAND = 64,
+	PHYLINK_PCS_NEG_INBAND_DISABLED = 64,
+	PHYLINK_PCS_NEG_INBAND_ENABLED = 80,
+	MAC_SYM_PAUSE = 1,
+	MAC_ASYM_PAUSE = 2,
+	MAC_10HD = 4,
+	MAC_10FD = 8,
+	MAC_10 = 12,
+	MAC_100HD = 16,
+	MAC_100FD = 32,
+	MAC_100 = 48,
+	MAC_1000HD = 64,
+	MAC_1000FD = 128,
+	MAC_1000 = 192,
+	MAC_2500FD = 256,
+	MAC_5000FD = 512,
+	MAC_10000FD = 1024,
+	MAC_20000FD = 2048,
+	MAC_25000FD = 4096,
+	MAC_40000FD = 8192,
+	MAC_50000FD = 16384,
+	MAC_56000FD = 32768,
+	MAC_100000FD = 65536,
+	MAC_200000FD = 131072,
+	MAC_400000FD = 262144,
+};
+
+enum phylink_op_type {
+	PHYLINK_NETDEV = 0,
+	PHYLINK_DEV = 1,
+};
+
+struct phylink_config {
+	struct device *dev;
+	enum phylink_op_type type;
+	bool poll_fixed_state;
+	bool mac_managed_pm;
+	bool mac_requires_rxc;
+	bool default_an_inband;
+	void (*get_fixed_state)(struct phylink_config *, struct phylink_link_state *);
+	long unsigned int supported_interfaces[2];
+	long unsigned int mac_capabilities;
+};
+
+struct phylink_mac_ops {
+	long unsigned int (*mac_get_caps)(struct phylink_config *, phy_interface_t);
+	struct phylink_pcs * (*mac_select_pcs)(struct phylink_config *, phy_interface_t);
+	int (*mac_prepare)(struct phylink_config *, unsigned int, phy_interface_t);
+	void (*mac_config)(struct phylink_config *, unsigned int, const struct phylink_link_state *);
+	int (*mac_finish)(struct phylink_config *, unsigned int, phy_interface_t);
+	void (*mac_link_down)(struct phylink_config *, unsigned int, phy_interface_t);
+	void (*mac_link_up)(struct phylink_config *, struct phy_device *, unsigned int, phy_interface_t, int, int, bool, bool);
+};
+
+struct phylink_pcs_ops;
+
+struct phylink_pcs {
+	const struct phylink_pcs_ops *ops;
+	struct phylink *phylink;
+	bool neg_mode;
+	bool poll;
+	bool rxc_always_on;
+};
+
+struct phylink_pcs_ops {
+	int (*pcs_validate)(struct phylink_pcs *, long unsigned int *, const struct phylink_link_state *);
+	int (*pcs_enable)(struct phylink_pcs *);
+	void (*pcs_disable)(struct phylink_pcs *);
+	void (*pcs_pre_config)(struct phylink_pcs *, phy_interface_t);
+	int (*pcs_post_config)(struct phylink_pcs *, phy_interface_t);
+	void (*pcs_get_state)(struct phylink_pcs *, struct phylink_link_state *);
+	int (*pcs_config)(struct phylink_pcs *, unsigned int, phy_interface_t, const long unsigned int *, bool);
+	void (*pcs_an_restart)(struct phylink_pcs *);
+	void (*pcs_link_up)(struct phylink_pcs *, unsigned int, phy_interface_t, int, int);
+	int (*pcs_pre_init)(struct phylink_pcs *);
+};
+
+struct sfp_eeprom_base {
+	u8 phys_id;
+	u8 phys_ext_id;
+	u8 connector;
+	u8 if_1x_copper_passive: 1;
+	u8 if_1x_copper_active: 1;
+	u8 if_1x_lx: 1;
+	u8 if_1x_sx: 1;
+	u8 e10g_base_sr: 1;
+	u8 e10g_base_lr: 1;
+	u8 e10g_base_lrm: 1;
+	u8 e10g_base_er: 1;
+	u8 sonet_oc3_short_reach: 1;
+	u8 sonet_oc3_smf_intermediate_reach: 1;
+	u8 sonet_oc3_smf_long_reach: 1;
+	u8 unallocated_5_3: 1;
+	u8 sonet_oc12_short_reach: 1;
+	u8 sonet_oc12_smf_intermediate_reach: 1;
+	u8 sonet_oc12_smf_long_reach: 1;
+	u8 unallocated_5_7: 1;
+	u8 sonet_oc48_short_reach: 1;
+	u8 sonet_oc48_intermediate_reach: 1;
+	u8 sonet_oc48_long_reach: 1;
+	u8 sonet_reach_bit2: 1;
+	u8 sonet_reach_bit1: 1;
+	u8 sonet_oc192_short_reach: 1;
+	u8 escon_smf_1310_laser: 1;
+	u8 escon_mmf_1310_led: 1;
+	u8 e1000_base_sx: 1;
+	u8 e1000_base_lx: 1;
+	u8 e1000_base_cx: 1;
+	u8 e1000_base_t: 1;
+	u8 e100_base_lx: 1;
+	u8 e100_base_fx: 1;
+	u8 e_base_bx10: 1;
+	u8 e_base_px: 1;
+	u8 fc_tech_electrical_inter_enclosure: 1;
+	u8 fc_tech_lc: 1;
+	u8 fc_tech_sa: 1;
+	u8 fc_ll_m: 1;
+	u8 fc_ll_l: 1;
+	u8 fc_ll_i: 1;
+	u8 fc_ll_s: 1;
+	u8 fc_ll_v: 1;
+	u8 unallocated_8_0: 1;
+	u8 unallocated_8_1: 1;
+	u8 sfp_ct_passive: 1;
+	u8 sfp_ct_active: 1;
+	u8 fc_tech_ll: 1;
+	u8 fc_tech_sl: 1;
+	u8 fc_tech_sn: 1;
+	u8 fc_tech_electrical_intra_enclosure: 1;
+	u8 fc_media_sm: 1;
+	u8 unallocated_9_1: 1;
+	u8 fc_media_m5: 1;
+	u8 fc_media_m6: 1;
+	u8 fc_media_tv: 1;
+	u8 fc_media_mi: 1;
+	u8 fc_media_tp: 1;
+	u8 fc_media_tw: 1;
+	u8 fc_speed_100: 1;
+	u8 unallocated_10_1: 1;
+	u8 fc_speed_200: 1;
+	u8 fc_speed_3200: 1;
+	u8 fc_speed_400: 1;
+	u8 fc_speed_1600: 1;
+	u8 fc_speed_800: 1;
+	u8 fc_speed_1200: 1;
+	u8 encoding;
+	u8 br_nominal;
+	u8 rate_id;
+	u8 link_len[6];
+	char vendor_name[16];
+	u8 extended_cc;
+	char vendor_oui[3];
+	char vendor_pn[16];
+	char vendor_rev[4];
+	union {
+		__be16 optical_wavelength;
+		__be16 cable_compliance;
+		struct {
+			u8 sff8431_app_e: 1;
+			u8 fc_pi_4_app_h: 1;
+			u8 reserved60_2: 6;
+			u8 reserved61: 8;
+		} passive;
+		struct {
+			u8 sff8431_app_e: 1;
+			u8 fc_pi_4_app_h: 1;
+			u8 sff8431_lim: 1;
+			u8 fc_pi_4_lim: 1;
+			u8 reserved60_4: 4;
+			u8 reserved61: 8;
+		} active;
+	};
+	u8 reserved62;
+	u8 cc_base;
+};
+
+struct sfp_eeprom_ext {
+	__be16 options;
+	u8 br_max;
+	u8 br_min;
+	char vendor_sn[16];
+	char datecode[8];
+	u8 diagmon;
+	u8 enhopts;
+	u8 sff8472_compliance;
+	u8 cc_ext;
+};
+
+struct sfp_eeprom_id {
+	struct sfp_eeprom_base base;
+	struct sfp_eeprom_ext ext;
+};
+
+struct sfp_upstream_ops {
+	void (*attach)(void *, struct sfp_bus *);
+	void (*detach)(void *, struct sfp_bus *);
+	int (*module_insert)(void *, const struct sfp_eeprom_id *);
+	void (*module_remove)(void *);
+	int (*module_start)(void *);
+	void (*module_stop)(void *);
+	void (*link_down)(void *);
+	void (*link_up)(void *);
+	int (*connect_phy)(void *, struct phy_device *);
+	void (*disconnect_phy)(void *, struct phy_device *);
+};
+
+enum {
+	PHYLINK_DISABLE_STOPPED = 0,
+	PHYLINK_DISABLE_LINK = 1,
+	PHYLINK_DISABLE_MAC_WOL = 2,
+	PCS_STATE_DOWN = 0,
+	PCS_STATE_STARTING = 1,
+	PCS_STATE_STARTED = 2,
+};
+
+struct phy_link_topology {
+	struct xarray phys;
+	u32 next_phy_index;
+};
+
+enum phy_upstream {
+	PHY_UPSTREAM_MAC = 0,
+	PHY_UPSTREAM_PHY = 1,
+};
+
+struct ethtool_phy_ops {
+	int (*get_sset_count)(struct phy_device *);
+	int (*get_strings)(struct phy_device *, u8 *);
+	int (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
+	int (*get_plca_cfg)(struct phy_device *, struct phy_plca_cfg *);
+	int (*set_plca_cfg)(struct phy_device *, const struct phy_plca_cfg *, struct netlink_ext_ack *);
+	int (*get_plca_status)(struct phy_device *, struct phy_plca_status *);
+	int (*start_cable_test)(struct phy_device *, struct netlink_ext_ack *);
+	int (*start_cable_test_tdr)(struct phy_device *, struct netlink_ext_ack *, const struct phy_tdr_config *);
+};
+
+enum phy_led_modes {
+	PHY_LED_ACTIVE_LOW = 0,
+	PHY_LED_INACTIVE_HIGH_IMPEDANCE = 1,
+	__PHY_LED_MODES_NUM = 2,
+};
+
+struct phy_led {
+	struct list_head list;
+	struct phy_device *phydev;
+	struct led_classdev led_cdev;
+	u8 index;
+};
+
+struct phy_fixup {
+	struct list_head list;
+	char bus_id[64];
+	u32 phy_uid;
+	u32 phy_uid_mask;
+	int (*run)(struct phy_device *);
+};
+
+struct phylib_stubs {
+	int (*hwtstamp_get)(struct phy_device *, struct kernel_hwtstamp_config *);
+	int (*hwtstamp_set)(struct phy_device *, struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
+};
+
+struct iproc_mdio_priv {
+	struct mii_bus *mii_bus;
+	void *base;
+};
+
+struct dsa_chip_data {
+	struct device *host_dev;
+	int sw_addr;
+	struct device *netdev[12];
+	int eeprom_len;
+	struct device_node *of_node;
+	char *port_names[12];
+	struct device_node *port_dn[12];
+	s8 rtable[4];
+};
+
+struct dsa_platform_data {
+	struct device *netdev;
+	struct net_device *of_netdev;
+	int nr_chips;
+	struct dsa_chip_data *chip;
+};
+
+struct b53_platform_data {
+	struct dsa_chip_data cd;
+	u32 chip_id;
+	u16 enabled_ports;
+	const char *alias;
+	unsigned int big_endian: 1;
+	void *regs;
+};
+
+struct flow_dissector {
+	long long unsigned int used_keys;
+	short unsigned int offset[33];
+	long: 32;
+};
+
+enum ethtool_stringset {
+	ETH_SS_TEST = 0,
+	ETH_SS_STATS = 1,
+	ETH_SS_PRIV_FLAGS = 2,
+	ETH_SS_NTUPLE_FILTERS = 3,
+	ETH_SS_FEATURES = 4,
+	ETH_SS_RSS_HASH_FUNCS = 5,
+	ETH_SS_TUNABLES = 6,
+	ETH_SS_PHY_STATS = 7,
+	ETH_SS_PHY_TUNABLES = 8,
+	ETH_SS_LINK_MODES = 9,
+	ETH_SS_MSG_CLASSES = 10,
+	ETH_SS_WOL_MODES = 11,
+	ETH_SS_SOF_TIMESTAMPING = 12,
+	ETH_SS_TS_TX_TYPES = 13,
+	ETH_SS_TS_RX_FILTERS = 14,
+	ETH_SS_UDP_TUNNEL_TYPES = 15,
+	ETH_SS_STATS_STD = 16,
+	ETH_SS_STATS_ETH_PHY = 17,
+	ETH_SS_STATS_ETH_MAC = 18,
+	ETH_SS_STATS_ETH_CTRL = 19,
+	ETH_SS_STATS_RMON = 20,
+	ETH_SS_COUNT = 21,
+};
+
+struct flow_match {
+	struct flow_dissector *dissector;
+	void *mask;
+	void *key;
+};
+
+enum flow_action_id {
+	FLOW_ACTION_ACCEPT = 0,
+	FLOW_ACTION_DROP = 1,
+	FLOW_ACTION_TRAP = 2,
+	FLOW_ACTION_GOTO = 3,
+	FLOW_ACTION_REDIRECT = 4,
+	FLOW_ACTION_MIRRED = 5,
+	FLOW_ACTION_REDIRECT_INGRESS = 6,
+	FLOW_ACTION_MIRRED_INGRESS = 7,
+	FLOW_ACTION_VLAN_PUSH = 8,
+	FLOW_ACTION_VLAN_POP = 9,
+	FLOW_ACTION_VLAN_MANGLE = 10,
+	FLOW_ACTION_TUNNEL_ENCAP = 11,
+	FLOW_ACTION_TUNNEL_DECAP = 12,
+	FLOW_ACTION_MANGLE = 13,
+	FLOW_ACTION_ADD = 14,
+	FLOW_ACTION_CSUM = 15,
+	FLOW_ACTION_MARK = 16,
+	FLOW_ACTION_PTYPE = 17,
+	FLOW_ACTION_PRIORITY = 18,
+	FLOW_ACTION_RX_QUEUE_MAPPING = 19,
+	FLOW_ACTION_WAKE = 20,
+	FLOW_ACTION_QUEUE = 21,
+	FLOW_ACTION_SAMPLE = 22,
+	FLOW_ACTION_POLICE = 23,
+	FLOW_ACTION_CT = 24,
+	FLOW_ACTION_CT_METADATA = 25,
+	FLOW_ACTION_MPLS_PUSH = 26,
+	FLOW_ACTION_MPLS_POP = 27,
+	FLOW_ACTION_MPLS_MANGLE = 28,
+	FLOW_ACTION_GATE = 29,
+	FLOW_ACTION_PPPOE_PUSH = 30,
+	FLOW_ACTION_JUMP = 31,
+	FLOW_ACTION_PIPE = 32,
+	FLOW_ACTION_VLAN_PUSH_ETH = 33,
+	FLOW_ACTION_VLAN_POP_ETH = 34,
+	FLOW_ACTION_CONTINUE = 35,
+	NUM_FLOW_ACTIONS = 36,
+};
+
+enum flow_action_hw_stats {
+	FLOW_ACTION_HW_STATS_IMMEDIATE = 1,
+	FLOW_ACTION_HW_STATS_DELAYED = 2,
+	FLOW_ACTION_HW_STATS_ANY = 3,
+	FLOW_ACTION_HW_STATS_DISABLED = 4,
+	FLOW_ACTION_HW_STATS_DONT_CARE = 7,
+};
+
+typedef void (*action_destr)(void *);
+
+enum flow_action_mangle_base {
+	FLOW_ACT_MANGLE_UNSPEC = 0,
+	FLOW_ACT_MANGLE_HDR_TYPE_ETH = 1,
+	FLOW_ACT_MANGLE_HDR_TYPE_IP4 = 2,
+	FLOW_ACT_MANGLE_HDR_TYPE_IP6 = 3,
+	FLOW_ACT_MANGLE_HDR_TYPE_TCP = 4,
+	FLOW_ACT_MANGLE_HDR_TYPE_UDP = 5,
+};
+
+struct nf_flowtable;
+
+struct ip_tunnel_info;
+
+struct psample_group;
+
+struct action_gate_entry;
+
+struct flow_action_cookie;
+
+struct flow_action_entry {
+	enum flow_action_id id;
+	u32 hw_index;
+	long unsigned int cookie;
+	long: 32;
+	u64 miss_cookie;
+	enum flow_action_hw_stats hw_stats;
+	action_destr destructor;
+	void *destructor_priv;
+	long: 32;
+	union {
+		u32 chain_index;
+		struct net_device *dev;
+		struct {
+			u16 vid;
+			__be16 proto;
+			u8 prio;
+		} vlan;
+		struct {
+			unsigned char dst[6];
+			unsigned char src[6];
+		} vlan_push_eth;
+		struct {
+			enum flow_action_mangle_base htype;
+			u32 offset;
+			u32 mask;
+			u32 val;
+		} mangle;
+		struct ip_tunnel_info *tunnel;
+		u32 csum_flags;
+		u32 mark;
+		u16 ptype;
+		u16 rx_queue;
+		u32 priority;
+		struct {
+			u32 ctx;
+			u32 index;
+			u8 vf;
+		} queue;
+		struct {
+			struct psample_group *psample_group;
+			u32 rate;
+			u32 trunc_size;
+			bool truncate;
+		} sample;
+		struct {
+			u32 burst;
+			long: 32;
+			u64 rate_bytes_ps;
+			u64 peakrate_bytes_ps;
+			u32 avrate;
+			u16 overhead;
+			u64 burst_pkt;
+			u64 rate_pkt_ps;
+			u32 mtu;
+			struct {
+				enum flow_action_id act_id;
+				u32 extval;
+			} exceed;
+			struct {
+				enum flow_action_id act_id;
+				u32 extval;
+			} notexceed;
+			long: 32;
+		} police;
+		struct {
+			int action;
+			u16 zone;
+			struct nf_flowtable *flow_table;
+		} ct;
+		struct {
+			long unsigned int cookie;
+			u32 mark;
+			u32 labels[4];
+			bool orig_dir;
+		} ct_metadata;
+		struct {
+			u32 label;
+			__be16 proto;
+			u8 tc;
+			u8 bos;
+			u8 ttl;
+		} mpls_push;
+		struct {
+			__be16 proto;
+		} mpls_pop;
+		struct {
+			u32 label;
+			u8 tc;
+			u8 bos;
+			u8 ttl;
+		} mpls_mangle;
+		struct {
+			s32 prio;
+			long: 32;
+			u64 basetime;
+			u64 cycletime;
+			u64 cycletimeext;
+			u32 num_entries;
+			struct action_gate_entry *entries;
+		} gate;
+		struct {
+			u16 sid;
+		} pppoe;
+	};
+	struct flow_action_cookie *user_cookie;
+	long: 32;
+};
+
+struct flow_action {
+	unsigned int num_entries;
+	long: 32;
+	struct flow_action_entry entries[0];
+};
+
+struct flow_rule {
+	struct flow_match match;
+	long: 32;
+	struct flow_action action;
+};
+
+struct fib_table {
+	struct hlist_node tb_hlist;
+	u32 tb_id;
+	int tb_num_default;
+	struct callback_head rcu;
+	long unsigned int *tb_data;
+	long unsigned int __data[0];
+};
+
+struct inet_peer_base {
+	struct rb_root rb_root;
+	seqlock_t lock;
+	int total;
+};
+
+enum devlink_port_type {
+	DEVLINK_PORT_TYPE_NOTSET = 0,
+	DEVLINK_PORT_TYPE_AUTO = 1,
+	DEVLINK_PORT_TYPE_ETH = 2,
+	DEVLINK_PORT_TYPE_IB = 3,
+};
+
+enum devlink_port_flavour {
+	DEVLINK_PORT_FLAVOUR_PHYSICAL = 0,
+	DEVLINK_PORT_FLAVOUR_CPU = 1,
+	DEVLINK_PORT_FLAVOUR_DSA = 2,
+	DEVLINK_PORT_FLAVOUR_PCI_PF = 3,
+	DEVLINK_PORT_FLAVOUR_PCI_VF = 4,
+	DEVLINK_PORT_FLAVOUR_VIRTUAL = 5,
+	DEVLINK_PORT_FLAVOUR_UNUSED = 6,
+	DEVLINK_PORT_FLAVOUR_PCI_SF = 7,
+};
+
+struct devlink_port_phys_attrs {
+	u32 port_number;
+	u32 split_subport_number;
+};
+
+struct devlink_port_pci_pf_attrs {
+	u32 controller;
+	u16 pf;
+	u8 external: 1;
+};
+
+struct devlink_port_pci_vf_attrs {
+	u32 controller;
+	u16 pf;
+	u16 vf;
+	u8 external: 1;
+};
+
+struct devlink_port_pci_sf_attrs {
+	u32 controller;
+	u32 sf;
+	u16 pf;
+	u8 external: 1;
+};
+
+struct devlink_port_attrs {
+	u8 split: 1;
+	u8 splittable: 1;
+	u32 lanes;
+	enum devlink_port_flavour flavour;
+	struct netdev_phys_item_id switch_id;
+	union {
+		struct devlink_port_phys_attrs phys;
+		struct devlink_port_pci_pf_attrs pci_pf;
+		struct devlink_port_pci_vf_attrs pci_vf;
+		struct devlink_port_pci_sf_attrs pci_sf;
+	};
+};
+
+struct devlink;
+
+struct devlink_port_ops;
+
+struct ib_device;
+
+struct devlink_rate;
+
+struct devlink_linecard;
+
+struct devlink_port {
+	struct list_head list;
+	struct list_head region_list;
+	struct devlink *devlink;
+	const struct devlink_port_ops *ops;
+	unsigned int index;
+	spinlock_t type_lock;
+	enum devlink_port_type type;
+	enum devlink_port_type desired_type;
+	union {
+		struct {
+			struct net_device *netdev;
+			int ifindex;
+			char ifname[16];
+		} type_eth;
+		struct {
+			struct ib_device *ibdev;
+		} type_ib;
+	};
+	struct devlink_port_attrs attrs;
+	u8 attrs_set: 1;
+	u8 switch_port: 1;
+	u8 registered: 1;
+	u8 initialized: 1;
+	struct delayed_work type_warn_dw;
+	struct list_head reporter_list;
+	struct devlink_rate *devlink_rate;
+	struct devlink_linecard *linecard;
+	u32 rel_index;
+};
+
+struct dsa_device_ops;
+
+struct dsa_switch_tree;
+
+struct dsa_switch;
+
+struct dsa_bridge;
+
+struct dsa_lag;
+
+struct dsa_port {
+	union {
+		struct net_device *conduit;
+		struct net_device *user;
+	};
+	const struct dsa_device_ops *tag_ops;
+	struct dsa_switch_tree *dst;
+	struct sk_buff * (*rcv)(struct sk_buff *, struct net_device *);
+	struct dsa_switch *ds;
+	unsigned int index;
+	enum {
+		DSA_PORT_TYPE_UNUSED = 0,
+		DSA_PORT_TYPE_CPU = 1,
+		DSA_PORT_TYPE_DSA = 2,
+		DSA_PORT_TYPE_USER = 3,
+	} type;
+	const char *name;
+	struct dsa_port *cpu_dp;
+	u8 mac[6];
+	u8 stp_state;
+	u8 vlan_filtering: 1;
+	u8 learning: 1;
+	u8 lag_tx_enabled: 1;
+	u8 conduit_admin_up: 1;
+	u8 conduit_oper_up: 1;
+	u8 cpu_port_in_lag: 1;
+	u8 setup: 1;
+	struct device_node *dn;
+	unsigned int ageing_time;
+	struct dsa_bridge *bridge;
+	struct devlink_port devlink_port;
+	struct phylink *pl;
+	struct phylink_config pl_config;
+	struct dsa_lag *lag;
+	struct net_device *hsr_dev;
+	struct list_head list;
+	const struct ethtool_ops *orig_ethtool_ops;
+	struct mutex addr_lists_lock;
+	struct list_head fdbs;
+	struct list_head mdbs;
+	struct mutex vlans_lock;
+	union {
+		struct list_head vlans;
+		struct list_head user_vlans;
+	};
+};
+
+enum netdev_lag_tx_type {
+	NETDEV_LAG_TX_TYPE_UNKNOWN = 0,
+	NETDEV_LAG_TX_TYPE_RANDOM = 1,
+	NETDEV_LAG_TX_TYPE_BROADCAST = 2,
+	NETDEV_LAG_TX_TYPE_ROUNDROBIN = 3,
+	NETDEV_LAG_TX_TYPE_ACTIVEBACKUP = 4,
+	NETDEV_LAG_TX_TYPE_HASH = 5,
+};
+
+enum netdev_lag_hash {
+	NETDEV_LAG_HASH_NONE = 0,
+	NETDEV_LAG_HASH_L2 = 1,
+	NETDEV_LAG_HASH_L34 = 2,
+	NETDEV_LAG_HASH_L23 = 3,
+	NETDEV_LAG_HASH_E23 = 4,
+	NETDEV_LAG_HASH_E34 = 5,
+	NETDEV_LAG_HASH_VLAN_SRCMAC = 6,
+	NETDEV_LAG_HASH_UNKNOWN = 7,
+};
+
+struct netdev_lag_upper_info {
+	enum netdev_lag_tx_type tx_type;
+	enum netdev_lag_hash hash_type;
+};
+
+struct netdev_notifier_info {
+	struct net_device *dev;
+	struct netlink_ext_ack *extack;
+};
+
+struct netdev_notifier_changeupper_info {
+	struct netdev_notifier_info info;
+	struct net_device *upper_dev;
+	bool master;
+	bool linking;
+	void *upper_info;
+};
+
+enum {
+	BR_MCAST_DIR_RX = 0,
+	BR_MCAST_DIR_TX = 1,
+	BR_MCAST_DIR_SIZE = 2,
+};
+
+struct flow_action_cookie {
+	u32 cookie_len;
+	u8 cookie[0];
+};
+
+struct flow_stats {
+	u64 pkts;
+	u64 bytes;
+	u64 drops;
+	u64 lastused;
+	enum flow_action_hw_stats used_hw_stats;
+	bool used_hw_stats_valid;
+};
+
+enum flow_cls_command {
+	FLOW_CLS_REPLACE = 0,
+	FLOW_CLS_DESTROY = 1,
+	FLOW_CLS_STATS = 2,
+	FLOW_CLS_TMPLT_CREATE = 3,
+	FLOW_CLS_TMPLT_DESTROY = 4,
+};
+
+struct flow_cls_common_offload {
+	u32 chain_index;
+	__be16 protocol;
+	u32 prio;
+	struct netlink_ext_ack *extack;
+};
+
+struct flow_cls_offload {
+	struct flow_cls_common_offload common;
+	enum flow_cls_command command;
+	bool use_act_stats;
+	long unsigned int cookie;
+	struct flow_rule *rule;
+	struct flow_stats stats;
+	u32 classid;
+	long: 32;
+};
+
+enum devlink_sb_pool_type {
+	DEVLINK_SB_POOL_TYPE_INGRESS = 0,
+	DEVLINK_SB_POOL_TYPE_EGRESS = 1,
+};
+
+enum devlink_sb_threshold_type {
+	DEVLINK_SB_THRESHOLD_TYPE_STATIC = 0,
+	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC = 1,
+};
+
+enum devlink_rate_type {
+	DEVLINK_RATE_TYPE_LEAF = 0,
+	DEVLINK_RATE_TYPE_NODE = 1,
+};
+
+enum devlink_param_cmode {
+	DEVLINK_PARAM_CMODE_RUNTIME = 0,
+	DEVLINK_PARAM_CMODE_DRIVERINIT = 1,
+	DEVLINK_PARAM_CMODE_PERMANENT = 2,
+	__DEVLINK_PARAM_CMODE_MAX = 3,
+	DEVLINK_PARAM_CMODE_MAX = 2,
+};
+
+enum devlink_resource_unit {
+	DEVLINK_RESOURCE_UNIT_ENTRY = 0,
+};
+
+enum devlink_port_fn_state {
+	DEVLINK_PORT_FN_STATE_INACTIVE = 0,
+	DEVLINK_PORT_FN_STATE_ACTIVE = 1,
+};
+
+enum devlink_port_fn_opstate {
+	DEVLINK_PORT_FN_OPSTATE_DETACHED = 0,
+	DEVLINK_PORT_FN_OPSTATE_ATTACHED = 1,
+};
+
+struct devlink_rate {
+	struct list_head list;
+	enum devlink_rate_type type;
+	struct devlink *devlink;
+	void *priv;
+	long: 32;
+	u64 tx_share;
+	u64 tx_max;
+	struct devlink_rate *parent;
+	union {
+		struct devlink_port *devlink_port;
+		struct {
+			char *name;
+			refcount_t refcnt;
+		};
+	};
+	u32 tx_priority;
+	u32 tx_weight;
+	long: 32;
+};
+
+struct devlink_port_ops {
+	int (*port_split)(struct devlink *, struct devlink_port *, unsigned int, struct netlink_ext_ack *);
+	int (*port_unsplit)(struct devlink *, struct devlink_port *, struct netlink_ext_ack *);
+	int (*port_type_set)(struct devlink_port *, enum devlink_port_type);
+	int (*port_del)(struct devlink *, struct devlink_port *, struct netlink_ext_ack *);
+	int (*port_fn_hw_addr_get)(struct devlink_port *, u8 *, int *, struct netlink_ext_ack *);
+	int (*port_fn_hw_addr_set)(struct devlink_port *, const u8 *, int, struct netlink_ext_ack *);
+	int (*port_fn_roce_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
+	int (*port_fn_roce_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
+	int (*port_fn_migratable_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
+	int (*port_fn_migratable_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
+	int (*port_fn_state_get)(struct devlink_port *, enum devlink_port_fn_state *, enum devlink_port_fn_opstate *, struct netlink_ext_ack *);
+	int (*port_fn_state_set)(struct devlink_port *, enum devlink_port_fn_state, struct netlink_ext_ack *);
+	int (*port_fn_ipsec_crypto_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
+	int (*port_fn_ipsec_crypto_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
+	int (*port_fn_ipsec_packet_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
+	int (*port_fn_ipsec_packet_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
+	int (*port_fn_max_io_eqs_get)(struct devlink_port *, u32 *, struct netlink_ext_ack *);
+	int (*port_fn_max_io_eqs_set)(struct devlink_port *, u32, struct netlink_ext_ack *);
+};
+
+struct devlink_sb_pool_info {
+	enum devlink_sb_pool_type pool_type;
+	u32 size;
+	enum devlink_sb_threshold_type threshold_type;
+	u32 cell_size;
+};
+
+struct devlink_resource_size_params {
+	u64 size_min;
+	u64 size_max;
+	u64 size_granularity;
+	enum devlink_resource_unit unit;
+	long: 32;
+};
+
+typedef u64 devlink_resource_occ_get_t(void *);
+
+union devlink_param_value {
+	u8 vu8;
+	u16 vu16;
+	u32 vu32;
+	char vstr[32];
+	bool vbool;
+};
+
+struct devlink_param_gset_ctx {
+	union devlink_param_value val;
+	enum devlink_param_cmode cmode;
+};
+
+struct switchdev_mst_state {
+	u16 msti;
+	u8 state;
+};
+
+struct switchdev_brport_flags {
+	long unsigned int val;
+	long unsigned int mask;
+};
+
+struct switchdev_vlan_msti {
+	u16 vid;
+	u16 msti;
+};
+
+enum switchdev_obj_id {
+	SWITCHDEV_OBJ_ID_UNDEFINED = 0,
+	SWITCHDEV_OBJ_ID_PORT_VLAN = 1,
+	SWITCHDEV_OBJ_ID_PORT_MDB = 2,
+	SWITCHDEV_OBJ_ID_HOST_MDB = 3,
+	SWITCHDEV_OBJ_ID_MRP = 4,
+	SWITCHDEV_OBJ_ID_RING_TEST_MRP = 5,
+	SWITCHDEV_OBJ_ID_RING_ROLE_MRP = 6,
+	SWITCHDEV_OBJ_ID_RING_STATE_MRP = 7,
+	SWITCHDEV_OBJ_ID_IN_TEST_MRP = 8,
+	SWITCHDEV_OBJ_ID_IN_ROLE_MRP = 9,
+	SWITCHDEV_OBJ_ID_IN_STATE_MRP = 10,
+};
+
+struct switchdev_obj {
+	struct list_head list;
+	struct net_device *orig_dev;
+	enum switchdev_obj_id id;
+	u32 flags;
+	void *complete_priv;
+	void (*complete)(struct net_device *, int, void *);
+};
+
+struct switchdev_obj_port_vlan {
+	struct switchdev_obj obj;
+	u16 flags;
+	u16 vid;
+	bool changed;
+};
+
+struct switchdev_obj_port_mdb {
+	struct switchdev_obj obj;
+	unsigned char addr[6];
+	u16 vid;
+};
+
+struct switchdev_obj_mrp {
+	struct switchdev_obj obj;
+	struct net_device *p_port;
+	struct net_device *s_port;
+	u32 ring_id;
+	u16 prio;
+};
+
+struct switchdev_obj_ring_role_mrp {
+	struct switchdev_obj obj;
+	u8 ring_role;
+	u32 ring_id;
+	u8 sw_backup;
+};
+
+enum dsa_tag_protocol {
+	DSA_TAG_PROTO_NONE = 0,
+	DSA_TAG_PROTO_BRCM = 1,
+	DSA_TAG_PROTO_BRCM_LEGACY = 22,
+	DSA_TAG_PROTO_BRCM_PREPEND = 2,
+	DSA_TAG_PROTO_DSA = 3,
+	DSA_TAG_PROTO_EDSA = 4,
+	DSA_TAG_PROTO_GSWIP = 5,
+	DSA_TAG_PROTO_KSZ9477 = 6,
+	DSA_TAG_PROTO_KSZ9893 = 7,
+	DSA_TAG_PROTO_LAN9303 = 8,
+	DSA_TAG_PROTO_MTK = 9,
+	DSA_TAG_PROTO_QCA = 10,
+	DSA_TAG_PROTO_TRAILER = 11,
+	DSA_TAG_PROTO_8021Q = 12,
+	DSA_TAG_PROTO_SJA1105 = 13,
+	DSA_TAG_PROTO_KSZ8795 = 14,
+	DSA_TAG_PROTO_OCELOT = 15,
+	DSA_TAG_PROTO_AR9331 = 16,
+	DSA_TAG_PROTO_RTL4_A = 17,
+	DSA_TAG_PROTO_HELLCREEK = 18,
+	DSA_TAG_PROTO_XRS700X = 19,
+	DSA_TAG_PROTO_OCELOT_8021Q = 20,
+	DSA_TAG_PROTO_SEVILLE = 21,
+	DSA_TAG_PROTO_SJA1110 = 23,
+	DSA_TAG_PROTO_RTL8_4 = 24,
+	DSA_TAG_PROTO_RTL8_4T = 25,
+	DSA_TAG_PROTO_RZN1_A5PSW = 26,
+	DSA_TAG_PROTO_LAN937X = 27,
+	DSA_TAG_PROTO_VSC73XX_8021Q = 28,
+};
+
+struct dsa_device_ops {
+	struct sk_buff * (*xmit)(struct sk_buff *, struct net_device *);
+	struct sk_buff * (*rcv)(struct sk_buff *, struct net_device *);
+	void (*flow_dissect)(const struct sk_buff *, __be16 *, int *);
+	int (*connect)(struct dsa_switch *);
+	void (*disconnect)(struct dsa_switch *);
+	unsigned int needed_headroom;
+	unsigned int needed_tailroom;
+	const char *name;
+	enum dsa_tag_protocol proto;
+	bool promisc_on_conduit;
+};
+
+struct dsa_switch_ops;
+
+struct dsa_8021q_context;
+
+struct dsa_switch {
+	struct device *dev;
+	struct dsa_switch_tree *dst;
+	unsigned int index;
+	u32 setup: 1;
+	u32 vlan_filtering_is_global: 1;
+	u32 needs_standalone_vlan_filtering: 1;
+	u32 configure_vlan_while_not_filtering: 1;
+	u32 untag_bridge_pvid: 1;
+	u32 untag_vlan_aware_bridge_pvid: 1;
+	u32 assisted_learning_on_cpu_port: 1;
+	u32 vlan_filtering: 1;
+	u32 mtu_enforcement_ingress: 1;
+	u32 fdb_isolation: 1;
+	u32 dscp_prio_mapping_is_global: 1;
+	struct notifier_block nb;
+	void *priv;
+	void *tagger_data;
+	struct dsa_chip_data *cd;
+	const struct dsa_switch_ops *ops;
+	const struct phylink_mac_ops *phylink_mac_ops;
+	u32 phys_mii_mask;
+	struct mii_bus *user_mii_bus;
+	unsigned int ageing_time_min;
+	unsigned int ageing_time_max;
+	struct dsa_8021q_context *tag_8021q_ctx;
+	struct devlink *devlink;
+	unsigned int num_tx_queues;
+	unsigned int num_lag_ids;
+	unsigned int max_num_bridges;
+	unsigned int num_ports;
+};
+
+struct dsa_lag {
+	struct net_device *dev;
+	unsigned int id;
+	struct mutex fdb_lock;
+	struct list_head fdbs;
+	refcount_t refcount;
+};
+
+struct dsa_switch_tree {
+	struct list_head list;
+	struct list_head ports;
+	struct raw_notifier_head nh;
+	unsigned int index;
+	struct kref refcount;
+	struct dsa_lag **lags;
+	const struct dsa_device_ops *tag_ops;
+	enum dsa_tag_protocol default_proto;
+	bool setup;
+	struct dsa_platform_data *pd;
+	struct list_head rtable;
+	unsigned int lags_len;
+	unsigned int last_switch;
+};
+
+struct dsa_mall_mirror_tc_entry {
+	u8 to_local_port;
+	bool ingress;
+};
+
+struct dsa_mall_policer_tc_entry {
+	u32 burst;
+	long: 32;
+	u64 rate_bytes_per_sec;
+};
+
+struct dsa_bridge {
+	struct net_device *dev;
+	unsigned int num;
+	bool tx_fwd_offload;
+	refcount_t refcount;
+};
+
+enum dsa_db_type {
+	DSA_DB_PORT = 0,
+	DSA_DB_LAG = 1,
+	DSA_DB_BRIDGE = 2,
+};
+
+struct dsa_db {
+	enum dsa_db_type type;
+	union {
+		const struct dsa_port *dp;
+		struct dsa_lag lag;
+		struct dsa_bridge bridge;
+	};
+};
+
+typedef int dsa_fdb_dump_cb_t(const unsigned char *, u16, bool, void *);
+
+struct devlink_info_req;
+
+struct dsa_switch_ops {
+	enum dsa_tag_protocol (*get_tag_protocol)(struct dsa_switch *, int, enum dsa_tag_protocol);
+	int (*change_tag_protocol)(struct dsa_switch *, enum dsa_tag_protocol);
+	int (*connect_tag_protocol)(struct dsa_switch *, enum dsa_tag_protocol);
+	int (*port_change_conduit)(struct dsa_switch *, int, struct net_device *, struct netlink_ext_ack *);
+	int (*setup)(struct dsa_switch *);
+	void (*teardown)(struct dsa_switch *);
+	int (*port_setup)(struct dsa_switch *, int);
+	void (*port_teardown)(struct dsa_switch *, int);
+	u32 (*get_phy_flags)(struct dsa_switch *, int);
+	int (*phy_read)(struct dsa_switch *, int, int);
+	int (*phy_write)(struct dsa_switch *, int, int, u16);
+	void (*phylink_get_caps)(struct dsa_switch *, int, struct phylink_config *);
+	struct phylink_pcs * (*phylink_mac_select_pcs)(struct dsa_switch *, int, phy_interface_t);
+	void (*phylink_mac_config)(struct dsa_switch *, int, unsigned int, const struct phylink_link_state *);
+	void (*phylink_mac_link_down)(struct dsa_switch *, int, unsigned int, phy_interface_t);
+	void (*phylink_mac_link_up)(struct dsa_switch *, int, unsigned int, phy_interface_t, struct phy_device *, int, int, bool, bool);
+	void (*phylink_fixed_state)(struct dsa_switch *, int, struct phylink_link_state *);
+	void (*get_strings)(struct dsa_switch *, int, u32, uint8_t *);
+	void (*get_ethtool_stats)(struct dsa_switch *, int, uint64_t *);
+	int (*get_sset_count)(struct dsa_switch *, int, int);
+	void (*get_ethtool_phy_stats)(struct dsa_switch *, int, uint64_t *);
+	void (*get_eth_phy_stats)(struct dsa_switch *, int, struct ethtool_eth_phy_stats *);
+	void (*get_eth_mac_stats)(struct dsa_switch *, int, struct ethtool_eth_mac_stats *);
+	void (*get_eth_ctrl_stats)(struct dsa_switch *, int, struct ethtool_eth_ctrl_stats *);
+	void (*get_rmon_stats)(struct dsa_switch *, int, struct ethtool_rmon_stats *, const struct ethtool_rmon_hist_range **);
+	void (*get_stats64)(struct dsa_switch *, int, struct rtnl_link_stats64 *);
+	void (*get_pause_stats)(struct dsa_switch *, int, struct ethtool_pause_stats *);
+	void (*self_test)(struct dsa_switch *, int, struct ethtool_test *, u64 *);
+	void (*get_wol)(struct dsa_switch *, int, struct ethtool_wolinfo *);
+	int (*set_wol)(struct dsa_switch *, int, struct ethtool_wolinfo *);
+	int (*get_ts_info)(struct dsa_switch *, int, struct kernel_ethtool_ts_info *);
+	int (*get_mm)(struct dsa_switch *, int, struct ethtool_mm_state *);
+	int (*set_mm)(struct dsa_switch *, int, struct ethtool_mm_cfg *, struct netlink_ext_ack *);
+	void (*get_mm_stats)(struct dsa_switch *, int, struct ethtool_mm_stats *);
+	int (*port_get_default_prio)(struct dsa_switch *, int);
+	int (*port_set_default_prio)(struct dsa_switch *, int, u8);
+	int (*port_get_dscp_prio)(struct dsa_switch *, int, u8);
+	int (*port_add_dscp_prio)(struct dsa_switch *, int, u8, u8);
+	int (*port_del_dscp_prio)(struct dsa_switch *, int, u8, u8);
+	int (*port_set_apptrust)(struct dsa_switch *, int, const u8 *, int);
+	int (*port_get_apptrust)(struct dsa_switch *, int, u8 *, int *);
+	int (*suspend)(struct dsa_switch *);
+	int (*resume)(struct dsa_switch *);
+	int (*port_enable)(struct dsa_switch *, int, struct phy_device *);
+	void (*port_disable)(struct dsa_switch *, int);
+	int (*port_set_mac_address)(struct dsa_switch *, int, const unsigned char *);
+	struct dsa_port * (*preferred_default_local_cpu_port)(struct dsa_switch *);
+	int (*set_mac_eee)(struct dsa_switch *, int, struct ethtool_keee *);
+	int (*get_mac_eee)(struct dsa_switch *, int, struct ethtool_keee *);
+	int (*get_eeprom_len)(struct dsa_switch *);
+	int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *);
+	int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *);
+	int (*get_regs_len)(struct dsa_switch *, int);
+	void (*get_regs)(struct dsa_switch *, int, struct ethtool_regs *, void *);
+	int (*port_prechangeupper)(struct dsa_switch *, int, struct netdev_notifier_changeupper_info *);
+	int (*set_ageing_time)(struct dsa_switch *, unsigned int);
+	int (*port_bridge_join)(struct dsa_switch *, int, struct dsa_bridge, bool *, struct netlink_ext_ack *);
+	void (*port_bridge_leave)(struct dsa_switch *, int, struct dsa_bridge);
+	void (*port_stp_state_set)(struct dsa_switch *, int, u8);
+	int (*port_mst_state_set)(struct dsa_switch *, int, const struct switchdev_mst_state *);
+	void (*port_fast_age)(struct dsa_switch *, int);
+	int (*port_vlan_fast_age)(struct dsa_switch *, int, u16);
+	int (*port_pre_bridge_flags)(struct dsa_switch *, int, struct switchdev_brport_flags, struct netlink_ext_ack *);
+	int (*port_bridge_flags)(struct dsa_switch *, int, struct switchdev_brport_flags, struct netlink_ext_ack *);
+	void (*port_set_host_flood)(struct dsa_switch *, int, bool, bool);
+	int (*port_vlan_filtering)(struct dsa_switch *, int, bool, struct netlink_ext_ack *);
+	int (*port_vlan_add)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *, struct netlink_ext_ack *);
+	int (*port_vlan_del)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *);
+	int (*vlan_msti_set)(struct dsa_switch *, struct dsa_bridge, const struct switchdev_vlan_msti *);
+	int (*port_fdb_add)(struct dsa_switch *, int, const unsigned char *, u16, struct dsa_db);
+	int (*port_fdb_del)(struct dsa_switch *, int, const unsigned char *, u16, struct dsa_db);
+	int (*port_fdb_dump)(struct dsa_switch *, int, dsa_fdb_dump_cb_t *, void *);
+	int (*lag_fdb_add)(struct dsa_switch *, struct dsa_lag, const unsigned char *, u16, struct dsa_db);
+	int (*lag_fdb_del)(struct dsa_switch *, struct dsa_lag, const unsigned char *, u16, struct dsa_db);
+	int (*port_mdb_add)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *, struct dsa_db);
+	int (*port_mdb_del)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *, struct dsa_db);
+	int (*get_rxnfc)(struct dsa_switch *, int, struct ethtool_rxnfc *, u32 *);
+	int (*set_rxnfc)(struct dsa_switch *, int, struct ethtool_rxnfc *);
+	int (*cls_flower_add)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
+	int (*cls_flower_del)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
+	int (*cls_flower_stats)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
+	int (*port_mirror_add)(struct dsa_switch *, int, struct dsa_mall_mirror_tc_entry *, bool, struct netlink_ext_ack *);
+	void (*port_mirror_del)(struct dsa_switch *, int, struct dsa_mall_mirror_tc_entry *);
+	int (*port_policer_add)(struct dsa_switch *, int, struct dsa_mall_policer_tc_entry *);
+	void (*port_policer_del)(struct dsa_switch *, int);
+	int (*port_setup_tc)(struct dsa_switch *, int, enum tc_setup_type, void *);
+	int (*crosschip_bridge_join)(struct dsa_switch *, int, int, int, struct dsa_bridge, struct netlink_ext_ack *);
+	void (*crosschip_bridge_leave)(struct dsa_switch *, int, int, int, struct dsa_bridge);
+	int (*crosschip_lag_change)(struct dsa_switch *, int, int);
+	int (*crosschip_lag_join)(struct dsa_switch *, int, int, struct dsa_lag, struct netdev_lag_upper_info *, struct netlink_ext_ack *);
+	int (*crosschip_lag_leave)(struct dsa_switch *, int, int, struct dsa_lag);
+	int (*port_hwtstamp_get)(struct dsa_switch *, int, struct ifreq *);
+	int (*port_hwtstamp_set)(struct dsa_switch *, int, struct ifreq *);
+	void (*port_txtstamp)(struct dsa_switch *, int, struct sk_buff *);
+	bool (*port_rxtstamp)(struct dsa_switch *, int, struct sk_buff *, unsigned int);
+	int (*devlink_param_get)(struct dsa_switch *, u32, struct devlink_param_gset_ctx *);
+	int (*devlink_param_set)(struct dsa_switch *, u32, struct devlink_param_gset_ctx *);
+	int (*devlink_info_get)(struct dsa_switch *, struct devlink_info_req *, struct netlink_ext_ack *);
+	int (*devlink_sb_pool_get)(struct dsa_switch *, unsigned int, u16, struct devlink_sb_pool_info *);
+	int (*devlink_sb_pool_set)(struct dsa_switch *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
+	int (*devlink_sb_port_pool_get)(struct dsa_switch *, int, unsigned int, u16, u32 *);
+	int (*devlink_sb_port_pool_set)(struct dsa_switch *, int, unsigned int, u16, u32, struct netlink_ext_ack *);
+	int (*devlink_sb_tc_pool_bind_get)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
+	int (*devlink_sb_tc_pool_bind_set)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
+	int (*devlink_sb_occ_snapshot)(struct dsa_switch *, unsigned int);
+	int (*devlink_sb_occ_max_clear)(struct dsa_switch *, unsigned int);
+	int (*devlink_sb_occ_port_pool_get)(struct dsa_switch *, int, unsigned int, u16, u32 *, u32 *);
+	int (*devlink_sb_occ_tc_port_bind_get)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
+	int (*port_change_mtu)(struct dsa_switch *, int, int);
+	int (*port_max_mtu)(struct dsa_switch *, int);
+	int (*port_lag_change)(struct dsa_switch *, int);
+	int (*port_lag_join)(struct dsa_switch *, int, struct dsa_lag, struct netdev_lag_upper_info *, struct netlink_ext_ack *);
+	int (*port_lag_leave)(struct dsa_switch *, int, struct dsa_lag);
+	int (*port_hsr_join)(struct dsa_switch *, int, struct net_device *, struct netlink_ext_ack *);
+	int (*port_hsr_leave)(struct dsa_switch *, int, struct net_device *);
+	int (*port_mrp_add)(struct dsa_switch *, int, const struct switchdev_obj_mrp *);
+	int (*port_mrp_del)(struct dsa_switch *, int, const struct switchdev_obj_mrp *);
+	int (*port_mrp_add_ring_role)(struct dsa_switch *, int, const struct switchdev_obj_ring_role_mrp *);
+	int (*port_mrp_del_ring_role)(struct dsa_switch *, int, const struct switchdev_obj_ring_role_mrp *);
+	int (*tag_8021q_vlan_add)(struct dsa_switch *, int, u16, u16);
+	int (*tag_8021q_vlan_del)(struct dsa_switch *, int, u16);
+	void (*conduit_state_change)(struct dsa_switch *, const struct net_device *, bool);
+};
+
+struct b53_device;
+
+struct b53_io_ops {
+	int (*read8)(struct b53_device *, u8, u8, u8 *);
+	int (*read16)(struct b53_device *, u8, u8, u16 *);
+	int (*read32)(struct b53_device *, u8, u8, u32 *);
+	int (*read48)(struct b53_device *, u8, u8, u64 *);
+	int (*read64)(struct b53_device *, u8, u8, u64 *);
+	int (*write8)(struct b53_device *, u8, u8, u8);
+	int (*write16)(struct b53_device *, u8, u8, u16);
+	int (*write32)(struct b53_device *, u8, u8, u32);
+	int (*write48)(struct b53_device *, u8, u8, u64);
+	int (*write64)(struct b53_device *, u8, u8, u64);
+	int (*phy_read16)(struct b53_device *, int, int, u16 *);
+	int (*phy_write16)(struct b53_device *, int, int, u16);
+	int (*irq_enable)(struct b53_device *, int);
+	void (*irq_disable)(struct b53_device *, int);
+	void (*phylink_get_caps)(struct b53_device *, int, struct phylink_config *);
+	struct phylink_pcs * (*phylink_mac_select_pcs)(struct b53_device *, int, phy_interface_t);
+	u8 (*serdes_map_lane)(struct b53_device *, int);
+	void (*serdes_link_set)(struct b53_device *, int, unsigned int, phy_interface_t, bool);
+};
+
+struct b53_pcs {
+	struct phylink_pcs pcs;
+	struct b53_device *dev;
+	u8 lane;
+};
+
+struct b53_vlan;
+
+struct b53_port;
+
+struct b53_device {
+	struct dsa_switch *ds;
+	struct b53_platform_data *pdata;
+	const char *name;
+	struct mutex reg_mutex;
+	struct mutex stats_mutex;
+	struct mutex arl_mutex;
+	const struct b53_io_ops *ops;
+	u32 chip_id;
+	u8 core_rev;
+	u8 vta_regs[3];
+	u8 duplex_reg;
+	u8 jumbo_pm_reg;
+	u8 jumbo_size_reg;
+	int reset_gpio;
+	u8 num_arl_bins;
+	u16 num_arl_buckets;
+	enum dsa_tag_protocol tag_protocol;
+	u16 enabled_ports;
+	unsigned int imp_port;
+	u8 current_page;
+	struct device *dev;
+	u8 serdes_lane;
+	struct mii_bus *bus;
+	void *priv;
+	bool enable_jumbo;
+	unsigned int num_vlans;
+	struct b53_vlan *vlans;
+	bool vlan_enabled;
+	unsigned int num_ports;
+	struct b53_port *ports;
+	struct b53_pcs pcs[2];
+};
+
+enum {
+	BCM4908_DEVICE_ID = 18696,
+	BCM5325_DEVICE_ID = 37,
+	BCM5365_DEVICE_ID = 101,
+	BCM5389_DEVICE_ID = 137,
+	BCM5395_DEVICE_ID = 149,
+	BCM5397_DEVICE_ID = 151,
+	BCM5398_DEVICE_ID = 152,
+	BCM53115_DEVICE_ID = 340245,
+	BCM53125_DEVICE_ID = 340261,
+	BCM53128_DEVICE_ID = 340264,
+	BCM63XX_DEVICE_ID = 25344,
+	BCM63268_DEVICE_ID = 406120,
+	BCM53010_DEVICE_ID = 339984,
+	BCM53011_DEVICE_ID = 339985,
+	BCM53012_DEVICE_ID = 339986,
+	BCM53018_DEVICE_ID = 339992,
+	BCM53019_DEVICE_ID = 339993,
+	BCM58XX_DEVICE_ID = 22528,
+	BCM583XX_DEVICE_ID = 361216,
+	BCM7445_DEVICE_ID = 29765,
+	BCM7278_DEVICE_ID = 29304,
+	BCM53134_DEVICE_ID = 20597,
+};
+
+struct b53_port {
+	u16 vlan_ctl_mask;
+	struct ethtool_keee eee;
+};
+
+struct b53_vlan {
+	u16 members;
+	u16 untag;
+	bool valid;
+};
+
+struct b53_arl_entry {
+	u16 port;
+	u8 mac[6];
+	u16 vid;
+	u8 is_valid: 1;
+	u8 is_age: 1;
+	u8 is_static: 1;
+};
+
+struct b53_mib_desc {
+	u8 size;
+	u8 offset;
+	const char *name;
+};
+
+enum b53_devlink_resource_id {
+	B53_DEVLINK_PARAM_ID_VLAN_TABLE = 0,
+};
+
+struct b53_chip_data {
+	u32 chip_id;
+	const char *dev_name;
+	u16 vlans;
+	u16 enabled_ports;
+	u8 imp_port;
+	u8 cpu_port;
+	u8 vta_regs[3];
+	u8 arl_bins;
+	u16 arl_buckets;
+	u8 duplex_reg;
+	u8 jumbo_pm_reg;
+	u8 jumbo_size_reg;
+};
+
+struct bgmac_slot_info {
+	union {
+		struct sk_buff *skb;
+		void *buf;
+	};
+	dma_addr_t dma_addr;
+};
+
+struct bgmac_dma_desc {
+	__le32 ctl0;
+	__le32 ctl1;
+	__le32 addr_low;
+	__le32 addr_high;
+};
+
+struct bgmac_dma_ring {
+	u32 start;
+	u32 end;
+	struct bgmac_dma_desc *cpu_base;
+	dma_addr_t dma_base;
+	u32 index_base;
+	u16 mmio_base;
+	bool unaligned;
+	struct bgmac_slot_info slots[512];
+};
+
+struct bgmac {
+	union {
+		struct {
+			void *base;
+			void *idm_base;
+			void *nicpm_base;
+		} plat;
+		struct {
+			struct bcma_device *core;
+			struct bcma_device *cmn;
+		} bcma;
+	};
+	struct device *dev;
+	struct device *dma_dev;
+	u32 feature_flags;
+	struct net_device *net_dev;
+	long: 32;
+	struct napi_struct napi;
+	struct mii_bus *mii_bus;
+	struct bgmac_dma_ring tx_ring[4];
+	struct bgmac_dma_ring rx_ring[1];
+	bool stats_grabbed;
+	u32 mib_tx_regs[43];
+	u32 mib_rx_regs[31];
+	int irq;
+	u32 int_mask;
+	bool in_init;
+	int mac_speed;
+	int mac_duplex;
+	u8 phyaddr;
+	bool has_robosw;
+	bool loopback;
+	u32 (*read)(struct bgmac *, u16);
+	void (*write)(struct bgmac *, u16, u32);
+	u32 (*idm_read)(struct bgmac *, u16);
+	void (*idm_write)(struct bgmac *, u16, u32);
+	bool (*clk_enabled)(struct bgmac *);
+	void (*clk_enable)(struct bgmac *, u32);
+	void (*cco_ctl_maskset)(struct bgmac *, u32, u32, u32);
+	u32 (*get_bus_clock)(struct bgmac *);
+	void (*cmn_maskset32)(struct bgmac *, u16, u32, u32);
+	int (*phy_connect)(struct bgmac *);
+	struct platform_device *b53_device;
+	long: 32;
+};
+
+enum {
+	POWER_SUPPLY_STATUS_UNKNOWN = 0,
+	POWER_SUPPLY_STATUS_CHARGING = 1,
+	POWER_SUPPLY_STATUS_DISCHARGING = 2,
+	POWER_SUPPLY_STATUS_NOT_CHARGING = 3,
+	POWER_SUPPLY_STATUS_FULL = 4,
+};
+
+enum {
+	POWER_SUPPLY_CHARGE_TYPE_UNKNOWN = 0,
+	POWER_SUPPLY_CHARGE_TYPE_NONE = 1,
+	POWER_SUPPLY_CHARGE_TYPE_TRICKLE = 2,
+	POWER_SUPPLY_CHARGE_TYPE_FAST = 3,
+	POWER_SUPPLY_CHARGE_TYPE_STANDARD = 4,
+	POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE = 5,
+	POWER_SUPPLY_CHARGE_TYPE_CUSTOM = 6,
+	POWER_SUPPLY_CHARGE_TYPE_LONGLIFE = 7,
+	POWER_SUPPLY_CHARGE_TYPE_BYPASS = 8,
+};
+
+enum {
+	POWER_SUPPLY_HEALTH_UNKNOWN = 0,
+	POWER_SUPPLY_HEALTH_GOOD = 1,
+	POWER_SUPPLY_HEALTH_OVERHEAT = 2,
+	POWER_SUPPLY_HEALTH_DEAD = 3,
+	POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4,
+	POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5,
+	POWER_SUPPLY_HEALTH_COLD = 6,
+	POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7,
+	POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8,
+	POWER_SUPPLY_HEALTH_OVERCURRENT = 9,
+	POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED = 10,
+	POWER_SUPPLY_HEALTH_WARM = 11,
+	POWER_SUPPLY_HEALTH_COOL = 12,
+	POWER_SUPPLY_HEALTH_HOT = 13,
+	POWER_SUPPLY_HEALTH_NO_BATTERY = 14,
+};
+
+enum {
+	POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0,
+	POWER_SUPPLY_TECHNOLOGY_NiMH = 1,
+	POWER_SUPPLY_TECHNOLOGY_LION = 2,
+	POWER_SUPPLY_TECHNOLOGY_LIPO = 3,
+	POWER_SUPPLY_TECHNOLOGY_LiFe = 4,
+	POWER_SUPPLY_TECHNOLOGY_NiCd = 5,
+	POWER_SUPPLY_TECHNOLOGY_LiMn = 6,
+};
+
+enum {
+	POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN = 0,
+	POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL = 1,
+	POWER_SUPPLY_CAPACITY_LEVEL_LOW = 2,
+	POWER_SUPPLY_CAPACITY_LEVEL_NORMAL = 3,
+	POWER_SUPPLY_CAPACITY_LEVEL_HIGH = 4,
+	POWER_SUPPLY_CAPACITY_LEVEL_FULL = 5,
+};
+
+enum {
+	POWER_SUPPLY_SCOPE_UNKNOWN = 0,
+	POWER_SUPPLY_SCOPE_SYSTEM = 1,
+	POWER_SUPPLY_SCOPE_DEVICE = 2,
+};
+
+enum power_supply_property {
+	POWER_SUPPLY_PROP_STATUS = 0,
+	POWER_SUPPLY_PROP_CHARGE_TYPE = 1,
+	POWER_SUPPLY_PROP_HEALTH = 2,
+	POWER_SUPPLY_PROP_PRESENT = 3,
+	POWER_SUPPLY_PROP_ONLINE = 4,
+	POWER_SUPPLY_PROP_AUTHENTIC = 5,
+	POWER_SUPPLY_PROP_TECHNOLOGY = 6,
+	POWER_SUPPLY_PROP_CYCLE_COUNT = 7,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX = 8,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN = 9,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN = 10,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN = 11,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW = 12,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG = 13,
+	POWER_SUPPLY_PROP_VOLTAGE_OCV = 14,
+	POWER_SUPPLY_PROP_VOLTAGE_BOOT = 15,
+	POWER_SUPPLY_PROP_CURRENT_MAX = 16,
+	POWER_SUPPLY_PROP_CURRENT_NOW = 17,
+	POWER_SUPPLY_PROP_CURRENT_AVG = 18,
+	POWER_SUPPLY_PROP_CURRENT_BOOT = 19,
+	POWER_SUPPLY_PROP_POWER_NOW = 20,
+	POWER_SUPPLY_PROP_POWER_AVG = 21,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN = 22,
+	POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN = 23,
+	POWER_SUPPLY_PROP_CHARGE_FULL = 24,
+	POWER_SUPPLY_PROP_CHARGE_EMPTY = 25,
+	POWER_SUPPLY_PROP_CHARGE_NOW = 26,
+	POWER_SUPPLY_PROP_CHARGE_AVG = 27,
+	POWER_SUPPLY_PROP_CHARGE_COUNTER = 28,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT = 29,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX = 30,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE = 31,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX = 32,
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT = 33,
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX = 34,
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_START_THRESHOLD = 35,
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD = 36,
+	POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR = 37,
+	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT = 38,
+	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT = 39,
+	POWER_SUPPLY_PROP_INPUT_POWER_LIMIT = 40,
+	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN = 41,
+	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN = 42,
+	POWER_SUPPLY_PROP_ENERGY_FULL = 43,
+	POWER_SUPPLY_PROP_ENERGY_EMPTY = 44,
+	POWER_SUPPLY_PROP_ENERGY_NOW = 45,
+	POWER_SUPPLY_PROP_ENERGY_AVG = 46,
+	POWER_SUPPLY_PROP_CAPACITY = 47,
+	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN = 48,
+	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX = 49,
+	POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN = 50,
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL = 51,
+	POWER_SUPPLY_PROP_TEMP = 52,
+	POWER_SUPPLY_PROP_TEMP_MAX = 53,
+	POWER_SUPPLY_PROP_TEMP_MIN = 54,
+	POWER_SUPPLY_PROP_TEMP_ALERT_MIN = 55,
+	POWER_SUPPLY_PROP_TEMP_ALERT_MAX = 56,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT = 57,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN = 58,
+	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX = 59,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW = 60,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG = 61,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW = 62,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG = 63,
+	POWER_SUPPLY_PROP_TYPE = 64,
+	POWER_SUPPLY_PROP_USB_TYPE = 65,
+	POWER_SUPPLY_PROP_SCOPE = 66,
+	POWER_SUPPLY_PROP_PRECHARGE_CURRENT = 67,
+	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT = 68,
+	POWER_SUPPLY_PROP_CALIBRATE = 69,
+	POWER_SUPPLY_PROP_MANUFACTURE_YEAR = 70,
+	POWER_SUPPLY_PROP_MANUFACTURE_MONTH = 71,
+	POWER_SUPPLY_PROP_MANUFACTURE_DAY = 72,
+	POWER_SUPPLY_PROP_MODEL_NAME = 73,
+	POWER_SUPPLY_PROP_MANUFACTURER = 74,
+	POWER_SUPPLY_PROP_SERIAL_NUMBER = 75,
+};
+
+enum power_supply_type {
+	POWER_SUPPLY_TYPE_UNKNOWN = 0,
+	POWER_SUPPLY_TYPE_BATTERY = 1,
+	POWER_SUPPLY_TYPE_UPS = 2,
+	POWER_SUPPLY_TYPE_MAINS = 3,
+	POWER_SUPPLY_TYPE_USB = 4,
+	POWER_SUPPLY_TYPE_USB_DCP = 5,
+	POWER_SUPPLY_TYPE_USB_CDP = 6,
+	POWER_SUPPLY_TYPE_USB_ACA = 7,
+	POWER_SUPPLY_TYPE_USB_TYPE_C = 8,
+	POWER_SUPPLY_TYPE_USB_PD = 9,
+	POWER_SUPPLY_TYPE_USB_PD_DRP = 10,
+	POWER_SUPPLY_TYPE_APPLE_BRICK_ID = 11,
+	POWER_SUPPLY_TYPE_WIRELESS = 12,
+};
+
+enum power_supply_usb_type {
+	POWER_SUPPLY_USB_TYPE_UNKNOWN = 0,
+	POWER_SUPPLY_USB_TYPE_SDP = 1,
+	POWER_SUPPLY_USB_TYPE_DCP = 2,
+	POWER_SUPPLY_USB_TYPE_CDP = 3,
+	POWER_SUPPLY_USB_TYPE_ACA = 4,
+	POWER_SUPPLY_USB_TYPE_C = 5,
+	POWER_SUPPLY_USB_TYPE_PD = 6,
+	POWER_SUPPLY_USB_TYPE_PD_DRP = 7,
+	POWER_SUPPLY_USB_TYPE_PD_PPS = 8,
+	POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID = 9,
+};
+
+enum power_supply_charge_behaviour {
+	POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO = 0,
+	POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE = 1,
+	POWER_SUPPLY_CHARGE_BEHAVIOUR_FORCE_DISCHARGE = 2,
+};
+
+union power_supply_propval {
+	int intval;
+	const char *strval;
+};
+
+struct power_supply;
+
+struct power_supply_desc {
+	const char *name;
+	enum power_supply_type type;
+	u8 charge_behaviours;
+	u32 usb_types;
+	const enum power_supply_property *properties;
+	size_t num_properties;
+	int (*get_property)(struct power_supply *, enum power_supply_property, union power_supply_propval *);
+	int (*set_property)(struct power_supply *, enum power_supply_property, const union power_supply_propval *);
+	int (*property_is_writeable)(struct power_supply *, enum power_supply_property);
+	void (*external_power_changed)(struct power_supply *);
+	void (*set_charged)(struct power_supply *);
+	bool no_thermal;
+	int use_for_apm;
+};
+
+struct power_supply_battery_info;
+
+struct thermal_zone_device;
+
+struct thermal_cooling_device;
+
+struct power_supply {
+	const struct power_supply_desc *desc;
+	char **supplied_to;
+	size_t num_supplicants;
+	char **supplied_from;
+	size_t num_supplies;
+	struct device_node *of_node;
+	void *drv_data;
+	long: 32;
+	struct device dev;
+	struct work_struct changed_work;
+	struct delayed_work deferred_register_work;
+	spinlock_t changed_lock;
+	bool changed;
+	bool initialized;
+	bool removing;
+	atomic_t use_cnt;
+	struct power_supply_battery_info *battery_info;
+	struct thermal_zone_device *tzd;
+	struct thermal_cooling_device *tcd;
+	struct led_trigger *trig;
+	struct led_trigger *charging_trig;
+	struct led_trigger *full_trig;
+	struct led_trigger *charging_blink_full_solid_trig;
+	struct led_trigger *charging_orange_full_green_trig;
+};
+
+struct power_supply_maintenance_charge_table;
+
+struct power_supply_battery_ocv_table;
+
+struct power_supply_resistance_temp_table;
+
+struct power_supply_vbat_ri_table;
+
+struct power_supply_battery_info {
+	unsigned int technology;
+	int energy_full_design_uwh;
+	int charge_full_design_uah;
+	int voltage_min_design_uv;
+	int voltage_max_design_uv;
+	int tricklecharge_current_ua;
+	int precharge_current_ua;
+	int precharge_voltage_max_uv;
+	int charge_term_current_ua;
+	int charge_restart_voltage_uv;
+	int overvoltage_limit_uv;
+	int constant_charge_current_max_ua;
+	int constant_charge_voltage_max_uv;
+	const struct power_supply_maintenance_charge_table *maintenance_charge;
+	int maintenance_charge_size;
+	int alert_low_temp_charge_current_ua;
+	int alert_low_temp_charge_voltage_uv;
+	int alert_high_temp_charge_current_ua;
+	int alert_high_temp_charge_voltage_uv;
+	int factory_internal_resistance_uohm;
+	int factory_internal_resistance_charging_uohm;
+	int ocv_temp[20];
+	int temp_ambient_alert_min;
+	int temp_ambient_alert_max;
+	int temp_alert_min;
+	int temp_alert_max;
+	int temp_min;
+	int temp_max;
+	struct power_supply_battery_ocv_table *ocv_table[20];
+	int ocv_table_size[20];
+	struct power_supply_resistance_temp_table *resist_table;
+	int resist_table_size;
+	const struct power_supply_vbat_ri_table *vbat2ri_discharging;
+	int vbat2ri_discharging_size;
+	const struct power_supply_vbat_ri_table *vbat2ri_charging;
+	int vbat2ri_charging_size;
+	int bti_resistance_ohm;
+	int bti_resistance_tolerance;
+};
+
+struct power_supply_battery_ocv_table {
+	int ocv;
+	int capacity;
+};
+
+struct power_supply_resistance_temp_table {
+	int temp;
+	int resistance;
+};
+
+struct power_supply_vbat_ri_table {
+	int vbat_uv;
+	int ri_uohm;
+};
+
+struct power_supply_maintenance_charge_table {
+	int charge_current_max_ua;
+	int charge_voltage_max_uv;
+	int charge_safety_timer_minutes;
+};
+
+struct power_supply_attr {
+	const char *prop_name;
+	char attr_name[31];
+	struct device_attribute dev_attr;
+	const char * const *text_values;
+	int text_values_len;
+};
+
+enum thermal_device_mode {
+	THERMAL_DEVICE_DISABLED = 0,
+	THERMAL_DEVICE_ENABLED = 1,
+};
+
+enum thermal_trip_type {
+	THERMAL_TRIP_ACTIVE = 0,
+	THERMAL_TRIP_PASSIVE = 1,
+	THERMAL_TRIP_HOT = 2,
+	THERMAL_TRIP_CRITICAL = 3,
+};
+
+enum thermal_trend {
+	THERMAL_TREND_STABLE = 0,
+	THERMAL_TREND_RAISING = 1,
+	THERMAL_TREND_DROPPING = 2,
+};
+
+enum thermal_notify_event {
+	THERMAL_EVENT_UNSPECIFIED = 0,
+	THERMAL_EVENT_TEMP_SAMPLE = 1,
+	THERMAL_TRIP_VIOLATED = 2,
+	THERMAL_TRIP_CHANGED = 3,
+	THERMAL_DEVICE_DOWN = 4,
+	THERMAL_DEVICE_UP = 5,
+	THERMAL_DEVICE_POWER_CAPABILITY_CHANGED = 6,
+	THERMAL_TABLE_CHANGED = 7,
+	THERMAL_EVENT_KEEP_ALIVE = 8,
+	THERMAL_TZ_BIND_CDEV = 9,
+	THERMAL_TZ_UNBIND_CDEV = 10,
+	THERMAL_INSTANCE_WEIGHT_CHANGED = 11,
+	THERMAL_TZ_RESUME = 12,
+};
+
+struct thermal_trip {
+	int temperature;
+	int hysteresis;
+	enum thermal_trip_type type;
+	u8 flags;
+	void *priv;
+};
+
+struct cooling_spec {
+	long unsigned int upper;
+	long unsigned int lower;
+	unsigned int weight;
+};
+
+struct thermal_zone_device_ops {
+	bool (*should_bind)(struct thermal_zone_device *, const struct thermal_trip *, struct thermal_cooling_device *, struct cooling_spec *);
+	int (*get_temp)(struct thermal_zone_device *, int *);
+	int (*set_trips)(struct thermal_zone_device *, int, int);
+	int (*change_mode)(struct thermal_zone_device *, enum thermal_device_mode);
+	int (*set_trip_temp)(struct thermal_zone_device *, const struct thermal_trip *, int);
+	int (*get_crit_temp)(struct thermal_zone_device *, int *);
+	int (*set_emul_temp)(struct thermal_zone_device *, int);
+	int (*get_trend)(struct thermal_zone_device *, const struct thermal_trip *, enum thermal_trend *);
+	void (*hot)(struct thermal_zone_device *);
+	void (*critical)(struct thermal_zone_device *);
+};
+
+struct thermal_attr {
+	struct device_attribute attr;
+	char name[20];
+};
+
+struct thermal_trip_attrs {
+	struct thermal_attr type;
+	struct thermal_attr temp;
+	struct thermal_attr hyst;
+};
+
+struct thermal_trip_desc {
+	struct thermal_trip trip;
+	struct thermal_trip_attrs trip_attrs;
+	struct list_head notify_list_node;
+	int notify_temp;
+	int threshold;
+};
+
+struct thermal_zone_params;
+
+struct thermal_governor;
+
+struct thermal_zone_device {
+	int id;
+	char type[20];
+	struct device device;
+	struct completion removal;
+	struct completion resume;
+	struct attribute_group trips_attribute_group;
+	enum thermal_device_mode mode;
+	void *devdata;
+	int num_trips;
+	long unsigned int passive_delay_jiffies;
+	long unsigned int polling_delay_jiffies;
+	long unsigned int recheck_delay_jiffies;
+	int temperature;
+	int last_temperature;
+	int emul_temperature;
+	int passive;
+	int prev_low_trip;
+	int prev_high_trip;
+	atomic_t need_update;
+	struct thermal_zone_device_ops ops;
+	struct thermal_zone_params *tzp;
+	struct thermal_governor *governor;
+	void *governor_data;
+	struct list_head thermal_instances;
+	struct ida ida;
+	struct mutex lock;
+	struct list_head node;
+	struct delayed_work poll_queue;
+	enum thermal_notify_event notify_event;
+	bool suspended;
+	bool resuming;
+	struct thermal_trip_desc trips[0];
+};
+
+struct thermal_cooling_device_ops;
+
+struct thermal_cooling_device {
+	int id;
+	const char *type;
+	long unsigned int max_state;
+	long: 32;
+	struct device device;
+	struct device_node *np;
+	void *devdata;
+	void *stats;
+	const struct thermal_cooling_device_ops *ops;
+	bool updated;
+	struct mutex lock;
+	struct list_head thermal_instances;
+	struct list_head node;
+};
+
+struct thermal_cooling_device_ops {
+	int (*get_max_state)(struct thermal_cooling_device *, long unsigned int *);
+	int (*get_cur_state)(struct thermal_cooling_device *, long unsigned int *);
+	int (*set_cur_state)(struct thermal_cooling_device *, long unsigned int);
+	int (*get_requested_power)(struct thermal_cooling_device *, u32 *);
+	int (*state2power)(struct thermal_cooling_device *, long unsigned int, u32 *);
+	int (*power2state)(struct thermal_cooling_device *, u32, long unsigned int *);
+};
+
+struct thermal_zone_params {
+	const char *governor_name;
+	bool no_hwmon;
+	u32 sustainable_power;
+	s32 k_po;
+	s32 k_pu;
+	s32 k_i;
+	s32 k_d;
+	s32 integral_cutoff;
+	int slope;
+	int offset;
+};
+
+struct thermal_governor {
+	const char *name;
+	int (*bind_to_tz)(struct thermal_zone_device *);
+	void (*unbind_from_tz)(struct thermal_zone_device *);
+	void (*trip_crossed)(struct thermal_zone_device *, const struct thermal_trip *, bool);
+	void (*manage)(struct thermal_zone_device *);
+	void (*update_tz)(struct thermal_zone_device *, enum thermal_notify_event);
+	struct list_head governor_list;
+};
+
+struct thermal_instance {
+	int id;
+	char name[20];
+	struct thermal_cooling_device *cdev;
+	const struct thermal_trip *trip;
+	bool initialized;
+	long unsigned int upper;
+	long unsigned int lower;
+	long unsigned int target;
+	char attr_name[20];
+	struct device_attribute attr;
+	char weight_attr_name[20];
+	struct device_attribute weight_attr;
+	struct list_head tz_node;
+	struct list_head cdev_node;
+	unsigned int weight;
+	bool upper_no_limit;
+};
+
+struct watchdog_info {
+	__u32 options;
+	__u32 firmware_version;
+	__u8 identity[32];
+};
+
+struct watchdog_device;
+
+struct watchdog_ops {
+	struct module *owner;
+	int (*start)(struct watchdog_device *);
+	int (*stop)(struct watchdog_device *);
+	int (*ping)(struct watchdog_device *);
+	unsigned int (*status)(struct watchdog_device *);
+	int (*set_timeout)(struct watchdog_device *, unsigned int);
+	int (*set_pretimeout)(struct watchdog_device *, unsigned int);
+	unsigned int (*get_timeleft)(struct watchdog_device *);
+	int (*restart)(struct watchdog_device *, long unsigned int, void *);
+	long int (*ioctl)(struct watchdog_device *, unsigned int, long unsigned int);
+};
+
+struct watchdog_governor;
+
+struct watchdog_core_data;
+
+struct watchdog_device {
+	int id;
+	struct device *parent;
+	const struct attribute_group **groups;
+	const struct watchdog_info *info;
+	const struct watchdog_ops *ops;
+	const struct watchdog_governor *gov;
+	unsigned int bootstatus;
+	unsigned int timeout;
+	unsigned int pretimeout;
+	unsigned int min_timeout;
+	unsigned int max_timeout;
+	unsigned int min_hw_heartbeat_ms;
+	unsigned int max_hw_heartbeat_ms;
+	struct notifier_block reboot_nb;
+	struct notifier_block restart_nb;
+	struct notifier_block pm_nb;
+	void *driver_data;
+	struct watchdog_core_data *wd_data;
+	long unsigned int status;
+	struct list_head deferred;
+};
+
+struct watchdog_governor {
+	const char name[20];
+	void (*pretimeout)(struct watchdog_device *);
+};
+
+struct watchdog_core_data {
+	struct device dev;
+	struct cdev cdev;
+	struct watchdog_device *wdd;
+	struct mutex lock;
+	long: 32;
+	ktime_t last_keepalive;
+	ktime_t last_hw_keepalive;
+	ktime_t open_deadline;
+	struct hrtimer timer;
+	struct kthread_work work;
+	long unsigned int status;
+};
+
+struct hd_geometry {
+	unsigned char heads;
+	unsigned char sectors;
+	short unsigned int cylinders;
+	long unsigned int start;
+};
+
+enum blk_crypto_mode_num {
+	BLK_ENCRYPTION_MODE_INVALID = 0,
+	BLK_ENCRYPTION_MODE_AES_256_XTS = 1,
+	BLK_ENCRYPTION_MODE_AES_128_CBC_ESSIV = 2,
+	BLK_ENCRYPTION_MODE_ADIANTUM = 3,
+	BLK_ENCRYPTION_MODE_SM4_XTS = 4,
+	BLK_ENCRYPTION_MODE_MAX = 5,
+};
+
+struct dm_kobject_holder {
+	struct kobject kobj;
+	struct completion completion;
+};
+
+struct clocksource_mmio {
+	void *reg;
+	long: 32;
+	struct clocksource clksrc;
+};
+
+typedef int (*of_init_fn_1_ret)(struct device_node *);
+
+struct alias_prop {
+	struct list_head link;
+	const char *alias;
+	struct device_node *np;
+	int id;
+	char stem[0];
+};
+
+enum memblock_flags {
+	MEMBLOCK_NONE = 0,
+	MEMBLOCK_HOTPLUG = 1,
+	MEMBLOCK_MIRROR = 2,
+	MEMBLOCK_NOMAP = 4,
+	MEMBLOCK_DRIVER_MANAGED = 8,
+	MEMBLOCK_RSRV_NOINIT = 16,
+};
+
+struct memblock_region {
+	phys_addr_t base;
+	phys_addr_t size;
+	enum memblock_flags flags;
+};
+
+typedef __be32 fdt32_t;
+
+struct fdt_header {
+	fdt32_t magic;
+	fdt32_t totalsize;
+	fdt32_t off_dt_struct;
+	fdt32_t off_dt_strings;
+	fdt32_t off_mem_rsvmap;
+	fdt32_t version;
+	fdt32_t last_comp_version;
+	fdt32_t boot_cpuid_phys;
+	fdt32_t size_dt_strings;
+	fdt32_t size_dt_struct;
+};
+
+struct earlycon_device {
+	struct console *con;
+	long: 32;
+	struct uart_port port;
+	char options[32];
+	unsigned int baud;
+	long: 32;
+};
+
+struct earlycon_id {
+	char name[15];
+	char name_term;
+	char compatible[128];
+	int (*setup)(struct earlycon_device *, const char *);
+};
+
+enum bcma_clkmode {
+	BCMA_CLKMODE_FAST = 0,
+	BCMA_CLKMODE_DYNAMIC = 1,
+};
+
+struct extcon_cable;
+
+struct extcon_dev {
+	const char *name;
+	const unsigned int *supported_cable;
+	const u32 *mutually_exclusive;
+	long: 32;
+	struct device dev;
+	unsigned int id;
+	struct raw_notifier_head nh_all;
+	struct raw_notifier_head *nh;
+	struct list_head entry;
+	int max_supported;
+	spinlock_t lock;
+	u32 state;
+	struct device_type extcon_dev_type;
+	struct extcon_cable *cables;
+	struct attribute_group attr_g_muex;
+	struct attribute **attrs_muex;
+	struct device_attribute *d_attrs_muex;
+};
+
+struct extcon_dev_notifier_devres {
+	struct extcon_dev *edev;
+	unsigned int id;
+	struct notifier_block *nb;
+};
+
+enum perf_hw_id {
+	PERF_COUNT_HW_CPU_CYCLES = 0,
+	PERF_COUNT_HW_INSTRUCTIONS = 1,
+	PERF_COUNT_HW_CACHE_REFERENCES = 2,
+	PERF_COUNT_HW_CACHE_MISSES = 3,
+	PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,
+	PERF_COUNT_HW_BRANCH_MISSES = 5,
+	PERF_COUNT_HW_BUS_CYCLES = 6,
+	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,
+	PERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,
+	PERF_COUNT_HW_REF_CPU_CYCLES = 9,
+	PERF_COUNT_HW_MAX = 10,
+};
+
+enum perf_hw_cache_id {
+	PERF_COUNT_HW_CACHE_L1D = 0,
+	PERF_COUNT_HW_CACHE_L1I = 1,
+	PERF_COUNT_HW_CACHE_LL = 2,
+	PERF_COUNT_HW_CACHE_DTLB = 3,
+	PERF_COUNT_HW_CACHE_ITLB = 4,
+	PERF_COUNT_HW_CACHE_BPU = 5,
+	PERF_COUNT_HW_CACHE_NODE = 6,
+	PERF_COUNT_HW_CACHE_MAX = 7,
+};
+
+enum perf_hw_cache_op_id {
+	PERF_COUNT_HW_CACHE_OP_READ = 0,
+	PERF_COUNT_HW_CACHE_OP_WRITE = 1,
+	PERF_COUNT_HW_CACHE_OP_PREFETCH = 2,
+	PERF_COUNT_HW_CACHE_OP_MAX = 3,
+};
+
+enum perf_hw_cache_op_result_id {
+	PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,
+	PERF_COUNT_HW_CACHE_RESULT_MISS = 1,
+	PERF_COUNT_HW_CACHE_RESULT_MAX = 2,
+};
+
+struct arm_pmu;
+
+struct pmu_hw_events {
+	struct perf_event *events[32];
+	long unsigned int used_mask[1];
+	struct arm_pmu *percpu_pmu;
+	int irq;
+};
+
+struct arm_pmu {
+	struct pmu pmu;
+	cpumask_t supported_cpus;
+	char *name;
+	int pmuver;
+	irqreturn_t (*handle_irq)(struct arm_pmu *);
+	void (*enable)(struct perf_event *);
+	void (*disable)(struct perf_event *);
+	int (*get_event_idx)(struct pmu_hw_events *, struct perf_event *);
+	void (*clear_event_idx)(struct pmu_hw_events *, struct perf_event *);
+	int (*set_event_filter)(struct hw_perf_event *, struct perf_event_attr *);
+	u64 (*read_counter)(struct perf_event *);
+	void (*write_counter)(struct perf_event *, u64);
+	void (*start)(struct arm_pmu *);
+	void (*stop)(struct arm_pmu *);
+	void (*reset)(void *);
+	int (*map_event)(struct perf_event *);
+	long unsigned int cntr_mask[1];
+	bool secure_access;
+	long unsigned int pmceid_bitmap[2];
+	long unsigned int pmceid_ext_bitmap[2];
+	struct platform_device *plat_device;
+	struct pmu_hw_events *hw_events;
+	struct hlist_node node;
+	struct notifier_block cpu_pm_nb;
+	const struct attribute_group *attr_groups[5];
+	long: 32;
+	u64 reg_pmmir;
+	long unsigned int acpi_cpuid;
+	long: 32;
+};
+
+enum armpmu_attr_groups {
+	ARMPMU_ATTR_GROUP_COMMON = 0,
+	ARMPMU_ATTR_GROUP_EVENTS = 1,
+	ARMPMU_ATTR_GROUP_FORMATS = 2,
+	ARMPMU_ATTR_GROUP_CAPS = 3,
+	ARMPMU_NR_ATTR_GROUPS = 4,
+};
+
+struct pmu_irq_ops {
+	void (*enable_pmuirq)(unsigned int);
+	void (*disable_pmuirq)(unsigned int);
+	void (*free_pmuirq)(unsigned int, int, void *);
+};
+
+typedef int (*nvmem_reg_read_t)(void *, unsigned int, void *, size_t);
+
+typedef int (*nvmem_reg_write_t)(void *, unsigned int, void *, size_t);
+
+typedef int (*nvmem_cell_post_process_t)(void *, const char *, int, unsigned int, void *, size_t);
+
+enum nvmem_type {
+	NVMEM_TYPE_UNKNOWN = 0,
+	NVMEM_TYPE_EEPROM = 1,
+	NVMEM_TYPE_OTP = 2,
+	NVMEM_TYPE_BATTERY_BACKED = 3,
+	NVMEM_TYPE_FRAM = 4,
+};
+
+struct nvmem_keepout {
+	unsigned int start;
+	unsigned int end;
+	unsigned char value;
+};
+
+struct nvmem_cell_info {
+	const char *name;
+	unsigned int offset;
+	size_t raw_len;
+	unsigned int bytes;
+	unsigned int bit_offset;
+	unsigned int nbits;
+	struct device_node *np;
+	nvmem_cell_post_process_t read_post_process;
+	void *priv;
+};
+
+struct nvmem_layout;
+
+struct nvmem_config {
+	struct device *dev;
+	const char *name;
+	int id;
+	struct module *owner;
+	const struct nvmem_cell_info *cells;
+	int ncells;
+	bool add_legacy_fixed_of_cells;
+	void (*fixup_dt_cell_info)(struct nvmem_device *, struct nvmem_cell_info *);
+	const struct nvmem_keepout *keepout;
+	unsigned int nkeepout;
+	enum nvmem_type type;
+	bool read_only;
+	bool root_only;
+	bool ignore_wp;
+	struct nvmem_layout *layout;
+	struct device_node *of_node;
+	nvmem_reg_read_t reg_read;
+	nvmem_reg_write_t reg_write;
+	int size;
+	int word_size;
+	int stride;
+	void *priv;
+	bool compat;
+	struct device *base_dev;
+};
+
+struct nvmem_layout {
+	struct device dev;
+	struct nvmem_device *nvmem;
+	int (*add_cells)(struct nvmem_layout *);
+};
+
+struct brcm_nvram {
+	struct device *dev;
+	size_t nvmem_size;
+	uint8_t *data;
+	size_t data_len;
+	uint8_t padding_byte;
+	struct nvmem_cell_info *cells;
+	int ncells;
+};
+
+struct brcm_nvram_header {
+	char magic[4];
+	__le32 len;
+	__le32 crc_ver_init;
+	__le32 config_refresh;
+	__le32 config_ncdl;
+};
+
+struct minmax_sample {
+	u32 t;
+	u32 v;
+};
+
+struct minmax {
+	struct minmax_sample s[3];
+};
+
+struct fastopen_queue {
+	struct request_sock *rskq_rst_head;
+	struct request_sock *rskq_rst_tail;
+	spinlock_t lock;
+	int qlen;
+	int max_qlen;
+	struct tcp_fastopen_context *ctx;
+};
+
+struct request_sock_queue {
+	spinlock_t rskq_lock;
+	u8 rskq_defer_accept;
+	u32 synflood_warned;
+	atomic_t qlen;
+	atomic_t young;
+	struct request_sock *rskq_accept_head;
+	struct request_sock *rskq_accept_tail;
+	struct fastopen_queue fastopenq;
+};
+
+struct ip_options {
+	__be32 faddr;
+	__be32 nexthop;
+	unsigned char optlen;
+	unsigned char srr;
+	unsigned char rr;
+	unsigned char ts;
+	unsigned char is_strictroute: 1;
+	unsigned char srr_is_hit: 1;
+	unsigned char is_changed: 1;
+	unsigned char rr_needaddr: 1;
+	unsigned char ts_needtime: 1;
+	unsigned char ts_needaddr: 1;
+	unsigned char router_alert;
+	unsigned char cipso;
+	unsigned char __pad2;
+	unsigned char __data[0];
+};
+
+struct ip_options_rcu {
+	struct callback_head rcu;
+	struct ip_options opt;
+};
+
+struct ipv6_txoptions;
+
+struct inet_request_sock {
+	struct request_sock req;
+	u16 snd_wscale: 4;
+	u16 rcv_wscale: 4;
+	u16 tstamp_ok: 1;
+	u16 sack_ok: 1;
+	u16 wscale_ok: 1;
+	u16 ecn_ok: 1;
+	u16 acked: 1;
+	u16 no_srccheck: 1;
+	u16 smc_ok: 1;
+	u32 ir_mark;
+	union {
+		struct ip_options_rcu *ireq_opt;
+		struct {
+			struct ipv6_txoptions *ipv6_opt;
+			struct sk_buff *pktopts;
+		};
+	};
+};
+
+struct inet_cork {
+	unsigned int flags;
+	__be32 addr;
+	struct ip_options *opt;
+	unsigned int fragsize;
+	int length;
+	struct dst_entry *dst;
+	u8 tx_flags;
+	__u8 ttl;
+	__s16 tos;
+	char priority;
+	__u16 gso_size;
+	u64 transmit_time;
+	u32 mark;
+	long: 32;
+};
+
+struct inet_cork_full {
+	struct inet_cork base;
+	struct flowi fl;
+};
+
+struct ipv6_pinfo;
+
+struct ip_mc_socklist;
+
+struct inet_sock {
+	struct sock sk;
+	struct ipv6_pinfo *pinet6;
+	long unsigned int inet_flags;
+	__be32 inet_saddr;
+	__s16 uc_ttl;
+	__be16 inet_sport;
+	struct ip_options_rcu *inet_opt;
+	atomic_t inet_id;
+	__u8 tos;
+	__u8 min_ttl;
+	__u8 mc_ttl;
+	__u8 pmtudisc;
+	__u8 rcv_tos;
+	__u8 convert_csum;
+	int uc_index;
+	int mc_index;
+	__be32 mc_addr;
+	u32 local_port_range;
+	struct ip_mc_socklist *mc_list;
+	long: 32;
+	struct inet_cork_full cork;
+};
+
+struct inet_connection_sock_af_ops {
+	int (*queue_xmit)(struct sock *, struct sk_buff *, struct flowi *);
+	void (*send_check)(struct sock *, struct sk_buff *);
+	int (*rebuild_header)(struct sock *);
+	void (*sk_rx_dst_set)(struct sock *, const struct sk_buff *);
+	int (*conn_request)(struct sock *, struct sk_buff *);
+	struct sock * (*syn_recv_sock)(const struct sock *, struct sk_buff *, struct request_sock *, struct dst_entry *, struct request_sock *, bool *);
+	u16 net_header_len;
+	u16 sockaddr_len;
+	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
+	int (*getsockopt)(struct sock *, int, int, char *, int *);
+	void (*addr2sockaddr)(struct sock *, struct sockaddr *);
+	void (*mtu_reduced)(struct sock *);
+};
+
+struct inet_bind_bucket;
+
+struct inet_bind2_bucket;
+
+struct tcp_ulp_ops;
+
+struct inet_connection_sock {
+	struct inet_sock icsk_inet;
+	struct request_sock_queue icsk_accept_queue;
+	struct inet_bind_bucket *icsk_bind_hash;
+	struct inet_bind2_bucket *icsk_bind2_hash;
+	long unsigned int icsk_timeout;
+	struct timer_list icsk_retransmit_timer;
+	struct timer_list icsk_delack_timer;
+	__u32 icsk_rto;
+	__u32 icsk_rto_min;
+	__u32 icsk_delack_max;
+	__u32 icsk_pmtu_cookie;
+	const struct tcp_congestion_ops *icsk_ca_ops;
+	const struct inet_connection_sock_af_ops *icsk_af_ops;
+	const struct tcp_ulp_ops *icsk_ulp_ops;
+	void *icsk_ulp_data;
+	void (*icsk_clean_acked)(struct sock *, u32);
+	unsigned int (*icsk_sync_mss)(struct sock *, u32);
+	__u8 icsk_ca_state: 5;
+	__u8 icsk_ca_initialized: 1;
+	__u8 icsk_ca_setsockopt: 1;
+	__u8 icsk_ca_dst_locked: 1;
+	__u8 icsk_retransmits;
+	__u8 icsk_pending;
+	__u8 icsk_backoff;
+	__u8 icsk_syn_retries;
+	__u8 icsk_probes_out;
+	__u16 icsk_ext_hdr_len;
+	struct {
+		__u8 pending;
+		__u8 quick;
+		__u8 pingpong;
+		__u8 retry;
+		__u32 ato: 8;
+		__u32 lrcv_flowlabel: 20;
+		__u32 unused: 4;
+		long unsigned int timeout;
+		__u32 lrcvtime;
+		__u16 last_seg_size;
+		__u16 rcv_mss;
+	} icsk_ack;
+	struct {
+		int search_high;
+		int search_low;
+		u32 probe_size: 31;
+		u32 enabled: 1;
+		u32 probe_timestamp;
+	} icsk_mtup;
+	u32 icsk_probes_tstamp;
+	u32 icsk_user_timeout;
+	long: 32;
+	u64 icsk_ca_priv[18];
+};
+
+struct tcp_ulp_ops {
+	struct list_head list;
+	int (*init)(struct sock *);
+	void (*update)(struct sock *, struct proto *, void (*)(struct sock *));
+	void (*release)(struct sock *);
+	int (*get_info)(struct sock *, struct sk_buff *);
+	size_t (*get_info_size)(const struct sock *);
+	void (*clone)(const struct request_sock *, struct sock *, const gfp_t);
+	char name[16];
+	struct module *owner;
+};
+
+struct tcp_sack_block {
+	u32 start_seq;
+	u32 end_seq;
+};
+
+struct tcp_options_received {
+	int ts_recent_stamp;
+	u32 ts_recent;
+	u32 rcv_tsval;
+	u32 rcv_tsecr;
+	u16 saw_tstamp: 1;
+	u16 tstamp_ok: 1;
+	u16 dsack: 1;
+	u16 wscale_ok: 1;
+	u16 sack_ok: 3;
+	u16 smc_ok: 1;
+	u16 snd_wscale: 4;
+	u16 rcv_wscale: 4;
+	u8 saw_unknown: 1;
+	u8 unused: 7;
+	u8 num_sacks;
+	u16 user_mss;
+	u16 mss_clamp;
+};
+
+struct tcp_request_sock_ops;
+
+struct tcp_request_sock {
+	struct inet_request_sock req;
+	const struct tcp_request_sock_ops *af_specific;
+	long: 32;
+	u64 snt_synack;
+	bool tfo_listener;
+	bool is_mptcp;
+	bool req_usec_ts;
+	bool drop_req;
+	u32 txhash;
+	u32 rcv_isn;
+	u32 snt_isn;
+	u32 ts_off;
+	u32 last_oow_ack_time;
+	u32 rcv_nxt;
+	u8 syn_tos;
+};
+
+enum tcp_synack_type {
+	TCP_SYNACK_NORMAL = 0,
+	TCP_SYNACK_FASTOPEN = 1,
+	TCP_SYNACK_COOKIE = 2,
+};
+
+struct tcp_fastopen_cookie;
+
+struct tcp_request_sock_ops {
+	u16 mss_clamp;
+	__u32 (*cookie_init_seq)(const struct sk_buff *, __u16 *);
+	struct dst_entry * (*route_req)(const struct sock *, struct sk_buff *, struct flowi *, struct request_sock *, u32);
+	u32 (*init_seq)(const struct sk_buff *);
+	u32 (*init_ts_off)(const struct net *, const struct sk_buff *);
+	int (*send_synack)(const struct sock *, struct dst_entry *, struct flowi *, struct request_sock *, struct tcp_fastopen_cookie *, enum tcp_synack_type, struct sk_buff *);
+};
+
+struct tcp_rack {
+	u64 mstamp;
+	u32 rtt_us;
+	u32 end_seq;
+	u32 last_delivered;
+	u8 reo_wnd_steps;
+	u8 reo_wnd_persist: 5;
+	u8 dsack_seen: 1;
+	u8 advanced: 1;
+};
+
+struct tcp_fastopen_request;
+
+struct tcp_sock {
+	struct inet_connection_sock inet_conn;
+	__u8 __cacheline_group_begin__tcp_sock_read_tx[0];
+	u32 max_window;
+	u32 rcv_ssthresh;
+	u32 reordering;
+	u32 notsent_lowat;
+	u16 gso_segs;
+	struct sk_buff *lost_skb_hint;
+	struct sk_buff *retransmit_skb_hint;
+	__u8 __cacheline_group_end__tcp_sock_read_tx[0];
+	__u8 __cacheline_group_begin__tcp_sock_read_txrx[0];
+	u32 tsoffset;
+	u32 snd_wnd;
+	u32 mss_cache;
+	u32 snd_cwnd;
+	u32 prr_out;
+	u32 lost_out;
+	u32 sacked_out;
+	u16 tcp_header_len;
+	u8 scaling_ratio;
+	u8 chrono_type: 2;
+	u8 repair: 1;
+	u8 tcp_usec_ts: 1;
+	u8 is_sack_reneg: 1;
+	u8 is_cwnd_limited: 1;
+	__u8 __cacheline_group_end__tcp_sock_read_txrx[0];
+	__u8 __cacheline_group_begin__tcp_sock_read_rx[0];
+	u32 copied_seq;
+	u32 rcv_tstamp;
+	u32 snd_wl1;
+	u32 tlp_high_seq;
+	u32 rttvar_us;
+	u32 retrans_out;
+	u16 advmss;
+	u16 urg_data;
+	u32 lost;
+	struct minmax rtt_min;
+	struct rb_root out_of_order_queue;
+	u32 snd_ssthresh;
+	u8 recvmsg_inq: 1;
+	__u8 __cacheline_group_end__tcp_sock_read_rx[0];
+	long: 0;
+	__u8 __cacheline_group_begin__tcp_sock_write_tx[0];
+	u32 segs_out;
+	u32 data_segs_out;
+	u64 bytes_sent;
+	u32 snd_sml;
+	u32 chrono_start;
+	u32 chrono_stat[3];
+	u32 write_seq;
+	u32 pushed_seq;
+	u32 lsndtime;
+	u32 mdev_us;
+	u32 rtt_seq;
+	u64 tcp_wstamp_ns;
+	struct list_head tsorted_sent_queue;
+	struct sk_buff *highest_sack;
+	u8 ecn_flags;
+	__u8 __cacheline_group_end__tcp_sock_write_tx[0];
+	__u8 __cacheline_group_begin__tcp_sock_write_txrx[0];
+	__be32 pred_flags;
+	long: 32;
+	u64 tcp_clock_cache;
+	u64 tcp_mstamp;
+	u32 rcv_nxt;
+	u32 snd_nxt;
+	u32 snd_una;
+	u32 window_clamp;
+	u32 srtt_us;
+	u32 packets_out;
+	u32 snd_up;
+	u32 delivered;
+	u32 delivered_ce;
+	u32 app_limited;
+	u32 rcv_wnd;
+	struct tcp_options_received rx_opt;
+	u8 nonagle: 4;
+	u8 rate_app_limited: 1;
+	__u8 __cacheline_group_end__tcp_sock_write_txrx[0];
+	long: 0;
+	__u8 __cacheline_group_begin__tcp_sock_write_rx[0];
+	u64 bytes_received;
+	u32 segs_in;
+	u32 data_segs_in;
+	u32 rcv_wup;
+	u32 max_packets_out;
+	u32 cwnd_usage_seq;
+	u32 rate_delivered;
+	u32 rate_interval_us;
+	u32 rcv_rtt_last_tsecr;
+	u64 first_tx_mstamp;
+	u64 delivered_mstamp;
+	u64 bytes_acked;
+	struct {
+		u32 rtt_us;
+		u32 seq;
+		u64 time;
+	} rcv_rtt_est;
+	struct {
+		u32 space;
+		u32 seq;
+		u64 time;
+	} rcvq_space;
+	__u8 __cacheline_group_end__tcp_sock_write_rx[0];
+	u32 dsack_dups;
+	u32 compressed_ack_rcv_nxt;
+	struct list_head tsq_node;
+	struct tcp_rack rack;
+	u8 compressed_ack;
+	u8 dup_ack_counter: 2;
+	u8 tlp_retrans: 1;
+	u8 fast_ack_mode: 2;
+	u8 tlp_orig_data_app_limited: 1;
+	u8 unused: 2;
+	u8 thin_lto: 1;
+	u8 fastopen_connect: 1;
+	u8 fastopen_no_cookie: 1;
+	u8 fastopen_client_fail: 2;
+	u8 frto: 1;
+	u8 repair_queue;
+	u8 save_syn: 2;
+	u8 syn_data: 1;
+	u8 syn_fastopen: 1;
+	u8 syn_fastopen_exp: 1;
+	u8 syn_fastopen_ch: 1;
+	u8 syn_data_acked: 1;
+	u8 keepalive_probes;
+	u32 tcp_tx_delay;
+	u32 mdev_max_us;
+	u32 reord_seen;
+	u32 snd_cwnd_cnt;
+	u32 snd_cwnd_clamp;
+	u32 snd_cwnd_used;
+	u32 snd_cwnd_stamp;
+	u32 prior_cwnd;
+	u32 prr_delivered;
+	u32 last_oow_ack_time;
+	struct hrtimer pacing_timer;
+	struct hrtimer compressed_ack_timer;
+	struct sk_buff *ooo_last_skb;
+	struct tcp_sack_block duplicate_sack[1];
+	struct tcp_sack_block selective_acks[4];
+	struct tcp_sack_block recv_sack_cache[4];
+	int lost_cnt_hint;
+	u32 prior_ssthresh;
+	u32 high_seq;
+	u32 retrans_stamp;
+	u32 undo_marker;
+	int undo_retrans;
+	long: 32;
+	u64 bytes_retrans;
+	u32 total_retrans;
+	u32 rto_stamp;
+	u16 total_rto;
+	u16 total_rto_recoveries;
+	u32 total_rto_time;
+	u32 urg_seq;
+	unsigned int keepalive_time;
+	unsigned int keepalive_intvl;
+	int linger2;
+	u8 bpf_sock_ops_cb_flags;
+	u8 bpf_chg_cc_inprogress: 1;
+	u16 timeout_rehash;
+	u32 rcv_ooopack;
+	struct {
+		u32 probe_seq_start;
+		u32 probe_seq_end;
+	} mtu_probe;
+	u32 plb_rehash;
+	u32 mtu_info;
+	bool is_mptcp;
+	struct tcp_fastopen_request *fastopen_req;
+	struct request_sock *fastopen_rsk;
+	struct saved_syn *saved_syn;
+};
+
+typedef __u16 __sum16;
+
+struct netdev_xmit {
+	u16 recursion;
+	u8 more;
+	u8 skip_txqueue;
+};
+
+struct page_pool_params_fast {
+	unsigned int order;
+	unsigned int pool_size;
+	int nid;
+	struct device *dev;
+	struct napi_struct *napi;
+	enum dma_data_direction dma_dir;
+	unsigned int max_len;
+	unsigned int offset;
+};
+
+typedef long unsigned int netmem_ref;
+
+struct pp_alloc_cache {
+	u32 count;
+	netmem_ref cache[128];
+};
+
+struct ptr_ring {
+	int producer;
+	spinlock_t producer_lock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	int consumer_head;
+	int consumer_tail;
+	spinlock_t consumer_lock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	int size;
+	int batch;
+	void **queue;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct page_pool_params_slow {
+	struct net_device *netdev;
+	unsigned int queue_idx;
+	unsigned int flags;
+	void (*init_callback)(netmem_ref, void *);
+	void *init_arg;
+};
+
+struct page_pool {
+	struct page_pool_params_fast p;
+	int cpuid;
+	u32 pages_state_hold_cnt;
+	bool has_init_callback: 1;
+	bool dma_map: 1;
+	bool dma_sync: 1;
+	long: 32;
+	__u8 __cacheline_group_begin__frag[0];
+	long int frag_users;
+	netmem_ref frag_page;
+	unsigned int frag_offset;
+	__u8 __cacheline_group_end__frag[0];
+	long: 32;
+	struct {} __cacheline_group_pad__frag;
+	struct delayed_work release_dw;
+	void (*disconnect)(void *);
+	long unsigned int defer_start;
+	long unsigned int defer_warn;
+	u32 xdp_mem_id;
+	long: 32;
+	struct pp_alloc_cache alloc;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct ptr_ring ring;
+	void *mp_priv;
+	atomic_t pages_state_release_cnt;
+	refcount_t user_cnt;
+	long: 32;
+	u64 destroy_cnt;
+	struct page_pool_params_slow slow;
+	long: 32;
+	struct {
+		struct hlist_node list;
+		u64 detach_time;
+		u32 napi_id;
+		u32 id;
+	} user;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct page_frag_cache {
+	void *va;
+	__u16 offset;
+	__u16 size;
+	unsigned int pagecnt_bias;
+	bool pfmemalloc;
+};
+
+enum skb_drop_reason {
+	SKB_NOT_DROPPED_YET = 0,
+	SKB_CONSUMED = 1,
+	SKB_DROP_REASON_NOT_SPECIFIED = 2,
+	SKB_DROP_REASON_NO_SOCKET = 3,
+	SKB_DROP_REASON_PKT_TOO_SMALL = 4,
+	SKB_DROP_REASON_TCP_CSUM = 5,
+	SKB_DROP_REASON_SOCKET_FILTER = 6,
+	SKB_DROP_REASON_UDP_CSUM = 7,
+	SKB_DROP_REASON_NETFILTER_DROP = 8,
+	SKB_DROP_REASON_OTHERHOST = 9,
+	SKB_DROP_REASON_IP_CSUM = 10,
+	SKB_DROP_REASON_IP_INHDR = 11,
+	SKB_DROP_REASON_IP_RPFILTER = 12,
+	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST = 13,
+	SKB_DROP_REASON_XFRM_POLICY = 14,
+	SKB_DROP_REASON_IP_NOPROTO = 15,
+	SKB_DROP_REASON_SOCKET_RCVBUFF = 16,
+	SKB_DROP_REASON_PROTO_MEM = 17,
+	SKB_DROP_REASON_TCP_AUTH_HDR = 18,
+	SKB_DROP_REASON_TCP_MD5NOTFOUND = 19,
+	SKB_DROP_REASON_TCP_MD5UNEXPECTED = 20,
+	SKB_DROP_REASON_TCP_MD5FAILURE = 21,
+	SKB_DROP_REASON_TCP_AONOTFOUND = 22,
+	SKB_DROP_REASON_TCP_AOUNEXPECTED = 23,
+	SKB_DROP_REASON_TCP_AOKEYNOTFOUND = 24,
+	SKB_DROP_REASON_TCP_AOFAILURE = 25,
+	SKB_DROP_REASON_SOCKET_BACKLOG = 26,
+	SKB_DROP_REASON_TCP_FLAGS = 27,
+	SKB_DROP_REASON_TCP_ABORT_ON_DATA = 28,
+	SKB_DROP_REASON_TCP_ZEROWINDOW = 29,
+	SKB_DROP_REASON_TCP_OLD_DATA = 30,
+	SKB_DROP_REASON_TCP_OVERWINDOW = 31,
+	SKB_DROP_REASON_TCP_OFOMERGE = 32,
+	SKB_DROP_REASON_TCP_RFC7323_PAWS = 33,
+	SKB_DROP_REASON_TCP_OLD_SEQUENCE = 34,
+	SKB_DROP_REASON_TCP_INVALID_SEQUENCE = 35,
+	SKB_DROP_REASON_TCP_INVALID_ACK_SEQUENCE = 36,
+	SKB_DROP_REASON_TCP_RESET = 37,
+	SKB_DROP_REASON_TCP_INVALID_SYN = 38,
+	SKB_DROP_REASON_TCP_CLOSE = 39,
+	SKB_DROP_REASON_TCP_FASTOPEN = 40,
+	SKB_DROP_REASON_TCP_OLD_ACK = 41,
+	SKB_DROP_REASON_TCP_TOO_OLD_ACK = 42,
+	SKB_DROP_REASON_TCP_ACK_UNSENT_DATA = 43,
+	SKB_DROP_REASON_TCP_OFO_QUEUE_PRUNE = 44,
+	SKB_DROP_REASON_TCP_OFO_DROP = 45,
+	SKB_DROP_REASON_IP_OUTNOROUTES = 46,
+	SKB_DROP_REASON_BPF_CGROUP_EGRESS = 47,
+	SKB_DROP_REASON_IPV6DISABLED = 48,
+	SKB_DROP_REASON_NEIGH_CREATEFAIL = 49,
+	SKB_DROP_REASON_NEIGH_FAILED = 50,
+	SKB_DROP_REASON_NEIGH_QUEUEFULL = 51,
+	SKB_DROP_REASON_NEIGH_DEAD = 52,
+	SKB_DROP_REASON_TC_EGRESS = 53,
+	SKB_DROP_REASON_SECURITY_HOOK = 54,
+	SKB_DROP_REASON_QDISC_DROP = 55,
+	SKB_DROP_REASON_CPU_BACKLOG = 56,
+	SKB_DROP_REASON_XDP = 57,
+	SKB_DROP_REASON_TC_INGRESS = 58,
+	SKB_DROP_REASON_UNHANDLED_PROTO = 59,
+	SKB_DROP_REASON_SKB_CSUM = 60,
+	SKB_DROP_REASON_SKB_GSO_SEG = 61,
+	SKB_DROP_REASON_SKB_UCOPY_FAULT = 62,
+	SKB_DROP_REASON_DEV_HDR = 63,
+	SKB_DROP_REASON_DEV_READY = 64,
+	SKB_DROP_REASON_FULL_RING = 65,
+	SKB_DROP_REASON_NOMEM = 66,
+	SKB_DROP_REASON_HDR_TRUNC = 67,
+	SKB_DROP_REASON_TAP_FILTER = 68,
+	SKB_DROP_REASON_TAP_TXFILTER = 69,
+	SKB_DROP_REASON_ICMP_CSUM = 70,
+	SKB_DROP_REASON_INVALID_PROTO = 71,
+	SKB_DROP_REASON_IP_INADDRERRORS = 72,
+	SKB_DROP_REASON_IP_INNOROUTES = 73,
+	SKB_DROP_REASON_PKT_TOO_BIG = 74,
+	SKB_DROP_REASON_DUP_FRAG = 75,
+	SKB_DROP_REASON_FRAG_REASM_TIMEOUT = 76,
+	SKB_DROP_REASON_FRAG_TOO_FAR = 77,
+	SKB_DROP_REASON_TCP_MINTTL = 78,
+	SKB_DROP_REASON_IPV6_BAD_EXTHDR = 79,
+	SKB_DROP_REASON_IPV6_NDISC_FRAG = 80,
+	SKB_DROP_REASON_IPV6_NDISC_HOP_LIMIT = 81,
+	SKB_DROP_REASON_IPV6_NDISC_BAD_CODE = 82,
+	SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS = 83,
+	SKB_DROP_REASON_IPV6_NDISC_NS_OTHERHOST = 84,
+	SKB_DROP_REASON_QUEUE_PURGE = 85,
+	SKB_DROP_REASON_TC_COOKIE_ERROR = 86,
+	SKB_DROP_REASON_PACKET_SOCK_ERROR = 87,
+	SKB_DROP_REASON_TC_CHAIN_NOTFOUND = 88,
+	SKB_DROP_REASON_TC_RECLASSIFY_LOOP = 89,
+	SKB_DROP_REASON_MAX = 90,
+	SKB_DROP_REASON_SUBSYS_MASK = 4294901760,
+};
+
+struct inet_ehash_bucket;
+
+struct inet_bind_hashbucket;
+
+struct inet_listen_hashbucket;
+
+struct inet_hashinfo {
+	struct inet_ehash_bucket *ehash;
+	spinlock_t *ehash_locks;
+	unsigned int ehash_mask;
+	unsigned int ehash_locks_mask;
+	struct kmem_cache *bind_bucket_cachep;
+	struct inet_bind_hashbucket *bhash;
+	struct kmem_cache *bind2_bucket_cachep;
+	struct inet_bind_hashbucket *bhash2;
+	unsigned int bhash_size;
+	unsigned int lhash2_mask;
+	struct inet_listen_hashbucket *lhash2;
+	bool pernet;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct ip_ra_chain {
+	struct ip_ra_chain *next;
+	struct sock *sk;
+	union {
+		void (*destructor)(struct sock *);
+		struct sock *saved_sk;
+	};
+	struct callback_head rcu;
+};
+
+struct tcp_fastopen_context {
+	siphash_key_t key[2];
+	int num;
+	struct callback_head rcu;
+	long: 32;
+};
+
+struct rt6key {
+	struct in6_addr addr;
+	int plen;
+};
+
+struct rtable;
+
+struct fnhe_hash_bucket;
+
+struct fib_nh_common {
+	struct net_device *nhc_dev;
+	netdevice_tracker nhc_dev_tracker;
+	int nhc_oif;
+	unsigned char nhc_scope;
+	u8 nhc_family;
+	u8 nhc_gw_family;
+	unsigned char nhc_flags;
+	struct lwtunnel_state *nhc_lwtstate;
+	union {
+		__be32 ipv4;
+		struct in6_addr ipv6;
+	} nhc_gw;
+	int nhc_weight;
+	atomic_t nhc_upper_bound;
+	struct rtable **nhc_pcpu_rth_output;
+	struct rtable *nhc_rth_input;
+	struct fnhe_hash_bucket *nhc_exceptions;
+};
+
+struct rt6_exception_bucket;
+
+struct fib6_nh {
+	struct fib_nh_common nh_common;
+	struct rt6_info **rt6i_pcpu;
+	struct rt6_exception_bucket *rt6i_exception_bucket;
+};
+
+struct fib6_node;
+
+struct dst_metrics;
+
+struct nexthop;
+
+struct fib6_info {
+	struct fib6_table *fib6_table;
+	struct fib6_info *fib6_next;
+	struct fib6_node *fib6_node;
+	union {
+		struct list_head fib6_siblings;
+		struct list_head nh_list;
+	};
+	unsigned int fib6_nsiblings;
+	refcount_t fib6_ref;
+	long unsigned int expires;
+	struct hlist_node gc_link;
+	struct dst_metrics *fib6_metrics;
+	struct rt6key fib6_dst;
+	u32 fib6_flags;
+	struct rt6key fib6_src;
+	struct rt6key fib6_prefsrc;
+	u32 fib6_metric;
+	u8 fib6_protocol;
+	u8 fib6_type;
+	u8 offload;
+	u8 trap;
+	u8 offload_failed;
+	u8 should_flush: 1;
+	u8 dst_nocount: 1;
+	u8 dst_nopolicy: 1;
+	u8 fib6_destroying: 1;
+	u8 unused: 4;
+	struct callback_head rcu;
+	struct nexthop *nh;
+	struct fib6_nh fib6_nh[0];
+};
+
+struct rt6_info {
+	struct dst_entry dst;
+	struct fib6_info *from;
+	int sernum;
+	struct rt6key rt6i_dst;
+	struct rt6key rt6i_src;
+	struct in6_addr rt6i_gateway;
+	struct inet6_dev *rt6i_idev;
+	u32 rt6i_flags;
+	short unsigned int rt6i_nfheader_len;
+};
+
+struct rt6_statistics {
+	__u32 fib_nodes;
+	__u32 fib_route_nodes;
+	__u32 fib_rt_entries;
+	__u32 fib_rt_cache;
+	__u32 fib_discarded_routes;
+	atomic_t fib_rt_alloc;
+};
+
+struct fib6_node {
+	struct fib6_node *parent;
+	struct fib6_node *left;
+	struct fib6_node *right;
+	struct fib6_node *subtree;
+	struct fib6_info *leaf;
+	__u16 fn_bit;
+	__u16 fn_flags;
+	int fn_sernum;
+	struct fib6_info *rr_ptr;
+	struct callback_head rcu;
+};
+
+struct fib6_table {
+	struct hlist_node tb6_hlist;
+	u32 tb6_id;
+	spinlock_t tb6_lock;
+	struct fib6_node tb6_root;
+	struct inet_peer_base tb6_peers;
+	unsigned int flags;
+	unsigned int fib_seq;
+	struct hlist_head tb6_gc_hlist;
+};
+
+typedef union {
+	__be32 a4;
+	__be32 a6[4];
+	struct in6_addr in6;
+} xfrm_address_t;
+
+struct xfrm_id {
+	xfrm_address_t daddr;
+	__be32 spi;
+	__u8 proto;
+};
+
+struct xfrm_sec_ctx {
+	__u8 ctx_doi;
+	__u8 ctx_alg;
+	__u16 ctx_len;
+	__u32 ctx_sid;
+	char ctx_str[0];
+};
+
+struct xfrm_selector {
+	xfrm_address_t daddr;
+	xfrm_address_t saddr;
+	__be16 dport;
+	__be16 dport_mask;
+	__be16 sport;
+	__be16 sport_mask;
+	__u16 family;
+	__u8 prefixlen_d;
+	__u8 prefixlen_s;
+	__u8 proto;
+	int ifindex;
+	__kernel_uid32_t user;
+};
+
+struct xfrm_lifetime_cfg {
+	__u64 soft_byte_limit;
+	__u64 hard_byte_limit;
+	__u64 soft_packet_limit;
+	__u64 hard_packet_limit;
+	__u64 soft_add_expires_seconds;
+	__u64 hard_add_expires_seconds;
+	__u64 soft_use_expires_seconds;
+	__u64 hard_use_expires_seconds;
+};
+
+struct xfrm_lifetime_cur {
+	__u64 bytes;
+	__u64 packets;
+	__u64 add_time;
+	__u64 use_time;
+};
+
+struct xfrm_replay_state {
+	__u32 oseq;
+	__u32 seq;
+	__u32 bitmap;
+};
+
+struct xfrm_replay_state_esn {
+	unsigned int bmp_len;
+	__u32 oseq;
+	__u32 seq;
+	__u32 oseq_hi;
+	__u32 seq_hi;
+	__u32 replay_window;
+	__u32 bmp[0];
+};
+
+struct xfrm_algo {
+	char alg_name[64];
+	unsigned int alg_key_len;
+	char alg_key[0];
+};
+
+struct xfrm_algo_auth {
+	char alg_name[64];
+	unsigned int alg_key_len;
+	unsigned int alg_trunc_len;
+	char alg_key[0];
+};
+
+struct xfrm_algo_aead {
+	char alg_name[64];
+	unsigned int alg_key_len;
+	unsigned int alg_icv_len;
+	char alg_key[0];
+};
+
+struct xfrm_stats {
+	__u32 replay_window;
+	__u32 replay;
+	__u32 integrity_failed;
+};
+
+enum {
+	XFRM_POLICY_TYPE_MAIN = 0,
+	XFRM_POLICY_TYPE_SUB = 1,
+	XFRM_POLICY_TYPE_MAX = 2,
+	XFRM_POLICY_TYPE_ANY = 255,
+};
+
+enum {
+	XFRM_MSG_BASE = 16,
+	XFRM_MSG_NEWSA = 16,
+	XFRM_MSG_DELSA = 17,
+	XFRM_MSG_GETSA = 18,
+	XFRM_MSG_NEWPOLICY = 19,
+	XFRM_MSG_DELPOLICY = 20,
+	XFRM_MSG_GETPOLICY = 21,
+	XFRM_MSG_ALLOCSPI = 22,
+	XFRM_MSG_ACQUIRE = 23,
+	XFRM_MSG_EXPIRE = 24,
+	XFRM_MSG_UPDPOLICY = 25,
+	XFRM_MSG_UPDSA = 26,
+	XFRM_MSG_POLEXPIRE = 27,
+	XFRM_MSG_FLUSHSA = 28,
+	XFRM_MSG_FLUSHPOLICY = 29,
+	XFRM_MSG_NEWAE = 30,
+	XFRM_MSG_GETAE = 31,
+	XFRM_MSG_REPORT = 32,
+	XFRM_MSG_MIGRATE = 33,
+	XFRM_MSG_NEWSADINFO = 34,
+	XFRM_MSG_GETSADINFO = 35,
+	XFRM_MSG_NEWSPDINFO = 36,
+	XFRM_MSG_GETSPDINFO = 37,
+	XFRM_MSG_MAPPING = 38,
+	XFRM_MSG_SETDEFAULT = 39,
+	XFRM_MSG_GETDEFAULT = 40,
+	__XFRM_MSG_MAX = 41,
+};
+
+struct xfrm_encap_tmpl {
+	__u16 encap_type;
+	__be16 encap_sport;
+	__be16 encap_dport;
+	xfrm_address_t encap_oa;
+};
+
+enum xfrm_attr_type_t {
+	XFRMA_UNSPEC = 0,
+	XFRMA_ALG_AUTH = 1,
+	XFRMA_ALG_CRYPT = 2,
+	XFRMA_ALG_COMP = 3,
+	XFRMA_ENCAP = 4,
+	XFRMA_TMPL = 5,
+	XFRMA_SA = 6,
+	XFRMA_POLICY = 7,
+	XFRMA_SEC_CTX = 8,
+	XFRMA_LTIME_VAL = 9,
+	XFRMA_REPLAY_VAL = 10,
+	XFRMA_REPLAY_THRESH = 11,
+	XFRMA_ETIMER_THRESH = 12,
+	XFRMA_SRCADDR = 13,
+	XFRMA_COADDR = 14,
+	XFRMA_LASTUSED = 15,
+	XFRMA_POLICY_TYPE = 16,
+	XFRMA_MIGRATE = 17,
+	XFRMA_ALG_AEAD = 18,
+	XFRMA_KMADDRESS = 19,
+	XFRMA_ALG_AUTH_TRUNC = 20,
+	XFRMA_MARK = 21,
+	XFRMA_TFCPAD = 22,
+	XFRMA_REPLAY_ESN_VAL = 23,
+	XFRMA_SA_EXTRA_FLAGS = 24,
+	XFRMA_PROTO = 25,
+	XFRMA_ADDRESS_FILTER = 26,
+	XFRMA_PAD = 27,
+	XFRMA_OFFLOAD_DEV = 28,
+	XFRMA_SET_MARK = 29,
+	XFRMA_SET_MARK_MASK = 30,
+	XFRMA_IF_ID = 31,
+	XFRMA_MTIMER_THRESH = 32,
+	XFRMA_SA_DIR = 33,
+	XFRMA_NAT_KEEPALIVE_INTERVAL = 34,
+	__XFRMA_MAX = 35,
+};
+
+struct xfrm_mark {
+	__u32 v;
+	__u32 m;
+};
+
+struct xfrm_address_filter {
+	xfrm_address_t saddr;
+	xfrm_address_t daddr;
+	__u16 family;
+	__u8 splen;
+	__u8 dplen;
+};
+
+enum {
+	NETIF_F_SG_BIT = 0,
+	NETIF_F_IP_CSUM_BIT = 1,
+	__UNUSED_NETIF_F_1 = 2,
+	NETIF_F_HW_CSUM_BIT = 3,
+	NETIF_F_IPV6_CSUM_BIT = 4,
+	NETIF_F_HIGHDMA_BIT = 5,
+	NETIF_F_FRAGLIST_BIT = 6,
+	NETIF_F_HW_VLAN_CTAG_TX_BIT = 7,
+	NETIF_F_HW_VLAN_CTAG_RX_BIT = 8,
+	NETIF_F_HW_VLAN_CTAG_FILTER_BIT = 9,
+	NETIF_F_VLAN_CHALLENGED_BIT = 10,
+	NETIF_F_GSO_BIT = 11,
+	__UNUSED_NETIF_F_12 = 12,
+	__UNUSED_NETIF_F_13 = 13,
+	NETIF_F_GRO_BIT = 14,
+	NETIF_F_LRO_BIT = 15,
+	NETIF_F_GSO_SHIFT = 16,
+	NETIF_F_TSO_BIT = 16,
+	NETIF_F_GSO_ROBUST_BIT = 17,
+	NETIF_F_TSO_ECN_BIT = 18,
+	NETIF_F_TSO_MANGLEID_BIT = 19,
+	NETIF_F_TSO6_BIT = 20,
+	NETIF_F_FSO_BIT = 21,
+	NETIF_F_GSO_GRE_BIT = 22,
+	NETIF_F_GSO_GRE_CSUM_BIT = 23,
+	NETIF_F_GSO_IPXIP4_BIT = 24,
+	NETIF_F_GSO_IPXIP6_BIT = 25,
+	NETIF_F_GSO_UDP_TUNNEL_BIT = 26,
+	NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT = 27,
+	NETIF_F_GSO_PARTIAL_BIT = 28,
+	NETIF_F_GSO_TUNNEL_REMCSUM_BIT = 29,
+	NETIF_F_GSO_SCTP_BIT = 30,
+	NETIF_F_GSO_ESP_BIT = 31,
+	NETIF_F_GSO_UDP_BIT = 32,
+	NETIF_F_GSO_UDP_L4_BIT = 33,
+	NETIF_F_GSO_FRAGLIST_BIT = 34,
+	NETIF_F_GSO_LAST = 34,
+	NETIF_F_FCOE_CRC_BIT = 35,
+	NETIF_F_SCTP_CRC_BIT = 36,
+	__UNUSED_NETIF_F_37 = 37,
+	NETIF_F_NTUPLE_BIT = 38,
+	NETIF_F_RXHASH_BIT = 39,
+	NETIF_F_RXCSUM_BIT = 40,
+	NETIF_F_NOCACHE_COPY_BIT = 41,
+	NETIF_F_LOOPBACK_BIT = 42,
+	NETIF_F_RXFCS_BIT = 43,
+	NETIF_F_RXALL_BIT = 44,
+	NETIF_F_HW_VLAN_STAG_TX_BIT = 45,
+	NETIF_F_HW_VLAN_STAG_RX_BIT = 46,
+	NETIF_F_HW_VLAN_STAG_FILTER_BIT = 47,
+	NETIF_F_HW_L2FW_DOFFLOAD_BIT = 48,
+	NETIF_F_HW_TC_BIT = 49,
+	NETIF_F_HW_ESP_BIT = 50,
+	NETIF_F_HW_ESP_TX_CSUM_BIT = 51,
+	NETIF_F_RX_UDP_TUNNEL_PORT_BIT = 52,
+	NETIF_F_HW_TLS_TX_BIT = 53,
+	NETIF_F_HW_TLS_RX_BIT = 54,
+	NETIF_F_GRO_HW_BIT = 55,
+	NETIF_F_HW_TLS_RECORD_BIT = 56,
+	NETIF_F_GRO_FRAGLIST_BIT = 57,
+	NETIF_F_HW_MACSEC_BIT = 58,
+	NETIF_F_GRO_UDP_FWD_BIT = 59,
+	NETIF_F_HW_HSR_TAG_INS_BIT = 60,
+	NETIF_F_HW_HSR_TAG_RM_BIT = 61,
+	NETIF_F_HW_HSR_FWD_BIT = 62,
+	NETIF_F_HW_HSR_DUP_BIT = 63,
+	NETDEV_FEATURE_COUNT = 64,
+};
+
+struct nf_conntrack {
+	refcount_t use;
+};
+
+struct dmabuf_genpool_chunk_owner;
+
+struct net_iov {
+	long unsigned int __unused_padding;
+	long unsigned int pp_magic;
+	struct page_pool *pp;
+	struct dmabuf_genpool_chunk_owner *owner;
+	long unsigned int dma_addr;
+	atomic_long_t pp_ref_count;
+};
+
+struct skb_frag {
+	netmem_ref netmem;
+	unsigned int len;
+	unsigned int offset;
+};
+
+typedef struct skb_frag skb_frag_t;
+
+enum {
+	SKBTX_HW_TSTAMP = 1,
+	SKBTX_SW_TSTAMP = 2,
+	SKBTX_IN_PROGRESS = 4,
+	SKBTX_HW_TSTAMP_USE_CYCLES = 8,
+	SKBTX_WIFI_STATUS = 16,
+	SKBTX_HW_TSTAMP_NETDEV = 32,
+	SKBTX_SCHED_TSTAMP = 64,
+};
+
+enum {
+	SKBFL_ZEROCOPY_ENABLE = 1,
+	SKBFL_SHARED_FRAG = 2,
+	SKBFL_PURE_ZEROCOPY = 4,
+	SKBFL_DONT_ORPHAN = 8,
+	SKBFL_MANAGED_FRAG_REFS = 16,
+};
+
+struct mmpin {
+	struct user_struct *user;
+	unsigned int num_pg;
+};
+
+struct ubuf_info_msgzc {
+	struct ubuf_info ubuf;
+	union {
+		struct {
+			long unsigned int desc;
+			void *ctx;
+		};
+		struct {
+			u32 id;
+			u16 len;
+			u16 zerocopy: 1;
+			u32 bytelen;
+		};
+	};
+	struct mmpin mmp;
+};
+
+struct xsk_tx_metadata_compl {
+	__u64 *tx_timestamp;
+};
+
+struct skb_shared_info {
+	__u8 flags;
+	__u8 meta_len;
+	__u8 nr_frags;
+	__u8 tx_flags;
+	short unsigned int gso_size;
+	short unsigned int gso_segs;
+	struct sk_buff *frag_list;
+	long: 32;
+	union {
+		struct skb_shared_hwtstamps hwtstamps;
+		struct xsk_tx_metadata_compl xsk_meta;
+	};
+	unsigned int gso_type;
+	u32 tskey;
+	atomic_t dataref;
+	unsigned int xdp_frags_size;
+	void *destructor_arg;
+	skb_frag_t frags[17];
+};
+
+enum {
+	SKB_FCLONE_UNAVAILABLE = 0,
+	SKB_FCLONE_ORIG = 1,
+	SKB_FCLONE_CLONE = 2,
+};
+
+enum {
+	SKB_GSO_TCPV4 = 1,
+	SKB_GSO_DODGY = 2,
+	SKB_GSO_TCP_ECN = 4,
+	SKB_GSO_TCP_FIXEDID = 8,
+	SKB_GSO_TCPV6 = 16,
+	SKB_GSO_FCOE = 32,
+	SKB_GSO_GRE = 64,
+	SKB_GSO_GRE_CSUM = 128,
+	SKB_GSO_IPXIP4 = 256,
+	SKB_GSO_IPXIP6 = 512,
+	SKB_GSO_UDP_TUNNEL = 1024,
+	SKB_GSO_UDP_TUNNEL_CSUM = 2048,
+	SKB_GSO_PARTIAL = 4096,
+	SKB_GSO_TUNNEL_REMCSUM = 8192,
+	SKB_GSO_SCTP = 16384,
+	SKB_GSO_ESP = 32768,
+	SKB_GSO_UDP = 65536,
+	SKB_GSO_UDP_L4 = 131072,
+	SKB_GSO_FRAGLIST = 262144,
+};
+
+enum skb_tstamp_type {
+	SKB_CLOCK_REALTIME = 0,
+	SKB_CLOCK_MONOTONIC = 1,
+	SKB_CLOCK_TAI = 2,
+	__SKB_CLOCK_MAX = 2,
+};
+
+struct sk_buff_fclones {
+	struct sk_buff skb1;
+	struct sk_buff skb2;
+	refcount_t fclone_ref;
+	long: 32;
+};
+
+struct skb_seq_state {
+	__u32 lower_offset;
+	__u32 upper_offset;
+	__u32 frag_idx;
+	__u32 stepped_offset;
+	struct sk_buff *root_skb;
+	struct sk_buff *cur_skb;
+	__u8 *frag_data;
+	__u32 frag_off;
+};
+
+struct skb_checksum_ops {
+	__wsum (*update)(const void *, int, __wsum);
+	__wsum (*combine)(__wsum, __wsum, int, int);
+};
+
+enum sock_type {
+	SOCK_STREAM = 1,
+	SOCK_DGRAM = 2,
+	SOCK_RAW = 3,
+	SOCK_RDM = 4,
+	SOCK_SEQPACKET = 5,
+	SOCK_DCCP = 6,
+	SOCK_PACKET = 10,
+};
+
+struct netdev_name_node {
+	struct hlist_node hlist;
+	struct list_head list;
+	struct net_device *dev;
+	const char *name;
+	struct callback_head rcu;
+};
+
+struct offload_callbacks {
+	struct sk_buff * (*gso_segment)(struct sk_buff *, netdev_features_t);
+	struct sk_buff * (*gro_receive)(struct list_head *, struct sk_buff *);
+	int (*gro_complete)(struct sk_buff *, int);
+};
+
+struct packet_offload {
+	__be16 type;
+	u16 priority;
+	struct offload_callbacks callbacks;
+	struct list_head list;
+};
+
+struct sd_flow_limit;
+
+struct softnet_data {
+	struct list_head poll_list;
+	struct sk_buff_head process_queue;
+	local_lock_t process_queue_bh_lock;
+	unsigned int processed;
+	unsigned int time_squeeze;
+	struct softnet_data *rps_ipi_list;
+	unsigned int received_rps;
+	bool in_net_rx_action;
+	bool in_napi_threaded_poll;
+	struct sd_flow_limit *flow_limit;
+	struct Qdisc *output_queue;
+	struct Qdisc **output_queue_tailp;
+	struct sk_buff *completion_queue;
+	struct netdev_xmit xmit;
+	unsigned int input_queue_head;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	call_single_data_t csd;
+	struct softnet_data *rps_ipi_next;
+	unsigned int cpu;
+	unsigned int input_queue_tail;
+	struct sk_buff_head input_pkt_queue;
+	long: 32;
+	struct napi_struct backlog;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	atomic_t dropped;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	spinlock_t defer_lock;
+	int defer_count;
+	int defer_ipi_scheduled;
+	struct sk_buff *defer_list;
+	call_single_data_t defer_csd;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct sd_flow_limit {
+	u64 count;
+	unsigned int num_buckets;
+	unsigned int history_head;
+	u16 history[128];
+	u8 buckets[0];
+};
+
+enum {
+	TCA_UNSPEC = 0,
+	TCA_KIND = 1,
+	TCA_OPTIONS = 2,
+	TCA_STATS = 3,
+	TCA_XSTATS = 4,
+	TCA_RATE = 5,
+	TCA_FCNT = 6,
+	TCA_STATS2 = 7,
+	TCA_STAB = 8,
+	TCA_PAD = 9,
+	TCA_DUMP_INVISIBLE = 10,
+	TCA_CHAIN = 11,
+	TCA_HW_OFFLOAD = 12,
+	TCA_INGRESS_BLOCK = 13,
+	TCA_EGRESS_BLOCK = 14,
+	TCA_DUMP_FLAGS = 15,
+	TCA_EXT_WARN_MSG = 16,
+	__TCA_MAX = 17,
+};
+
+struct xfrm_state_walk {
+	struct list_head all;
+	u8 state;
+	u8 dying;
+	u8 proto;
+	u32 seq;
+	struct xfrm_address_filter *filter;
+};
+
+enum xfrm_replay_mode {
+	XFRM_REPLAY_MODE_LEGACY = 0,
+	XFRM_REPLAY_MODE_BMP = 1,
+	XFRM_REPLAY_MODE_ESN = 2,
+};
+
+struct xfrm_dev_offload {
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	struct net_device *real_dev;
+	long unsigned int offload_handle;
+	u8 dir: 2;
+	u8 type: 2;
+	u8 flags: 2;
+};
+
+struct xfrm_mode {
+	u8 encap;
+	u8 family;
+	u8 flags;
+};
+
+struct xfrm_type;
+
+struct xfrm_type_offload;
+
+struct xfrm_state {
+	possible_net_t xs_net;
+	union {
+		struct hlist_node gclist;
+		struct hlist_node bydst;
+	};
+	union {
+		struct hlist_node dev_gclist;
+		struct hlist_node bysrc;
+	};
+	struct hlist_node byspi;
+	struct hlist_node byseq;
+	refcount_t refcnt;
+	spinlock_t lock;
+	struct xfrm_id id;
+	struct xfrm_selector sel;
+	struct xfrm_mark mark;
+	u32 if_id;
+	u32 tfcpad;
+	u32 genid;
+	struct xfrm_state_walk km;
+	struct {
+		u32 reqid;
+		u8 mode;
+		u8 replay_window;
+		u8 aalgo;
+		u8 ealgo;
+		u8 calgo;
+		u8 flags;
+		u16 family;
+		xfrm_address_t saddr;
+		int header_len;
+		int trailer_len;
+		u32 extra_flags;
+		struct xfrm_mark smark;
+	} props;
+	long: 32;
+	struct xfrm_lifetime_cfg lft;
+	struct xfrm_algo_auth *aalg;
+	struct xfrm_algo *ealg;
+	struct xfrm_algo *calg;
+	struct xfrm_algo_aead *aead;
+	const char *geniv;
+	__be16 new_mapping_sport;
+	u32 new_mapping;
+	u32 mapping_maxage;
+	struct xfrm_encap_tmpl *encap;
+	struct sock *encap_sk;
+	u32 nat_keepalive_interval;
+	long: 32;
+	time64_t nat_keepalive_expiration;
+	xfrm_address_t *coaddr;
+	struct xfrm_state *tunnel;
+	atomic_t tunnel_users;
+	struct xfrm_replay_state replay;
+	struct xfrm_replay_state_esn *replay_esn;
+	struct xfrm_replay_state preplay;
+	struct xfrm_replay_state_esn *preplay_esn;
+	enum xfrm_replay_mode repl_mode;
+	u32 xflags;
+	u32 replay_maxage;
+	u32 replay_maxdiff;
+	struct timer_list rtimer;
+	struct xfrm_stats stats;
+	long: 32;
+	struct xfrm_lifetime_cur curlft;
+	struct hrtimer mtimer;
+	struct xfrm_dev_offload xso;
+	long int saved_tmo;
+	long: 32;
+	time64_t lastused;
+	struct page_frag xfrag;
+	const struct xfrm_type *type;
+	struct xfrm_mode inner_mode;
+	struct xfrm_mode inner_mode_iaf;
+	struct xfrm_mode outer_mode;
+	const struct xfrm_type_offload *type_offload;
+	struct xfrm_sec_ctx *security;
+	void *data;
+	u8 dir;
+};
+
+struct lwtunnel_state {
+	__u16 type;
+	__u16 flags;
+	__u16 headroom;
+	atomic_t refcnt;
+	int (*orig_output)(struct net *, struct sock *, struct sk_buff *);
+	int (*orig_input)(struct sk_buff *);
+	struct callback_head rcu;
+	__u8 data[0];
+};
+
+struct dst_metrics {
+	u32 metrics[17];
+	refcount_t refcnt;
+};
+
+enum {
+	SOF_TIMESTAMPING_TX_HARDWARE = 1,
+	SOF_TIMESTAMPING_TX_SOFTWARE = 2,
+	SOF_TIMESTAMPING_RX_HARDWARE = 4,
+	SOF_TIMESTAMPING_RX_SOFTWARE = 8,
+	SOF_TIMESTAMPING_SOFTWARE = 16,
+	SOF_TIMESTAMPING_SYS_HARDWARE = 32,
+	SOF_TIMESTAMPING_RAW_HARDWARE = 64,
+	SOF_TIMESTAMPING_OPT_ID = 128,
+	SOF_TIMESTAMPING_TX_SCHED = 256,
+	SOF_TIMESTAMPING_TX_ACK = 512,
+	SOF_TIMESTAMPING_OPT_CMSG = 1024,
+	SOF_TIMESTAMPING_OPT_TSONLY = 2048,
+	SOF_TIMESTAMPING_OPT_STATS = 4096,
+	SOF_TIMESTAMPING_OPT_PKTINFO = 8192,
+	SOF_TIMESTAMPING_OPT_TX_SWHW = 16384,
+	SOF_TIMESTAMPING_BIND_PHC = 32768,
+	SOF_TIMESTAMPING_OPT_ID_TCP = 65536,
+	SOF_TIMESTAMPING_OPT_RX_FILTER = 131072,
+	SOF_TIMESTAMPING_LAST = 131072,
+	SOF_TIMESTAMPING_MASK = 262143,
+};
+
+struct xfrm_policy_walk_entry {
+	struct list_head all;
+	u8 dead;
+};
+
+struct xfrm_policy_queue {
+	struct sk_buff_head hold_queue;
+	struct timer_list hold_timer;
+	long unsigned int timeout;
+};
+
+struct xfrm_tmpl {
+	struct xfrm_id id;
+	xfrm_address_t saddr;
+	short unsigned int encap_family;
+	u32 reqid;
+	u8 mode;
+	u8 share;
+	u8 optional;
+	u8 allalgs;
+	u32 aalgos;
+	u32 ealgos;
+	u32 calgos;
+};
+
+struct xfrm_policy {
+	possible_net_t xp_net;
+	struct hlist_node bydst;
+	struct hlist_node byidx;
+	rwlock_t lock;
+	refcount_t refcnt;
+	u32 pos;
+	struct timer_list timer;
+	atomic_t genid;
+	u32 priority;
+	u32 index;
+	u32 if_id;
+	struct xfrm_mark mark;
+	struct xfrm_selector selector;
+	long: 32;
+	struct xfrm_lifetime_cfg lft;
+	struct xfrm_lifetime_cur curlft;
+	struct xfrm_policy_walk_entry walk;
+	struct xfrm_policy_queue polq;
+	bool bydst_reinsert;
+	u8 type;
+	u8 action;
+	u8 flags;
+	u8 xfrm_nr;
+	u16 family;
+	struct xfrm_sec_ctx *security;
+	struct xfrm_tmpl xfrm_vec[6];
+	struct callback_head rcu;
+	struct xfrm_dev_offload xdo;
+};
+
+struct sock_reuseport {
+	struct callback_head rcu;
+	u16 max_socks;
+	u16 num_socks;
+	u16 num_closed_socks;
+	u16 incoming_cpu;
+	unsigned int synq_overflow_ts;
+	unsigned int reuseport_id;
+	unsigned int bind_inany: 1;
+	unsigned int has_conns: 1;
+	struct bpf_prog *prog;
+	struct sock *socks[0];
+};
+
+enum sock_flags {
+	SOCK_DEAD = 0,
+	SOCK_DONE = 1,
+	SOCK_URGINLINE = 2,
+	SOCK_KEEPOPEN = 3,
+	SOCK_LINGER = 4,
+	SOCK_DESTROY = 5,
+	SOCK_BROADCAST = 6,
+	SOCK_TIMESTAMP = 7,
+	SOCK_ZAPPED = 8,
+	SOCK_USE_WRITE_QUEUE = 9,
+	SOCK_DBG = 10,
+	SOCK_RCVTSTAMP = 11,
+	SOCK_RCVTSTAMPNS = 12,
+	SOCK_LOCALROUTE = 13,
+	SOCK_MEMALLOC = 14,
+	SOCK_TIMESTAMPING_RX_SOFTWARE = 15,
+	SOCK_FASYNC = 16,
+	SOCK_RXQ_OVFL = 17,
+	SOCK_ZEROCOPY = 18,
+	SOCK_WIFI_STATUS = 19,
+	SOCK_NOFCS = 20,
+	SOCK_FILTER_LOCKED = 21,
+	SOCK_SELECT_ERR_QUEUE = 22,
+	SOCK_RCU_FREE = 23,
+	SOCK_TXTIME = 24,
+	SOCK_XDP = 25,
+	SOCK_TSTAMP_NEW = 26,
+	SOCK_RCVMARK = 27,
+};
+
+struct tcphdr {
+	__be16 source;
+	__be16 dest;
+	__be32 seq;
+	__be32 ack_seq;
+	__u16 res1: 4;
+	__u16 doff: 4;
+	__u16 fin: 1;
+	__u16 syn: 1;
+	__u16 rst: 1;
+	__u16 psh: 1;
+	__u16 ack: 1;
+	__u16 urg: 1;
+	__u16 ece: 1;
+	__u16 cwr: 1;
+	__be16 window;
+	__sum16 check;
+	__be16 urg_ptr;
+};
+
+struct udphdr {
+	__be16 source;
+	__be16 dest;
+	__be16 len;
+	__sum16 check;
+};
+
+struct vlan_hdr {
+	__be16 h_vlan_TCI;
+	__be16 h_vlan_encapsulated_proto;
+};
+
+struct vlan_ethhdr {
+	union {
+		struct {
+			unsigned char h_dest[6];
+			unsigned char h_source[6];
+		};
+		struct {
+			unsigned char h_dest[6];
+			unsigned char h_source[6];
+		} addrs;
+	};
+	__be16 h_vlan_proto;
+	__be16 h_vlan_TCI;
+	__be16 h_vlan_encapsulated_proto;
+};
+
+struct qdisc_walker {
+	int stop;
+	int skip;
+	int count;
+	int (*fn)(struct Qdisc *, long unsigned int, struct qdisc_walker *);
+};
+
+struct partial_page {
+	unsigned int offset;
+	unsigned int len;
+	long unsigned int private;
+};
+
+struct splice_pipe_desc {
+	struct page **pages;
+	struct partial_page *partial;
+	int nr_pages;
+	unsigned int nr_pages_max;
+	const struct pipe_buf_operations *ops;
+	void (*spd_release)(struct splice_pipe_desc *, unsigned int);
+};
+
+struct iphdr {
+	__u8 ihl: 4;
+	__u8 version: 4;
+	__u8 tos;
+	__be16 tot_len;
+	__be16 id;
+	__be16 frag_off;
+	__u8 ttl;
+	__u8 protocol;
+	__sum16 check;
+	union {
+		struct {
+			__be32 saddr;
+			__be32 daddr;
+		};
+		struct {
+			__be32 saddr;
+			__be32 daddr;
+		} addrs;
+	};
+};
+
+struct ip_auth_hdr {
+	__u8 nexthdr;
+	__u8 hdrlen;
+	__be16 reserved;
+	__be32 spi;
+	__be32 seq_no;
+	__u8 auth_data[0];
+};
+
+struct ipv6_opt_hdr {
+	__u8 nexthdr;
+	__u8 hdrlen;
+};
+
+struct ipv6hdr {
+	__u8 priority: 4;
+	__u8 version: 4;
+	__u8 flow_lbl[3];
+	__be16 payload_len;
+	__u8 nexthdr;
+	__u8 hop_limit;
+	union {
+		struct {
+			struct in6_addr saddr;
+			struct in6_addr daddr;
+		};
+		struct {
+			struct in6_addr saddr;
+			struct in6_addr daddr;
+		} addrs;
+	};
+};
+
+struct inet6_skb_parm {
+	int iif;
+	__be16 ra;
+	__u16 dst0;
+	__u16 srcrt;
+	__u16 dst1;
+	__u16 lastopt;
+	__u16 nhoff;
+	__u16 flags;
+	__u16 frag_max_size;
+	__u16 srhoff;
+};
+
+struct frag_hdr {
+	__u8 nexthdr;
+	__u8 reserved;
+	__be16 frag_off;
+	__be32 identification;
+};
+
+struct fib_nh_exception {
+	struct fib_nh_exception *fnhe_next;
+	int fnhe_genid;
+	__be32 fnhe_daddr;
+	u32 fnhe_pmtu;
+	bool fnhe_mtu_locked;
+	__be32 fnhe_gw;
+	long unsigned int fnhe_expires;
+	struct rtable *fnhe_rth_input;
+	struct rtable *fnhe_rth_output;
+	long unsigned int fnhe_stamp;
+	struct callback_head rcu;
+};
+
+struct rtable {
+	struct dst_entry dst;
+	int rt_genid;
+	unsigned int rt_flags;
+	__u16 rt_type;
+	__u8 rt_is_input;
+	__u8 rt_uses_gateway;
+	int rt_iif;
+	u8 rt_gw_family;
+	union {
+		__be32 rt_gw4;
+		struct in6_addr rt_gw6;
+	};
+	u32 rt_mtu_locked: 1;
+	u32 rt_pmtu: 31;
+};
+
+struct fnhe_hash_bucket {
+	struct fib_nh_exception *chain;
+};
+
+enum {
+	__ND_OPT_PREFIX_INFO_END = 0,
+	ND_OPT_SOURCE_LL_ADDR = 1,
+	ND_OPT_TARGET_LL_ADDR = 2,
+	ND_OPT_PREFIX_INFO = 3,
+	ND_OPT_REDIRECT_HDR = 4,
+	ND_OPT_MTU = 5,
+	ND_OPT_NONCE = 14,
+	__ND_OPT_ARRAY_MAX = 15,
+	ND_OPT_ROUTE_INFO = 24,
+	ND_OPT_RDNSS = 25,
+	ND_OPT_DNSSL = 31,
+	ND_OPT_6CO = 34,
+	ND_OPT_CAPTIVE_PORTAL = 37,
+	ND_OPT_PREF64 = 38,
+	__ND_OPT_MAX = 39,
+};
+
+struct nd_opt_hdr {
+	__u8 nd_opt_type;
+	__u8 nd_opt_len;
+};
+
+struct ndisc_options {
+	struct nd_opt_hdr *nd_opt_array[15];
+	struct nd_opt_hdr *nd_useropts;
+	struct nd_opt_hdr *nd_useropts_end;
+	struct nd_opt_hdr *nd_802154_opt_array[3];
+};
+
+struct prefix_info {
+	__u8 type;
+	__u8 length;
+	__u8 prefix_len;
+	union {
+		__u8 flags;
+		struct {
+			__u8 reserved: 4;
+			__u8 preferpd: 1;
+			__u8 routeraddr: 1;
+			__u8 autoconf: 1;
+			__u8 onlink: 1;
+		};
+	};
+	__be32 valid;
+	__be32 prefered;
+	__be32 reserved2;
+	struct in6_addr prefix;
+};
+
+struct inet_skb_parm {
+	int iif;
+	struct ip_options opt;
+	u16 flags;
+	u16 frag_max_size;
+};
+
+struct sock_ee_data_rfc4884 {
+	__u16 len;
+	__u8 flags;
+	__u8 reserved;
+};
+
+struct sock_extended_err {
+	__u32 ee_errno;
+	__u8 ee_origin;
+	__u8 ee_type;
+	__u8 ee_code;
+	__u8 ee_pad;
+	__u32 ee_info;
+	union {
+		__u32 ee_data;
+		struct sock_ee_data_rfc4884 ee_rfc4884;
+	};
+};
+
+enum {
+	SCM_TSTAMP_SND = 0,
+	SCM_TSTAMP_SCHED = 1,
+	SCM_TSTAMP_ACK = 2,
+};
+
+struct sock_exterr_skb {
+	union {
+		struct inet_skb_parm h4;
+		struct inet6_skb_parm h6;
+	} header;
+	struct sock_extended_err ee;
+	u16 addr_offset;
+	__be16 port;
+	u8 opt_stats: 1;
+	u8 unused: 7;
+};
+
+typedef size_t (*iov_step_f)(void *, size_t, size_t, void *, void *);
+
+typedef size_t (*iov_ustep_f)(void *, size_t, size_t, void *, void *);
+
+struct net_protocol {
+	int (*handler)(struct sk_buff *);
+	int (*err_handler)(struct sk_buff *, u32);
+	unsigned int no_policy: 1;
+	unsigned int icmp_strict_tag_validation: 1;
+	u32 secret;
+};
+
+struct inet6_protocol {
+	int (*handler)(struct sk_buff *);
+	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
+	unsigned int flags;
+	u32 secret;
+};
+
+struct net_offload {
+	struct offload_callbacks callbacks;
+	unsigned int flags;
+	u32 secret;
+};
+
+struct skb_gso_cb {
+	union {
+		int mac_offset;
+		int data_offset;
+	};
+	int encap_level;
+	__wsum csum;
+	__u16 csum_start;
+};
+
+struct rps_sock_flow_table;
+
+struct net_hotdata {
+	struct packet_offload ip_packet_offload;
+	struct net_offload tcpv4_offload;
+	struct net_protocol tcp_protocol;
+	struct net_offload udpv4_offload;
+	struct net_protocol udp_protocol;
+	struct packet_offload ipv6_packet_offload;
+	struct net_offload tcpv6_offload;
+	struct inet6_protocol tcpv6_protocol;
+	struct inet6_protocol udpv6_protocol;
+	struct net_offload udpv6_offload;
+	struct list_head offload_base;
+	struct list_head ptype_all;
+	struct kmem_cache *skbuff_cache;
+	struct kmem_cache *skbuff_fclone_cache;
+	struct kmem_cache *skb_small_head_cache;
+	struct rps_sock_flow_table *rps_sock_flow_table;
+	u32 rps_cpu_mask;
+	int gro_normal_batch;
+	int netdev_budget;
+	int netdev_budget_usecs;
+	int tstamp_prequeue;
+	int max_backlog;
+	int dev_tx_weight;
+	int dev_rx_weight;
+	int sysctl_max_skb_frags;
+	int sysctl_skb_defer_max;
+	int sysctl_mem_pcpu_rsv;
+};
+
+struct rt6_exception_bucket {
+	struct hlist_head chain;
+	int depth;
+};
+
+struct xfrm_type {
+	struct module *owner;
+	u8 proto;
+	u8 flags;
+	int (*init_state)(struct xfrm_state *, struct netlink_ext_ack *);
+	void (*destructor)(struct xfrm_state *);
+	int (*input)(struct xfrm_state *, struct sk_buff *);
+	int (*output)(struct xfrm_state *, struct sk_buff *);
+	int (*reject)(struct xfrm_state *, struct sk_buff *, const struct flowi *);
+};
+
+struct xfrm_type_offload {
+	struct module *owner;
+	u8 proto;
+	void (*encap)(struct xfrm_state *, struct sk_buff *);
+	int (*input_tail)(struct xfrm_state *, struct sk_buff *);
+	int (*xmit)(struct xfrm_state *, struct sk_buff *, netdev_features_t);
+};
+
+struct xfrm_offload {
+	struct {
+		__u32 low;
+		__u32 hi;
+	} seq;
+	__u32 flags;
+	__u32 status;
+	__u32 orig_mac_len;
+	__u8 proto;
+	__u8 inner_ipproto;
+};
+
+struct sec_path {
+	int len;
+	int olen;
+	int verified_cnt;
+	struct xfrm_state *xvec[6];
+	struct xfrm_offload ovec[1];
+};
+
+struct mpls_shim_hdr {
+	__be32 label_stack_entry;
+};
+
+enum skb_drop_reason_subsys {
+	SKB_DROP_REASON_SUBSYS_CORE = 0,
+	SKB_DROP_REASON_SUBSYS_MAC80211_UNUSABLE = 1,
+	SKB_DROP_REASON_SUBSYS_MAC80211_MONITOR = 2,
+	SKB_DROP_REASON_SUBSYS_OPENVSWITCH = 3,
+	SKB_DROP_REASON_SUBSYS_NUM = 4,
+};
+
+struct drop_reason_list {
+	const char * const *reasons;
+	size_t n_reasons;
+};
+
+struct inet_ehash_bucket {
+	struct hlist_nulls_head chain;
+};
+
+struct inet_bind_hashbucket {
+	spinlock_t lock;
+	struct hlist_head chain;
+};
+
+struct inet_listen_hashbucket {
+	spinlock_t lock;
+	struct hlist_nulls_head nulls_head;
+};
+
+struct ack_sample {
+	u32 pkts_acked;
+	s32 rtt_us;
+	u32 in_flight;
+};
+
+struct rate_sample {
+	u64 prior_mstamp;
+	u32 prior_lost;
+	u32 prior_delivered;
+	u32 prior_delivered_ce;
+	u32 tx_in_flight;
+	s32 lost;
+	s32 delivered;
+	s32 delivered_ce;
+	long int interval_us;
+	u32 snd_interval_us;
+	u32 rcv_interval_us;
+	long int rtt_us;
+	int losses;
+	u32 acked_sacked;
+	u32 prior_in_flight;
+	u32 last_end_seq;
+	bool is_app_limited;
+	bool is_retrans;
+	bool is_acking_tlp_retrans_seq;
+	bool is_ack_delayed;
+	bool is_ece;
+	long: 32;
+};
+
+struct page_frag_1k {
+	void *va;
+	u16 offset;
+	bool pfmemalloc;
+};
+
+struct napi_alloc_cache {
+	local_lock_t bh_lock;
+	struct page_frag_cache page;
+	struct page_frag_1k page_small;
+	unsigned int skb_count;
+	void *skb_cache[64];
+};
+
+struct skb_free_array {
+	unsigned int skb_count;
+	void *skb_array[16];
+};
+
+typedef int (*sendmsg_func)(struct sock *, struct msghdr *);
+
+struct gnet_stats_rate_est64 {
+	__u64 bps;
+	__u64 pps;
+};
+
+struct gnet_estimator {
+	signed char interval;
+	unsigned char ewma_log;
+};
+
+struct net_rate_estimator {
+	struct gnet_stats_basic_sync *bstats;
+	spinlock_t *stats_lock;
+	bool running;
+	struct gnet_stats_basic_sync *cpu_bstats;
+	u8 ewma_log;
+	u8 intvl_log;
+	seqcount_t seq;
+	u64 last_packets;
+	u64 last_bytes;
+	u64 avpps;
+	u64 avbps;
+	long unsigned int next_jiffies;
+	struct timer_list timer;
+	struct callback_head rcu;
+};
+
+struct pernet_operations {
+	struct list_head list;
+	int (*init)(struct net *);
+	void (*pre_exit)(struct net *);
+	void (*exit)(struct net *);
+	void (*exit_batch)(struct list_head *);
+	void (*exit_batch_rtnl)(struct list_head *, struct list_head *);
+	unsigned int * const id;
+	const size_t size;
+};
+
+struct rps_sock_flow_table {
+	u32 mask;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	u32 ents[0];
+};
+
+struct xa_limit {
+	u32 max;
+	u32 min;
+};
+
+enum tca_id {
+	TCA_ID_UNSPEC = 0,
+	TCA_ID_POLICE = 1,
+	TCA_ID_GACT = 5,
+	TCA_ID_IPT = 6,
+	TCA_ID_PEDIT = 7,
+	TCA_ID_MIRRED = 8,
+	TCA_ID_NAT = 9,
+	TCA_ID_XT = 10,
+	TCA_ID_SKBEDIT = 11,
+	TCA_ID_VLAN = 12,
+	TCA_ID_BPF = 13,
+	TCA_ID_CONNMARK = 14,
+	TCA_ID_SKBMOD = 15,
+	TCA_ID_CSUM = 16,
+	TCA_ID_TUNNEL_KEY = 17,
+	TCA_ID_SIMP = 22,
+	TCA_ID_IFE = 25,
+	TCA_ID_SAMPLE = 26,
+	TCA_ID_CTINFO = 27,
+	TCA_ID_MPLS = 28,
+	TCA_ID_CT = 29,
+	TCA_ID_GATE = 30,
+	__TCA_ID_MAX = 255,
+};
+
+struct tcf_t {
+	__u64 install;
+	__u64 lastuse;
+	__u64 expires;
+	__u64 firstuse;
+};
+
+struct udp_hslot;
+
+struct udp_table {
+	struct udp_hslot *hash;
+	struct udp_hslot *hash2;
+	unsigned int mask;
+	unsigned int log;
+};
+
+struct ipv4_devconf {
+	void *sysctl;
+	int data[33];
+	long unsigned int state[2];
+};
+
+struct in_addr {
+	__be32 s_addr;
+};
+
+enum nf_dev_hooks {
+	NF_NETDEV_INGRESS = 0,
+	NF_NETDEV_EGRESS = 1,
+	NF_NETDEV_NUMHOOKS = 2,
+};
+
+struct nf_hook_state;
+
+typedef unsigned int nf_hookfn(void *, struct sk_buff *, const struct nf_hook_state *);
+
+struct nf_hook_entry {
+	nf_hookfn *hook;
+	void *priv;
+};
+
+struct nf_hook_entries {
+	u16 num_hook_entries;
+	struct nf_hook_entry hooks[0];
+};
+
+struct net_generic {
+	union {
+		struct {
+			unsigned int len;
+			struct callback_head rcu;
+		} s;
+		struct {
+			struct {} __empty_ptr;
+			void *ptr[0];
+		};
+	};
+};
+
+enum tcx_action_base {
+	TCX_NEXT = -1,
+	TCX_PASS = 0,
+	TCX_DROP = 2,
+	TCX_REDIRECT = 7,
+};
+
+enum net_device_flags {
+	IFF_UP = 1,
+	IFF_BROADCAST = 2,
+	IFF_DEBUG = 4,
+	IFF_LOOPBACK = 8,
+	IFF_POINTOPOINT = 16,
+	IFF_NOTRAILERS = 32,
+	IFF_RUNNING = 64,
+	IFF_NOARP = 128,
+	IFF_PROMISC = 256,
+	IFF_ALLMULTI = 512,
+	IFF_MASTER = 1024,
+	IFF_SLAVE = 2048,
+	IFF_MULTICAST = 4096,
+	IFF_PORTSEL = 8192,
+	IFF_AUTOMEDIA = 16384,
+	IFF_DYNAMIC = 32768,
+	IFF_LOWER_UP = 65536,
+	IFF_DORMANT = 131072,
+	IFF_ECHO = 262144,
+};
+
+enum {
+	IF_OPER_UNKNOWN = 0,
+	IF_OPER_NOTPRESENT = 1,
+	IF_OPER_DOWN = 2,
+	IF_OPER_LOWERLAYERDOWN = 3,
+	IF_OPER_TESTING = 4,
+	IF_OPER_DORMANT = 5,
+	IF_OPER_UP = 6,
+};
+
+enum macsec_validation_type {
+	MACSEC_VALIDATE_DISABLED = 0,
+	MACSEC_VALIDATE_CHECK = 1,
+	MACSEC_VALIDATE_STRICT = 2,
+	__MACSEC_VALIDATE_END = 3,
+	MACSEC_VALIDATE_MAX = 2,
+};
+
+enum macsec_offload {
+	MACSEC_OFFLOAD_OFF = 0,
+	MACSEC_OFFLOAD_PHY = 1,
+	MACSEC_OFFLOAD_MAC = 2,
+	__MACSEC_OFFLOAD_END = 3,
+	MACSEC_OFFLOAD_MAX = 2,
+};
+
+struct ifbond {
+	__s32 bond_mode;
+	__s32 num_slaves;
+	__s32 miimon;
+};
+
+typedef struct ifbond ifbond;
+
+struct ifslave {
+	__s32 slave_id;
+	char slave_name[16];
+	__s8 link;
+	__s8 state;
+	__u32 link_failure_count;
+};
+
+typedef struct ifslave ifslave;
+
+enum netdev_queue_type {
+	NETDEV_QUEUE_TYPE_RX = 0,
+	NETDEV_QUEUE_TYPE_TX = 1,
+};
+
+enum {
+	NAPIF_STATE_SCHED = 1,
+	NAPIF_STATE_MISSED = 2,
+	NAPIF_STATE_DISABLE = 4,
+	NAPIF_STATE_NPSVC = 8,
+	NAPIF_STATE_LISTED = 16,
+	NAPIF_STATE_NO_BUSY_POLL = 32,
+	NAPIF_STATE_IN_BUSY_POLL = 64,
+	NAPIF_STATE_PREFER_BUSY_POLL = 128,
+	NAPIF_STATE_THREADED = 256,
+	NAPIF_STATE_SCHED_THREADED = 512,
+};
+
+enum netdev_queue_state_t {
+	__QUEUE_STATE_DRV_XOFF = 0,
+	__QUEUE_STATE_STACK_XOFF = 1,
+	__QUEUE_STATE_FROZEN = 2,
+};
+
+struct net_device_path_stack {
+	int num_paths;
+	struct net_device_path path[5];
+};
+
+struct bpf_xdp_link {
+	struct bpf_link link;
+	struct net_device *dev;
+	int flags;
+};
+
+struct netdev_net_notifier {
+	struct list_head list;
+	struct notifier_block *nb;
+};
+
+struct netpoll;
+
+struct netpoll_info {
+	refcount_t refcnt;
+	struct semaphore dev_lock;
+	struct sk_buff_head txq;
+	struct delayed_work tx_work;
+	struct netpoll *netpoll;
+	struct callback_head rcu;
+};
+
+struct ip_tunnel_parm_kern {
+	char name[16];
+	long unsigned int i_flags[1];
+	long unsigned int o_flags[1];
+	__be32 i_key;
+	__be32 o_key;
+	int link;
+	struct iphdr iph;
+};
+
+enum netdev_priv_flags {
+	IFF_802_1Q_VLAN = 1,
+	IFF_EBRIDGE = 2,
+	IFF_BONDING = 4,
+	IFF_ISATAP = 8,
+	IFF_WAN_HDLC = 16,
+	IFF_XMIT_DST_RELEASE = 32,
+	IFF_DONT_BRIDGE = 64,
+	IFF_DISABLE_NETPOLL = 128,
+	IFF_MACVLAN_PORT = 256,
+	IFF_BRIDGE_PORT = 512,
+	IFF_OVS_DATAPATH = 1024,
+	IFF_TX_SKB_SHARING = 2048,
+	IFF_UNICAST_FLT = 4096,
+	IFF_TEAM_PORT = 8192,
+	IFF_SUPP_NOFCS = 16384,
+	IFF_LIVE_ADDR_CHANGE = 32768,
+	IFF_MACVLAN = 65536,
+	IFF_XMIT_DST_RELEASE_PERM = 131072,
+	IFF_L3MDEV_MASTER = 262144,
+	IFF_NO_QUEUE = 524288,
+	IFF_OPENVSWITCH = 1048576,
+	IFF_L3MDEV_SLAVE = 2097152,
+	IFF_TEAM = 4194304,
+	IFF_RXFH_CONFIGURED = 8388608,
+	IFF_PHONY_HEADROOM = 16777216,
+	IFF_MACSEC = 33554432,
+	IFF_NO_RX_HANDLER = 67108864,
+	IFF_FAILOVER = 134217728,
+	IFF_FAILOVER_SLAVE = 268435456,
+	IFF_L3MDEV_RX_HANDLER = 536870912,
+	IFF_NO_ADDRCONF = 1073741824,
+	IFF_TX_SKB_NO_LINEAR = 2147483648,
+};
+
+enum netdev_reg_state {
+	NETREG_UNINITIALIZED = 0,
+	NETREG_REGISTERED = 1,
+	NETREG_UNREGISTERING = 2,
+	NETREG_UNREGISTERED = 3,
+	NETREG_RELEASED = 4,
+	NETREG_DUMMY = 5,
+};
+
+struct pp_memory_provider_params {
+	void *mp_priv;
+};
+
+struct rps_map;
+
+struct rps_dev_flow_table;
+
+struct netdev_rx_queue {
+	struct xdp_rxq_info xdp_rxq;
+	struct rps_map *rps_map;
+	struct rps_dev_flow_table *rps_flow_table;
+	struct kobject kobj;
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	struct xsk_buff_pool *pool;
+	struct napi_struct *napi;
+	struct pp_memory_provider_params mp_params;
+	long: 32;
+};
+
+struct in_ifaddr;
+
+struct ip_mc_list;
+
+struct in_device {
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	refcount_t refcnt;
+	int dead;
+	struct in_ifaddr *ifa_list;
+	struct ip_mc_list *mc_list;
+	struct ip_mc_list **mc_hash;
+	int mc_count;
+	spinlock_t mc_tomb_lock;
+	struct ip_mc_list *mc_tomb;
+	long unsigned int mr_v1_seen;
+	long unsigned int mr_v2_seen;
+	long unsigned int mr_maxdelay;
+	long unsigned int mr_qi;
+	long unsigned int mr_qri;
+	unsigned char mr_qrv;
+	unsigned char mr_gq_running;
+	u32 mr_ifc_count;
+	struct timer_list mr_gq_timer;
+	struct timer_list mr_ifc_timer;
+	struct neigh_parms *arp_parms;
+	struct ipv4_devconf cnf;
+	struct callback_head callback_head;
+};
+
+struct packet_type {
+	__be16 type;
+	bool ignore_outgoing;
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
+	void (*list_func)(struct list_head *, struct packet_type *, struct net_device *);
+	bool (*id_match)(struct packet_type *, struct sock *);
+	struct net *af_packet_net;
+	void *af_packet_priv;
+	struct list_head list;
+};
+
+enum netdev_cmd {
+	NETDEV_UP = 1,
+	NETDEV_DOWN = 2,
+	NETDEV_REBOOT = 3,
+	NETDEV_CHANGE = 4,
+	NETDEV_REGISTER = 5,
+	NETDEV_UNREGISTER = 6,
+	NETDEV_CHANGEMTU = 7,
+	NETDEV_CHANGEADDR = 8,
+	NETDEV_PRE_CHANGEADDR = 9,
+	NETDEV_GOING_DOWN = 10,
+	NETDEV_CHANGENAME = 11,
+	NETDEV_FEAT_CHANGE = 12,
+	NETDEV_BONDING_FAILOVER = 13,
+	NETDEV_PRE_UP = 14,
+	NETDEV_PRE_TYPE_CHANGE = 15,
+	NETDEV_POST_TYPE_CHANGE = 16,
+	NETDEV_POST_INIT = 17,
+	NETDEV_PRE_UNINIT = 18,
+	NETDEV_RELEASE = 19,
+	NETDEV_NOTIFY_PEERS = 20,
+	NETDEV_JOIN = 21,
+	NETDEV_CHANGEUPPER = 22,
+	NETDEV_RESEND_IGMP = 23,
+	NETDEV_PRECHANGEMTU = 24,
+	NETDEV_CHANGEINFODATA = 25,
+	NETDEV_BONDING_INFO = 26,
+	NETDEV_PRECHANGEUPPER = 27,
+	NETDEV_CHANGELOWERSTATE = 28,
+	NETDEV_UDP_TUNNEL_PUSH_INFO = 29,
+	NETDEV_UDP_TUNNEL_DROP_INFO = 30,
+	NETDEV_CHANGE_TX_QUEUE_LEN = 31,
+	NETDEV_CVLAN_FILTER_PUSH_INFO = 32,
+	NETDEV_CVLAN_FILTER_DROP_INFO = 33,
+	NETDEV_SVLAN_FILTER_PUSH_INFO = 34,
+	NETDEV_SVLAN_FILTER_DROP_INFO = 35,
+	NETDEV_OFFLOAD_XSTATS_ENABLE = 36,
+	NETDEV_OFFLOAD_XSTATS_DISABLE = 37,
+	NETDEV_OFFLOAD_XSTATS_REPORT_USED = 38,
+	NETDEV_OFFLOAD_XSTATS_REPORT_DELTA = 39,
+	NETDEV_XDP_FEAT_CHANGE = 40,
+};
+
+struct netdev_notifier_info_ext {
+	struct netdev_notifier_info info;
+	union {
+		u32 mtu;
+	} ext;
+};
+
+struct netdev_notifier_change_info {
+	struct netdev_notifier_info info;
+	unsigned int flags_changed;
+};
+
+struct netdev_notifier_changelowerstate_info {
+	struct netdev_notifier_info info;
+	void *lower_state_info;
+};
+
+struct netdev_notifier_pre_changeaddr_info {
+	struct netdev_notifier_info info;
+	const unsigned char *dev_addr;
+};
+
+enum netdev_offload_xstats_type {
+	NETDEV_OFFLOAD_XSTATS_TYPE_L3 = 1,
+};
+
+struct netdev_notifier_offload_xstats_rd {
+	struct rtnl_hw_stats64 stats;
+	bool used;
+	long: 32;
+};
+
+struct netdev_notifier_offload_xstats_ru {
+	bool used;
+};
+
+struct netdev_notifier_offload_xstats_info {
+	struct netdev_notifier_info info;
+	enum netdev_offload_xstats_type type;
+	union {
+		struct netdev_notifier_offload_xstats_rd *report_delta;
+		struct netdev_notifier_offload_xstats_ru *report_used;
+	};
+};
+
+enum {
+	NESTED_SYNC_IMM_BIT = 0,
+	NESTED_SYNC_TODO_BIT = 1,
+};
+
+struct netdev_nested_priv {
+	unsigned char flags;
+	void *data;
+};
+
+struct netdev_bonding_info {
+	ifslave slave;
+	ifbond master;
+};
+
+struct netdev_notifier_bonding_info {
+	struct netdev_notifier_info info;
+	struct netdev_bonding_info bonding_info;
+};
+
+enum {
+	RTM_BASE = 16,
+	RTM_NEWLINK = 16,
+	RTM_DELLINK = 17,
+	RTM_GETLINK = 18,
+	RTM_SETLINK = 19,
+	RTM_NEWADDR = 20,
+	RTM_DELADDR = 21,
+	RTM_GETADDR = 22,
+	RTM_NEWROUTE = 24,
+	RTM_DELROUTE = 25,
+	RTM_GETROUTE = 26,
+	RTM_NEWNEIGH = 28,
+	RTM_DELNEIGH = 29,
+	RTM_GETNEIGH = 30,
+	RTM_NEWRULE = 32,
+	RTM_DELRULE = 33,
+	RTM_GETRULE = 34,
+	RTM_NEWQDISC = 36,
+	RTM_DELQDISC = 37,
+	RTM_GETQDISC = 38,
+	RTM_NEWTCLASS = 40,
+	RTM_DELTCLASS = 41,
+	RTM_GETTCLASS = 42,
+	RTM_NEWTFILTER = 44,
+	RTM_DELTFILTER = 45,
+	RTM_GETTFILTER = 46,
+	RTM_NEWACTION = 48,
+	RTM_DELACTION = 49,
+	RTM_GETACTION = 50,
+	RTM_NEWPREFIX = 52,
+	RTM_GETMULTICAST = 58,
+	RTM_GETANYCAST = 62,
+	RTM_NEWNEIGHTBL = 64,
+	RTM_GETNEIGHTBL = 66,
+	RTM_SETNEIGHTBL = 67,
+	RTM_NEWNDUSEROPT = 68,
+	RTM_NEWADDRLABEL = 72,
+	RTM_DELADDRLABEL = 73,
+	RTM_GETADDRLABEL = 74,
+	RTM_GETDCB = 78,
+	RTM_SETDCB = 79,
+	RTM_NEWNETCONF = 80,
+	RTM_DELNETCONF = 81,
+	RTM_GETNETCONF = 82,
+	RTM_NEWMDB = 84,
+	RTM_DELMDB = 85,
+	RTM_GETMDB = 86,
+	RTM_NEWNSID = 88,
+	RTM_DELNSID = 89,
+	RTM_GETNSID = 90,
+	RTM_NEWSTATS = 92,
+	RTM_GETSTATS = 94,
+	RTM_SETSTATS = 95,
+	RTM_NEWCACHEREPORT = 96,
+	RTM_NEWCHAIN = 100,
+	RTM_DELCHAIN = 101,
+	RTM_GETCHAIN = 102,
+	RTM_NEWNEXTHOP = 104,
+	RTM_DELNEXTHOP = 105,
+	RTM_GETNEXTHOP = 106,
+	RTM_NEWLINKPROP = 108,
+	RTM_DELLINKPROP = 109,
+	RTM_GETLINKPROP = 110,
+	RTM_NEWVLAN = 112,
+	RTM_DELVLAN = 113,
+	RTM_GETVLAN = 114,
+	RTM_NEWNEXTHOPBUCKET = 116,
+	RTM_DELNEXTHOPBUCKET = 117,
+	RTM_GETNEXTHOPBUCKET = 118,
+	RTM_NEWTUNNEL = 120,
+	RTM_DELTUNNEL = 121,
+	RTM_GETTUNNEL = 122,
+	__RTM_MAX = 123,
+};
+
+union inet_addr {
+	__u32 all[4];
+	__be32 ip;
+	__be32 ip6[4];
+	struct in_addr in;
+	struct in6_addr in6;
+};
+
+struct netpoll {
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	char dev_name[16];
+	const char *name;
+	union inet_addr local_ip;
+	union inet_addr remote_ip;
+	bool ipv6;
+	u16 local_port;
+	u16 remote_port;
+	u8 remote_mac[6];
+};
+
+struct ip_tunnel_key {
+	__be64 tun_id;
+	union {
+		struct {
+			__be32 src;
+			__be32 dst;
+		} ipv4;
+		struct {
+			struct in6_addr src;
+			struct in6_addr dst;
+		} ipv6;
+	} u;
+	long unsigned int tun_flags[1];
+	__be32 label;
+	u32 nhid;
+	u8 tos;
+	u8 ttl;
+	__be16 tp_src;
+	__be16 tp_dst;
+	__u8 flow_flags;
+	long: 32;
+};
+
+struct ip_tunnel_encap {
+	u16 type;
+	u16 flags;
+	__be16 sport;
+	__be16 dport;
+};
+
+struct dst_cache_pcpu;
+
+struct dst_cache {
+	struct dst_cache_pcpu *cache;
+	long unsigned int reset_ts;
+};
+
+struct ip_tunnel_info {
+	struct ip_tunnel_key key;
+	struct ip_tunnel_encap encap;
+	struct dst_cache dst_cache;
+	u8 options_len;
+	u8 mode;
+	long: 32;
+};
+
+enum qdisc_state_t {
+	__QDISC_STATE_SCHED = 0,
+	__QDISC_STATE_DEACTIVATED = 1,
+	__QDISC_STATE_MISSED = 2,
+	__QDISC_STATE_DRAINING = 3,
+};
+
+enum qdisc_state2_t {
+	__QDISC_STATE2_RUNNING = 0,
+};
+
+struct tcf_walker {
+	int stop;
+	int skip;
+	int count;
+	bool nonempty;
+	long unsigned int cookie;
+	int (*fn)(struct tcf_proto *, void *, struct tcf_walker *);
+};
+
+struct tc_action;
+
+struct tcf_exts_miss_cookie_node;
+
+struct tcf_exts {
+	__u32 type;
+	int nr_actions;
+	struct tc_action **actions;
+	struct net *net;
+	netns_tracker ns_tracker;
+	struct tcf_exts_miss_cookie_node *miss_cookie_node;
+	int action;
+	int police;
+};
+
+struct tc_skb_cb {
+	struct qdisc_skb_cb qdisc_cb;
+	u32 drop_reason;
+	u16 zone;
+	u16 mru;
+	u8 post_ct: 1;
+	u8 post_ct_snat: 1;
+	u8 post_ct_dnat: 1;
+};
+
+struct mini_Qdisc {
+	struct tcf_proto *filter_list;
+	struct tcf_block *block;
+	struct gnet_stats_basic_sync *cpu_bstats;
+	struct gnet_stats_queue *cpu_qstats;
+	long unsigned int rcu_state;
+};
+
+enum xdp_buff_flags {
+	XDP_FLAGS_HAS_FRAGS = 1,
+	XDP_FLAGS_FRAGS_PF_MEMALLOC = 2,
+};
+
+enum {
+	TCPF_ESTABLISHED = 2,
+	TCPF_SYN_SENT = 4,
+	TCPF_SYN_RECV = 8,
+	TCPF_FIN_WAIT1 = 16,
+	TCPF_FIN_WAIT2 = 32,
+	TCPF_TIME_WAIT = 64,
+	TCPF_CLOSE = 128,
+	TCPF_CLOSE_WAIT = 256,
+	TCPF_LAST_ACK = 512,
+	TCPF_LISTEN = 1024,
+	TCPF_CLOSING = 2048,
+	TCPF_NEW_SYN_RECV = 4096,
+	TCPF_BOUND_INACTIVE = 8192,
+};
+
+enum {
+	IPV4_DEVCONF_FORWARDING = 1,
+	IPV4_DEVCONF_MC_FORWARDING = 2,
+	IPV4_DEVCONF_PROXY_ARP = 3,
+	IPV4_DEVCONF_ACCEPT_REDIRECTS = 4,
+	IPV4_DEVCONF_SECURE_REDIRECTS = 5,
+	IPV4_DEVCONF_SEND_REDIRECTS = 6,
+	IPV4_DEVCONF_SHARED_MEDIA = 7,
+	IPV4_DEVCONF_RP_FILTER = 8,
+	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE = 9,
+	IPV4_DEVCONF_BOOTP_RELAY = 10,
+	IPV4_DEVCONF_LOG_MARTIANS = 11,
+	IPV4_DEVCONF_TAG = 12,
+	IPV4_DEVCONF_ARPFILTER = 13,
+	IPV4_DEVCONF_MEDIUM_ID = 14,
+	IPV4_DEVCONF_NOXFRM = 15,
+	IPV4_DEVCONF_NOPOLICY = 16,
+	IPV4_DEVCONF_FORCE_IGMP_VERSION = 17,
+	IPV4_DEVCONF_ARP_ANNOUNCE = 18,
+	IPV4_DEVCONF_ARP_IGNORE = 19,
+	IPV4_DEVCONF_PROMOTE_SECONDARIES = 20,
+	IPV4_DEVCONF_ARP_ACCEPT = 21,
+	IPV4_DEVCONF_ARP_NOTIFY = 22,
+	IPV4_DEVCONF_ACCEPT_LOCAL = 23,
+	IPV4_DEVCONF_SRC_VMARK = 24,
+	IPV4_DEVCONF_PROXY_ARP_PVLAN = 25,
+	IPV4_DEVCONF_ROUTE_LOCALNET = 26,
+	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL = 27,
+	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL = 28,
+	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 29,
+	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 30,
+	IPV4_DEVCONF_DROP_GRATUITOUS_ARP = 31,
+	IPV4_DEVCONF_BC_FORWARDING = 32,
+	IPV4_DEVCONF_ARP_EVICT_NOCARRIER = 33,
+	__IPV4_DEVCONF_MAX = 34,
+};
+
+struct fib_info;
+
+struct fib_nh {
+	struct fib_nh_common nh_common;
+	struct hlist_node nh_hash;
+	struct fib_info *nh_parent;
+	__u32 nh_tclassid;
+	__be32 nh_saddr;
+	int nh_saddr_genid;
+};
+
+struct fib_info {
+	struct hlist_node fib_hash;
+	struct hlist_node fib_lhash;
+	struct list_head nh_list;
+	struct net *fib_net;
+	refcount_t fib_treeref;
+	refcount_t fib_clntref;
+	unsigned int fib_flags;
+	unsigned char fib_dead;
+	unsigned char fib_protocol;
+	unsigned char fib_scope;
+	unsigned char fib_type;
+	__be32 fib_prefsrc;
+	u32 fib_tb_id;
+	u32 fib_priority;
+	struct dst_metrics *fib_metrics;
+	int fib_nhs;
+	bool fib_nh_is_v6;
+	bool nh_updated;
+	bool pfsrc_removed;
+	struct nexthop *nh;
+	struct callback_head rcu;
+	struct fib_nh fib_nh[0];
+};
+
+struct nh_info;
+
+struct nh_group;
+
+struct nexthop {
+	struct rb_node rb_node;
+	struct list_head fi_list;
+	struct list_head f6i_list;
+	struct list_head fdb_list;
+	struct list_head grp_list;
+	struct net *net;
+	u32 id;
+	u8 protocol;
+	u8 nh_flags;
+	bool is_group;
+	refcount_t refcnt;
+	struct callback_head rcu;
+	union {
+		struct nh_info *nh_info;
+		struct nh_group *nh_grp;
+	};
+};
+
+enum {
+	IP_TUNNEL_CSUM_BIT = 0,
+	IP_TUNNEL_ROUTING_BIT = 1,
+	IP_TUNNEL_KEY_BIT = 2,
+	IP_TUNNEL_SEQ_BIT = 3,
+	IP_TUNNEL_STRICT_BIT = 4,
+	IP_TUNNEL_REC_BIT = 5,
+	IP_TUNNEL_VERSION_BIT = 6,
+	IP_TUNNEL_NO_KEY_BIT = 7,
+	IP_TUNNEL_DONT_FRAGMENT_BIT = 8,
+	IP_TUNNEL_OAM_BIT = 9,
+	IP_TUNNEL_CRIT_OPT_BIT = 10,
+	IP_TUNNEL_GENEVE_OPT_BIT = 11,
+	IP_TUNNEL_VXLAN_OPT_BIT = 12,
+	IP_TUNNEL_NOCACHE_BIT = 13,
+	IP_TUNNEL_ERSPAN_OPT_BIT = 14,
+	IP_TUNNEL_GTP_OPT_BIT = 15,
+	IP_TUNNEL_VTI_BIT = 16,
+	IP_TUNNEL_SIT_ISATAP_BIT = 16,
+	IP_TUNNEL_PFCP_OPT_BIT = 17,
+	__IP_TUNNEL_FLAG_NUM = 18,
+};
+
+struct nh_info {
+	struct hlist_node dev_hash;
+	struct nexthop *nh_parent;
+	u8 family;
+	bool reject_nh;
+	bool fdb_nh;
+	union {
+		struct fib_nh_common fib_nhc;
+		struct fib_nh fib_nh;
+		struct fib6_nh fib6_nh;
+	};
+};
+
+struct nh_grp_entry;
+
+struct nh_res_bucket {
+	struct nh_grp_entry *nh_entry;
+	atomic_long_t used_time;
+	long unsigned int migrated_time;
+	bool occupied;
+	u8 nh_flags;
+};
+
+struct nh_grp_entry_stats;
+
+struct nh_grp_entry {
+	struct nexthop *nh;
+	struct nh_grp_entry_stats *stats;
+	u16 weight;
+	union {
+		struct {
+			atomic_t upper_bound;
+		} hthr;
+		struct {
+			struct list_head uw_nh_entry;
+			u16 count_buckets;
+			u16 wants_buckets;
+		} res;
+	};
+	struct list_head nh_list;
+	struct nexthop *nh_parent;
+	long: 32;
+	u64 packets_hw;
+};
+
+struct nh_res_table {
+	struct net *net;
+	u32 nhg_id;
+	struct delayed_work upkeep_dw;
+	struct list_head uw_nh_entries;
+	long unsigned int unbalanced_since;
+	u32 idle_timer;
+	u32 unbalanced_timer;
+	u16 num_nh_buckets;
+	struct nh_res_bucket nh_buckets[0];
+};
+
+struct nh_grp_entry_stats {
+	u64_stats_t packets;
+	struct u64_stats_sync syncp;
+	long: 32;
+};
+
+struct nh_group {
+	struct nh_group *spare;
+	u16 num_nh;
+	bool is_multipath;
+	bool hash_threshold;
+	bool resilient;
+	bool fdb_nh;
+	bool has_v4;
+	bool hw_stats;
+	struct nh_res_table *res_table;
+	struct nh_grp_entry nh_entries[0];
+};
+
+typedef u64 sci_t;
+
+typedef u32 ssci_t;
+
+union salt {
+	struct {
+		u32 ssci;
+		u64 pn;
+	};
+	u8 bytes[12];
+};
+
+typedef union salt salt_t;
+
+union pn {
+	struct {
+		u32 lower;
+		u32 upper;
+	};
+	u64 full64;
+};
+
+typedef union pn pn_t;
+
+struct macsec_key {
+	u8 id[16];
+	struct crypto_aead *tfm;
+	salt_t salt;
+};
+
+struct macsec_rx_sc_stats {
+	__u64 InOctetsValidated;
+	__u64 InOctetsDecrypted;
+	__u64 InPktsUnchecked;
+	__u64 InPktsDelayed;
+	__u64 InPktsOK;
+	__u64 InPktsInvalid;
+	__u64 InPktsLate;
+	__u64 InPktsNotValid;
+	__u64 InPktsNotUsingSA;
+	__u64 InPktsUnusedSA;
+};
+
+struct macsec_rx_sa_stats {
+	__u32 InPktsOK;
+	__u32 InPktsInvalid;
+	__u32 InPktsNotValid;
+	__u32 InPktsNotUsingSA;
+	__u32 InPktsUnusedSA;
+};
+
+struct macsec_tx_sa_stats {
+	__u32 OutPktsProtected;
+	__u32 OutPktsEncrypted;
+};
+
+struct macsec_tx_sc_stats {
+	__u64 OutPktsProtected;
+	__u64 OutPktsEncrypted;
+	__u64 OutOctetsProtected;
+	__u64 OutOctetsEncrypted;
+};
+
+struct macsec_dev_stats {
+	__u64 OutPktsUntagged;
+	__u64 InPktsUntagged;
+	__u64 OutPktsTooLong;
+	__u64 InPktsNoTag;
+	__u64 InPktsBadTag;
+	__u64 InPktsUnknownSCI;
+	__u64 InPktsNoSCI;
+	__u64 InPktsOverrun;
+};
+
+struct macsec_rx_sc;
+
+struct macsec_rx_sa {
+	struct macsec_key key;
+	ssci_t ssci;
+	spinlock_t lock;
+	union {
+		pn_t next_pn_halves;
+		u64 next_pn;
+	};
+	refcount_t refcnt;
+	bool active;
+	struct macsec_rx_sa_stats *stats;
+	struct macsec_rx_sc *sc;
+	struct callback_head rcu;
+};
+
+struct pcpu_rx_sc_stats;
+
+struct macsec_rx_sc {
+	struct macsec_rx_sc *next;
+	long: 32;
+	sci_t sci;
+	bool active;
+	struct macsec_rx_sa *sa[4];
+	struct pcpu_rx_sc_stats *stats;
+	refcount_t refcnt;
+	struct callback_head callback_head;
+	long: 32;
+};
+
+struct pcpu_rx_sc_stats {
+	struct macsec_rx_sc_stats stats;
+	struct u64_stats_sync syncp;
+	long: 32;
+};
+
+struct pcpu_tx_sc_stats {
+	struct macsec_tx_sc_stats stats;
+	struct u64_stats_sync syncp;
+	long: 32;
+};
+
+struct macsec_tx_sa {
+	struct macsec_key key;
+	ssci_t ssci;
+	spinlock_t lock;
+	union {
+		pn_t next_pn_halves;
+		u64 next_pn;
+	};
+	refcount_t refcnt;
+	bool active;
+	struct macsec_tx_sa_stats *stats;
+	struct callback_head rcu;
+	long: 32;
+};
+
+struct metadata_dst;
+
+struct macsec_tx_sc {
+	bool active;
+	u8 encoding_sa;
+	bool encrypt;
+	bool send_sci;
+	bool end_station;
+	bool scb;
+	struct macsec_tx_sa *sa[4];
+	struct pcpu_tx_sc_stats *stats;
+	struct metadata_dst *md_dst;
+};
+
+enum metadata_type {
+	METADATA_IP_TUNNEL = 0,
+	METADATA_HW_PORT_MUX = 1,
+	METADATA_MACSEC = 2,
+	METADATA_XFRM = 3,
+};
+
+struct hw_port_info {
+	struct net_device *lower_dev;
+	u32 port_id;
+};
+
+struct macsec_info {
+	sci_t sci;
+};
+
+struct xfrm_md_info {
+	u32 if_id;
+	int link;
+	struct dst_entry *dst_orig;
+};
+
+struct metadata_dst {
+	struct dst_entry dst;
+	enum metadata_type type;
+	long: 32;
+	union {
+		struct ip_tunnel_info tun_info;
+		struct hw_port_info port_info;
+		struct macsec_info macsec_info;
+		struct xfrm_md_info xfrm_info;
+	} u;
+};
+
+struct macsec_secy {
+	struct net_device *netdev;
+	unsigned int n_rx_sc;
+	sci_t sci;
+	u16 key_len;
+	u16 icv_len;
+	enum macsec_validation_type validate_frames;
+	bool xpn;
+	bool operational;
+	bool protect_frames;
+	bool replay_protect;
+	u32 replay_window;
+	struct macsec_tx_sc tx_sc;
+	struct macsec_rx_sc *rx_sc;
+	long: 32;
+};
+
+struct macsec_context {
+	union {
+		struct net_device *netdev;
+		struct phy_device *phydev;
+	};
+	enum macsec_offload offload;
+	struct macsec_secy *secy;
+	struct macsec_rx_sc *rx_sc;
+	struct {
+		bool update_pn;
+		unsigned char assoc_num;
+		u8 key[128];
+		union {
+			struct macsec_rx_sa *rx_sa;
+			struct macsec_tx_sa *tx_sa;
+		};
+	} sa;
+	union {
+		struct macsec_tx_sc_stats *tx_sc_stats;
+		struct macsec_tx_sa_stats *tx_sa_stats;
+		struct macsec_rx_sc_stats *rx_sc_stats;
+		struct macsec_rx_sa_stats *rx_sa_stats;
+		struct macsec_dev_stats *dev_stats;
+	} stats;
+};
+
+struct udp_hslot {
+	struct hlist_head head;
+	int count;
+	spinlock_t lock;
+	long: 32;
+};
+
+struct tcf_idrinfo {
+	struct mutex lock;
+	struct idr action_idr;
+	struct net *net;
+};
+
+struct tc_action_ops;
+
+struct tc_cookie;
+
+struct tc_action {
+	const struct tc_action_ops *ops;
+	__u32 type;
+	struct tcf_idrinfo *idrinfo;
+	u32 tcfa_index;
+	refcount_t tcfa_refcnt;
+	atomic_t tcfa_bindcnt;
+	int tcfa_action;
+	long: 32;
+	struct tcf_t tcfa_tm;
+	struct gnet_stats_basic_sync tcfa_bstats;
+	struct gnet_stats_basic_sync tcfa_bstats_hw;
+	struct gnet_stats_queue tcfa_qstats;
+	struct net_rate_estimator *tcfa_rate_est;
+	spinlock_t tcfa_lock;
+	struct gnet_stats_basic_sync *cpu_bstats;
+	struct gnet_stats_basic_sync *cpu_bstats_hw;
+	struct gnet_stats_queue *cpu_qstats;
+	struct tc_cookie *user_cookie;
+	struct tcf_chain *goto_chain;
+	u32 tcfa_flags;
+	u8 hw_stats;
+	u8 used_hw_stats;
+	bool used_hw_stats_valid;
+	u32 in_hw_count;
+	long: 32;
+};
+
+typedef void (*tc_action_priv_destructor)(void *);
+
+struct tc_action_ops {
+	struct list_head head;
+	char kind[16];
+	enum tca_id id;
+	unsigned int net_id;
+	size_t size;
+	struct module *owner;
+	int (*act)(struct sk_buff *, const struct tc_action *, struct tcf_result *);
+	int (*dump)(struct sk_buff *, struct tc_action *, int, int);
+	void (*cleanup)(struct tc_action *);
+	int (*lookup)(struct net *, struct tc_action **, u32);
+	int (*init)(struct net *, struct nlattr *, struct nlattr *, struct tc_action **, struct tcf_proto *, u32, struct netlink_ext_ack *);
+	int (*walk)(struct net *, struct sk_buff *, struct netlink_callback *, int, const struct tc_action_ops *, struct netlink_ext_ack *);
+	void (*stats_update)(struct tc_action *, u64, u64, u64, u64, bool);
+	size_t (*get_fill_size)(const struct tc_action *);
+	struct net_device * (*get_dev)(const struct tc_action *, tc_action_priv_destructor *);
+	struct psample_group * (*get_psample_group)(const struct tc_action *, tc_action_priv_destructor *);
+	int (*offload_act_setup)(struct tc_action *, void *, u32 *, bool, struct netlink_ext_ack *);
+};
+
+struct tc_cookie {
+	u8 *data;
+	u32 len;
+	struct callback_head rcu;
+};
+
+struct tcx_entry {
+	struct mini_Qdisc *miniq;
+	long: 32;
+	struct bpf_mprog_bundle bundle;
+	u32 miniq_active;
+	struct callback_head rcu;
+	long: 32;
+};
+
+struct in_ifaddr {
+	struct hlist_node hash;
+	struct in_ifaddr *ifa_next;
+	struct in_device *ifa_dev;
+	struct callback_head callback_head;
+	__be32 ifa_local;
+	__be32 ifa_address;
+	__be32 ifa_mask;
+	__u32 ifa_rt_priority;
+	__be32 ifa_broadcast;
+	unsigned char ifa_scope;
+	unsigned char ifa_prefixlen;
+	unsigned char ifa_proto;
+	__u32 ifa_flags;
+	char ifa_label[16];
+	__u32 ifa_valid_lft;
+	__u32 ifa_preferred_lft;
+	long unsigned int ifa_cstamp;
+	long unsigned int ifa_tstamp;
+};
+
+struct nf_hook_state {
+	u8 hook;
+	u8 pf;
+	struct net_device *in;
+	struct net_device *out;
+	struct sock *sk;
+	struct net *net;
+	int (*okfn)(struct net *, struct sock *, struct sk_buff *);
+};
+
+enum sctp_msg_flags {
+	MSG_NOTIFICATION = 32768,
+};
+
+struct udp_tunnel_info {
+	short unsigned int type;
+	sa_family_t sa_family;
+	__be16 port;
+	u8 hw_priv;
+};
+
+struct udp_tunnel_nic_shared {
+	struct udp_tunnel_nic *udp_tunnel_nic_info;
+	struct list_head devices;
+};
+
+struct page_pool_params {
+	union {
+		struct {
+			unsigned int order;
+			unsigned int pool_size;
+			int nid;
+			struct device *dev;
+			struct napi_struct *napi;
+			enum dma_data_direction dma_dir;
+			unsigned int max_len;
+			unsigned int offset;
+		};
+		struct page_pool_params_fast fast;
+	};
+	union {
+		struct {
+			struct net_device *netdev;
+			unsigned int queue_idx;
+			unsigned int flags;
+			void (*init_callback)(netmem_ref, void *);
+			void *init_arg;
+		};
+		struct page_pool_params_slow slow;
+	};
+};
+
+struct rps_map {
+	unsigned int len;
+	struct callback_head rcu;
+	u16 cpus[0];
+};
+
+struct rps_dev_flow {
+	u16 cpu;
+	u16 filter;
+	unsigned int last_qtail;
+};
+
+struct rps_dev_flow_table {
+	unsigned int mask;
+	struct callback_head rcu;
+	struct rps_dev_flow flows[0];
+};
+
+typedef int (*bpf_op_t)(struct net_device *, struct netdev_bpf *);
+
+struct dev_kfree_skb_cb {
+	enum skb_drop_reason reason;
+};
+
+enum {
+	NAPI_F_PREFER_BUSY_POLL = 1,
+	NAPI_F_END_ON_RESCHED = 2,
+};
+
+struct netdev_adjacent {
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	bool master;
+	bool ignore;
+	u16 ref_nr;
+	void *private;
+	struct list_head list;
+	struct callback_head rcu;
+};
+
+struct scm_creds {
+	u32 pid;
+	kuid_t uid;
+	kgid_t gid;
+};
+
+struct netlink_skb_parms {
+	struct scm_creds creds;
+	__u32 portid;
+	__u32 dst_group;
+	__u32 flags;
+	struct sock *sk;
+	bool nsid_is_set;
+	int nsid;
+};
+
+struct netlink_kernel_cfg {
+	unsigned int groups;
+	unsigned int flags;
+	void (*input)(struct sk_buff *);
+	int (*bind)(struct net *, int);
+	void (*unbind)(struct net *, int);
+	void (*release)(struct sock *, long unsigned int *);
+};
+
+typedef int (*netlink_filter_fn)(struct sock *, struct sk_buff *, void *);
+
+struct pcpu_gen_cookie {
+	local_t nesting;
+	long: 32;
+	u64 last;
+};
+
+struct gen_cookie {
+	struct pcpu_gen_cookie *local;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	atomic64_t forward_last;
+	atomic64_t reverse_last;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+enum {
+	INET_DIAG_REQ_NONE = 0,
+	INET_DIAG_REQ_BYTECODE = 1,
+	INET_DIAG_REQ_SK_BPF_STORAGES = 2,
+	INET_DIAG_REQ_PROTOCOL = 3,
+	__INET_DIAG_REQ_MAX = 4,
+};
+
+struct sock_diag_req {
+	__u8 sdiag_family;
+	__u8 sdiag_protocol;
+};
+
+enum {
+	SK_MEMINFO_RMEM_ALLOC = 0,
+	SK_MEMINFO_RCVBUF = 1,
+	SK_MEMINFO_WMEM_ALLOC = 2,
+	SK_MEMINFO_SNDBUF = 3,
+	SK_MEMINFO_FWD_ALLOC = 4,
+	SK_MEMINFO_WMEM_QUEUED = 5,
+	SK_MEMINFO_OPTMEM = 6,
+	SK_MEMINFO_BACKLOG = 7,
+	SK_MEMINFO_DROPS = 8,
+	SK_MEMINFO_VARS = 9,
+};
+
+enum sknetlink_groups {
+	SKNLGRP_NONE = 0,
+	SKNLGRP_INET_TCP_DESTROY = 1,
+	SKNLGRP_INET_UDP_DESTROY = 2,
+	SKNLGRP_INET6_TCP_DESTROY = 3,
+	SKNLGRP_INET6_UDP_DESTROY = 4,
+	__SKNLGRP_MAX = 5,
+};
+
+struct sock_diag_handler {
+	struct module *owner;
+	__u8 family;
+	int (*dump)(struct sk_buff *, struct nlmsghdr *);
+	int (*get_info)(struct sk_buff *, struct sock *);
+	int (*destroy)(struct sk_buff *, struct nlmsghdr *);
+};
+
+struct sock_diag_inet_compat {
+	struct module *owner;
+	int (*fn)(struct sk_buff *, struct nlmsghdr *);
+};
+
+struct broadcast_sk {
+	struct sock *sk;
+	struct work_struct work;
+};
+
+struct flow_dissector_key_control {
+	u16 thoff;
+	u16 addr_type;
+	u32 flags;
+};
+
+struct flow_dissector_key_basic {
+	__be16 n_proto;
+	u8 ip_proto;
+	u8 padding;
+};
+
+struct flow_dissector_key_vlan {
+	union {
+		struct {
+			u16 vlan_id: 12;
+			u16 vlan_dei: 1;
+			u16 vlan_priority: 3;
+		};
+		__be16 vlan_tci;
+	};
+	__be16 vlan_tpid;
+	__be16 vlan_eth_type;
+	u16 padding;
+};
+
+struct flow_dissector_mpls_lse {
+	u32 mpls_ttl: 8;
+	u32 mpls_bos: 1;
+	u32 mpls_tc: 3;
+	u32 mpls_label: 20;
+};
+
+struct flow_dissector_key_mpls {
+	struct flow_dissector_mpls_lse ls[7];
+	u8 used_lses;
+};
+
+struct flow_dissector_key_enc_opts {
+	u8 data[255];
+	u8 len;
+	u32 dst_opt_type;
+};
+
+struct flow_dissector_key_keyid {
+	__be32 keyid;
+};
+
+struct flow_dissector_key_ipv4_addrs {
+	__be32 src;
+	__be32 dst;
+};
+
+struct flow_dissector_key_ipv6_addrs {
+	struct in6_addr src;
+	struct in6_addr dst;
+};
+
+struct flow_dissector_key_arp {
+	__u32 sip;
+	__u32 tip;
+	__u8 op;
+	unsigned char sha[6];
+	unsigned char tha[6];
+};
+
+struct flow_dissector_key_ports {
+	union {
+		__be32 ports;
+		struct {
+			__be16 src;
+			__be16 dst;
+		};
+	};
+};
+
+struct flow_dissector_key_ports_range {
+	union {
+		struct flow_dissector_key_ports tp;
+		struct {
+			struct flow_dissector_key_ports tp_min;
+			struct flow_dissector_key_ports tp_max;
+		};
+	};
+};
+
+struct flow_dissector_key_icmp {
+	struct {
+		u8 type;
+		u8 code;
+	};
+	u16 id;
+};
+
+struct flow_dissector_key_eth_addrs {
+	unsigned char dst[6];
+	unsigned char src[6];
+};
+
+struct flow_dissector_key_tcp {
+	__be16 flags;
+};
+
+struct flow_dissector_key_ip {
+	__u8 tos;
+	__u8 ttl;
+};
+
+struct flow_dissector_key_meta {
+	int ingress_ifindex;
+	u16 ingress_iftype;
+	u8 l2_miss;
+};
+
+struct flow_dissector_key_ct {
+	u16 ct_state;
+	u16 ct_zone;
+	u32 ct_mark;
+	u32 ct_labels[4];
+};
+
+struct flow_dissector_key_pppoe {
+	__be16 session_id;
+	__be16 ppp_proto;
+	__be16 type;
+};
+
+struct flow_dissector_key_l2tpv3 {
+	__be32 session_id;
+};
+
+struct flow_dissector_key_ipsec {
+	__be32 spi;
+};
+
+struct flow_match_meta {
+	struct flow_dissector_key_meta *key;
+	struct flow_dissector_key_meta *mask;
+};
+
+struct flow_match_basic {
+	struct flow_dissector_key_basic *key;
+	struct flow_dissector_key_basic *mask;
+};
+
+struct flow_match_control {
+	struct flow_dissector_key_control *key;
+	struct flow_dissector_key_control *mask;
+};
+
+struct flow_match_eth_addrs {
+	struct flow_dissector_key_eth_addrs *key;
+	struct flow_dissector_key_eth_addrs *mask;
+};
+
+struct flow_match_vlan {
+	struct flow_dissector_key_vlan *key;
+	struct flow_dissector_key_vlan *mask;
+};
+
+struct flow_match_arp {
+	struct flow_dissector_key_arp *key;
+	struct flow_dissector_key_arp *mask;
+};
+
+struct flow_match_ipv4_addrs {
+	struct flow_dissector_key_ipv4_addrs *key;
+	struct flow_dissector_key_ipv4_addrs *mask;
+};
+
+struct flow_match_ipv6_addrs {
+	struct flow_dissector_key_ipv6_addrs *key;
+	struct flow_dissector_key_ipv6_addrs *mask;
+};
+
+struct flow_match_ip {
+	struct flow_dissector_key_ip *key;
+	struct flow_dissector_key_ip *mask;
+};
+
+struct flow_match_ports {
+	struct flow_dissector_key_ports *key;
+	struct flow_dissector_key_ports *mask;
+};
+
+struct flow_match_ports_range {
+	struct flow_dissector_key_ports_range *key;
+	struct flow_dissector_key_ports_range *mask;
+};
+
+struct flow_match_icmp {
+	struct flow_dissector_key_icmp *key;
+	struct flow_dissector_key_icmp *mask;
+};
+
+struct flow_match_tcp {
+	struct flow_dissector_key_tcp *key;
+	struct flow_dissector_key_tcp *mask;
+};
+
+struct flow_match_ipsec {
+	struct flow_dissector_key_ipsec *key;
+	struct flow_dissector_key_ipsec *mask;
+};
+
+struct flow_match_mpls {
+	struct flow_dissector_key_mpls *key;
+	struct flow_dissector_key_mpls *mask;
+};
+
+struct flow_match_enc_keyid {
+	struct flow_dissector_key_keyid *key;
+	struct flow_dissector_key_keyid *mask;
+};
+
+struct flow_match_enc_opts {
+	struct flow_dissector_key_enc_opts *key;
+	struct flow_dissector_key_enc_opts *mask;
+};
+
+struct flow_match_ct {
+	struct flow_dissector_key_ct *key;
+	struct flow_dissector_key_ct *mask;
+};
+
+struct flow_match_pppoe {
+	struct flow_dissector_key_pppoe *key;
+	struct flow_dissector_key_pppoe *mask;
+};
+
+struct flow_match_l2tpv3 {
+	struct flow_dissector_key_l2tpv3 *key;
+	struct flow_dissector_key_l2tpv3 *mask;
+};
+
+enum flow_block_command {
+	FLOW_BLOCK_BIND = 0,
+	FLOW_BLOCK_UNBIND = 1,
+};
+
+enum flow_block_binder_type {
+	FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
+	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
+	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2,
+	FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP = 3,
+	FLOW_BLOCK_BINDER_TYPE_RED_MARK = 4,
+};
+
+struct flow_block_offload {
+	enum flow_block_command command;
+	enum flow_block_binder_type binder_type;
+	bool block_shared;
+	bool unlocked_driver_cb;
+	struct net *net;
+	struct flow_block *block;
+	struct list_head cb_list;
+	struct list_head *driver_block_list;
+	struct netlink_ext_ack *extack;
+	struct Qdisc *sch;
+	struct list_head *cb_list_head;
+};
+
+struct flow_block_cb;
+
+struct flow_block_indr {
+	struct list_head list;
+	struct net_device *dev;
+	struct Qdisc *sch;
+	enum flow_block_binder_type binder_type;
+	void *data;
+	void *cb_priv;
+	void (*cleanup)(struct flow_block_cb *);
+};
+
+struct flow_block_cb {
+	struct list_head driver_list;
+	struct list_head list;
+	flow_setup_cb_t *cb;
+	void *cb_ident;
+	void *cb_priv;
+	void (*release)(void *);
+	struct flow_block_indr indr;
+	unsigned int refcnt;
+};
+
+enum offload_act_command {
+	FLOW_ACT_REPLACE = 0,
+	FLOW_ACT_DESTROY = 1,
+	FLOW_ACT_STATS = 2,
+};
+
+struct flow_offload_action {
+	struct netlink_ext_ack *extack;
+	enum offload_act_command command;
+	enum flow_action_id id;
+	u32 index;
+	long unsigned int cookie;
+	long: 32;
+	struct flow_stats stats;
+	struct flow_action action;
+};
+
+typedef int flow_indr_block_bind_cb_t(struct net_device *, struct Qdisc *, void *, enum tc_setup_type, void *, void *, void (*)(struct flow_block_cb *));
+
+struct flow_indr_dev {
+	struct list_head list;
+	flow_indr_block_bind_cb_t *cb;
+	void *cb_priv;
+	refcount_t refcnt;
+};
+
+struct flow_indir_dev_info {
+	void *data;
+	struct net_device *dev;
+	struct Qdisc *sch;
+	enum tc_setup_type type;
+	void (*cleanup)(struct flow_block_cb *);
+	struct list_head list;
+	enum flow_block_command command;
+	enum flow_block_binder_type binder_type;
+	struct list_head *cb_list;
+};
+
+enum rt_class_t {
+	RT_TABLE_UNSPEC = 0,
+	RT_TABLE_COMPAT = 252,
+	RT_TABLE_DEFAULT = 253,
+	RT_TABLE_MAIN = 254,
+	RT_TABLE_LOCAL = 255,
+	RT_TABLE_MAX = 4294967295,
+};
+
+struct rtgenmsg {
+	unsigned char rtgen_family;
+};
+
+enum {
+	NLA_UNSPEC = 0,
+	NLA_U8 = 1,
+	NLA_U16 = 2,
+	NLA_U32 = 3,
+	NLA_U64 = 4,
+	NLA_STRING = 5,
+	NLA_FLAG = 6,
+	NLA_MSECS = 7,
+	NLA_NESTED = 8,
+	NLA_NESTED_ARRAY = 9,
+	NLA_NUL_STRING = 10,
+	NLA_BINARY = 11,
+	NLA_S8 = 12,
+	NLA_S16 = 13,
+	NLA_S32 = 14,
+	NLA_S64 = 15,
+	NLA_BITFIELD32 = 16,
+	NLA_REJECT = 17,
+	NLA_BE16 = 18,
+	NLA_BE32 = 19,
+	NLA_SINT = 20,
+	NLA_UINT = 21,
+	__NLA_TYPE_MAX = 22,
+};
+
+enum nla_policy_validation {
+	NLA_VALIDATE_NONE = 0,
+	NLA_VALIDATE_RANGE = 1,
+	NLA_VALIDATE_RANGE_WARN_TOO_LONG = 2,
+	NLA_VALIDATE_MIN = 3,
+	NLA_VALIDATE_MAX = 4,
+	NLA_VALIDATE_MASK = 5,
+	NLA_VALIDATE_RANGE_PTR = 6,
+	NLA_VALIDATE_FUNCTION = 7,
+};
+
+enum netlink_validation {
+	NL_VALIDATE_LIBERAL = 0,
+	NL_VALIDATE_TRAILING = 1,
+	NL_VALIDATE_MAXTYPE = 2,
+	NL_VALIDATE_UNSPEC = 4,
+	NL_VALIDATE_STRICT_ATTRS = 8,
+	NL_VALIDATE_NESTED = 16,
+};
+
+typedef int (*rtnl_doit_func)(struct sk_buff *, struct nlmsghdr *, struct netlink_ext_ack *);
+
+typedef int (*rtnl_dumpit_func)(struct sk_buff *, struct netlink_callback *);
+
+enum rtnl_link_flags {
+	RTNL_FLAG_DOIT_UNLOCKED = 1,
+	RTNL_FLAG_BULK_DEL_SUPPORTED = 2,
+	RTNL_FLAG_DUMP_UNLOCKED = 4,
+	RTNL_FLAG_DUMP_SPLIT_NLM_DONE = 8,
+};
+
+struct fib_rule_uid_range {
+	__u32 start;
+	__u32 end;
+};
+
+enum {
+	FRA_UNSPEC = 0,
+	FRA_DST = 1,
+	FRA_SRC = 2,
+	FRA_IIFNAME = 3,
+	FRA_GOTO = 4,
+	FRA_UNUSED2 = 5,
+	FRA_PRIORITY = 6,
+	FRA_UNUSED3 = 7,
+	FRA_UNUSED4 = 8,
+	FRA_UNUSED5 = 9,
+	FRA_FWMARK = 10,
+	FRA_FLOW = 11,
+	FRA_TUN_ID = 12,
+	FRA_SUPPRESS_IFGROUP = 13,
+	FRA_SUPPRESS_PREFIXLEN = 14,
+	FRA_TABLE = 15,
+	FRA_FWMASK = 16,
+	FRA_OIFNAME = 17,
+	FRA_PAD = 18,
+	FRA_L3MDEV = 19,
+	FRA_UID_RANGE = 20,
+	FRA_PROTOCOL = 21,
+	FRA_IP_PROTO = 22,
+	FRA_SPORT_RANGE = 23,
+	FRA_DPORT_RANGE = 24,
+	FRA_DSCP = 25,
+	__FRA_MAX = 26,
+};
+
+enum {
+	FR_ACT_UNSPEC = 0,
+	FR_ACT_TO_TBL = 1,
+	FR_ACT_GOTO = 2,
+	FR_ACT_NOP = 3,
+	FR_ACT_RES3 = 4,
+	FR_ACT_RES4 = 5,
+	FR_ACT_BLACKHOLE = 6,
+	FR_ACT_UNREACHABLE = 7,
+	FR_ACT_PROHIBIT = 8,
+	FR_ACT_RES9 = 9,
+	FR_ACT_RES10 = 10,
+	FR_ACT_RES11 = 11,
+	FR_ACT_POLICY_FAILED = 12,
+	__FR_ACT_MAX = 13,
+};
+
+struct fib_notifier_info {
+	int family;
+	struct netlink_ext_ack *extack;
+};
+
+enum fib_event_type {
+	FIB_EVENT_ENTRY_REPLACE = 0,
+	FIB_EVENT_ENTRY_APPEND = 1,
+	FIB_EVENT_ENTRY_ADD = 2,
+	FIB_EVENT_ENTRY_DEL = 3,
+	FIB_EVENT_RULE_ADD = 4,
+	FIB_EVENT_RULE_DEL = 5,
+	FIB_EVENT_NH_ADD = 6,
+	FIB_EVENT_NH_DEL = 7,
+	FIB_EVENT_VIF_ADD = 8,
+	FIB_EVENT_VIF_DEL = 9,
+};
+
+struct fib_rule_notifier_info {
+	struct fib_notifier_info info;
+	struct fib_rule *rule;
+};
+
+struct cgroup_cls_state {
+	struct cgroup_subsys_state css;
+	u32 classid;
+	long: 32;
+};
+
+struct update_classid_context {
+	u32 classid;
+	unsigned int batch;
+};
+
+enum gro_result {
+	GRO_MERGED = 0,
+	GRO_MERGED_FREE = 1,
+	GRO_HELD = 2,
+	GRO_NORMAL = 3,
+	GRO_CONSUMED = 4,
+};
+
+typedef enum gro_result gro_result_t;
+
+struct gro_cell;
+
+struct gro_cells {
+	struct gro_cell *cells;
+};
+
+struct gro_cell {
+	struct sk_buff_head napi_skbs;
+	struct napi_struct napi;
+};
+
+struct percpu_free_defer {
+	struct callback_head rcu;
+	void *ptr;
+};
+
+struct llc_addr {
+	unsigned char lsap;
+	unsigned char mac[6];
+};
+
+struct llc_sap {
+	unsigned char state;
+	unsigned char p_bit;
+	unsigned char f_bit;
+	refcount_t refcnt;
+	int (*rcv_func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
+	struct llc_addr laddr;
+	struct list_head node;
+	spinlock_t sk_lock;
+	int sk_count;
+	struct hlist_nulls_head sk_laddr_hash[64];
+	struct hlist_head sk_dev_hash[64];
+	struct callback_head rcu;
+};
+
+struct llc_pdu_un {
+	u8 dsap;
+	u8 ssap;
+	u8 ctrl_1;
+};
+
+struct stp_proto {
+	unsigned char group_address[6];
+	void (*rcv)(const struct stp_proto *, struct sk_buff *, struct net_device *);
+	void *data;
+};
+
+struct nl_info {
+	struct nlmsghdr *nlh;
+	struct net *nl_net;
+	u32 portid;
+	u8 skip_notify: 1;
+	u8 skip_notify_kernel: 1;
+};
+
+struct ipv6_rt_hdr;
+
+struct ipv6_txoptions {
+	refcount_t refcnt;
+	int tot_len;
+	__u16 opt_flen;
+	__u16 opt_nflen;
+	struct ipv6_opt_hdr *hopopt;
+	struct ipv6_opt_hdr *dst0opt;
+	struct ipv6_rt_hdr *srcrt;
+	struct ipv6_opt_hdr *dst1opt;
+	struct callback_head rcu;
+};
+
+struct ipv6_rt_hdr {
+	__u8 nexthdr;
+	__u8 hdrlen;
+	__u8 type;
+	__u8 segments_left;
+};
+
+struct fib6_result;
+
+struct fib6_config;
+
+struct ipv6_stub {
+	int (*ipv6_sock_mc_join)(struct sock *, int, const struct in6_addr *);
+	int (*ipv6_sock_mc_drop)(struct sock *, int, const struct in6_addr *);
+	struct dst_entry * (*ipv6_dst_lookup_flow)(struct net *, const struct sock *, struct flowi6 *, const struct in6_addr *);
+	int (*ipv6_route_input)(struct sk_buff *);
+	struct fib6_table * (*fib6_get_table)(struct net *, u32);
+	int (*fib6_lookup)(struct net *, int, struct flowi6 *, struct fib6_result *, int);
+	int (*fib6_table_lookup)(struct net *, struct fib6_table *, int, struct flowi6 *, struct fib6_result *, int);
+	void (*fib6_select_path)(const struct net *, struct fib6_result *, struct flowi6 *, int, bool, const struct sk_buff *, int);
+	u32 (*ip6_mtu_from_fib6)(const struct fib6_result *, const struct in6_addr *, const struct in6_addr *);
+	int (*fib6_nh_init)(struct net *, struct fib6_nh *, struct fib6_config *, gfp_t, struct netlink_ext_ack *);
+	void (*fib6_nh_release)(struct fib6_nh *);
+	void (*fib6_nh_release_dsts)(struct fib6_nh *);
+	void (*fib6_update_sernum)(struct net *, struct fib6_info *);
+	int (*ip6_del_rt)(struct net *, struct fib6_info *, bool);
+	void (*fib6_rt_update)(struct net *, struct fib6_info *, struct nl_info *);
+	void (*udpv6_encap_enable)();
+	void (*ndisc_send_na)(struct net_device *, const struct in6_addr *, const struct in6_addr *, bool, bool, bool, bool);
+	void (*xfrm6_local_rxpmtu)(struct sk_buff *, u32);
+	int (*xfrm6_udp_encap_rcv)(struct sock *, struct sk_buff *);
+	struct sk_buff * (*xfrm6_gro_udp_encap_rcv)(struct sock *, struct list_head *, struct sk_buff *);
+	int (*xfrm6_rcv_encap)(struct sk_buff *, int, __be32, int);
+	struct neigh_table *nd_tbl;
+	int (*ipv6_fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
+	struct net_device * (*ipv6_dev_find)(struct net *, const struct in6_addr *, struct net_device *);
+	int (*ip6_xmit)(const struct sock *, struct sk_buff *, struct flowi6 *, __u32, struct ipv6_txoptions *, int, u32);
+};
+
+struct fib6_result {
+	struct fib6_nh *nh;
+	struct fib6_info *f6i;
+	u32 fib6_flags;
+	u8 fib6_type;
+	struct rt6_info *rt6;
+};
+
+struct fib6_config {
+	u32 fc_table;
+	u32 fc_metric;
+	int fc_dst_len;
+	int fc_src_len;
+	int fc_ifindex;
+	u32 fc_flags;
+	u32 fc_protocol;
+	u16 fc_type;
+	u16 fc_delete_all_nh: 1;
+	u16 fc_ignore_dev_down: 1;
+	u16 __unused: 14;
+	u32 fc_nh_id;
+	struct in6_addr fc_dst;
+	struct in6_addr fc_src;
+	struct in6_addr fc_prefsrc;
+	struct in6_addr fc_gateway;
+	long unsigned int fc_expires;
+	struct nlattr *fc_mx;
+	int fc_mx_len;
+	int fc_mp_len;
+	struct nlattr *fc_mp;
+	struct nl_info fc_nlinfo;
+	struct nlattr *fc_encap;
+	u16 fc_encap_type;
+	bool fc_is_fdb;
+};
+
+struct sch_frag_data {
+	long unsigned int dst;
+	struct qdisc_skb_cb cb;
+	__be16 inner_protocol;
+	u16 vlan_tci;
+	__be16 vlan_proto;
+	unsigned int l2_len;
+	u8 l2_data[18];
+	int (*xmit)(struct sk_buff *);
+};
+
+enum {
+	TCA_ACT_UNSPEC = 0,
+	TCA_ACT_KIND = 1,
+	TCA_ACT_OPTIONS = 2,
+	TCA_ACT_INDEX = 3,
+	TCA_ACT_STATS = 4,
+	TCA_ACT_PAD = 5,
+	TCA_ACT_COOKIE = 6,
+	TCA_ACT_FLAGS = 7,
+	TCA_ACT_HW_STATS = 8,
+	TCA_ACT_USED_HW_STATS = 9,
+	TCA_ACT_IN_HW_COUNT = 10,
+	__TCA_ACT_MAX = 11,
+};
+
+struct nla_bitfield32 {
+	__u32 value;
+	__u32 selector;
+};
+
+enum rtnetlink_groups {
+	RTNLGRP_NONE = 0,
+	RTNLGRP_LINK = 1,
+	RTNLGRP_NOTIFY = 2,
+	RTNLGRP_NEIGH = 3,
+	RTNLGRP_TC = 4,
+	RTNLGRP_IPV4_IFADDR = 5,
+	RTNLGRP_IPV4_MROUTE = 6,
+	RTNLGRP_IPV4_ROUTE = 7,
+	RTNLGRP_IPV4_RULE = 8,
+	RTNLGRP_IPV6_IFADDR = 9,
+	RTNLGRP_IPV6_MROUTE = 10,
+	RTNLGRP_IPV6_ROUTE = 11,
+	RTNLGRP_IPV6_IFINFO = 12,
+	RTNLGRP_DECnet_IFADDR = 13,
+	RTNLGRP_NOP2 = 14,
+	RTNLGRP_DECnet_ROUTE = 15,
+	RTNLGRP_DECnet_RULE = 16,
+	RTNLGRP_NOP4 = 17,
+	RTNLGRP_IPV6_PREFIX = 18,
+	RTNLGRP_IPV6_RULE = 19,
+	RTNLGRP_ND_USEROPT = 20,
+	RTNLGRP_PHONET_IFADDR = 21,
+	RTNLGRP_PHONET_ROUTE = 22,
+	RTNLGRP_DCB = 23,
+	RTNLGRP_IPV4_NETCONF = 24,
+	RTNLGRP_IPV6_NETCONF = 25,
+	RTNLGRP_MDB = 26,
+	RTNLGRP_MPLS_ROUTE = 27,
+	RTNLGRP_NSID = 28,
+	RTNLGRP_MPLS_NETCONF = 29,
+	RTNLGRP_IPV4_MROUTE_R = 30,
+	RTNLGRP_IPV6_MROUTE_R = 31,
+	RTNLGRP_NEXTHOP = 32,
+	RTNLGRP_BRVLAN = 33,
+	RTNLGRP_MCTP_IFADDR = 34,
+	RTNLGRP_TUNNEL = 35,
+	RTNLGRP_STATS = 36,
+	__RTNLGRP_MAX = 37,
+};
+
+struct psample_group {
+	struct list_head list;
+	struct net *net;
+	u32 group_num;
+	u32 refcount;
+	u32 seq;
+	struct callback_head rcu;
+};
+
+struct action_gate_entry {
+	u8 gate_state;
+	u32 interval;
+	s32 ipv;
+	s32 maxoctets;
+};
+
+enum qdisc_class_ops_flags {
+	QDISC_CLASS_OPS_DOIT_UNLOCKED = 1,
+};
+
+enum tcf_proto_ops_flags {
+	TCF_PROTO_OPS_DOIT_UNLOCKED = 1,
+};
+
+typedef void tcf_chain_head_change_t(struct tcf_proto *, void *);
+
+enum net_xmit_qdisc_t {
+	__NET_XMIT_STOLEN = 65536,
+	__NET_XMIT_BYPASS = 131072,
+};
+
+struct tcf_block_ext_info {
+	enum flow_block_binder_type binder_type;
+	tcf_chain_head_change_t *chain_head_change;
+	void *chain_head_change_priv;
+	u32 block_index;
+};
+
+struct tcf_qevent {
+	struct tcf_block *block;
+	struct tcf_block_ext_info info;
+	struct tcf_proto *filter_chain;
+};
+
+struct tcf_exts_miss_cookie_node {
+	const struct tcf_chain *chain;
+	const struct tcf_proto *tp;
+	const struct tcf_exts *exts;
+	u32 chain_index;
+	u32 tp_prio;
+	u32 handle;
+	u32 miss_cookie_base;
+	struct callback_head rcu;
+};
+
+enum pedit_header_type {
+	TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK = 0,
+	TCA_PEDIT_KEY_EX_HDR_TYPE_ETH = 1,
+	TCA_PEDIT_KEY_EX_HDR_TYPE_IP4 = 2,
+	TCA_PEDIT_KEY_EX_HDR_TYPE_IP6 = 3,
+	TCA_PEDIT_KEY_EX_HDR_TYPE_TCP = 4,
+	TCA_PEDIT_KEY_EX_HDR_TYPE_UDP = 5,
+	__PEDIT_HDR_TYPE_MAX = 6,
+};
+
+enum pedit_cmd {
+	TCA_PEDIT_KEY_EX_CMD_SET = 0,
+	TCA_PEDIT_KEY_EX_CMD_ADD = 1,
+	__PEDIT_CMD_MAX = 2,
+};
+
+struct tc_pedit_key {
+	__u32 mask;
+	__u32 val;
+	__u32 off;
+	__u32 at;
+	__u32 offmask;
+	__u32 shift;
+};
+
+struct tcf_pedit_key_ex {
+	enum pedit_header_type htype;
+	enum pedit_cmd cmd;
+};
+
+struct tcf_pedit_parms {
+	struct tc_pedit_key *tcfp_keys;
+	struct tcf_pedit_key_ex *tcfp_keys_ex;
+	u32 tcfp_off_max_hint;
+	unsigned char tcfp_nkeys;
+	unsigned char tcfp_flags;
+	struct callback_head rcu;
+};
+
+struct tcf_pedit {
+	struct tc_action common;
+	struct tcf_pedit_parms *parms;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+enum ip_conntrack_dir {
+	IP_CT_DIR_ORIGINAL = 0,
+	IP_CT_DIR_REPLY = 1,
+	IP_CT_DIR_MAX = 2,
+};
+
+enum nf_ct_ext_id {
+	NF_CT_EXT_HELPER = 0,
+	NF_CT_EXT_NAT = 1,
+	NF_CT_EXT_SEQADJ = 2,
+	NF_CT_EXT_ACCT = 3,
+	NF_CT_EXT_ECACHE = 4,
+	NF_CT_EXT_TIMEOUT = 5,
+	NF_CT_EXT_LABELS = 6,
+	NF_CT_EXT_NUM = 7,
+};
+
+union tcf_exts_miss_cookie {
+	struct {
+		u32 miss_cookie_base;
+		u32 act_index;
+	};
+	u64 miss_cookie;
+};
+
+struct tcf_filter_chain_list_item {
+	struct list_head list;
+	tcf_chain_head_change_t *chain_head_change;
+	void *chain_head_change_priv;
+};
+
+struct tcf_net {
+	spinlock_t idr_lock;
+	struct idr idr;
+};
+
+struct tcf_block_owner_item {
+	struct list_head list;
+	struct Qdisc *q;
+	enum flow_block_binder_type binder_type;
+};
+
+struct tcf_chain_info {
+	struct tcf_proto **pprev;
+	struct tcf_proto *next;
+};
+
+struct tcf_dump_args {
+	struct tcf_walker w;
+	struct sk_buff *skb;
+	struct netlink_callback *cb;
+	struct tcf_block *block;
+	struct Qdisc *q;
+	u32 parent;
+	bool terse_dump;
+};
+
+struct netlink_dump_control {
+	int (*start)(struct netlink_callback *);
+	int (*dump)(struct sk_buff *, struct netlink_callback *);
+	int (*done)(struct netlink_callback *);
+	struct netlink_ext_ack *extack;
+	void *data;
+	struct module *module;
+	u32 min_dump_alloc;
+	int flags;
+};
+
+struct genlmsghdr {
+	__u8 cmd;
+	__u8 version;
+	__u16 reserved;
+};
+
+enum {
+	CTRL_CMD_UNSPEC = 0,
+	CTRL_CMD_NEWFAMILY = 1,
+	CTRL_CMD_DELFAMILY = 2,
+	CTRL_CMD_GETFAMILY = 3,
+	CTRL_CMD_NEWOPS = 4,
+	CTRL_CMD_DELOPS = 5,
+	CTRL_CMD_GETOPS = 6,
+	CTRL_CMD_NEWMCAST_GRP = 7,
+	CTRL_CMD_DELMCAST_GRP = 8,
+	CTRL_CMD_GETMCAST_GRP = 9,
+	CTRL_CMD_GETPOLICY = 10,
+	__CTRL_CMD_MAX = 11,
+};
+
+enum {
+	CTRL_ATTR_UNSPEC = 0,
+	CTRL_ATTR_FAMILY_ID = 1,
+	CTRL_ATTR_FAMILY_NAME = 2,
+	CTRL_ATTR_VERSION = 3,
+	CTRL_ATTR_HDRSIZE = 4,
+	CTRL_ATTR_MAXATTR = 5,
+	CTRL_ATTR_OPS = 6,
+	CTRL_ATTR_MCAST_GROUPS = 7,
+	CTRL_ATTR_POLICY = 8,
+	CTRL_ATTR_OP_POLICY = 9,
+	CTRL_ATTR_OP = 10,
+	__CTRL_ATTR_MAX = 11,
+};
+
+enum {
+	CTRL_ATTR_OP_UNSPEC = 0,
+	CTRL_ATTR_OP_ID = 1,
+	CTRL_ATTR_OP_FLAGS = 2,
+	__CTRL_ATTR_OP_MAX = 3,
+};
+
+enum {
+	CTRL_ATTR_MCAST_GRP_UNSPEC = 0,
+	CTRL_ATTR_MCAST_GRP_NAME = 1,
+	CTRL_ATTR_MCAST_GRP_ID = 2,
+	__CTRL_ATTR_MCAST_GRP_MAX = 3,
+};
+
+enum {
+	CTRL_ATTR_POLICY_UNSPEC = 0,
+	CTRL_ATTR_POLICY_DO = 1,
+	CTRL_ATTR_POLICY_DUMP = 2,
+	__CTRL_ATTR_POLICY_DUMP_MAX = 3,
+	CTRL_ATTR_POLICY_DUMP_MAX = 2,
+};
+
+struct genl_multicast_group {
+	char name[16];
+	u8 flags;
+};
+
+struct genl_split_ops;
+
+struct genl_info;
+
+struct genl_ops;
+
+struct genl_small_ops;
+
+struct genl_family {
+	unsigned int hdrsize;
+	char name[16];
+	unsigned int version;
+	unsigned int maxattr;
+	u8 netnsok: 1;
+	u8 parallel_ops: 1;
+	u8 n_ops;
+	u8 n_small_ops;
+	u8 n_split_ops;
+	u8 n_mcgrps;
+	u8 resv_start_op;
+	const struct nla_policy *policy;
+	int (*pre_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
+	void (*post_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
+	int (*bind)(int);
+	void (*unbind)(int);
+	const struct genl_ops *ops;
+	const struct genl_small_ops *small_ops;
+	const struct genl_split_ops *split_ops;
+	const struct genl_multicast_group *mcgrps;
+	struct module *module;
+	size_t sock_priv_size;
+	void (*sock_priv_init)(void *);
+	void (*sock_priv_destroy)(void *);
+	int id;
+	unsigned int mcgrp_offset;
+	struct xarray *sock_privs;
+};
+
+struct genl_split_ops {
+	union {
+		struct {
+			int (*pre_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
+			int (*doit)(struct sk_buff *, struct genl_info *);
+			void (*post_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
+		};
+		struct {
+			int (*start)(struct netlink_callback *);
+			int (*dumpit)(struct sk_buff *, struct netlink_callback *);
+			int (*done)(struct netlink_callback *);
+		};
+	};
+	const struct nla_policy *policy;
+	unsigned int maxattr;
+	u8 cmd;
+	u8 internal_flags;
+	u8 flags;
+	u8 validate;
+};
+
+struct genl_info {
+	u32 snd_seq;
+	u32 snd_portid;
+	const struct genl_family *family;
+	const struct nlmsghdr *nlhdr;
+	struct genlmsghdr *genlhdr;
+	struct nlattr **attrs;
+	possible_net_t _net;
+	void *user_ptr[2];
+	struct netlink_ext_ack *extack;
+};
+
+struct genl_ops {
+	int (*doit)(struct sk_buff *, struct genl_info *);
+	int (*start)(struct netlink_callback *);
+	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
+	int (*done)(struct netlink_callback *);
+	const struct nla_policy *policy;
+	unsigned int maxattr;
+	u8 cmd;
+	u8 internal_flags;
+	u8 flags;
+	u8 validate;
+};
+
+struct genl_small_ops {
+	int (*doit)(struct sk_buff *, struct genl_info *);
+	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
+	u8 cmd;
+	u8 internal_flags;
+	u8 flags;
+	u8 validate;
+};
+
+enum genl_validate_flags {
+	GENL_DONT_VALIDATE_STRICT = 1,
+	GENL_DONT_VALIDATE_DUMP = 2,
+	GENL_DONT_VALIDATE_DUMP_STRICT = 4,
+};
+
+struct genl_dumpit_info {
+	struct genl_split_ops op;
+	struct genl_info info;
+};
+
+struct genl_op_iter {
+	const struct genl_family *family;
+	struct genl_split_ops doit;
+	struct genl_split_ops dumpit;
+	int cmd_idx;
+	int entry_idx;
+	u32 cmd;
+	u8 flags;
+};
+
+struct genl_start_context {
+	const struct genl_family *family;
+	struct nlmsghdr *nlh;
+	struct netlink_ext_ack *extack;
+	const struct genl_split_ops *ops;
+	int hdrlen;
+};
+
+struct netlink_policy_dump_state;
+
+struct ctrl_dump_policy_ctx {
+	struct netlink_policy_dump_state *state;
+	const struct genl_family *rt;
+	struct genl_op_iter *op_iter;
+	u32 op;
+	u16 fam_id;
+	u8 dump_map: 1;
+	u8 single_op: 1;
+};
+
+struct xdp_umem;
+
+struct xsk_queue;
+
+struct xdp_buff_xsk;
+
+struct xdp_desc;
+
+struct xsk_buff_pool {
+	struct device *dev;
+	struct net_device *netdev;
+	struct list_head xsk_tx_list;
+	spinlock_t xsk_tx_list_lock;
+	refcount_t users;
+	struct xdp_umem *umem;
+	struct work_struct work;
+	struct list_head free_list;
+	struct list_head xskb_list;
+	u32 heads_cnt;
+	u16 queue_id;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct xsk_queue *fq;
+	struct xsk_queue *cq;
+	dma_addr_t *dma_pages;
+	struct xdp_buff_xsk *heads;
+	struct xdp_desc *tx_descs;
+	long: 32;
+	u64 chunk_mask;
+	u64 addrs_cnt;
+	u32 free_list_cnt;
+	u32 dma_pages_cnt;
+	u32 free_heads_cnt;
+	u32 headroom;
+	u32 chunk_size;
+	u32 chunk_shift;
+	u32 frame_len;
+	u8 tx_metadata_len;
+	u8 cached_need_wakeup;
+	bool uses_need_wakeup;
+	bool unaligned;
+	bool tx_sw_csum;
+	void *addrs;
+	spinlock_t cq_lock;
+	struct xdp_buff_xsk *free_heads[0];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct ethtool_cmd {
+	__u32 cmd;
+	__u32 supported;
+	__u32 advertising;
+	__u16 speed;
+	__u8 duplex;
+	__u8 port;
+	__u8 phy_address;
+	__u8 transceiver;
+	__u8 autoneg;
+	__u8 mdio_support;
+	__u32 maxtxpkt;
+	__u32 maxrxpkt;
+	__u16 speed_hi;
+	__u8 eth_tp_mdix;
+	__u8 eth_tp_mdix_ctrl;
+	__u32 lp_advertising;
+	__u32 reserved[2];
+};
+
+struct ethtool_value {
+	__u32 cmd;
+	__u32 data;
+};
+
+enum tunable_id {
+	ETHTOOL_ID_UNSPEC = 0,
+	ETHTOOL_RX_COPYBREAK = 1,
+	ETHTOOL_TX_COPYBREAK = 2,
+	ETHTOOL_PFC_PREVENTION_TOUT = 3,
+	ETHTOOL_TX_COPYBREAK_BUF_SIZE = 4,
+	__ETHTOOL_TUNABLE_COUNT = 5,
+};
+
+enum tunable_type_id {
+	ETHTOOL_TUNABLE_UNSPEC = 0,
+	ETHTOOL_TUNABLE_U8 = 1,
+	ETHTOOL_TUNABLE_U16 = 2,
+	ETHTOOL_TUNABLE_U32 = 3,
+	ETHTOOL_TUNABLE_U64 = 4,
+	ETHTOOL_TUNABLE_STRING = 5,
+	ETHTOOL_TUNABLE_S8 = 6,
+	ETHTOOL_TUNABLE_S16 = 7,
+	ETHTOOL_TUNABLE_S32 = 8,
+	ETHTOOL_TUNABLE_S64 = 9,
+};
+
+enum phy_tunable_id {
+	ETHTOOL_PHY_ID_UNSPEC = 0,
+	ETHTOOL_PHY_DOWNSHIFT = 1,
+	ETHTOOL_PHY_FAST_LINK_DOWN = 2,
+	ETHTOOL_PHY_EDPD = 3,
+	__ETHTOOL_PHY_TUNABLE_COUNT = 4,
+};
+
+struct ethtool_eee {
+	__u32 cmd;
+	__u32 supported;
+	__u32 advertised;
+	__u32 lp_advertised;
+	__u32 eee_active;
+	__u32 eee_enabled;
+	__u32 tx_lpi_enabled;
+	__u32 tx_lpi_timer;
+	__u32 reserved[2];
+};
+
+struct ethtool_gstrings {
+	__u32 cmd;
+	__u32 string_set;
+	__u32 len;
+	__u8 data[0];
+};
+
+struct ethtool_sset_info {
+	__u32 cmd;
+	__u32 reserved;
+	__u64 sset_mask;
+	__u32 data[0];
+};
+
+struct ethtool_perm_addr {
+	__u32 cmd;
+	__u32 size;
+	__u8 data[0];
+};
+
+enum ethtool_flags {
+	ETH_FLAG_TXVLAN = 128,
+	ETH_FLAG_RXVLAN = 256,
+	ETH_FLAG_LRO = 32768,
+	ETH_FLAG_NTUPLE = 134217728,
+	ETH_FLAG_RXHASH = 268435456,
+};
+
+struct ethtool_rxfh {
+	__u32 cmd;
+	__u32 rss_context;
+	__u32 indir_size;
+	__u32 key_size;
+	__u8 hfunc;
+	__u8 input_xfrm;
+	__u8 rsvd8[2];
+	__u32 rsvd32;
+	__u32 rss_config[0];
+};
+
+struct ethtool_get_features_block {
+	__u32 available;
+	__u32 requested;
+	__u32 active;
+	__u32 never_changed;
+};
+
+struct ethtool_gfeatures {
+	__u32 cmd;
+	__u32 size;
+	struct ethtool_get_features_block features[0];
+};
+
+struct ethtool_set_features_block {
+	__u32 valid;
+	__u32 requested;
+};
+
+struct ethtool_sfeatures {
+	__u32 cmd;
+	__u32 size;
+	struct ethtool_set_features_block features[0];
+};
+
+struct ethtool_ts_info {
+	__u32 cmd;
+	__u32 so_timestamping;
+	__s32 phc_index;
+	__u32 tx_types;
+	__u32 tx_reserved[3];
+	__u32 rx_filters;
+	__u32 rx_reserved[3];
+};
+
+enum ethtool_sfeatures_retval_bits {
+	ETHTOOL_F_UNSUPPORTED__BIT = 0,
+	ETHTOOL_F_WISH__BIT = 1,
+	ETHTOOL_F_COMPAT__BIT = 2,
+};
+
+struct ethtool_per_queue_op {
+	__u32 cmd;
+	__u32 sub_command;
+	__u32 queue_mask[128];
+	char data[0];
+};
+
+enum ethtool_fec_config_bits {
+	ETHTOOL_FEC_NONE_BIT = 0,
+	ETHTOOL_FEC_AUTO_BIT = 1,
+	ETHTOOL_FEC_OFF_BIT = 2,
+	ETHTOOL_FEC_RS_BIT = 3,
+	ETHTOOL_FEC_BASER_BIT = 4,
+	ETHTOOL_FEC_LLRS_BIT = 5,
+};
+
+enum {
+	ETH_RSS_HASH_TOP_BIT = 0,
+	ETH_RSS_HASH_XOR_BIT = 1,
+	ETH_RSS_HASH_CRC32_BIT = 2,
+	ETH_RSS_HASH_FUNCS_COUNT = 3,
+};
+
+struct ethtool_rx_flow_rule {
+	struct flow_rule *rule;
+	long unsigned int priv[0];
+};
+
+struct ethtool_rx_flow_spec_input {
+	const struct ethtool_rx_flow_spec *fs;
+	u32 rss_ctx;
+};
+
+struct xdp_desc {
+	__u64 addr;
+	__u32 len;
+	__u32 options;
+};
+
+struct xdp_umem {
+	void *addrs;
+	long: 32;
+	u64 size;
+	u32 headroom;
+	u32 chunk_size;
+	u32 chunks;
+	u32 npgs;
+	struct user_struct *user;
+	refcount_t users;
+	u8 flags;
+	u8 tx_metadata_len;
+	bool zc;
+	struct page **pgs;
+	int id;
+	struct list_head xsk_dma_list;
+	struct work_struct work;
+	long: 32;
+};
+
+struct xdp_buff_xsk {
+	struct xdp_buff xdp;
+	u8 cb[24];
+	dma_addr_t dma;
+	dma_addr_t frame_dma;
+	struct xsk_buff_pool *pool;
+	long: 32;
+	u64 orig_addr;
+	struct list_head free_list_node;
+	struct list_head xskb_list_node;
+};
+
+enum {
+	ETHTOOL_MSG_KERNEL_NONE = 0,
+	ETHTOOL_MSG_STRSET_GET_REPLY = 1,
+	ETHTOOL_MSG_LINKINFO_GET_REPLY = 2,
+	ETHTOOL_MSG_LINKINFO_NTF = 3,
+	ETHTOOL_MSG_LINKMODES_GET_REPLY = 4,
+	ETHTOOL_MSG_LINKMODES_NTF = 5,
+	ETHTOOL_MSG_LINKSTATE_GET_REPLY = 6,
+	ETHTOOL_MSG_DEBUG_GET_REPLY = 7,
+	ETHTOOL_MSG_DEBUG_NTF = 8,
+	ETHTOOL_MSG_WOL_GET_REPLY = 9,
+	ETHTOOL_MSG_WOL_NTF = 10,
+	ETHTOOL_MSG_FEATURES_GET_REPLY = 11,
+	ETHTOOL_MSG_FEATURES_SET_REPLY = 12,
+	ETHTOOL_MSG_FEATURES_NTF = 13,
+	ETHTOOL_MSG_PRIVFLAGS_GET_REPLY = 14,
+	ETHTOOL_MSG_PRIVFLAGS_NTF = 15,
+	ETHTOOL_MSG_RINGS_GET_REPLY = 16,
+	ETHTOOL_MSG_RINGS_NTF = 17,
+	ETHTOOL_MSG_CHANNELS_GET_REPLY = 18,
+	ETHTOOL_MSG_CHANNELS_NTF = 19,
+	ETHTOOL_MSG_COALESCE_GET_REPLY = 20,
+	ETHTOOL_MSG_COALESCE_NTF = 21,
+	ETHTOOL_MSG_PAUSE_GET_REPLY = 22,
+	ETHTOOL_MSG_PAUSE_NTF = 23,
+	ETHTOOL_MSG_EEE_GET_REPLY = 24,
+	ETHTOOL_MSG_EEE_NTF = 25,
+	ETHTOOL_MSG_TSINFO_GET_REPLY = 26,
+	ETHTOOL_MSG_CABLE_TEST_NTF = 27,
+	ETHTOOL_MSG_CABLE_TEST_TDR_NTF = 28,
+	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY = 29,
+	ETHTOOL_MSG_FEC_GET_REPLY = 30,
+	ETHTOOL_MSG_FEC_NTF = 31,
+	ETHTOOL_MSG_MODULE_EEPROM_GET_REPLY = 32,
+	ETHTOOL_MSG_STATS_GET_REPLY = 33,
+	ETHTOOL_MSG_PHC_VCLOCKS_GET_REPLY = 34,
+	ETHTOOL_MSG_MODULE_GET_REPLY = 35,
+	ETHTOOL_MSG_MODULE_NTF = 36,
+	ETHTOOL_MSG_PSE_GET_REPLY = 37,
+	ETHTOOL_MSG_RSS_GET_REPLY = 38,
+	ETHTOOL_MSG_PLCA_GET_CFG_REPLY = 39,
+	ETHTOOL_MSG_PLCA_GET_STATUS_REPLY = 40,
+	ETHTOOL_MSG_PLCA_NTF = 41,
+	ETHTOOL_MSG_MM_GET_REPLY = 42,
+	ETHTOOL_MSG_MM_NTF = 43,
+	ETHTOOL_MSG_MODULE_FW_FLASH_NTF = 44,
+	ETHTOOL_MSG_PHY_GET_REPLY = 45,
+	ETHTOOL_MSG_PHY_NTF = 46,
+	__ETHTOOL_MSG_KERNEL_CNT = 47,
+	ETHTOOL_MSG_KERNEL_MAX = 46,
+};
+
+struct ethtool_devlink_compat {
+	struct devlink *devlink;
+	union {
+		struct ethtool_flash efl;
+		struct ethtool_drvinfo info;
+	};
+};
+
+struct ethtool_link_usettings {
+	struct ethtool_link_settings base;
+	struct {
+		__u32 supported[4];
+		__u32 advertising[4];
+		__u32 lp_advertising[4];
+	} link_modes;
+};
+
+struct ethtool_rx_flow_key {
+	struct flow_dissector_key_basic basic;
+	union {
+		struct flow_dissector_key_ipv4_addrs ipv4;
+		struct flow_dissector_key_ipv6_addrs ipv6;
+	};
+	struct flow_dissector_key_ports tp;
+	struct flow_dissector_key_ip ip;
+	struct flow_dissector_key_vlan vlan;
+	struct flow_dissector_key_eth_addrs eth_addrs;
+};
+
+struct ethtool_rx_flow_match {
+	struct flow_dissector dissector;
+	struct ethtool_rx_flow_key key;
+	struct ethtool_rx_flow_key mask;
+};
+
+enum {
+	ETHTOOL_MSG_USER_NONE = 0,
+	ETHTOOL_MSG_STRSET_GET = 1,
+	ETHTOOL_MSG_LINKINFO_GET = 2,
+	ETHTOOL_MSG_LINKINFO_SET = 3,
+	ETHTOOL_MSG_LINKMODES_GET = 4,
+	ETHTOOL_MSG_LINKMODES_SET = 5,
+	ETHTOOL_MSG_LINKSTATE_GET = 6,
+	ETHTOOL_MSG_DEBUG_GET = 7,
+	ETHTOOL_MSG_DEBUG_SET = 8,
+	ETHTOOL_MSG_WOL_GET = 9,
+	ETHTOOL_MSG_WOL_SET = 10,
+	ETHTOOL_MSG_FEATURES_GET = 11,
+	ETHTOOL_MSG_FEATURES_SET = 12,
+	ETHTOOL_MSG_PRIVFLAGS_GET = 13,
+	ETHTOOL_MSG_PRIVFLAGS_SET = 14,
+	ETHTOOL_MSG_RINGS_GET = 15,
+	ETHTOOL_MSG_RINGS_SET = 16,
+	ETHTOOL_MSG_CHANNELS_GET = 17,
+	ETHTOOL_MSG_CHANNELS_SET = 18,
+	ETHTOOL_MSG_COALESCE_GET = 19,
+	ETHTOOL_MSG_COALESCE_SET = 20,
+	ETHTOOL_MSG_PAUSE_GET = 21,
+	ETHTOOL_MSG_PAUSE_SET = 22,
+	ETHTOOL_MSG_EEE_GET = 23,
+	ETHTOOL_MSG_EEE_SET = 24,
+	ETHTOOL_MSG_TSINFO_GET = 25,
+	ETHTOOL_MSG_CABLE_TEST_ACT = 26,
+	ETHTOOL_MSG_CABLE_TEST_TDR_ACT = 27,
+	ETHTOOL_MSG_TUNNEL_INFO_GET = 28,
+	ETHTOOL_MSG_FEC_GET = 29,
+	ETHTOOL_MSG_FEC_SET = 30,
+	ETHTOOL_MSG_MODULE_EEPROM_GET = 31,
+	ETHTOOL_MSG_STATS_GET = 32,
+	ETHTOOL_MSG_PHC_VCLOCKS_GET = 33,
+	ETHTOOL_MSG_MODULE_GET = 34,
+	ETHTOOL_MSG_MODULE_SET = 35,
+	ETHTOOL_MSG_PSE_GET = 36,
+	ETHTOOL_MSG_PSE_SET = 37,
+	ETHTOOL_MSG_RSS_GET = 38,
+	ETHTOOL_MSG_PLCA_GET_CFG = 39,
+	ETHTOOL_MSG_PLCA_SET_CFG = 40,
+	ETHTOOL_MSG_PLCA_GET_STATUS = 41,
+	ETHTOOL_MSG_MM_GET = 42,
+	ETHTOOL_MSG_MM_SET = 43,
+	ETHTOOL_MSG_MODULE_FW_FLASH_ACT = 44,
+	ETHTOOL_MSG_PHY_GET = 45,
+	__ETHTOOL_MSG_USER_CNT = 46,
+	ETHTOOL_MSG_USER_MAX = 45,
+};
+
+enum {
+	ETHTOOL_A_HEADER_UNSPEC = 0,
+	ETHTOOL_A_HEADER_DEV_INDEX = 1,
+	ETHTOOL_A_HEADER_DEV_NAME = 2,
+	ETHTOOL_A_HEADER_FLAGS = 3,
+	ETHTOOL_A_HEADER_PHY_INDEX = 4,
+	__ETHTOOL_A_HEADER_CNT = 5,
+	ETHTOOL_A_HEADER_MAX = 4,
+};
+
+enum {
+	ETHTOOL_A_STRING_UNSPEC = 0,
+	ETHTOOL_A_STRING_INDEX = 1,
+	ETHTOOL_A_STRING_VALUE = 2,
+	__ETHTOOL_A_STRING_CNT = 3,
+	ETHTOOL_A_STRING_MAX = 2,
+};
+
+enum {
+	ETHTOOL_A_STRINGS_UNSPEC = 0,
+	ETHTOOL_A_STRINGS_STRING = 1,
+	__ETHTOOL_A_STRINGS_CNT = 2,
+	ETHTOOL_A_STRINGS_MAX = 1,
+};
+
+enum {
+	ETHTOOL_A_STRINGSET_UNSPEC = 0,
+	ETHTOOL_A_STRINGSET_ID = 1,
+	ETHTOOL_A_STRINGSET_COUNT = 2,
+	ETHTOOL_A_STRINGSET_STRINGS = 3,
+	__ETHTOOL_A_STRINGSET_CNT = 4,
+	ETHTOOL_A_STRINGSET_MAX = 3,
+};
+
+enum {
+	ETHTOOL_A_STRINGSETS_UNSPEC = 0,
+	ETHTOOL_A_STRINGSETS_STRINGSET = 1,
+	__ETHTOOL_A_STRINGSETS_CNT = 2,
+	ETHTOOL_A_STRINGSETS_MAX = 1,
+};
+
+enum {
+	ETHTOOL_A_STRSET_UNSPEC = 0,
+	ETHTOOL_A_STRSET_HEADER = 1,
+	ETHTOOL_A_STRSET_STRINGSETS = 2,
+	ETHTOOL_A_STRSET_COUNTS_ONLY = 3,
+	__ETHTOOL_A_STRSET_CNT = 4,
+	ETHTOOL_A_STRSET_MAX = 3,
+};
+
+enum {
+	ETHTOOL_A_LINKINFO_UNSPEC = 0,
+	ETHTOOL_A_LINKINFO_HEADER = 1,
+	ETHTOOL_A_LINKINFO_PORT = 2,
+	ETHTOOL_A_LINKINFO_PHYADDR = 3,
+	ETHTOOL_A_LINKINFO_TP_MDIX = 4,
+	ETHTOOL_A_LINKINFO_TP_MDIX_CTRL = 5,
+	ETHTOOL_A_LINKINFO_TRANSCEIVER = 6,
+	__ETHTOOL_A_LINKINFO_CNT = 7,
+	ETHTOOL_A_LINKINFO_MAX = 6,
+};
+
+enum {
+	ETHTOOL_A_LINKMODES_UNSPEC = 0,
+	ETHTOOL_A_LINKMODES_HEADER = 1,
+	ETHTOOL_A_LINKMODES_AUTONEG = 2,
+	ETHTOOL_A_LINKMODES_OURS = 3,
+	ETHTOOL_A_LINKMODES_PEER = 4,
+	ETHTOOL_A_LINKMODES_SPEED = 5,
+	ETHTOOL_A_LINKMODES_DUPLEX = 6,
+	ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG = 7,
+	ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE = 8,
+	ETHTOOL_A_LINKMODES_LANES = 9,
+	ETHTOOL_A_LINKMODES_RATE_MATCHING = 10,
+	__ETHTOOL_A_LINKMODES_CNT = 11,
+	ETHTOOL_A_LINKMODES_MAX = 10,
+};
+
+enum {
+	ETHTOOL_A_LINKSTATE_UNSPEC = 0,
+	ETHTOOL_A_LINKSTATE_HEADER = 1,
+	ETHTOOL_A_LINKSTATE_LINK = 2,
+	ETHTOOL_A_LINKSTATE_SQI = 3,
+	ETHTOOL_A_LINKSTATE_SQI_MAX = 4,
+	ETHTOOL_A_LINKSTATE_EXT_STATE = 5,
+	ETHTOOL_A_LINKSTATE_EXT_SUBSTATE = 6,
+	ETHTOOL_A_LINKSTATE_EXT_DOWN_CNT = 7,
+	__ETHTOOL_A_LINKSTATE_CNT = 8,
+	ETHTOOL_A_LINKSTATE_MAX = 7,
+};
+
+enum {
+	ETHTOOL_A_DEBUG_UNSPEC = 0,
+	ETHTOOL_A_DEBUG_HEADER = 1,
+	ETHTOOL_A_DEBUG_MSGMASK = 2,
+	__ETHTOOL_A_DEBUG_CNT = 3,
+	ETHTOOL_A_DEBUG_MAX = 2,
+};
+
+enum {
+	ETHTOOL_A_WOL_UNSPEC = 0,
+	ETHTOOL_A_WOL_HEADER = 1,
+	ETHTOOL_A_WOL_MODES = 2,
+	ETHTOOL_A_WOL_SOPASS = 3,
+	__ETHTOOL_A_WOL_CNT = 4,
+	ETHTOOL_A_WOL_MAX = 3,
+};
+
+enum {
+	ETHTOOL_A_FEATURES_UNSPEC = 0,
+	ETHTOOL_A_FEATURES_HEADER = 1,
+	ETHTOOL_A_FEATURES_HW = 2,
+	ETHTOOL_A_FEATURES_WANTED = 3,
+	ETHTOOL_A_FEATURES_ACTIVE = 4,
+	ETHTOOL_A_FEATURES_NOCHANGE = 5,
+	__ETHTOOL_A_FEATURES_CNT = 6,
+	ETHTOOL_A_FEATURES_MAX = 5,
+};
+
+enum {
+	ETHTOOL_A_PRIVFLAGS_UNSPEC = 0,
+	ETHTOOL_A_PRIVFLAGS_HEADER = 1,
+	ETHTOOL_A_PRIVFLAGS_FLAGS = 2,
+	__ETHTOOL_A_PRIVFLAGS_CNT = 3,
+	ETHTOOL_A_PRIVFLAGS_MAX = 2,
+};
+
+enum {
+	ETHTOOL_A_RINGS_UNSPEC = 0,
+	ETHTOOL_A_RINGS_HEADER = 1,
+	ETHTOOL_A_RINGS_RX_MAX = 2,
+	ETHTOOL_A_RINGS_RX_MINI_MAX = 3,
+	ETHTOOL_A_RINGS_RX_JUMBO_MAX = 4,
+	ETHTOOL_A_RINGS_TX_MAX = 5,
+	ETHTOOL_A_RINGS_RX = 6,
+	ETHTOOL_A_RINGS_RX_MINI = 7,
+	ETHTOOL_A_RINGS_RX_JUMBO = 8,
+	ETHTOOL_A_RINGS_TX = 9,
+	ETHTOOL_A_RINGS_RX_BUF_LEN = 10,
+	ETHTOOL_A_RINGS_TCP_DATA_SPLIT = 11,
+	ETHTOOL_A_RINGS_CQE_SIZE = 12,
+	ETHTOOL_A_RINGS_TX_PUSH = 13,
+	ETHTOOL_A_RINGS_RX_PUSH = 14,
+	ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN = 15,
+	ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN_MAX = 16,
+	__ETHTOOL_A_RINGS_CNT = 17,
+	ETHTOOL_A_RINGS_MAX = 16,
+};
+
+enum {
+	ETHTOOL_A_CHANNELS_UNSPEC = 0,
+	ETHTOOL_A_CHANNELS_HEADER = 1,
+	ETHTOOL_A_CHANNELS_RX_MAX = 2,
+	ETHTOOL_A_CHANNELS_TX_MAX = 3,
+	ETHTOOL_A_CHANNELS_OTHER_MAX = 4,
+	ETHTOOL_A_CHANNELS_COMBINED_MAX = 5,
+	ETHTOOL_A_CHANNELS_RX_COUNT = 6,
+	ETHTOOL_A_CHANNELS_TX_COUNT = 7,
+	ETHTOOL_A_CHANNELS_OTHER_COUNT = 8,
+	ETHTOOL_A_CHANNELS_COMBINED_COUNT = 9,
+	__ETHTOOL_A_CHANNELS_CNT = 10,
+	ETHTOOL_A_CHANNELS_MAX = 9,
+};
+
+enum {
+	ETHTOOL_A_COALESCE_UNSPEC = 0,
+	ETHTOOL_A_COALESCE_HEADER = 1,
+	ETHTOOL_A_COALESCE_RX_USECS = 2,
+	ETHTOOL_A_COALESCE_RX_MAX_FRAMES = 3,
+	ETHTOOL_A_COALESCE_RX_USECS_IRQ = 4,
+	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ = 5,
+	ETHTOOL_A_COALESCE_TX_USECS = 6,
+	ETHTOOL_A_COALESCE_TX_MAX_FRAMES = 7,
+	ETHTOOL_A_COALESCE_TX_USECS_IRQ = 8,
+	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ = 9,
+	ETHTOOL_A_COALESCE_STATS_BLOCK_USECS = 10,
+	ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX = 11,
+	ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX = 12,
+	ETHTOOL_A_COALESCE_PKT_RATE_LOW = 13,
+	ETHTOOL_A_COALESCE_RX_USECS_LOW = 14,
+	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW = 15,
+	ETHTOOL_A_COALESCE_TX_USECS_LOW = 16,
+	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW = 17,
+	ETHTOOL_A_COALESCE_PKT_RATE_HIGH = 18,
+	ETHTOOL_A_COALESCE_RX_USECS_HIGH = 19,
+	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH = 20,
+	ETHTOOL_A_COALESCE_TX_USECS_HIGH = 21,
+	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH = 22,
+	ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL = 23,
+	ETHTOOL_A_COALESCE_USE_CQE_MODE_TX = 24,
+	ETHTOOL_A_COALESCE_USE_CQE_MODE_RX = 25,
+	ETHTOOL_A_COALESCE_TX_AGGR_MAX_BYTES = 26,
+	ETHTOOL_A_COALESCE_TX_AGGR_MAX_FRAMES = 27,
+	ETHTOOL_A_COALESCE_TX_AGGR_TIME_USECS = 28,
+	ETHTOOL_A_COALESCE_RX_PROFILE = 29,
+	ETHTOOL_A_COALESCE_TX_PROFILE = 30,
+	__ETHTOOL_A_COALESCE_CNT = 31,
+	ETHTOOL_A_COALESCE_MAX = 30,
+};
+
+enum {
+	ETHTOOL_A_PAUSE_UNSPEC = 0,
+	ETHTOOL_A_PAUSE_HEADER = 1,
+	ETHTOOL_A_PAUSE_AUTONEG = 2,
+	ETHTOOL_A_PAUSE_RX = 3,
+	ETHTOOL_A_PAUSE_TX = 4,
+	ETHTOOL_A_PAUSE_STATS = 5,
+	ETHTOOL_A_PAUSE_STATS_SRC = 6,
+	__ETHTOOL_A_PAUSE_CNT = 7,
+	ETHTOOL_A_PAUSE_MAX = 6,
+};
+
+enum {
+	ETHTOOL_A_EEE_UNSPEC = 0,
+	ETHTOOL_A_EEE_HEADER = 1,
+	ETHTOOL_A_EEE_MODES_OURS = 2,
+	ETHTOOL_A_EEE_MODES_PEER = 3,
+	ETHTOOL_A_EEE_ACTIVE = 4,
+	ETHTOOL_A_EEE_ENABLED = 5,
+	ETHTOOL_A_EEE_TX_LPI_ENABLED = 6,
+	ETHTOOL_A_EEE_TX_LPI_TIMER = 7,
+	__ETHTOOL_A_EEE_CNT = 8,
+	ETHTOOL_A_EEE_MAX = 7,
+};
+
+enum {
+	ETHTOOL_A_TSINFO_UNSPEC = 0,
+	ETHTOOL_A_TSINFO_HEADER = 1,
+	ETHTOOL_A_TSINFO_TIMESTAMPING = 2,
+	ETHTOOL_A_TSINFO_TX_TYPES = 3,
+	ETHTOOL_A_TSINFO_RX_FILTERS = 4,
+	ETHTOOL_A_TSINFO_PHC_INDEX = 5,
+	ETHTOOL_A_TSINFO_STATS = 6,
+	__ETHTOOL_A_TSINFO_CNT = 7,
+	ETHTOOL_A_TSINFO_MAX = 6,
+};
+
+enum {
+	ETHTOOL_A_PHC_VCLOCKS_UNSPEC = 0,
+	ETHTOOL_A_PHC_VCLOCKS_HEADER = 1,
+	ETHTOOL_A_PHC_VCLOCKS_NUM = 2,
+	ETHTOOL_A_PHC_VCLOCKS_INDEX = 3,
+	__ETHTOOL_A_PHC_VCLOCKS_CNT = 4,
+	ETHTOOL_A_PHC_VCLOCKS_MAX = 3,
+};
+
+enum {
+	ETHTOOL_A_CABLE_TEST_UNSPEC = 0,
+	ETHTOOL_A_CABLE_TEST_HEADER = 1,
+	__ETHTOOL_A_CABLE_TEST_CNT = 2,
+	ETHTOOL_A_CABLE_TEST_MAX = 1,
+};
+
+enum {
+	ETHTOOL_A_CABLE_TEST_TDR_UNSPEC = 0,
+	ETHTOOL_A_CABLE_TEST_TDR_HEADER = 1,
+	ETHTOOL_A_CABLE_TEST_TDR_CFG = 2,
+	__ETHTOOL_A_CABLE_TEST_TDR_CNT = 3,
+	ETHTOOL_A_CABLE_TEST_TDR_MAX = 2,
+};
+
+enum {
+	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN = 0,
+	ETHTOOL_UDP_TUNNEL_TYPE_GENEVE = 1,
+	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE = 2,
+	__ETHTOOL_UDP_TUNNEL_TYPE_CNT = 3,
+};
+
+enum {
+	ETHTOOL_A_TUNNEL_INFO_UNSPEC = 0,
+	ETHTOOL_A_TUNNEL_INFO_HEADER = 1,
+	ETHTOOL_A_TUNNEL_INFO_UDP_PORTS = 2,
+	__ETHTOOL_A_TUNNEL_INFO_CNT = 3,
+	ETHTOOL_A_TUNNEL_INFO_MAX = 2,
+};
+
+enum {
+	ETHTOOL_A_FEC_UNSPEC = 0,
+	ETHTOOL_A_FEC_HEADER = 1,
+	ETHTOOL_A_FEC_MODES = 2,
+	ETHTOOL_A_FEC_AUTO = 3,
+	ETHTOOL_A_FEC_ACTIVE = 4,
+	ETHTOOL_A_FEC_STATS = 5,
+	__ETHTOOL_A_FEC_CNT = 6,
+	ETHTOOL_A_FEC_MAX = 5,
+};
+
+enum {
+	ETHTOOL_A_MODULE_EEPROM_UNSPEC = 0,
+	ETHTOOL_A_MODULE_EEPROM_HEADER = 1,
+	ETHTOOL_A_MODULE_EEPROM_OFFSET = 2,
+	ETHTOOL_A_MODULE_EEPROM_LENGTH = 3,
+	ETHTOOL_A_MODULE_EEPROM_PAGE = 4,
+	ETHTOOL_A_MODULE_EEPROM_BANK = 5,
+	ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS = 6,
+	ETHTOOL_A_MODULE_EEPROM_DATA = 7,
+	__ETHTOOL_A_MODULE_EEPROM_CNT = 8,
+	ETHTOOL_A_MODULE_EEPROM_MAX = 7,
+};
+
+enum {
+	ETHTOOL_A_STATS_UNSPEC = 0,
+	ETHTOOL_A_STATS_PAD = 1,
+	ETHTOOL_A_STATS_HEADER = 2,
+	ETHTOOL_A_STATS_GROUPS = 3,
+	ETHTOOL_A_STATS_GRP = 4,
+	ETHTOOL_A_STATS_SRC = 5,
+	__ETHTOOL_A_STATS_CNT = 6,
+	ETHTOOL_A_STATS_MAX = 5,
+};
+
+enum {
+	ETHTOOL_STATS_ETH_PHY = 0,
+	ETHTOOL_STATS_ETH_MAC = 1,
+	ETHTOOL_STATS_ETH_CTRL = 2,
+	ETHTOOL_STATS_RMON = 3,
+	__ETHTOOL_STATS_CNT = 4,
+};
+
+enum {
+	ETHTOOL_A_STATS_ETH_PHY_5_SYM_ERR = 0,
+	__ETHTOOL_A_STATS_ETH_PHY_CNT = 1,
+	ETHTOOL_A_STATS_ETH_PHY_MAX = 0,
+};
+
+enum {
+	ETHTOOL_A_STATS_ETH_MAC_2_TX_PKT = 0,
+	ETHTOOL_A_STATS_ETH_MAC_3_SINGLE_COL = 1,
+	ETHTOOL_A_STATS_ETH_MAC_4_MULTI_COL = 2,
+	ETHTOOL_A_STATS_ETH_MAC_5_RX_PKT = 3,
+	ETHTOOL_A_STATS_ETH_MAC_6_FCS_ERR = 4,
+	ETHTOOL_A_STATS_ETH_MAC_7_ALIGN_ERR = 5,
+	ETHTOOL_A_STATS_ETH_MAC_8_TX_BYTES = 6,
+	ETHTOOL_A_STATS_ETH_MAC_9_TX_DEFER = 7,
+	ETHTOOL_A_STATS_ETH_MAC_10_LATE_COL = 8,
+	ETHTOOL_A_STATS_ETH_MAC_11_XS_COL = 9,
+	ETHTOOL_A_STATS_ETH_MAC_12_TX_INT_ERR = 10,
+	ETHTOOL_A_STATS_ETH_MAC_13_CS_ERR = 11,
+	ETHTOOL_A_STATS_ETH_MAC_14_RX_BYTES = 12,
+	ETHTOOL_A_STATS_ETH_MAC_15_RX_INT_ERR = 13,
+	ETHTOOL_A_STATS_ETH_MAC_18_TX_MCAST = 14,
+	ETHTOOL_A_STATS_ETH_MAC_19_TX_BCAST = 15,
+	ETHTOOL_A_STATS_ETH_MAC_20_XS_DEFER = 16,
+	ETHTOOL_A_STATS_ETH_MAC_21_RX_MCAST = 17,
+	ETHTOOL_A_STATS_ETH_MAC_22_RX_BCAST = 18,
+	ETHTOOL_A_STATS_ETH_MAC_23_IR_LEN_ERR = 19,
+	ETHTOOL_A_STATS_ETH_MAC_24_OOR_LEN = 20,
+	ETHTOOL_A_STATS_ETH_MAC_25_TOO_LONG_ERR = 21,
+	__ETHTOOL_A_STATS_ETH_MAC_CNT = 22,
+	ETHTOOL_A_STATS_ETH_MAC_MAX = 21,
+};
+
+enum {
+	ETHTOOL_A_STATS_ETH_CTRL_3_TX = 0,
+	ETHTOOL_A_STATS_ETH_CTRL_4_RX = 1,
+	ETHTOOL_A_STATS_ETH_CTRL_5_RX_UNSUP = 2,
+	__ETHTOOL_A_STATS_ETH_CTRL_CNT = 3,
+	ETHTOOL_A_STATS_ETH_CTRL_MAX = 2,
+};
+
+enum {
+	ETHTOOL_A_STATS_RMON_UNDERSIZE = 0,
+	ETHTOOL_A_STATS_RMON_OVERSIZE = 1,
+	ETHTOOL_A_STATS_RMON_FRAG = 2,
+	ETHTOOL_A_STATS_RMON_JABBER = 3,
+	__ETHTOOL_A_STATS_RMON_CNT = 4,
+	ETHTOOL_A_STATS_RMON_MAX = 3,
+};
+
+enum {
+	ETHTOOL_A_MODULE_UNSPEC = 0,
+	ETHTOOL_A_MODULE_HEADER = 1,
+	ETHTOOL_A_MODULE_POWER_MODE_POLICY = 2,
+	ETHTOOL_A_MODULE_POWER_MODE = 3,
+	__ETHTOOL_A_MODULE_CNT = 4,
+	ETHTOOL_A_MODULE_MAX = 3,
+};
+
+enum {
+	ETHTOOL_A_PSE_UNSPEC = 0,
+	ETHTOOL_A_PSE_HEADER = 1,
+	ETHTOOL_A_PODL_PSE_ADMIN_STATE = 2,
+	ETHTOOL_A_PODL_PSE_ADMIN_CONTROL = 3,
+	ETHTOOL_A_PODL_PSE_PW_D_STATUS = 4,
+	ETHTOOL_A_C33_PSE_ADMIN_STATE = 5,
+	ETHTOOL_A_C33_PSE_ADMIN_CONTROL = 6,
+	ETHTOOL_A_C33_PSE_PW_D_STATUS = 7,
+	ETHTOOL_A_C33_PSE_PW_CLASS = 8,
+	ETHTOOL_A_C33_PSE_ACTUAL_PW = 9,
+	ETHTOOL_A_C33_PSE_EXT_STATE = 10,
+	ETHTOOL_A_C33_PSE_EXT_SUBSTATE = 11,
+	ETHTOOL_A_C33_PSE_AVAIL_PW_LIMIT = 12,
+	ETHTOOL_A_C33_PSE_PW_LIMIT_RANGES = 13,
+	__ETHTOOL_A_PSE_CNT = 14,
+	ETHTOOL_A_PSE_MAX = 13,
+};
+
+enum {
+	ETHTOOL_A_RSS_UNSPEC = 0,
+	ETHTOOL_A_RSS_HEADER = 1,
+	ETHTOOL_A_RSS_CONTEXT = 2,
+	ETHTOOL_A_RSS_HFUNC = 3,
+	ETHTOOL_A_RSS_INDIR = 4,
+	ETHTOOL_A_RSS_HKEY = 5,
+	ETHTOOL_A_RSS_INPUT_XFRM = 6,
+	ETHTOOL_A_RSS_START_CONTEXT = 7,
+	__ETHTOOL_A_RSS_CNT = 8,
+	ETHTOOL_A_RSS_MAX = 7,
+};
+
+enum {
+	ETHTOOL_A_PLCA_UNSPEC = 0,
+	ETHTOOL_A_PLCA_HEADER = 1,
+	ETHTOOL_A_PLCA_VERSION = 2,
+	ETHTOOL_A_PLCA_ENABLED = 3,
+	ETHTOOL_A_PLCA_STATUS = 4,
+	ETHTOOL_A_PLCA_NODE_CNT = 5,
+	ETHTOOL_A_PLCA_NODE_ID = 6,
+	ETHTOOL_A_PLCA_TO_TMR = 7,
+	ETHTOOL_A_PLCA_BURST_CNT = 8,
+	ETHTOOL_A_PLCA_BURST_TMR = 9,
+	__ETHTOOL_A_PLCA_CNT = 10,
+	ETHTOOL_A_PLCA_MAX = 9,
+};
+
+enum {
+	ETHTOOL_A_MM_UNSPEC = 0,
+	ETHTOOL_A_MM_HEADER = 1,
+	ETHTOOL_A_MM_PMAC_ENABLED = 2,
+	ETHTOOL_A_MM_TX_ENABLED = 3,
+	ETHTOOL_A_MM_TX_ACTIVE = 4,
+	ETHTOOL_A_MM_TX_MIN_FRAG_SIZE = 5,
+	ETHTOOL_A_MM_RX_MIN_FRAG_SIZE = 6,
+	ETHTOOL_A_MM_VERIFY_ENABLED = 7,
+	ETHTOOL_A_MM_VERIFY_STATUS = 8,
+	ETHTOOL_A_MM_VERIFY_TIME = 9,
+	ETHTOOL_A_MM_MAX_VERIFY_TIME = 10,
+	ETHTOOL_A_MM_STATS = 11,
+	__ETHTOOL_A_MM_CNT = 12,
+	ETHTOOL_A_MM_MAX = 11,
+};
+
+enum {
+	ETHTOOL_A_MODULE_FW_FLASH_UNSPEC = 0,
+	ETHTOOL_A_MODULE_FW_FLASH_HEADER = 1,
+	ETHTOOL_A_MODULE_FW_FLASH_FILE_NAME = 2,
+	ETHTOOL_A_MODULE_FW_FLASH_PASSWORD = 3,
+	ETHTOOL_A_MODULE_FW_FLASH_STATUS = 4,
+	ETHTOOL_A_MODULE_FW_FLASH_STATUS_MSG = 5,
+	ETHTOOL_A_MODULE_FW_FLASH_DONE = 6,
+	ETHTOOL_A_MODULE_FW_FLASH_TOTAL = 7,
+	__ETHTOOL_A_MODULE_FW_FLASH_CNT = 8,
+	ETHTOOL_A_MODULE_FW_FLASH_MAX = 7,
+};
+
+enum {
+	ETHTOOL_A_PHY_UNSPEC = 0,
+	ETHTOOL_A_PHY_HEADER = 1,
+	ETHTOOL_A_PHY_INDEX = 2,
+	ETHTOOL_A_PHY_DRVNAME = 3,
+	ETHTOOL_A_PHY_NAME = 4,
+	ETHTOOL_A_PHY_UPSTREAM_TYPE = 5,
+	ETHTOOL_A_PHY_UPSTREAM_INDEX = 6,
+	ETHTOOL_A_PHY_UPSTREAM_SFP_NAME = 7,
+	ETHTOOL_A_PHY_DOWNSTREAM_SFP_NAME = 8,
+	__ETHTOOL_A_PHY_CNT = 9,
+	ETHTOOL_A_PHY_MAX = 8,
+};
+
+struct ethnl_req_info {
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	u32 flags;
+	u32 phy_index;
+};
+
+struct ethnl_reply_data {
+	struct net_device *dev;
+};
+
+struct ethnl_request_ops {
+	u8 request_cmd;
+	u8 reply_cmd;
+	u16 hdr_attr;
+	unsigned int req_info_size;
+	unsigned int reply_data_size;
+	bool allow_nodev_do;
+	u8 set_ntf_cmd;
+	int (*parse_request)(struct ethnl_req_info *, struct nlattr **, struct netlink_ext_ack *);
+	int (*prepare_data)(const struct ethnl_req_info *, struct ethnl_reply_data *, const struct genl_info *);
+	int (*reply_size)(const struct ethnl_req_info *, const struct ethnl_reply_data *);
+	int (*fill_reply)(struct sk_buff *, const struct ethnl_req_info *, const struct ethnl_reply_data *);
+	void (*cleanup_data)(struct ethnl_reply_data *);
+	int (*set_validate)(struct ethnl_req_info *, struct genl_info *);
+	int (*set)(struct ethnl_req_info *, struct genl_info *);
+};
+
+struct strset_info {
+	bool per_dev;
+	bool free_strings;
+	unsigned int count;
+	const char (*strings)[32];
+};
+
+struct strset_req_info {
+	struct ethnl_req_info base;
+	u32 req_ids;
+	bool counts_only;
+};
+
+struct strset_reply_data {
+	struct ethnl_reply_data base;
+	struct strset_info sets[21];
+};
+
+enum ethtool_header_flags {
+	ETHTOOL_FLAG_COMPACT_BITSETS = 1,
+	ETHTOOL_FLAG_OMIT_REPLY = 2,
+	ETHTOOL_FLAG_STATS = 4,
+};
+
+struct linkstate_reply_data {
+	struct ethnl_reply_data base;
+	int link;
+	int sqi;
+	int sqi_max;
+	struct ethtool_link_ext_stats link_stats;
+	bool link_ext_state_provided;
+	struct ethtool_link_ext_state_info ethtool_link_ext_state_info;
+	long: 32;
+};
+
+enum ethtool_supported_ring_param {
+	ETHTOOL_RING_USE_RX_BUF_LEN = 1,
+	ETHTOOL_RING_USE_CQE_SIZE = 2,
+	ETHTOOL_RING_USE_TX_PUSH = 4,
+	ETHTOOL_RING_USE_RX_PUSH = 8,
+	ETHTOOL_RING_USE_TX_PUSH_BUF_LEN = 16,
+	ETHTOOL_RING_USE_TCP_DATA_SPLIT = 32,
+};
+
+enum {
+	ETHTOOL_TCP_DATA_SPLIT_UNKNOWN = 0,
+	ETHTOOL_TCP_DATA_SPLIT_DISABLED = 1,
+	ETHTOOL_TCP_DATA_SPLIT_ENABLED = 2,
+};
+
+struct rings_reply_data {
+	struct ethnl_reply_data base;
+	struct ethtool_ringparam ringparam;
+	struct kernel_ethtool_ringparam kernel_ringparam;
+	u32 supported_ring_params;
+};
+
+typedef const char (* const ethnl_string_array_t)[32];
+
+struct eee_reply_data {
+	struct ethnl_reply_data base;
+	struct ethtool_keee eee;
+};
+
+enum {
+	ETHTOOL_A_FEC_STAT_UNSPEC = 0,
+	ETHTOOL_A_FEC_STAT_PAD = 1,
+	ETHTOOL_A_FEC_STAT_CORRECTED = 2,
+	ETHTOOL_A_FEC_STAT_UNCORR = 3,
+	ETHTOOL_A_FEC_STAT_CORR_BITS = 4,
+	__ETHTOOL_A_FEC_STAT_CNT = 5,
+	ETHTOOL_A_FEC_STAT_MAX = 4,
+};
+
+struct fec_stat_grp {
+	u64 stats[9];
+	u8 cnt;
+	long: 32;
+};
+
+struct fec_reply_data {
+	struct ethnl_reply_data base;
+	long unsigned int fec_link_modes[4];
+	u32 active_fec;
+	u8 fec_auto;
+	long: 32;
+	struct fec_stat_grp corr;
+	struct fec_stat_grp uncorr;
+	struct fec_stat_grp corr_bits;
+};
+
+enum {
+	ETHTOOL_A_STATS_GRP_UNSPEC = 0,
+	ETHTOOL_A_STATS_GRP_PAD = 1,
+	ETHTOOL_A_STATS_GRP_ID = 2,
+	ETHTOOL_A_STATS_GRP_SS_ID = 3,
+	ETHTOOL_A_STATS_GRP_STAT = 4,
+	ETHTOOL_A_STATS_GRP_HIST_RX = 5,
+	ETHTOOL_A_STATS_GRP_HIST_TX = 6,
+	ETHTOOL_A_STATS_GRP_HIST_BKT_LOW = 7,
+	ETHTOOL_A_STATS_GRP_HIST_BKT_HI = 8,
+	ETHTOOL_A_STATS_GRP_HIST_VAL = 9,
+	__ETHTOOL_A_STATS_GRP_CNT = 10,
+	ETHTOOL_A_STATS_GRP_MAX = 9,
+};
+
+struct stats_req_info {
+	struct ethnl_req_info base;
+	long unsigned int stat_mask[1];
+	enum ethtool_mac_stats_src src;
+};
+
+struct stats_reply_data {
+	struct ethnl_reply_data base;
+	long: 32;
+	union {
+		struct {
+			struct ethtool_eth_phy_stats phy_stats;
+			struct ethtool_eth_mac_stats mac_stats;
+			struct ethtool_eth_ctrl_stats ctrl_stats;
+			struct ethtool_rmon_stats rmon_stats;
+		};
+		struct {
+			struct ethtool_eth_phy_stats phy_stats;
+			struct ethtool_eth_mac_stats mac_stats;
+			struct ethtool_eth_ctrl_stats ctrl_stats;
+			struct ethtool_rmon_stats rmon_stats;
+		} stats;
+	};
+	const struct ethtool_rmon_hist_range *rmon_ranges;
+	long: 32;
+};
+
+enum ethtool_module_fw_flash_status {
+	ETHTOOL_MODULE_FW_FLASH_STATUS_STARTED = 1,
+	ETHTOOL_MODULE_FW_FLASH_STATUS_IN_PROGRESS = 2,
+	ETHTOOL_MODULE_FW_FLASH_STATUS_COMPLETED = 3,
+	ETHTOOL_MODULE_FW_FLASH_STATUS_ERROR = 4,
+};
+
+enum {
+	SFF8024_ID_UNK = 0,
+	SFF8024_ID_SFF_8472 = 2,
+	SFF8024_ID_SFP = 3,
+	SFF8024_ID_DWDM_SFP = 11,
+	SFF8024_ID_QSFP_8438 = 12,
+	SFF8024_ID_QSFP_8436_8636 = 13,
+	SFF8024_ID_QSFP28_8636 = 17,
+	SFF8024_ID_QSFP_DD = 24,
+	SFF8024_ID_OSFP = 25,
+	SFF8024_ID_DSFP = 27,
+	SFF8024_ID_QSFP_PLUS_CMIS = 30,
+	SFF8024_ID_SFP_DD_CMIS = 31,
+	SFF8024_ID_SFP_PLUS_CMIS = 32,
+	SFF8024_ENCODING_UNSPEC = 0,
+	SFF8024_ENCODING_8B10B = 1,
+	SFF8024_ENCODING_4B5B = 2,
+	SFF8024_ENCODING_NRZ = 3,
+	SFF8024_ENCODING_8472_MANCHESTER = 4,
+	SFF8024_ENCODING_8472_SONET = 5,
+	SFF8024_ENCODING_8472_64B66B = 6,
+	SFF8024_ENCODING_8436_MANCHESTER = 6,
+	SFF8024_ENCODING_8436_SONET = 4,
+	SFF8024_ENCODING_8436_64B66B = 5,
+	SFF8024_ENCODING_256B257B = 7,
+	SFF8024_ENCODING_PAM4 = 8,
+	SFF8024_CONNECTOR_UNSPEC = 0,
+	SFF8024_CONNECTOR_SC = 1,
+	SFF8024_CONNECTOR_FIBERJACK = 6,
+	SFF8024_CONNECTOR_LC = 7,
+	SFF8024_CONNECTOR_MT_RJ = 8,
+	SFF8024_CONNECTOR_MU = 9,
+	SFF8024_CONNECTOR_SG = 10,
+	SFF8024_CONNECTOR_OPTICAL_PIGTAIL = 11,
+	SFF8024_CONNECTOR_MPO_1X12 = 12,
+	SFF8024_CONNECTOR_MPO_2X16 = 13,
+	SFF8024_CONNECTOR_HSSDC_II = 32,
+	SFF8024_CONNECTOR_COPPER_PIGTAIL = 33,
+	SFF8024_CONNECTOR_RJ45 = 34,
+	SFF8024_CONNECTOR_NOSEPARATE = 35,
+	SFF8024_CONNECTOR_MXC_2X16 = 36,
+	SFF8024_ECC_UNSPEC = 0,
+	SFF8024_ECC_100G_25GAUI_C2M_AOC = 1,
+	SFF8024_ECC_100GBASE_SR4_25GBASE_SR = 2,
+	SFF8024_ECC_100GBASE_LR4_25GBASE_LR = 3,
+	SFF8024_ECC_100GBASE_ER4_25GBASE_ER = 4,
+	SFF8024_ECC_100GBASE_SR10 = 5,
+	SFF8024_ECC_100GBASE_CR4 = 11,
+	SFF8024_ECC_25GBASE_CR_S = 12,
+	SFF8024_ECC_25GBASE_CR_N = 13,
+	SFF8024_ECC_10GBASE_T_SFI = 22,
+	SFF8024_ECC_10GBASE_T_SR = 28,
+	SFF8024_ECC_5GBASE_T = 29,
+	SFF8024_ECC_2_5GBASE_T = 30,
+};
+
+enum {
+	SFP_PHYS_ID = 0,
+	SFP_PHYS_EXT_ID = 1,
+	SFP_PHYS_EXT_ID_SFP = 4,
+	SFP_CONNECTOR = 2,
+	SFP_COMPLIANCE = 3,
+	SFP_ENCODING = 11,
+	SFP_BR_NOMINAL = 12,
+	SFP_RATE_ID = 13,
+	SFF_RID_8079 = 1,
+	SFF_RID_8431_RX_ONLY = 2,
+	SFF_RID_8431_TX_ONLY = 4,
+	SFF_RID_8431 = 6,
+	SFF_RID_10G8G = 14,
+	SFP_LINK_LEN_SM_KM = 14,
+	SFP_LINK_LEN_SM_100M = 15,
+	SFP_LINK_LEN_50UM_OM2_10M = 16,
+	SFP_LINK_LEN_62_5UM_OM1_10M = 17,
+	SFP_LINK_LEN_COPPER_1M = 18,
+	SFP_LINK_LEN_50UM_OM4_10M = 18,
+	SFP_LINK_LEN_50UM_OM3_10M = 19,
+	SFP_VENDOR_NAME = 20,
+	SFP_VENDOR_OUI = 37,
+	SFP_VENDOR_PN = 40,
+	SFP_VENDOR_REV = 56,
+	SFP_OPTICAL_WAVELENGTH_MSB = 60,
+	SFP_OPTICAL_WAVELENGTH_LSB = 61,
+	SFP_CABLE_SPEC = 60,
+	SFP_CC_BASE = 63,
+	SFP_OPTIONS = 64,
+	SFP_OPTIONS_HIGH_POWER_LEVEL = 8192,
+	SFP_OPTIONS_PAGING_A2 = 4096,
+	SFP_OPTIONS_RETIMER = 2048,
+	SFP_OPTIONS_COOLED_XCVR = 1024,
+	SFP_OPTIONS_POWER_DECL = 512,
+	SFP_OPTIONS_RX_LINEAR_OUT = 256,
+	SFP_OPTIONS_RX_DECISION_THRESH = 128,
+	SFP_OPTIONS_TUNABLE_TX = 64,
+	SFP_OPTIONS_RATE_SELECT = 32,
+	SFP_OPTIONS_TX_DISABLE = 16,
+	SFP_OPTIONS_TX_FAULT = 8,
+	SFP_OPTIONS_LOS_INVERTED = 4,
+	SFP_OPTIONS_LOS_NORMAL = 2,
+	SFP_BR_MAX = 66,
+	SFP_BR_MIN = 67,
+	SFP_VENDOR_SN = 68,
+	SFP_DATECODE = 84,
+	SFP_DIAGMON = 92,
+	SFP_DIAGMON_DDM = 64,
+	SFP_DIAGMON_INT_CAL = 32,
+	SFP_DIAGMON_EXT_CAL = 16,
+	SFP_DIAGMON_RXPWR_AVG = 8,
+	SFP_DIAGMON_ADDRMODE = 4,
+	SFP_ENHOPTS = 93,
+	SFP_ENHOPTS_ALARMWARN = 128,
+	SFP_ENHOPTS_SOFT_TX_DISABLE = 64,
+	SFP_ENHOPTS_SOFT_TX_FAULT = 32,
+	SFP_ENHOPTS_SOFT_RX_LOS = 16,
+	SFP_ENHOPTS_SOFT_RATE_SELECT = 8,
+	SFP_ENHOPTS_APP_SELECT_SFF8079 = 4,
+	SFP_ENHOPTS_SOFT_RATE_SFF8431 = 2,
+	SFP_SFF8472_COMPLIANCE = 94,
+	SFP_SFF8472_COMPLIANCE_NONE = 0,
+	SFP_SFF8472_COMPLIANCE_REV9_3 = 1,
+	SFP_SFF8472_COMPLIANCE_REV9_5 = 2,
+	SFP_SFF8472_COMPLIANCE_REV10_2 = 3,
+	SFP_SFF8472_COMPLIANCE_REV10_4 = 4,
+	SFP_SFF8472_COMPLIANCE_REV11_0 = 5,
+	SFP_SFF8472_COMPLIANCE_REV11_3 = 6,
+	SFP_SFF8472_COMPLIANCE_REV11_4 = 7,
+	SFP_SFF8472_COMPLIANCE_REV12_0 = 8,
+	SFP_CC_EXT = 95,
+};
+
+enum ethnl_sock_type {
+	ETHTOOL_SOCK_TYPE_MODULE_FW_FLASH = 0,
+};
+
+struct ethnl_sock_priv {
+	struct net_device *dev;
+	u32 portid;
+	enum ethnl_sock_type type;
+};
+
+struct ethnl_module_fw_flash_ntf_params {
+	u32 portid;
+	u32 seq;
+	bool closed_sock;
+};
+
+struct ethtool_module_fw_flash_params {
+	__be32 password;
+	u8 password_valid: 1;
+};
+
+struct ethtool_cmis_fw_update_params {
+	struct net_device *dev;
+	struct ethtool_module_fw_flash_params params;
+	struct ethnl_module_fw_flash_ntf_params ntf_params;
+	const struct firmware *fw;
+};
+
+struct ethtool_module_fw_flash {
+	struct list_head list;
+	netdevice_tracker dev_tracker;
+	struct work_struct work;
+	struct ethtool_cmis_fw_update_params fw_update;
+};
+
+struct module_reply_data {
+	struct ethnl_reply_data base;
+	struct ethtool_module_power_mode_params power;
+};
+
+struct phy_device_node {
+	enum phy_upstream upstream_type;
+	union {
+		struct net_device *netdev;
+		struct phy_device *phydev;
+	} upstream;
+	struct sfp_bus *parent_sfp_bus;
+	struct phy_device *phy;
+};
+
+struct phy_req_info {
+	struct ethnl_req_info base;
+	struct phy_device_node *pdn;
+};
+
+struct ethnl_phy_dump_ctx {
+	struct phy_req_info *phy_req_info;
+	long unsigned int ifindex;
+	long unsigned int phy_index;
+};
+
+typedef u32 u_int32_t;
+
+struct nf_bridge_info {
+	enum {
+		BRNF_PROTO_UNCHANGED = 0,
+		BRNF_PROTO_8021Q = 1,
+		BRNF_PROTO_PPPOE = 2,
+	} orig_proto: 8;
+	u8 pkt_otherhost: 1;
+	u8 in_prerouting: 1;
+	u8 bridged_dnat: 1;
+	u8 sabotage_in_done: 1;
+	__u16 frag_max_size;
+	int physinif;
+	struct net_device *physoutdev;
+	union {
+		__be32 ipv4_daddr;
+		struct in6_addr ipv6_daddr;
+		char neigh_header[8];
+	};
+};
+
+struct ip_rt_info {
+	__be32 daddr;
+	__be32 saddr;
+	u_int8_t tos;
+	u_int32_t mark;
+};
+
+struct ip6_rt_info {
+	struct in6_addr daddr;
+	struct in6_addr saddr;
+	u_int32_t mark;
+};
+
+struct nf_queue_entry {
+	struct list_head list;
+	struct sk_buff *skb;
+	unsigned int id;
+	unsigned int hook_index;
+	struct net_device *physin;
+	struct net_device *physout;
+	struct nf_hook_state state;
+	u16 size;
+};
+
+enum l2tp_debug_flags {
+	L2TP_MSG_DEBUG = 1,
+	L2TP_MSG_CONTROL = 2,
+	L2TP_MSG_SEQ = 4,
+	L2TP_MSG_DATA = 8,
+};
+
+struct nf_queue_handler {
+	int (*outfn)(struct nf_queue_entry *, unsigned int);
+	void (*nf_hook_drop)(struct net *);
+};
+
+typedef u16 u_int16_t;
+
+struct icmpv6_echo {
+	__be16 identifier;
+	__be16 sequence;
+};
+
+struct icmpv6_nd_advt {
+	__u32 reserved: 5;
+	__u32 override: 1;
+	__u32 solicited: 1;
+	__u32 router: 1;
+	__u32 reserved2: 24;
+};
+
+struct icmpv6_nd_ra {
+	__u8 hop_limit;
+	__u8 reserved: 3;
+	__u8 router_pref: 2;
+	__u8 home_agent: 1;
+	__u8 other: 1;
+	__u8 managed: 1;
+	__be16 rt_lifetime;
+};
+
+struct icmp6hdr {
+	__u8 icmp6_type;
+	__u8 icmp6_code;
+	__sum16 icmp6_cksum;
+	union {
+		__be32 un_data32[1];
+		__be16 un_data16[2];
+		__u8 un_data8[4];
+		struct icmpv6_echo u_echo;
+		struct icmpv6_nd_advt u_nd_advt;
+		struct icmpv6_nd_ra u_nd_ra;
+	} icmp6_dataun;
+};
+
+struct arphdr {
+	__be16 ar_hrd;
+	__be16 ar_pro;
+	unsigned char ar_hln;
+	unsigned char ar_pln;
+	__be16 ar_op;
+};
+
+struct ip_esp_hdr {
+	__be32 spi;
+	__be32 seq_no;
+	__u8 enc_data[0];
+};
+
+union tcp_word_hdr {
+	struct tcphdr hdr;
+	__be32 words[5];
+};
+
+enum {
+	TCP_FLAG_CWR = 32768,
+	TCP_FLAG_ECE = 16384,
+	TCP_FLAG_URG = 8192,
+	TCP_FLAG_ACK = 4096,
+	TCP_FLAG_PSH = 2048,
+	TCP_FLAG_RST = 1024,
+	TCP_FLAG_SYN = 512,
+	TCP_FLAG_FIN = 256,
+	TCP_RESERVED_BITS = 15,
+	TCP_DATA_OFFSET = 240,
+};
+
+struct icmphdr {
+	__u8 type;
+	__u8 code;
+	__sum16 checksum;
+	union {
+		struct {
+			__be16 id;
+			__be16 sequence;
+		} echo;
+		__be32 gateway;
+		struct {
+			__be16 __unused;
+			__be16 mtu;
+		} frag;
+		__u8 reserved[4];
+	} un;
+};
+
+struct nf_loginfo {
+	u_int8_t type;
+	union {
+		struct {
+			u_int32_t copy_len;
+			u_int16_t group;
+			u_int16_t qthreshold;
+			u_int16_t flags;
+		} ulog;
+		struct {
+			u_int8_t level;
+			u_int8_t logflags;
+		} log;
+	} u;
+};
+
+struct arppayload {
+	unsigned char mac_src[6];
+	unsigned char ip_src[4];
+	unsigned char mac_dst[6];
+	unsigned char ip_dst[4];
+};
+
+enum {
+	RTN_UNSPEC = 0,
+	RTN_UNICAST = 1,
+	RTN_LOCAL = 2,
+	RTN_BROADCAST = 3,
+	RTN_ANYCAST = 4,
+	RTN_MULTICAST = 5,
+	RTN_BLACKHOLE = 6,
+	RTN_UNREACHABLE = 7,
+	RTN_PROHIBIT = 8,
+	RTN_THROW = 9,
+	RTN_NAT = 10,
+	RTN_XRESOLVE = 11,
+	RTN_POLICY_FAILED = 12,
+	__RTN_MAX = 13,
+};
+
+struct raw_hashinfo {
+	spinlock_t lock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct hlist_head ht[256];
+};
+
+struct in6_pktinfo {
+	struct in6_addr ipi6_addr;
+	int ipi6_ifindex;
+};
+
+struct inet6_cork {
+	struct ipv6_txoptions *opt;
+	u8 hop_limit;
+	u8 tclass;
+};
+
+struct ipv6_mc_socklist;
+
+struct ipv6_ac_socklist;
+
+struct ipv6_fl_socklist;
+
+struct ipv6_pinfo {
+	struct in6_addr saddr;
+	struct in6_pktinfo sticky_pktinfo;
+	const struct in6_addr *daddr_cache;
+	const struct in6_addr *saddr_cache;
+	__be32 flow_label;
+	__u32 frag_size;
+	s16 hop_limit;
+	u8 mcast_hops;
+	int ucast_oif;
+	int mcast_oif;
+	union {
+		struct {
+			__u16 srcrt: 1;
+			__u16 osrcrt: 1;
+			__u16 rxinfo: 1;
+			__u16 rxoinfo: 1;
+			__u16 rxhlim: 1;
+			__u16 rxohlim: 1;
+			__u16 hopopts: 1;
+			__u16 ohopopts: 1;
+			__u16 dstopts: 1;
+			__u16 odstopts: 1;
+			__u16 rxflow: 1;
+			__u16 rxtclass: 1;
+			__u16 rxpmtu: 1;
+			__u16 rxorigdstaddr: 1;
+			__u16 recvfragsize: 1;
+		} bits;
+		__u16 all;
+	} rxopt;
+	__u8 srcprefs;
+	__u8 pmtudisc;
+	__u8 min_hopcount;
+	__u8 tclass;
+	__be32 rcv_flowinfo;
+	__u32 dst_cookie;
+	struct ipv6_mc_socklist *ipv6_mc_list;
+	struct ipv6_ac_socklist *ipv6_ac_list;
+	struct ipv6_fl_socklist *ipv6_fl_list;
+	struct ipv6_txoptions *opt;
+	struct sk_buff *pktoptions;
+	struct sk_buff *rxpmtu;
+	struct inet6_cork cork;
+};
+
+struct ip6_sf_socklist;
+
+struct ipv6_mc_socklist {
+	struct in6_addr addr;
+	int ifindex;
+	unsigned int sfmode;
+	struct ipv6_mc_socklist *next;
+	struct ip6_sf_socklist *sflist;
+	struct callback_head rcu;
+};
+
+struct ipv6_ac_socklist {
+	struct in6_addr acl_addr;
+	int acl_ifindex;
+	struct ipv6_ac_socklist *acl_next;
+};
+
+struct ip6_flowlabel;
+
+struct ipv6_fl_socklist {
+	struct ipv6_fl_socklist *next;
+	struct ip6_flowlabel *fl;
+	struct callback_head rcu;
+};
+
+struct ip6_sf_socklist {
+	unsigned int sl_max;
+	unsigned int sl_count;
+	struct callback_head rcu;
+	struct in6_addr sl_addr[0];
+};
+
+struct ip6_flowlabel {
+	struct ip6_flowlabel *next;
+	__be32 label;
+	atomic_t users;
+	struct in6_addr dst;
+	struct ipv6_txoptions *opt;
+	long unsigned int linger;
+	struct callback_head rcu;
+	u8 share;
+	union {
+		struct pid *pid;
+		kuid_t uid;
+	} owner;
+	long unsigned int lastuse;
+	long unsigned int expires;
+	struct net *fl_net;
+};
+
+struct ip_rt_acct {
+	__u32 o_bytes;
+	__u32 o_packets;
+	__u32 i_bytes;
+	__u32 i_packets;
+};
+
+enum ip_defrag_users {
+	IP_DEFRAG_LOCAL_DELIVER = 0,
+	IP_DEFRAG_CALL_RA_CHAIN = 1,
+	IP_DEFRAG_CONNTRACK_IN = 2,
+	__IP_DEFRAG_CONNTRACK_IN_END = 65537,
+	IP_DEFRAG_CONNTRACK_OUT = 65538,
+	__IP_DEFRAG_CONNTRACK_OUT_END = 131073,
+	IP_DEFRAG_CONNTRACK_BRIDGE_IN = 131074,
+	__IP_DEFRAG_CONNTRACK_BRIDGE_IN = 196609,
+	IP_DEFRAG_VS_IN = 196610,
+	IP_DEFRAG_VS_OUT = 196611,
+	IP_DEFRAG_VS_FWD = 196612,
+	IP_DEFRAG_AF_PACKET = 196613,
+	IP_DEFRAG_MACVLAN = 196614,
+};
+
+enum {
+	INET_ECN_NOT_ECT = 0,
+	INET_ECN_ECT_1 = 1,
+	INET_ECN_ECT_0 = 2,
+	INET_ECN_CE = 3,
+	INET_ECN_MASK = 3,
+};
+
+enum {
+	XFRM_DEV_OFFLOAD_UNSPECIFIED = 0,
+	XFRM_DEV_OFFLOAD_CRYPTO = 1,
+	XFRM_DEV_OFFLOAD_PACKET = 2,
+};
+
+enum {
+	INET_FLAGS_PKTINFO = 0,
+	INET_FLAGS_TTL = 1,
+	INET_FLAGS_TOS = 2,
+	INET_FLAGS_RECVOPTS = 3,
+	INET_FLAGS_RETOPTS = 4,
+	INET_FLAGS_PASSSEC = 5,
+	INET_FLAGS_ORIGDSTADDR = 6,
+	INET_FLAGS_CHECKSUM = 7,
+	INET_FLAGS_RECVFRAGSIZE = 8,
+	INET_FLAGS_RECVERR = 9,
+	INET_FLAGS_RECVERR_RFC4884 = 10,
+	INET_FLAGS_FREEBIND = 11,
+	INET_FLAGS_HDRINCL = 12,
+	INET_FLAGS_MC_LOOP = 13,
+	INET_FLAGS_MC_ALL = 14,
+	INET_FLAGS_TRANSPARENT = 15,
+	INET_FLAGS_IS_ICSK = 16,
+	INET_FLAGS_NODEFRAG = 17,
+	INET_FLAGS_BIND_ADDRESS_NO_PORT = 18,
+	INET_FLAGS_DEFER_CONNECT = 19,
+	INET_FLAGS_MC6_LOOP = 20,
+	INET_FLAGS_RECVERR6_RFC4884 = 21,
+	INET_FLAGS_MC6_ALL = 22,
+	INET_FLAGS_AUTOFLOWLABEL_SET = 23,
+	INET_FLAGS_AUTOFLOWLABEL = 24,
+	INET_FLAGS_DONTFRAG = 25,
+	INET_FLAGS_RECVERR6 = 26,
+	INET_FLAGS_REPFLOW = 27,
+	INET_FLAGS_RTALERT_ISOLATE = 28,
+	INET_FLAGS_SNDFLOW = 29,
+	INET_FLAGS_RTALERT = 30,
+};
+
+struct inet_bind_bucket {
+	possible_net_t ib_net;
+	int l3mdev;
+	short unsigned int port;
+	signed char fastreuse;
+	signed char fastreuseport;
+	kuid_t fastuid;
+	struct in6_addr fast_v6_rcv_saddr;
+	__be32 fast_rcv_saddr;
+	short unsigned int fast_sk_family;
+	bool fast_ipv6_only;
+	struct hlist_node node;
+	struct hlist_head bhash2;
+};
+
+struct inet_bind2_bucket {
+	possible_net_t ib_net;
+	int l3mdev;
+	short unsigned int port;
+	short unsigned int addr_type;
+	struct in6_addr v6_rcv_saddr;
+	struct hlist_node node;
+	struct hlist_node bhash_node;
+	struct hlist_head owners;
+};
+
+struct inet_timewait_sock {
+	struct sock_common __tw_common;
+	__u32 tw_mark;
+	unsigned char tw_substate;
+	unsigned char tw_rcv_wscale;
+	__be16 tw_sport;
+	unsigned int tw_transparent: 1;
+	unsigned int tw_flowlabel: 20;
+	unsigned int tw_usec_ts: 1;
+	unsigned int tw_pad: 2;
+	unsigned int tw_tos: 8;
+	u32 tw_txhash;
+	u32 tw_priority;
+	struct timer_list tw_timer;
+	struct inet_bind_bucket *tw_tb;
+	struct inet_bind2_bucket *tw_tb2;
+};
+
+enum pkt_hash_types {
+	PKT_HASH_TYPE_NONE = 0,
+	PKT_HASH_TYPE_L2 = 1,
+	PKT_HASH_TYPE_L3 = 2,
+	PKT_HASH_TYPE_L4 = 3,
+};
+
+struct tasklet_struct {
+	struct tasklet_struct *next;
+	long unsigned int state;
+	atomic_t count;
+	bool use_callback;
+	union {
+		void (*func)(long unsigned int);
+		void (*callback)(struct tasklet_struct *);
+	};
+	long unsigned int data;
+};
+
+enum {
+	TASKLET_STATE_SCHED = 0,
+	TASKLET_STATE_RUN = 1,
+};
+
+enum {
+	BPF_SOCK_OPS_RTO_CB_FLAG = 1,
+	BPF_SOCK_OPS_RETRANS_CB_FLAG = 2,
+	BPF_SOCK_OPS_STATE_CB_FLAG = 4,
+	BPF_SOCK_OPS_RTT_CB_FLAG = 8,
+	BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG = 16,
+	BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG = 32,
+	BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG = 64,
+	BPF_SOCK_OPS_ALL_CB_FLAGS = 127,
+};
+
+enum {
+	BPF_SOCK_OPS_VOID = 0,
+	BPF_SOCK_OPS_TIMEOUT_INIT = 1,
+	BPF_SOCK_OPS_RWND_INIT = 2,
+	BPF_SOCK_OPS_TCP_CONNECT_CB = 3,
+	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 4,
+	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 5,
+	BPF_SOCK_OPS_NEEDS_ECN = 6,
+	BPF_SOCK_OPS_BASE_RTT = 7,
+	BPF_SOCK_OPS_RTO_CB = 8,
+	BPF_SOCK_OPS_RETRANS_CB = 9,
+	BPF_SOCK_OPS_STATE_CB = 10,
+	BPF_SOCK_OPS_TCP_LISTEN_CB = 11,
+	BPF_SOCK_OPS_RTT_CB = 12,
+	BPF_SOCK_OPS_PARSE_HDR_OPT_CB = 13,
+	BPF_SOCK_OPS_HDR_OPT_LEN_CB = 14,
+	BPF_SOCK_OPS_WRITE_HDR_OPT_CB = 15,
+};
+
+enum {
+	BPF_WRITE_HDR_TCP_CURRENT_MSS = 1,
+	BPF_WRITE_HDR_TCP_SYNACK_COOKIE = 2,
+};
+
+enum sk_pacing {
+	SK_PACING_NONE = 0,
+	SK_PACING_NEEDED = 1,
+	SK_PACING_FQ = 2,
+};
+
+enum inet_csk_ack_state_t {
+	ICSK_ACK_SCHED = 1,
+	ICSK_ACK_TIMER = 2,
+	ICSK_ACK_PUSHED = 4,
+	ICSK_ACK_PUSHED2 = 8,
+	ICSK_ACK_NOW = 16,
+	ICSK_ACK_NOMEM = 32,
+};
+
+enum {
+	TCP_NO_QUEUE = 0,
+	TCP_RECV_QUEUE = 1,
+	TCP_SEND_QUEUE = 2,
+	TCP_QUEUES_NR = 3,
+};
+
+enum tcp_ca_state {
+	TCP_CA_Open = 0,
+	TCP_CA_Disorder = 1,
+	TCP_CA_CWR = 2,
+	TCP_CA_Recovery = 3,
+	TCP_CA_Loss = 4,
+};
+
+struct tcp_fastopen_cookie {
+	__le64 val[2];
+	s8 len;
+	bool exp;
+	long: 32;
+};
+
+struct tcp_fastopen_request {
+	struct tcp_fastopen_cookie cookie;
+	struct msghdr *data;
+	size_t size;
+	int copied;
+	struct ubuf_info *uarg;
+};
+
+enum tsq_flags {
+	TSQF_THROTTLED = 1,
+	TSQF_QUEUED = 2,
+	TCPF_TSQ_DEFERRED = 4,
+	TCPF_WRITE_TIMER_DEFERRED = 8,
+	TCPF_DELACK_TIMER_DEFERRED = 16,
+	TCPF_MTU_REDUCED_DEFERRED = 32,
+	TCPF_ACK_DEFERRED = 64,
+};
+
+union tcp_ao_addr {
+	struct in_addr a4;
+	struct in6_addr a6;
+};
+
+struct tcp_ao_key {
+	struct hlist_node node;
+	union tcp_ao_addr addr;
+	u8 key[80];
+	unsigned int tcp_sigpool_id;
+	unsigned int digest_size;
+	int l3index;
+	u8 prefixlen;
+	u8 family;
+	u8 keylen;
+	u8 keyflags;
+	u8 sndid;
+	u8 rcvid;
+	u8 maclen;
+	struct callback_head rcu;
+	long: 32;
+	atomic64_t pkt_good;
+	atomic64_t pkt_bad;
+	u8 traffic_keys[0];
+};
+
+struct mptcp_ext {
+	union {
+		u64 data_ack;
+		u32 data_ack32;
+	};
+	u64 data_seq;
+	u32 subflow_seq;
+	u16 data_len;
+	__sum16 csum;
+	u8 use_map: 1;
+	u8 dsn64: 1;
+	u8 data_fin: 1;
+	u8 use_ack: 1;
+	u8 ack64: 1;
+	u8 mpc_map: 1;
+	u8 frozen: 1;
+	u8 reset_transient: 1;
+	u8 reset_reason: 4;
+	u8 csum_reqd: 1;
+	u8 infinite_map: 1;
+	long: 32;
+};
+
+struct mptcp_rm_list {
+	u8 ids[8];
+	u8 nr;
+};
+
+struct mptcp_addr_info {
+	u8 id;
+	sa_family_t family;
+	__be16 port;
+	union {
+		struct in_addr addr;
+		struct in6_addr addr6;
+	};
+};
+
+struct mptcp_out_options {
+	u16 suboptions;
+	struct mptcp_rm_list rm_list;
+	u8 join_id;
+	u8 backup;
+	u8 reset_reason: 4;
+	u8 reset_transient: 1;
+	u8 csum_reqd: 1;
+	u8 allow_join_id0: 1;
+	union {
+		struct {
+			u64 sndr_key;
+			u64 rcvr_key;
+			u64 data_seq;
+			u32 subflow_seq;
+			u16 data_len;
+			__sum16 csum;
+		};
+		struct {
+			struct mptcp_addr_info addr;
+			u64 ahmac;
+		};
+		struct {
+			struct mptcp_ext ext_copy;
+			u64 fail_seq;
+		};
+		struct {
+			u32 nonce;
+			u32 token;
+			u64 thmac;
+			u8 hmac[20];
+			long: 32;
+		};
+	};
+};
+
+enum tcp_queue {
+	TCP_FRAG_IN_WRITE_QUEUE = 0,
+	TCP_FRAG_IN_RTX_QUEUE = 1,
+};
+
+enum tcp_skb_cb_sacked_flags {
+	TCPCB_SACKED_ACKED = 1,
+	TCPCB_SACKED_RETRANS = 2,
+	TCPCB_LOST = 4,
+	TCPCB_TAGBITS = 7,
+	TCPCB_REPAIRED = 16,
+	TCPCB_EVER_RETRANS = 128,
+	TCPCB_RETRANS = 146,
+};
+
+struct tcp_skb_cb {
+	__u32 seq;
+	__u32 end_seq;
+	union {
+		struct {
+			u16 tcp_gso_segs;
+			u16 tcp_gso_size;
+		};
+	};
+	__u8 tcp_flags;
+	__u8 sacked;
+	__u8 ip_dsfield;
+	__u8 txstamp_ack: 1;
+	__u8 eor: 1;
+	__u8 has_rxtstamp: 1;
+	__u8 unused: 5;
+	__u32 ack_seq;
+	union {
+		struct {
+			__u32 is_app_limited: 1;
+			__u32 delivered_ce: 20;
+			__u32 unused: 11;
+			__u32 delivered;
+			u32 first_tx_mstamp;
+			u32 delivered_mstamp;
+			u32 in_flight: 20;
+			u32 unused2: 12;
+			u32 lost;
+		} tx;
+		union {
+			struct inet_skb_parm h4;
+			struct inet6_skb_parm h6;
+		} header;
+	};
+};
+
+struct tcp_md5sig_key {
+	struct hlist_node node;
+	u8 keylen;
+	u8 family;
+	u8 prefixlen;
+	u8 flags;
+	union tcp_ao_addr addr;
+	int l3index;
+	u8 key[80];
+	struct callback_head rcu;
+};
+
+enum tcp_chrono {
+	TCP_CHRONO_UNSPEC = 0,
+	TCP_CHRONO_BUSY = 1,
+	TCP_CHRONO_RWND_LIMITED = 2,
+	TCP_CHRONO_SNDBUF_LIMITED = 3,
+	__TCP_CHRONO_MAX = 4,
+};
+
+struct tcp_key {
+	union {
+		struct {
+			struct tcp_ao_key *ao_key;
+			char *traffic_key;
+			u32 sne;
+			u8 rcv_next;
+		};
+		struct tcp_md5sig_key *md5_key;
+	};
+	enum {
+		TCP_KEY_NONE = 0,
+		TCP_KEY_MD5 = 1,
+		TCP_KEY_AO = 2,
+	} type;
+};
+
+struct tcp_out_options {
+	u16 options;
+	u16 mss;
+	u8 ws;
+	u8 num_sack_blocks;
+	u8 hash_size;
+	u8 bpf_opt_len;
+	__u8 *hash_location;
+	__u32 tsval;
+	__u32 tsecr;
+	struct tcp_fastopen_cookie *fastopen_cookie;
+	struct mptcp_out_options mptcp;
+};
+
+struct tsq_tasklet {
+	struct tasklet_struct tasklet;
+	struct list_head head;
+};
+
+struct tcp_timewait_sock {
+	struct inet_timewait_sock tw_sk;
+	u32 tw_rcv_wnd;
+	u32 tw_ts_offset;
+	u32 tw_ts_recent;
+	u32 tw_last_oow_ack_time;
+	int tw_ts_recent_stamp;
+	u32 tw_tx_delay;
+};
+
+enum tcp_tw_status {
+	TCP_TW_SUCCESS = 0,
+	TCP_TW_RST = 1,
+	TCP_TW_ACK = 2,
+	TCP_TW_SYN = 3,
+};
+
+enum tcp_fastopen_client_fail {
+	TFO_STATUS_UNSPEC = 0,
+	TFO_COOKIE_UNAVAILABLE = 1,
+	TFO_DATA_NOT_ACKED = 2,
+	TFO_SYN_RETRANSMITTED = 3,
+};
+
+struct sockaddr_in {
+	__kernel_sa_family_t sin_family;
+	__be16 sin_port;
+	struct in_addr sin_addr;
+	unsigned char __pad[8];
+};
+
+enum rt_scope_t {
+	RT_SCOPE_UNIVERSE = 0,
+	RT_SCOPE_SITE = 200,
+	RT_SCOPE_LINK = 253,
+	RT_SCOPE_HOST = 254,
+	RT_SCOPE_NOWHERE = 255,
+};
+
+enum {
+	BTF_SOCK_TYPE_INET = 0,
+	BTF_SOCK_TYPE_INET_CONN = 1,
+	BTF_SOCK_TYPE_INET_REQ = 2,
+	BTF_SOCK_TYPE_INET_TW = 3,
+	BTF_SOCK_TYPE_REQ = 4,
+	BTF_SOCK_TYPE_SOCK = 5,
+	BTF_SOCK_TYPE_SOCK_COMMON = 6,
+	BTF_SOCK_TYPE_TCP = 7,
+	BTF_SOCK_TYPE_TCP_REQ = 8,
+	BTF_SOCK_TYPE_TCP_TW = 9,
+	BTF_SOCK_TYPE_TCP6 = 10,
+	BTF_SOCK_TYPE_UDP = 11,
+	BTF_SOCK_TYPE_UDP6 = 12,
+	BTF_SOCK_TYPE_UNIX = 13,
+	BTF_SOCK_TYPE_MPTCP = 14,
+	BTF_SOCK_TYPE_SOCKET = 15,
+	MAX_BTF_SOCK_TYPE = 16,
+};
+
+struct cmsghdr {
+	__kernel_size_t cmsg_len;
+	int cmsg_level;
+	int cmsg_type;
+};
+
+struct ip_mreqn {
+	struct in_addr imr_multiaddr;
+	struct in_addr imr_address;
+	int imr_ifindex;
+};
+
+struct seq_net_private {
+	struct net *net;
+	netns_tracker ns_tracker;
+};
+
+enum {
+	SOCK_WAKE_IO = 0,
+	SOCK_WAKE_WAITD = 1,
+	SOCK_WAKE_SPACE = 2,
+	SOCK_WAKE_URG = 3,
+};
+
+struct sockcm_cookie {
+	u64 transmit_time;
+	u32 mark;
+	u32 tsflags;
+};
+
+struct sock_skb_cb {
+	u32 dropcount;
+};
+
+struct ip_sf_socklist {
+	unsigned int sl_max;
+	unsigned int sl_count;
+	struct callback_head rcu;
+	__be32 sl_addr[0];
+};
+
+struct ip_mc_socklist {
+	struct ip_mc_socklist *next_rcu;
+	struct ip_mreqn multi;
+	unsigned int sfmode;
+	struct ip_sf_socklist *sflist;
+	struct callback_head rcu;
+};
+
+struct ip_sf_list {
+	struct ip_sf_list *sf_next;
+	long unsigned int sf_count[2];
+	__be32 sf_inaddr;
+	unsigned char sf_gsresp;
+	unsigned char sf_oldin;
+	unsigned char sf_crcount;
+};
+
+struct ip_mc_list {
+	struct in_device *interface;
+	__be32 multiaddr;
+	unsigned int sfmode;
+	struct ip_sf_list *sources;
+	struct ip_sf_list *tomb;
+	long unsigned int sfcount[2];
+	union {
+		struct ip_mc_list *next;
+		struct ip_mc_list *next_rcu;
+	};
+	struct ip_mc_list *next_hash;
+	struct timer_list timer;
+	int users;
+	refcount_t refcnt;
+	spinlock_t lock;
+	char tm_running;
+	char reporter;
+	char unsolicit_count;
+	char loaded;
+	unsigned char gsquery;
+	unsigned char crcount;
+	struct callback_head rcu;
+};
+
+struct ip_options_data {
+	struct ip_options_rcu opt;
+	char data[40];
+};
+
+enum {
+	UDP_FLAGS_CORK = 0,
+	UDP_FLAGS_NO_CHECK6_TX = 1,
+	UDP_FLAGS_NO_CHECK6_RX = 2,
+	UDP_FLAGS_GRO_ENABLED = 3,
+	UDP_FLAGS_ACCEPT_FRAGLIST = 4,
+	UDP_FLAGS_ACCEPT_L4 = 5,
+	UDP_FLAGS_ENCAP_ENABLED = 6,
+	UDP_FLAGS_UDPLITE_SEND_CC = 7,
+	UDP_FLAGS_UDPLITE_RECV_CC = 8,
+};
+
+struct udp_sock {
+	struct inet_sock inet;
+	long unsigned int udp_flags;
+	int pending;
+	__u8 encap_type;
+	__u16 len;
+	__u16 gso_size;
+	__u16 pcslen;
+	__u16 pcrlen;
+	int (*encap_rcv)(struct sock *, struct sk_buff *);
+	void (*encap_err_rcv)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
+	int (*encap_err_lookup)(struct sock *, struct sk_buff *);
+	void (*encap_destroy)(struct sock *);
+	struct sk_buff * (*gro_receive)(struct sock *, struct list_head *, struct sk_buff *);
+	int (*gro_complete)(struct sock *, struct sk_buff *, int);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct sk_buff_head reader_queue;
+	int forward_deficit;
+	int forward_threshold;
+	bool peeking_with_offset;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct ipcm_cookie {
+	struct sockcm_cookie sockc;
+	__be32 addr;
+	int oif;
+	struct ip_options_rcu *opt;
+	__u8 protocol;
+	__u8 ttl;
+	__s16 tos;
+	char priority;
+	__u16 gso_size;
+	long: 32;
+};
+
+struct icmp_err {
+	int errno;
+	unsigned int fatal: 1;
+};
+
+typedef u32 inet_ehashfn_t(const struct net *, const __be32, const __u16, const __be32, const __be16);
+
+struct ip_tunnel_encap_ops {
+	size_t (*encap_hlen)(struct ip_tunnel_encap *);
+	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi4 *);
+	int (*err_handler)(struct sk_buff *, u32);
+};
+
+struct udp_skb_cb {
+	union {
+		struct inet_skb_parm h4;
+		struct inet6_skb_parm h6;
+	} header;
+	__u16 cscov;
+	__u8 partial_cov;
+};
+
+struct udp_dev_scratch {
+	u32 _tsize_state;
+};
+
+struct udp_seq_afinfo {
+	sa_family_t family;
+	struct udp_table *udp_table;
+};
+
+struct udp_iter_state {
+	struct seq_net_private p;
+	int bucket;
+};
+
+struct napi_gro_cb {
+	union {
+		struct {
+			void *frag0;
+			unsigned int frag0_len;
+		};
+		struct {
+			struct sk_buff *last;
+			long unsigned int age;
+		};
+	};
+	int data_offset;
+	u16 flush;
+	u16 count;
+	u16 proto;
+	u16 pad;
+	union {
+		struct {
+			u16 gro_remcsum_start;
+			u8 same_flow: 1;
+			u8 encap_mark: 1;
+			u8 csum_valid: 1;
+			u8 csum_cnt: 3;
+			u8 free: 2;
+			u8 is_ipv6: 1;
+			u8 is_fou: 1;
+			u8 ip_fixedid: 1;
+			u8 recursion_counter: 4;
+			u8 is_flist: 1;
+		};
+		struct {
+			u16 gro_remcsum_start;
+			u8 same_flow: 1;
+			u8 encap_mark: 1;
+			u8 csum_valid: 1;
+			u8 csum_cnt: 3;
+			u8 free: 2;
+			u8 is_ipv6: 1;
+			u8 is_fou: 1;
+			u8 ip_fixedid: 1;
+			u8 recursion_counter: 4;
+			u8 is_flist: 1;
+		} zeroed;
+	};
+	__wsum csum;
+	union {
+		struct {
+			u16 network_offset;
+			u16 inner_network_offset;
+		};
+		u16 network_offsets[2];
+	};
+};
+
+struct bpf_iter__udp {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct udp_sock *udp_sk;
+	};
+	uid_t uid;
+	long: 32;
+	int bucket;
+	long: 32;
+};
+
+struct bpf_udp_iter_state {
+	struct udp_iter_state state;
+	unsigned int cur_sk;
+	unsigned int end_sk;
+	unsigned int max_sk;
+	int offset;
+	struct sock **batch;
+	bool st_bucket_done;
+};
+
+struct ip_mreq_source {
+	__be32 imr_multiaddr;
+	__be32 imr_interface;
+	__be32 imr_sourceaddr;
+};
+
+struct ip_msfilter {
+	__be32 imsf_multiaddr;
+	__be32 imsf_interface;
+	__u32 imsf_fmode;
+	__u32 imsf_numsrc;
+	union {
+		__be32 imsf_slist[1];
+		struct {
+			struct {} __empty_imsf_slist_flex;
+			__be32 imsf_slist_flex[0];
+		};
+	};
+};
+
+struct group_filter {
+	union {
+		struct {
+			__u32 gf_interface_aux;
+			struct __kernel_sockaddr_storage gf_group_aux;
+			__u32 gf_fmode_aux;
+			__u32 gf_numsrc_aux;
+			struct __kernel_sockaddr_storage gf_slist[1];
+		};
+		struct {
+			__u32 gf_interface;
+			struct __kernel_sockaddr_storage gf_group;
+			__u32 gf_fmode;
+			__u32 gf_numsrc;
+			struct __kernel_sockaddr_storage gf_slist_flex[0];
+		};
+	};
+};
+
+struct igmphdr {
+	__u8 type;
+	__u8 code;
+	__sum16 csum;
+	__be32 group;
+};
+
+struct igmpv3_grec {
+	__u8 grec_type;
+	__u8 grec_auxwords;
+	__be16 grec_nsrcs;
+	__be32 grec_mca;
+	__be32 grec_src[0];
+};
+
+struct igmpv3_report {
+	__u8 type;
+	__u8 resv1;
+	__sum16 csum;
+	__be16 resv2;
+	__be16 ngrec;
+	struct igmpv3_grec grec[0];
+};
+
+struct igmpv3_query {
+	__u8 type;
+	__u8 code;
+	__sum16 csum;
+	__be32 group;
+	__u8 qrv: 3;
+	__u8 suppress: 1;
+	__u8 resv: 4;
+	__u8 qqic;
+	__be16 nsrcs;
+	__be32 srcs[0];
+};
+
+struct igmp_mc_iter_state {
+	struct seq_net_private p;
+	struct net_device *dev;
+	struct in_device *in_dev;
+};
+
+struct igmp_mcf_iter_state {
+	struct seq_net_private p;
+	struct net_device *dev;
+	struct in_device *idev;
+	struct ip_mc_list *im;
+};
+
+enum lwtunnel_encap_types {
+	LWTUNNEL_ENCAP_NONE = 0,
+	LWTUNNEL_ENCAP_MPLS = 1,
+	LWTUNNEL_ENCAP_IP = 2,
+	LWTUNNEL_ENCAP_ILA = 3,
+	LWTUNNEL_ENCAP_IP6 = 4,
+	LWTUNNEL_ENCAP_SEG6 = 5,
+	LWTUNNEL_ENCAP_BPF = 6,
+	LWTUNNEL_ENCAP_SEG6_LOCAL = 7,
+	LWTUNNEL_ENCAP_RPL = 8,
+	LWTUNNEL_ENCAP_IOAM6 = 9,
+	LWTUNNEL_ENCAP_XFRM = 10,
+	__LWTUNNEL_ENCAP_MAX = 11,
+};
+
+enum lwtunnel_ip_t {
+	LWTUNNEL_IP_UNSPEC = 0,
+	LWTUNNEL_IP_ID = 1,
+	LWTUNNEL_IP_DST = 2,
+	LWTUNNEL_IP_SRC = 3,
+	LWTUNNEL_IP_TTL = 4,
+	LWTUNNEL_IP_TOS = 5,
+	LWTUNNEL_IP_FLAGS = 6,
+	LWTUNNEL_IP_PAD = 7,
+	LWTUNNEL_IP_OPTS = 8,
+	__LWTUNNEL_IP_MAX = 9,
+};
+
+enum lwtunnel_ip6_t {
+	LWTUNNEL_IP6_UNSPEC = 0,
+	LWTUNNEL_IP6_ID = 1,
+	LWTUNNEL_IP6_DST = 2,
+	LWTUNNEL_IP6_SRC = 3,
+	LWTUNNEL_IP6_HOPLIMIT = 4,
+	LWTUNNEL_IP6_TC = 5,
+	LWTUNNEL_IP6_FLAGS = 6,
+	LWTUNNEL_IP6_PAD = 7,
+	LWTUNNEL_IP6_OPTS = 8,
+	__LWTUNNEL_IP6_MAX = 9,
+};
+
+enum {
+	LWTUNNEL_IP_OPTS_UNSPEC = 0,
+	LWTUNNEL_IP_OPTS_GENEVE = 1,
+	LWTUNNEL_IP_OPTS_VXLAN = 2,
+	LWTUNNEL_IP_OPTS_ERSPAN = 3,
+	__LWTUNNEL_IP_OPTS_MAX = 4,
+};
+
+enum {
+	LWTUNNEL_IP_OPT_GENEVE_UNSPEC = 0,
+	LWTUNNEL_IP_OPT_GENEVE_CLASS = 1,
+	LWTUNNEL_IP_OPT_GENEVE_TYPE = 2,
+	LWTUNNEL_IP_OPT_GENEVE_DATA = 3,
+	__LWTUNNEL_IP_OPT_GENEVE_MAX = 4,
+};
+
+enum {
+	LWTUNNEL_IP_OPT_VXLAN_UNSPEC = 0,
+	LWTUNNEL_IP_OPT_VXLAN_GBP = 1,
+	__LWTUNNEL_IP_OPT_VXLAN_MAX = 2,
+};
+
+enum {
+	LWTUNNEL_IP_OPT_ERSPAN_UNSPEC = 0,
+	LWTUNNEL_IP_OPT_ERSPAN_VER = 1,
+	LWTUNNEL_IP_OPT_ERSPAN_INDEX = 2,
+	LWTUNNEL_IP_OPT_ERSPAN_DIR = 3,
+	LWTUNNEL_IP_OPT_ERSPAN_HWID = 4,
+	__LWTUNNEL_IP_OPT_ERSPAN_MAX = 5,
+};
+
+struct lwtunnel_encap_ops {
+	int (*build_state)(struct net *, struct nlattr *, unsigned int, const void *, struct lwtunnel_state **, struct netlink_ext_ack *);
+	void (*destroy_state)(struct lwtunnel_state *);
+	int (*output)(struct net *, struct sock *, struct sk_buff *);
+	int (*input)(struct sk_buff *);
+	int (*fill_encap)(struct sk_buff *, struct lwtunnel_state *);
+	int (*get_encap_size)(struct lwtunnel_state *);
+	int (*cmp_encap)(struct lwtunnel_state *, struct lwtunnel_state *);
+	int (*xmit)(struct sk_buff *);
+	struct module *owner;
+};
+
+enum {
+	IFLA_IPTUN_UNSPEC = 0,
+	IFLA_IPTUN_LINK = 1,
+	IFLA_IPTUN_LOCAL = 2,
+	IFLA_IPTUN_REMOTE = 3,
+	IFLA_IPTUN_TTL = 4,
+	IFLA_IPTUN_TOS = 5,
+	IFLA_IPTUN_ENCAP_LIMIT = 6,
+	IFLA_IPTUN_FLOWINFO = 7,
+	IFLA_IPTUN_FLAGS = 8,
+	IFLA_IPTUN_PROTO = 9,
+	IFLA_IPTUN_PMTUDISC = 10,
+	IFLA_IPTUN_6RD_PREFIX = 11,
+	IFLA_IPTUN_6RD_RELAY_PREFIX = 12,
+	IFLA_IPTUN_6RD_PREFIXLEN = 13,
+	IFLA_IPTUN_6RD_RELAY_PREFIXLEN = 14,
+	IFLA_IPTUN_ENCAP_TYPE = 15,
+	IFLA_IPTUN_ENCAP_FLAGS = 16,
+	IFLA_IPTUN_ENCAP_SPORT = 17,
+	IFLA_IPTUN_ENCAP_DPORT = 18,
+	IFLA_IPTUN_COLLECT_METADATA = 19,
+	IFLA_IPTUN_FWMARK = 20,
+	IFLA_IPTUN_FMRS = 21,
+	__IFLA_IPTUN_MAX = 22,
+};
+
+struct ip6_tnl_encap_ops {
+	size_t (*encap_hlen)(struct ip_tunnel_encap *);
+	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi6 *);
+	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
+};
+
+struct geneve_opt {
+	__be16 opt_class;
+	u8 type;
+	u8 length: 5;
+	u8 r3: 1;
+	u8 r2: 1;
+	u8 r1: 1;
+	u8 opt_data[0];
+};
+
+struct vxlan_metadata {
+	u32 gbp;
+};
+
+struct erspan_md2 {
+	__be32 timestamp;
+	__be16 sgt;
+	__u8 hwid_upper: 2;
+	__u8 ft: 5;
+	__u8 p: 1;
+	__u8 o: 1;
+	__u8 gra: 2;
+	__u8 dir: 1;
+	__u8 hwid: 4;
+};
+
+struct erspan_metadata {
+	int version;
+	union {
+		__be32 index;
+		struct erspan_md2 md2;
+	} u;
+};
+
+enum netevent_notif_type {
+	NETEVENT_NEIGH_UPDATE = 1,
+	NETEVENT_REDIRECT = 2,
+	NETEVENT_DELAY_PROBE_TIME_UPDATE = 3,
+	NETEVENT_IPV4_MPATH_HASH_UPDATE = 4,
+	NETEVENT_IPV6_MPATH_HASH_UPDATE = 5,
+	NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE = 6,
+};
+
+struct nlmsgerr {
+	int error;
+	struct nlmsghdr msg;
+};
+
+enum {
+	IFLA_UNSPEC = 0,
+	IFLA_ADDRESS = 1,
+	IFLA_BROADCAST = 2,
+	IFLA_IFNAME = 3,
+	IFLA_MTU = 4,
+	IFLA_LINK = 5,
+	IFLA_QDISC = 6,
+	IFLA_STATS = 7,
+	IFLA_COST = 8,
+	IFLA_PRIORITY = 9,
+	IFLA_MASTER = 10,
+	IFLA_WIRELESS = 11,
+	IFLA_PROTINFO = 12,
+	IFLA_TXQLEN = 13,
+	IFLA_MAP = 14,
+	IFLA_WEIGHT = 15,
+	IFLA_OPERSTATE = 16,
+	IFLA_LINKMODE = 17,
+	IFLA_LINKINFO = 18,
+	IFLA_NET_NS_PID = 19,
+	IFLA_IFALIAS = 20,
+	IFLA_NUM_VF = 21,
+	IFLA_VFINFO_LIST = 22,
+	IFLA_STATS64 = 23,
+	IFLA_VF_PORTS = 24,
+	IFLA_PORT_SELF = 25,
+	IFLA_AF_SPEC = 26,
+	IFLA_GROUP = 27,
+	IFLA_NET_NS_FD = 28,
+	IFLA_EXT_MASK = 29,
+	IFLA_PROMISCUITY = 30,
+	IFLA_NUM_TX_QUEUES = 31,
+	IFLA_NUM_RX_QUEUES = 32,
+	IFLA_CARRIER = 33,
+	IFLA_PHYS_PORT_ID = 34,
+	IFLA_CARRIER_CHANGES = 35,
+	IFLA_PHYS_SWITCH_ID = 36,
+	IFLA_LINK_NETNSID = 37,
+	IFLA_PHYS_PORT_NAME = 38,
+	IFLA_PROTO_DOWN = 39,
+	IFLA_GSO_MAX_SEGS = 40,
+	IFLA_GSO_MAX_SIZE = 41,
+	IFLA_PAD = 42,
+	IFLA_XDP = 43,
+	IFLA_EVENT = 44,
+	IFLA_NEW_NETNSID = 45,
+	IFLA_IF_NETNSID = 46,
+	IFLA_TARGET_NETNSID = 46,
+	IFLA_CARRIER_UP_COUNT = 47,
+	IFLA_CARRIER_DOWN_COUNT = 48,
+	IFLA_NEW_IFINDEX = 49,
+	IFLA_MIN_MTU = 50,
+	IFLA_MAX_MTU = 51,
+	IFLA_PROP_LIST = 52,
+	IFLA_ALT_IFNAME = 53,
+	IFLA_PERM_ADDRESS = 54,
+	IFLA_PROTO_DOWN_REASON = 55,
+	IFLA_PARENT_DEV_NAME = 56,
+	IFLA_PARENT_DEV_BUS_NAME = 57,
+	IFLA_GRO_MAX_SIZE = 58,
+	IFLA_TSO_MAX_SIZE = 59,
+	IFLA_TSO_MAX_SEGS = 60,
+	IFLA_ALLMULTI = 61,
+	IFLA_DEVLINK_PORT = 62,
+	IFLA_GSO_IPV4_MAX_SIZE = 63,
+	IFLA_GRO_IPV4_MAX_SIZE = 64,
+	IFLA_DPLL_PIN = 65,
+	__IFLA_MAX = 66,
+};
+
+struct rtmsg {
+	unsigned char rtm_family;
+	unsigned char rtm_dst_len;
+	unsigned char rtm_src_len;
+	unsigned char rtm_tos;
+	unsigned char rtm_table;
+	unsigned char rtm_protocol;
+	unsigned char rtm_scope;
+	unsigned char rtm_type;
+	unsigned int rtm_flags;
+};
+
+enum rtattr_type_t {
+	RTA_UNSPEC = 0,
+	RTA_DST = 1,
+	RTA_SRC = 2,
+	RTA_IIF = 3,
+	RTA_OIF = 4,
+	RTA_GATEWAY = 5,
+	RTA_PRIORITY = 6,
+	RTA_PREFSRC = 7,
+	RTA_METRICS = 8,
+	RTA_MULTIPATH = 9,
+	RTA_PROTOINFO = 10,
+	RTA_FLOW = 11,
+	RTA_CACHEINFO = 12,
+	RTA_SESSION = 13,
+	RTA_MP_ALGO = 14,
+	RTA_TABLE = 15,
+	RTA_MARK = 16,
+	RTA_MFC_STATS = 17,
+	RTA_VIA = 18,
+	RTA_NEWDST = 19,
+	RTA_PREF = 20,
+	RTA_ENCAP_TYPE = 21,
+	RTA_ENCAP = 22,
+	RTA_EXPIRES = 23,
+	RTA_PAD = 24,
+	RTA_UID = 25,
+	RTA_TTL_PROPAGATE = 26,
+	RTA_IP_PROTO = 27,
+	RTA_SPORT = 28,
+	RTA_DPORT = 29,
+	RTA_NH_ID = 30,
+	__RTA_MAX = 31,
+};
+
+struct rtnexthop {
+	short unsigned int rtnh_len;
+	unsigned char rtnh_flags;
+	unsigned char rtnh_hops;
+	int rtnh_ifindex;
+};
+
+struct ifinfomsg {
+	unsigned char ifi_family;
+	unsigned char __ifi_pad;
+	short unsigned int ifi_type;
+	int ifi_index;
+	unsigned int ifi_flags;
+	unsigned int ifi_change;
+};
+
+enum {
+	PIM_TYPE_HELLO = 0,
+	PIM_TYPE_REGISTER = 1,
+	PIM_TYPE_REGISTER_STOP = 2,
+	PIM_TYPE_JOIN_PRUNE = 3,
+	PIM_TYPE_BOOTSTRAP = 4,
+	PIM_TYPE_ASSERT = 5,
+	PIM_TYPE_GRAFT = 6,
+	PIM_TYPE_GRAFT_ACK = 7,
+	PIM_TYPE_CANDIDATE_RP_ADV = 8,
+};
+
+struct pimreghdr {
+	__u8 type;
+	__u8 reserved;
+	__be16 csum;
+	__be32 flags;
+};
+
+typedef short unsigned int vifi_t;
+
+struct vifctl {
+	vifi_t vifc_vifi;
+	unsigned char vifc_flags;
+	unsigned char vifc_threshold;
+	unsigned int vifc_rate_limit;
+	union {
+		struct in_addr vifc_lcl_addr;
+		int vifc_lcl_ifindex;
+	};
+	struct in_addr vifc_rmt_addr;
+};
+
+struct mfcctl {
+	struct in_addr mfcc_origin;
+	struct in_addr mfcc_mcastgrp;
+	vifi_t mfcc_parent;
+	unsigned char mfcc_ttls[32];
+	unsigned int mfcc_pkt_cnt;
+	unsigned int mfcc_byte_cnt;
+	unsigned int mfcc_wrong_if;
+	int mfcc_expire;
+};
+
+struct sioc_sg_req {
+	struct in_addr src;
+	struct in_addr grp;
+	long unsigned int pktcnt;
+	long unsigned int bytecnt;
+	long unsigned int wrong_if;
+};
+
+struct sioc_vif_req {
+	vifi_t vifi;
+	long unsigned int icount;
+	long unsigned int ocount;
+	long unsigned int ibytes;
+	long unsigned int obytes;
+};
+
+struct igmpmsg {
+	__u32 unused1;
+	__u32 unused2;
+	unsigned char im_msgtype;
+	unsigned char im_mbz;
+	unsigned char im_vif;
+	unsigned char im_vif_hi;
+	struct in_addr im_src;
+	struct in_addr im_dst;
+};
+
+enum {
+	IPMRA_TABLE_UNSPEC = 0,
+	IPMRA_TABLE_ID = 1,
+	IPMRA_TABLE_CACHE_RES_QUEUE_LEN = 2,
+	IPMRA_TABLE_MROUTE_REG_VIF_NUM = 3,
+	IPMRA_TABLE_MROUTE_DO_ASSERT = 4,
+	IPMRA_TABLE_MROUTE_DO_PIM = 5,
+	IPMRA_TABLE_VIFS = 6,
+	IPMRA_TABLE_MROUTE_DO_WRVIFWHOLE = 7,
+	__IPMRA_TABLE_MAX = 8,
+};
+
+enum {
+	IPMRA_VIF_UNSPEC = 0,
+	IPMRA_VIF = 1,
+	__IPMRA_VIF_MAX = 2,
+};
+
+enum {
+	IPMRA_VIFA_UNSPEC = 0,
+	IPMRA_VIFA_IFINDEX = 1,
+	IPMRA_VIFA_VIF_ID = 2,
+	IPMRA_VIFA_FLAGS = 3,
+	IPMRA_VIFA_BYTES_IN = 4,
+	IPMRA_VIFA_BYTES_OUT = 5,
+	IPMRA_VIFA_PACKETS_IN = 6,
+	IPMRA_VIFA_PACKETS_OUT = 7,
+	IPMRA_VIFA_LOCAL_ADDR = 8,
+	IPMRA_VIFA_REMOTE_ADDR = 9,
+	IPMRA_VIFA_PAD = 10,
+	__IPMRA_VIFA_MAX = 11,
+};
+
+enum {
+	IPMRA_CREPORT_UNSPEC = 0,
+	IPMRA_CREPORT_MSGTYPE = 1,
+	IPMRA_CREPORT_VIF_ID = 2,
+	IPMRA_CREPORT_SRC_ADDR = 3,
+	IPMRA_CREPORT_DST_ADDR = 4,
+	IPMRA_CREPORT_PKT = 5,
+	IPMRA_CREPORT_TABLE = 6,
+	__IPMRA_CREPORT_MAX = 7,
+};
+
+struct fib_dump_filter {
+	u32 table_id;
+	bool filter_set;
+	bool dump_routes;
+	bool dump_exceptions;
+	bool rtnl_held;
+	unsigned char protocol;
+	unsigned char rt_type;
+	unsigned int flags;
+	struct net_device *dev;
+};
+
+struct vif_device {
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	long unsigned int bytes_in;
+	long unsigned int bytes_out;
+	long unsigned int pkt_in;
+	long unsigned int pkt_out;
+	long unsigned int rate_limit;
+	unsigned char threshold;
+	short unsigned int flags;
+	int link;
+	struct netdev_phys_item_id dev_parent_id;
+	__be32 local;
+	__be32 remote;
+};
+
+struct vif_entry_notifier_info {
+	struct fib_notifier_info info;
+	struct net_device *dev;
+	short unsigned int vif_index;
+	short unsigned int vif_flags;
+	u32 tb_id;
+};
+
+enum {
+	MFC_STATIC = 1,
+	MFC_OFFLOAD = 2,
+};
+
+struct mr_mfc {
+	struct rhlist_head mnode;
+	short unsigned int mfc_parent;
+	int mfc_flags;
+	union {
+		struct {
+			long unsigned int expires;
+			struct sk_buff_head unresolved;
+		} unres;
+		struct {
+			long unsigned int last_assert;
+			int minvif;
+			int maxvif;
+			long unsigned int bytes;
+			long unsigned int pkt;
+			long unsigned int wrong_if;
+			long unsigned int lastuse;
+			unsigned char ttls[32];
+			refcount_t refcount;
+		} res;
+	} mfc_un;
+	struct list_head list;
+	struct callback_head rcu;
+	void (*free)(struct callback_head *);
+};
+
+struct mfc_entry_notifier_info {
+	struct fib_notifier_info info;
+	struct mr_mfc *mfc;
+	u32 tb_id;
+};
+
+struct mr_table_ops {
+	const struct rhashtable_params *rht_params;
+	void *cmparg_any;
+};
+
+struct mr_table {
+	struct list_head list;
+	possible_net_t net;
+	struct mr_table_ops ops;
+	u32 id;
+	struct sock *mroute_sk;
+	struct timer_list ipmr_expire_timer;
+	struct list_head mfc_unres_queue;
+	struct vif_device vif_table[32];
+	struct rhltable mfc_hash;
+	struct list_head mfc_cache_list;
+	int maxvif;
+	atomic_t cache_resolve_queue_len;
+	bool mroute_do_assert;
+	bool mroute_do_pim;
+	bool mroute_do_wrvifwhole;
+	int mroute_reg_vif_num;
+};
+
+struct mr_vif_iter {
+	struct seq_net_private p;
+	struct mr_table *mrt;
+	int ct;
+};
+
+struct mr_mfc_iter {
+	struct seq_net_private p;
+	struct mr_table *mrt;
+	struct list_head *cache;
+	spinlock_t *lock;
+};
+
+struct mfc_cache_cmp_arg {
+	__be32 mfc_mcastgrp;
+	__be32 mfc_origin;
+};
+
+struct mfc_cache {
+	struct mr_mfc _c;
+	union {
+		struct {
+			__be32 mfc_mcastgrp;
+			__be32 mfc_origin;
+		};
+		struct mfc_cache_cmp_arg cmparg;
+	};
+};
+
+struct icmp_filter {
+	__u32 data;
+};
+
+struct raw_sock {
+	struct inet_sock inet;
+	struct icmp_filter filter;
+	u32 ipmr_table;
+};
+
+enum {
+	NETCONFA_UNSPEC = 0,
+	NETCONFA_IFINDEX = 1,
+	NETCONFA_FORWARDING = 2,
+	NETCONFA_RP_FILTER = 3,
+	NETCONFA_MC_FORWARDING = 4,
+	NETCONFA_PROXY_NEIGH = 5,
+	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN = 6,
+	NETCONFA_INPUT = 7,
+	NETCONFA_BC_FORWARDING = 8,
+	__NETCONFA_MAX = 9,
+};
+
+struct ipmr_result {
+	struct mr_table *mrt;
+};
+
+struct xfrm_dst_lookup_params {
+	struct net *net;
+	int tos;
+	int oif;
+	xfrm_address_t *saddr;
+	xfrm_address_t *daddr;
+	u32 mark;
+	__u8 ipproto;
+	union flowi_uli uli;
+};
+
+struct xfrm_dst;
+
+struct xfrm_policy_afinfo {
+	struct dst_ops *dst_ops;
+	struct dst_entry * (*dst_lookup)(const struct xfrm_dst_lookup_params *);
+	int (*get_saddr)(xfrm_address_t *, const struct xfrm_dst_lookup_params *);
+	int (*fill_dst)(struct xfrm_dst *, struct net_device *, const struct flowi *);
+	struct dst_entry * (*blackhole_route)(struct net *, struct dst_entry *);
+};
+
+struct xfrm_dst {
+	union {
+		struct dst_entry dst;
+		struct rtable rt;
+		struct rt6_info rt6;
+	} u;
+	struct dst_entry *route;
+	struct dst_entry *child;
+	struct dst_entry *path;
+	struct xfrm_policy *pols[2];
+	int num_pols;
+	int num_xfrms;
+	u32 xfrm_genid;
+	u32 policy_genid;
+	u32 route_mtu_cached;
+	u32 child_mtu_cached;
+	u32 route_cookie;
+	u32 path_cookie;
+};
+
+struct ip_tunnel;
+
+struct ip6_tnl;
+
+struct xfrm_tunnel_skb_cb {
+	union {
+		struct inet_skb_parm h4;
+		struct inet6_skb_parm h6;
+	} header;
+	union {
+		struct ip_tunnel *ip4;
+		struct ip6_tnl *ip6;
+	} tunnel;
+};
+
+struct xfrm_mode_skb_cb {
+	struct xfrm_tunnel_skb_cb header;
+	__be16 id;
+	__be16 frag_off;
+	u8 ihl;
+	u8 tos;
+	u8 ttl;
+	u8 protocol;
+	u8 optlen;
+	u8 flow_lbl[3];
+};
+
+struct xfrm_spi_skb_cb {
+	struct xfrm_tunnel_skb_cb header;
+	unsigned int daddroff;
+	unsigned int family;
+	__be32 seq;
+};
+
+typedef struct sk_buff * (*gro_receive_t)(struct list_head *, struct sk_buff *);
+
+enum xfrm_sa_dir {
+	XFRM_SA_DIR_IN = 1,
+	XFRM_SA_DIR_OUT = 2,
+};
+
+struct ip_beet_phdr {
+	__u8 nexthdr;
+	__u8 hdrlen;
+	__u8 padlen;
+	__u8 reserved;
+};
+
+enum {
+	XFRM_MODE_FLAG_TUNNEL = 1,
+};
+
+enum {
+	XFRM_STATE_VOID = 0,
+	XFRM_STATE_ACQ = 1,
+	XFRM_STATE_VALID = 2,
+	XFRM_STATE_ERROR = 3,
+	XFRM_STATE_EXPIRED = 4,
+	XFRM_STATE_DEAD = 5,
+};
+
+struct xfrm_state_afinfo {
+	u8 family;
+	u8 proto;
+	const struct xfrm_type_offload *type_offload_esp;
+	const struct xfrm_type *type_esp;
+	const struct xfrm_type *type_ipip;
+	const struct xfrm_type *type_ipip6;
+	const struct xfrm_type *type_comp;
+	const struct xfrm_type *type_ah;
+	const struct xfrm_type *type_routing;
+	const struct xfrm_type *type_dstopts;
+	int (*output)(struct net *, struct sock *, struct sk_buff *);
+	int (*transport_finish)(struct sk_buff *, int);
+	void (*local_error)(struct sk_buff *, u32);
+};
+
+struct xfrm_input_afinfo {
+	u8 family;
+	bool is_ipip;
+	int (*callback)(struct sk_buff *, u8, int);
+};
+
+struct ip_tunnel_6rd_parm {
+	struct in6_addr prefix;
+	__be32 relay_prefix;
+	u16 prefixlen;
+	u16 relay_prefixlen;
+};
+
+struct ip_tunnel_prl_entry;
+
+struct ip_tunnel {
+	struct ip_tunnel *next;
+	struct hlist_node hash_node;
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	struct net *net;
+	long unsigned int err_time;
+	int err_count;
+	u32 i_seqno;
+	atomic_t o_seqno;
+	int tun_hlen;
+	u32 index;
+	u8 erspan_ver;
+	u8 dir;
+	u16 hwid;
+	struct dst_cache dst_cache;
+	struct ip_tunnel_parm_kern parms;
+	int mlink;
+	int encap_hlen;
+	int hlen;
+	struct ip_tunnel_encap encap;
+	struct ip_tunnel_6rd_parm ip6rd;
+	struct ip_tunnel_prl_entry *prl;
+	unsigned int prl_count;
+	unsigned int ip_tnl_net_id;
+	struct gro_cells gro_cells;
+	__u32 fwmark;
+	bool collect_md;
+	bool ignore_df;
+};
+
+struct __ip6_tnl_fmr;
+
+struct __ip6_tnl_parm {
+	char name[16];
+	int link;
+	__u8 proto;
+	__u8 encap_limit;
+	__u8 hop_limit;
+	bool collect_md;
+	__be32 flowinfo;
+	__u32 flags;
+	struct in6_addr laddr;
+	struct in6_addr raddr;
+	struct __ip6_tnl_fmr *fmrs;
+	long unsigned int i_flags[1];
+	long unsigned int o_flags[1];
+	__be32 i_key;
+	__be32 o_key;
+	__u32 fwmark;
+	__u32 index;
+	__u8 erspan_ver;
+	__u8 dir;
+	__u16 hwid;
+};
+
+struct ip6_tnl {
+	struct ip6_tnl *next;
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	struct net *net;
+	struct __ip6_tnl_parm parms;
+	long: 32;
+	struct flowi fl;
+	struct dst_cache dst_cache;
+	struct gro_cells gro_cells;
+	int err_count;
+	long unsigned int err_time;
+	__u32 i_seqno;
+	atomic_t o_seqno;
+	int hlen;
+	int tun_hlen;
+	int encap_hlen;
+	struct ip_tunnel_encap encap;
+	int mlink;
+	long: 32;
+};
+
+struct xfrm_skb_cb {
+	struct xfrm_tunnel_skb_cb header;
+	union {
+		struct {
+			__u32 low;
+			__u32 hi;
+		} output;
+		struct {
+			__be32 low;
+			__be32 hi;
+		} input;
+	} seq;
+};
+
+struct ip_tunnel_prl_entry {
+	struct ip_tunnel_prl_entry *next;
+	__be32 addr;
+	u16 flags;
+	struct callback_head callback_head;
+};
+
+struct __ip6_tnl_fmr {
+	struct __ip6_tnl_fmr *next;
+	struct in6_addr ip6_prefix;
+	struct in_addr ip4_prefix;
+	__u8 ip6_prefix_len;
+	__u8 ip4_prefix_len;
+	__u8 ea_len;
+	__u8 offset;
+};
+
+struct xfrm_trans_tasklet {
+	struct work_struct work;
+	spinlock_t queue_lock;
+	struct sk_buff_head queue;
+};
+
+struct xfrm_trans_cb {
+	union {
+		struct inet_skb_parm h4;
+		struct inet6_skb_parm h6;
+	} header;
+	int (*finish)(struct net *, struct sock *, struct sk_buff *);
+	struct net *net;
+};
+
+enum {
+	BPF_F_CURRENT_NETNS = -1,
+};
+
+struct bpf_xfrm_state_opts {
+	s32 error;
+	s32 netns_id;
+	u32 mark;
+	xfrm_address_t daddr;
+	__be32 spi;
+	u8 proto;
+	u16 family;
+};
+
+enum {
+	BPF_XFRM_STATE_OPTS_SZ = 36,
+};
+
+struct sk_psock_progs {
+	struct bpf_prog *msg_parser;
+	struct bpf_prog *stream_parser;
+	struct bpf_prog *stream_verdict;
+	struct bpf_prog *skb_verdict;
+	struct bpf_link *msg_parser_link;
+	struct bpf_link *stream_parser_link;
+	struct bpf_link *stream_verdict_link;
+	struct bpf_link *skb_verdict_link;
+};
+
+struct sk_psock_work_state {
+	u32 len;
+	u32 off;
+};
+
+struct sk_msg;
+
+struct sk_psock {
+	struct sock *sk;
+	struct sock *sk_redir;
+	u32 apply_bytes;
+	u32 cork_bytes;
+	u32 eval;
+	bool redir_ingress;
+	struct sk_msg *cork;
+	struct sk_psock_progs progs;
+	struct sk_buff_head ingress_skb;
+	struct list_head ingress_msg;
+	spinlock_t ingress_lock;
+	long unsigned int state;
+	struct list_head link;
+	spinlock_t link_lock;
+	refcount_t refcnt;
+	void (*saved_unhash)(struct sock *);
+	void (*saved_destroy)(struct sock *);
+	void (*saved_close)(struct sock *, long int);
+	void (*saved_write_space)(struct sock *);
+	void (*saved_data_ready)(struct sock *);
+	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
+	struct proto *sk_proto;
+	struct mutex work_mutex;
+	struct sk_psock_work_state work_state;
+	struct delayed_work work;
+	struct sock *sk_pair;
+	struct rcu_work rwork;
+};
+
+struct sk_msg_sg {
+	u32 start;
+	u32 curr;
+	u32 end;
+	u32 size;
+	u32 copybreak;
+	long unsigned int copy[1];
+	struct scatterlist data[19];
+};
+
+struct sk_msg {
+	struct sk_msg_sg sg;
+	void *data;
+	void *data_end;
+	u32 apply_bytes;
+	u32 cork_bytes;
+	u32 flags;
+	struct sk_buff *skb;
+	struct sock *sk_redir;
+	struct sock *sk;
+	struct list_head list;
+};
+
+struct sockaddr_un {
+	__kernel_sa_family_t sun_family;
+	char sun_path[108];
+};
+
+struct unix_vertex {
+	struct list_head edges;
+	struct list_head entry;
+	struct list_head scc_entry;
+	long unsigned int out_degree;
+	long unsigned int index;
+	long unsigned int scc_index;
+};
+
+struct scm_stat {
+	atomic_t nr_fds;
+	long unsigned int nr_unix_fds;
+};
+
+struct unix_address;
+
+struct unix_sock {
+	struct sock sk;
+	struct unix_address *addr;
+	struct path path;
+	struct mutex iolock;
+	struct mutex bindlock;
+	struct sock *peer;
+	struct sock *listener;
+	struct unix_vertex *vertex;
+	spinlock_t lock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct socket_wq peer_wq;
+	wait_queue_entry_t peer_wake;
+	struct scm_stat scm_stat;
+	struct sk_buff *oob_skb;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct unix_address {
+	refcount_t refcnt;
+	int len;
+	struct sockaddr_un name[0];
+};
+
+struct flow_dissector_key_tags {
+	u32 flow_label;
+};
+
+struct flow_dissector_key_tipc {
+	__be32 key;
+};
+
+struct flow_dissector_key_addrs {
+	union {
+		struct flow_dissector_key_ipv4_addrs v4addrs;
+		struct flow_dissector_key_ipv6_addrs v6addrs;
+		struct flow_dissector_key_tipc tipckey;
+	};
+};
+
+struct flow_keys {
+	struct flow_dissector_key_control control;
+	struct flow_dissector_key_basic basic;
+	struct flow_dissector_key_tags tags;
+	struct flow_dissector_key_vlan vlan;
+	struct flow_dissector_key_vlan cvlan;
+	struct flow_dissector_key_keyid keyid;
+	struct flow_dissector_key_ports ports;
+	struct flow_dissector_key_icmp icmp;
+	struct flow_dissector_key_addrs addrs;
+	long: 32;
+};
+
+struct hop_jumbo_hdr {
+	u8 nexthdr;
+	u8 hdrlen;
+	u8 tlv_type;
+	u8 tlv_len;
+	__be32 jumbo_payload_len;
+};
+
+struct ip6_fraglist_iter {
+	struct ipv6hdr *tmp_hdr;
+	struct sk_buff *frag;
+	int offset;
+	unsigned int hlen;
+	__be32 frag_id;
+	u8 nexthdr;
+};
+
+struct ip6_frag_state {
+	u8 *prevhdr;
+	unsigned int hlen;
+	unsigned int mtu;
+	unsigned int left;
+	int offset;
+	int ptr;
+	int hroom;
+	int troom;
+	__be32 frag_id;
+	u8 nexthdr;
+};
+
+struct ip6_ra_chain {
+	struct ip6_ra_chain *next;
+	struct sock *sk;
+	int sel;
+	void (*destructor)(struct sock *);
+};
+
+struct ipcm6_cookie {
+	struct sockcm_cookie sockc;
+	__s16 hlimit;
+	__s16 tclass;
+	__u16 gso_size;
+	__s8 dontfrag;
+	struct ipv6_txoptions *opt;
+	long: 32;
+};
+
+struct ipv4_addr_key {
+	__be32 addr;
+	int vif;
+};
+
+struct inetpeer_addr {
+	union {
+		struct ipv4_addr_key a4;
+		struct in6_addr a6;
+		u32 key[4];
+	};
+	__u16 family;
+};
+
+struct inet_peer {
+	struct rb_node rb_node;
+	struct inetpeer_addr daddr;
+	u32 metrics[17];
+	u32 rate_tokens;
+	u32 n_redirects;
+	long unsigned int rate_last;
+	union {
+		struct {
+			atomic_t rid;
+		};
+		struct callback_head rcu;
+	};
+	__u32 dtime;
+	refcount_t refcnt;
+};
+
+enum {
+	LWTUNNEL_XMIT_DONE = 0,
+	LWTUNNEL_XMIT_CONTINUE = 256,
+};
+
+enum flow_dissector_ctrl_flags {
+	FLOW_DIS_IS_FRAGMENT = 1,
+	FLOW_DIS_FIRST_FRAG = 2,
+	FLOW_DIS_F_TUNNEL_CSUM = 4,
+	FLOW_DIS_F_TUNNEL_DONT_FRAGMENT = 8,
+	FLOW_DIS_F_TUNNEL_OAM = 16,
+	FLOW_DIS_F_TUNNEL_CRIT_OPT = 32,
+	FLOW_DIS_ENCAPSULATION = 64,
+};
+
+struct uncached_list {
+	spinlock_t lock;
+	struct list_head head;
+};
+
+struct inet6_ifaddr {
+	struct in6_addr addr;
+	__u32 prefix_len;
+	__u32 rt_priority;
+	__u32 valid_lft;
+	__u32 prefered_lft;
+	refcount_t refcnt;
+	spinlock_t lock;
+	int state;
+	__u32 flags;
+	__u8 dad_probes;
+	__u8 stable_privacy_retry;
+	__u16 scope;
+	long: 32;
+	__u64 dad_nonce;
+	long unsigned int cstamp;
+	long unsigned int tstamp;
+	struct delayed_work dad_work;
+	struct inet6_dev *idev;
+	struct fib6_info *rt;
+	struct hlist_node addr_lst;
+	struct list_head if_list;
+	struct list_head if_list_aux;
+	struct list_head tmp_list;
+	struct inet6_ifaddr *ifpub;
+	int regen_count;
+	bool tokenized;
+	u8 ifa_proto;
+	struct callback_head rcu;
+	struct in6_addr peer_addr;
+};
+
+struct in6_rtmsg {
+	struct in6_addr rtmsg_dst;
+	struct in6_addr rtmsg_src;
+	struct in6_addr rtmsg_gateway;
+	__u32 rtmsg_type;
+	__u16 rtmsg_dst_len;
+	__u16 rtmsg_src_len;
+	__u32 rtmsg_metric;
+	long unsigned int rtmsg_info;
+	__u32 rtmsg_flags;
+	int rtmsg_ifindex;
+};
+
+struct fib6_gc_args {
+	int timeout;
+	int more;
+};
+
+struct rt6_exception {
+	struct hlist_node hlist;
+	struct rt6_info *rt6i;
+	long unsigned int stamp;
+	struct callback_head rcu;
+};
+
+typedef struct rt6_info * (*pol_lookup_t)(struct net *, struct fib6_table *, struct flowi6 *, const struct sk_buff *, int);
+
+struct rd_msg {
+	struct icmp6hdr icmph;
+	struct in6_addr target;
+	struct in6_addr dest;
+	__u8 opt[0];
+};
+
+struct rt6_rtnl_dump_arg {
+	struct sk_buff *skb;
+	struct netlink_callback *cb;
+	struct net *net;
+	struct fib_dump_filter filter;
+};
+
+struct netevent_redirect {
+	struct dst_entry *old;
+	struct dst_entry *new;
+	struct neighbour *neigh;
+	const void *daddr;
+};
+
+struct trace_event_raw_fib6_table_lookup {
+	struct trace_entry ent;
+	u32 tb_id;
+	int err;
+	int oif;
+	int iif;
+	__u8 tos;
+	__u8 scope;
+	__u8 flags;
+	__u8 src[16];
+	__u8 dst[16];
+	u16 sport;
+	u16 dport;
+	u8 proto;
+	u8 rt_type;
+	char name[16];
+	__u8 gw[16];
+	char __data[0];
+};
+
+struct trace_event_data_offsets_fib6_table_lookup {};
+
+typedef void (*btf_trace_fib6_table_lookup)(void *, const struct net *, const struct fib6_result *, struct fib6_table *, const struct flowi6 *);
+
+enum rt6_nud_state {
+	RT6_NUD_FAIL_HARD = -3,
+	RT6_NUD_FAIL_PROBE = -2,
+	RT6_NUD_FAIL_DO_RR = -1,
+	RT6_NUD_SUCCEED = 1,
+};
+
+struct fib6_nh_dm_arg {
+	struct net *net;
+	const struct in6_addr *saddr;
+	int oif;
+	int flags;
+	struct fib6_nh *nh;
+};
+
+struct fib6_nh_frl_arg {
+	u32 flags;
+	int oif;
+	int strict;
+	int *mpri;
+	bool *do_rr;
+	struct fib6_nh *nh;
+};
+
+struct fib6_nh_excptn_arg {
+	struct rt6_info *rt;
+	int plen;
+};
+
+struct fib6_nh_match_arg {
+	const struct net_device *dev;
+	const struct in6_addr *gw;
+	struct fib6_nh *match;
+};
+
+struct fib6_nh_age_excptn_arg {
+	struct fib6_gc_args *gc_args;
+	long unsigned int now;
+};
+
+struct fib6_nh_rd_arg {
+	struct fib6_result *res;
+	struct flowi6 *fl6;
+	const struct in6_addr *gw;
+	struct rt6_info **ret;
+};
+
+struct ip6rd_flowi {
+	struct flowi6 fl6;
+	struct in6_addr gateway;
+};
+
+struct fib6_nh_del_cached_rt_arg {
+	struct fib6_config *cfg;
+	struct fib6_info *f6i;
+};
+
+struct arg_dev_net_ip {
+	struct net *net;
+	struct in6_addr *addr;
+};
+
+struct arg_netdev_event {
+	const struct net_device *dev;
+	union {
+		unsigned char nh_flags;
+		long unsigned int event;
+	};
+};
+
+struct rt6_mtu_change_arg {
+	struct net_device *dev;
+	unsigned int mtu;
+	struct fib6_info *f6i;
+};
+
+struct rt6_nh {
+	struct fib6_info *fib6_info;
+	struct fib6_config r_cfg;
+	struct list_head next;
+};
+
+struct fib6_nh_exception_dump_walker {
+	struct rt6_rtnl_dump_arg *dump;
+	struct fib6_info *rt;
+	unsigned int flags;
+	unsigned int skip;
+	unsigned int count;
+};
+
+struct group_source_req {
+	__u32 gsr_interface;
+	struct __kernel_sockaddr_storage gsr_group;
+	struct __kernel_sockaddr_storage gsr_source;
+};
+
+struct sockaddr_in6 {
+	short unsigned int sin6_family;
+	__be16 sin6_port;
+	__be32 sin6_flowinfo;
+	struct in6_addr sin6_addr;
+	__u32 sin6_scope_id;
+};
+
+struct mld_msg {
+	struct icmp6hdr mld_hdr;
+	struct in6_addr mld_mca;
+};
+
+struct mld2_grec {
+	__u8 grec_type;
+	__u8 grec_auxwords;
+	__be16 grec_nsrcs;
+	struct in6_addr grec_mca;
+	struct in6_addr grec_src[0];
+};
+
+struct mld2_report {
+	struct icmp6hdr mld2r_hdr;
+	struct mld2_grec mld2r_grec[0];
+};
+
+struct mld2_query {
+	struct icmp6hdr mld2q_hdr;
+	struct in6_addr mld2q_mca;
+	__u8 mld2q_qrv: 3;
+	__u8 mld2q_suppress: 1;
+	__u8 mld2q_resv2: 4;
+	__u8 mld2q_qqic;
+	__be16 mld2q_nsrcs;
+	struct in6_addr mld2q_srcs[0];
+};
+
+struct igmp6_mc_iter_state {
+	struct seq_net_private p;
+	struct net_device *dev;
+	struct inet6_dev *idev;
+};
+
+struct igmp6_mcf_iter_state {
+	struct seq_net_private p;
+	struct net_device *dev;
+	struct inet6_dev *idev;
+	struct ifmcaddr6 *im;
+};
+
+struct seg6_pernet_data {
+	struct mutex lock;
+	struct in6_addr *tun_src;
+};
+
+struct ioam6_pernet_data {
+	struct mutex lock;
+	struct rhashtable namespaces;
+	struct rhashtable schemas;
+};
+
+struct rt0_hdr {
+	struct ipv6_rt_hdr rt_hdr;
+	__u32 reserved;
+	struct in6_addr addr[0];
+};
+
+struct ipv6_sr_hdr {
+	__u8 nexthdr;
+	__u8 hdrlen;
+	__u8 type;
+	__u8 segments_left;
+	__u8 first_segment;
+	__u8 flags;
+	__u16 tag;
+	struct in6_addr segments[0];
+};
+
+struct ipv6_rpl_sr_hdr {
+	__u8 nexthdr;
+	__u8 hdrlen;
+	__u8 type;
+	__u8 segments_left;
+	__u32 cmpre: 4;
+	__u32 cmpri: 4;
+	__u32 reserved: 4;
+	__u32 pad: 4;
+	__u32 reserved1: 16;
+	union {
+		struct {
+			struct {} __empty_addr;
+			struct in6_addr addr[0];
+		};
+		struct {
+			struct {} __empty_data;
+			__u8 data[0];
+		};
+	} segments;
+};
+
+struct ioam6_hdr {
+	__u8 opt_type;
+	__u8 opt_len;
+	char: 8;
+	__u8 type;
+};
+
+struct ioam6_trace_hdr {
+	__be16 namespace_id;
+	char: 2;
+	__u8 overflow: 1;
+	__u8 nodelen: 5;
+	__u8 remlen: 7;
+	union {
+		__be32 type_be32;
+		struct {
+			__u32 bit7: 1;
+			__u32 bit6: 1;
+			__u32 bit5: 1;
+			__u32 bit4: 1;
+			__u32 bit3: 1;
+			__u32 bit2: 1;
+			__u32 bit1: 1;
+			__u32 bit0: 1;
+			__u32 bit15: 1;
+			__u32 bit14: 1;
+			__u32 bit13: 1;
+			__u32 bit12: 1;
+			__u32 bit11: 1;
+			__u32 bit10: 1;
+			__u32 bit9: 1;
+			__u32 bit8: 1;
+			__u32 bit23: 1;
+			__u32 bit22: 1;
+			__u32 bit21: 1;
+			__u32 bit20: 1;
+			__u32 bit19: 1;
+			__u32 bit18: 1;
+			__u32 bit17: 1;
+			__u32 bit16: 1;
+		} type;
+	};
+	__u8 data[0];
+};
+
+enum ioam6_event_type {
+	IOAM6_EVENT_UNSPEC = 0,
+	IOAM6_EVENT_TRACE = 1,
+};
+
+struct ioam6_schema;
+
+struct ioam6_namespace {
+	struct rhash_head head;
+	struct callback_head rcu;
+	struct ioam6_schema *schema;
+	__be16 id;
+	__be32 data;
+	__be64 data_wide;
+};
+
+struct ioam6_schema {
+	struct rhash_head head;
+	struct callback_head rcu;
+	struct ioam6_namespace *ns;
+	u32 id;
+	int len;
+	__be32 hdr;
+	u8 data[0];
+};
+
+typedef struct sock * (*udp_lookup_t)(const struct sk_buff *, __be16, __be16);
+
+enum {
+	IOAM6_ATTR_UNSPEC = 0,
+	IOAM6_ATTR_NS_ID = 1,
+	IOAM6_ATTR_NS_DATA = 2,
+	IOAM6_ATTR_NS_DATA_WIDE = 3,
+	IOAM6_ATTR_SC_ID = 4,
+	IOAM6_ATTR_SC_DATA = 5,
+	IOAM6_ATTR_SC_NONE = 6,
+	IOAM6_ATTR_PAD = 7,
+	__IOAM6_ATTR_MAX = 8,
+};
+
+enum {
+	IOAM6_CMD_UNSPEC = 0,
+	IOAM6_CMD_ADD_NAMESPACE = 1,
+	IOAM6_CMD_DEL_NAMESPACE = 2,
+	IOAM6_CMD_DUMP_NAMESPACES = 3,
+	IOAM6_CMD_ADD_SCHEMA = 4,
+	IOAM6_CMD_DEL_SCHEMA = 5,
+	IOAM6_CMD_DUMP_SCHEMAS = 6,
+	IOAM6_CMD_NS_SET_SCHEMA = 7,
+	__IOAM6_CMD_MAX = 8,
+};
+
+enum ioam6_event_attr {
+	IOAM6_EVENT_ATTR_UNSPEC = 0,
+	IOAM6_EVENT_ATTR_TRACE_NAMESPACE = 1,
+	IOAM6_EVENT_ATTR_TRACE_NODELEN = 2,
+	IOAM6_EVENT_ATTR_TRACE_TYPE = 3,
+	IOAM6_EVENT_ATTR_TRACE_DATA = 4,
+	__IOAM6_EVENT_ATTR_MAX = 5,
+};
+
+typedef u8 dscp_t;
+
+struct fib6_rule {
+	struct fib_rule common;
+	struct rt6key src;
+	struct rt6key dst;
+	dscp_t dscp;
+	u8 dscp_full: 1;
+	long: 32;
+};
+
+enum {
+	SEG6_IPTUNNEL_UNSPEC = 0,
+	SEG6_IPTUNNEL_SRH = 1,
+	__SEG6_IPTUNNEL_MAX = 2,
+};
+
+struct seg6_iptunnel_encap {
+	int mode;
+	struct ipv6_sr_hdr srh[0];
+};
+
+enum {
+	SEG6_IPTUN_MODE_INLINE = 0,
+	SEG6_IPTUN_MODE_ENCAP = 1,
+	SEG6_IPTUN_MODE_L2ENCAP = 2,
+	SEG6_IPTUN_MODE_ENCAP_RED = 3,
+	SEG6_IPTUN_MODE_L2ENCAP_RED = 4,
+};
+
+struct seg6_lwt {
+	struct dst_cache cache;
+	struct seg6_iptunnel_encap tuninfo[0];
+};
+
+enum {
+	NDA_UNSPEC = 0,
+	NDA_DST = 1,
+	NDA_LLADDR = 2,
+	NDA_CACHEINFO = 3,
+	NDA_PROBES = 4,
+	NDA_VLAN = 5,
+	NDA_PORT = 6,
+	NDA_VNI = 7,
+	NDA_IFINDEX = 8,
+	NDA_MASTER = 9,
+	NDA_LINK_NETNSID = 10,
+	NDA_SRC_VNI = 11,
+	NDA_PROTOCOL = 12,
+	NDA_NH_ID = 13,
+	NDA_FDB_EXT_ATTRS = 14,
+	NDA_FLAGS_EXT = 15,
+	NDA_NDM_STATE_MASK = 16,
+	NDA_NDM_FLAGS_MASK = 17,
+	__NDA_MAX = 18,
+};
+
+struct nda_cacheinfo {
+	__u32 ndm_confirmed;
+	__u32 ndm_used;
+	__u32 ndm_updated;
+	__u32 ndm_refcnt;
+};
+
+enum {
+	FDB_NOTIFY_BIT = 1,
+	FDB_NOTIFY_INACTIVE_BIT = 2,
+};
+
+enum {
+	NFEA_UNSPEC = 0,
+	NFEA_ACTIVITY_NOTIFY = 1,
+	NFEA_DONT_REFRESH = 2,
+	__NFEA_MAX = 3,
+};
+
+struct __fdb_entry {
+	__u8 mac_addr[6];
+	__u8 port_no;
+	__u8 is_local;
+	__u32 ageing_timer_value;
+	__u8 port_hi;
+	__u8 pad0;
+	__u16 unused;
+};
+
+struct bridge_stp_xstats {
+	__u64 transition_blk;
+	__u64 transition_fwd;
+	__u64 rx_bpdu;
+	__u64 tx_bpdu;
+	__u64 rx_tcn;
+	__u64 tx_tcn;
+};
+
+struct br_mcast_stats {
+	__u64 igmp_v1queries[2];
+	__u64 igmp_v2queries[2];
+	__u64 igmp_v3queries[2];
+	__u64 igmp_leaves[2];
+	__u64 igmp_v1reports[2];
+	__u64 igmp_v2reports[2];
+	__u64 igmp_v3reports[2];
+	__u64 igmp_parse_errors;
+	__u64 mld_v1queries[2];
+	__u64 mld_v2queries[2];
+	__u64 mld_leaves[2];
+	__u64 mld_v1reports[2];
+	__u64 mld_v2reports[2];
+	__u64 mld_parse_errors;
+	__u64 mcast_bytes[2];
+	__u64 mcast_packets[2];
+};
+
+struct br_ip {
+	union {
+		__be32 ip4;
+		struct in6_addr ip6;
+	} src;
+	union {
+		__be32 ip4;
+		struct in6_addr ip6;
+		unsigned char mac_addr[6];
+	} dst;
+	__be16 proto;
+	__u16 vid;
+};
+
+struct bridge_id {
+	unsigned char prio[2];
+	unsigned char addr[6];
+};
+
+typedef struct bridge_id bridge_id;
+
+struct mac_addr {
+	unsigned char addr[6];
+};
+
+typedef struct mac_addr mac_addr;
+
+typedef __u16 port_id;
+
+struct bridge_mcast_own_query {
+	struct timer_list timer;
+	u32 startup_sent;
+};
+
+struct bridge_mcast_other_query {
+	struct timer_list timer;
+	struct timer_list delay_timer;
+};
+
+struct bridge_mcast_querier {
+	struct br_ip addr;
+	int port_ifidx;
+	seqcount_spinlock_t seq;
+};
+
+struct bridge_mcast_stats {
+	struct br_mcast_stats mstats;
+	struct u64_stats_sync syncp;
+	long: 32;
+};
+
+struct net_bridge;
+
+struct net_bridge_vlan;
+
+struct net_bridge_mcast {
+	struct net_bridge *br;
+	struct net_bridge_vlan *vlan;
+	u32 multicast_last_member_count;
+	u32 multicast_startup_query_count;
+	u8 multicast_querier;
+	u8 multicast_igmp_version;
+	u8 multicast_router;
+	u8 multicast_mld_version;
+	long unsigned int multicast_last_member_interval;
+	long unsigned int multicast_membership_interval;
+	long unsigned int multicast_querier_interval;
+	long unsigned int multicast_query_interval;
+	long unsigned int multicast_query_response_interval;
+	long unsigned int multicast_startup_query_interval;
+	struct hlist_head ip4_mc_router_list;
+	struct timer_list ip4_mc_router_timer;
+	struct bridge_mcast_other_query ip4_other_query;
+	struct bridge_mcast_own_query ip4_own_query;
+	struct bridge_mcast_querier ip4_querier;
+	struct hlist_head ip6_mc_router_list;
+	struct timer_list ip6_mc_router_timer;
+	struct bridge_mcast_other_query ip6_other_query;
+	struct bridge_mcast_own_query ip6_own_query;
+	struct bridge_mcast_querier ip6_querier;
+};
+
+struct net_bridge_vlan_group;
+
+struct net_bridge {
+	spinlock_t lock;
+	spinlock_t hash_lock;
+	struct hlist_head frame_type_list;
+	struct net_device *dev;
+	long unsigned int options;
+	__be16 vlan_proto;
+	u16 default_pvid;
+	struct net_bridge_vlan_group *vlgrp;
+	struct rhashtable fdb_hash_tbl;
+	struct list_head port_list;
+	union {
+		struct rtable fake_rtable;
+		struct rt6_info fake_rt6_info;
+	};
+	u16 group_fwd_mask;
+	u16 group_fwd_mask_required;
+	bridge_id designated_root;
+	bridge_id bridge_id;
+	unsigned char topology_change;
+	unsigned char topology_change_detected;
+	u16 root_port;
+	long unsigned int max_age;
+	long unsigned int hello_time;
+	long unsigned int forward_delay;
+	long unsigned int ageing_time;
+	long unsigned int bridge_max_age;
+	long unsigned int bridge_hello_time;
+	long unsigned int bridge_forward_delay;
+	long unsigned int bridge_ageing_time;
+	u32 root_path_cost;
+	u8 group_addr[6];
+	enum {
+		BR_NO_STP = 0,
+		BR_KERNEL_STP = 1,
+		BR_USER_STP = 2,
+	} stp_enabled;
+	struct net_bridge_mcast multicast_ctx;
+	struct bridge_mcast_stats *mcast_stats;
+	u32 hash_max;
+	spinlock_t multicast_lock;
+	struct rhashtable mdb_hash_tbl;
+	struct rhashtable sg_port_tbl;
+	struct hlist_head mcast_gc_list;
+	struct hlist_head mdb_list;
+	struct work_struct mcast_gc_work;
+	struct timer_list hello_timer;
+	struct timer_list tcn_timer;
+	struct timer_list topology_change_timer;
+	struct delayed_work gc_work;
+	struct kobject *ifobj;
+	u32 auto_cnt;
+	atomic_t fdb_n_learned;
+	u32 fdb_max_learned;
+	int last_hwdom;
+	long unsigned int busy_hwdoms;
+	struct hlist_head fdb_list;
+};
+
+struct net_bridge_port;
+
+struct net_bridge_mcast_port {
+	struct net_bridge_port *port;
+	struct net_bridge_vlan *vlan;
+	struct bridge_mcast_own_query ip4_own_query;
+	struct timer_list ip4_mc_router_timer;
+	struct hlist_node ip4_rlist;
+	struct bridge_mcast_own_query ip6_own_query;
+	struct timer_list ip6_mc_router_timer;
+	struct hlist_node ip6_rlist;
+	unsigned char multicast_router;
+	u32 mdb_n_entries;
+	u32 mdb_max_entries;
+};
+
+struct net_bridge_port {
+	struct net_bridge *br;
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	struct list_head list;
+	long unsigned int flags;
+	struct net_bridge_vlan_group *vlgrp;
+	struct net_bridge_port *backup_port;
+	u32 backup_nhid;
+	u8 priority;
+	u8 state;
+	u16 port_no;
+	unsigned char topology_change_ack;
+	unsigned char config_pending;
+	port_id port_id;
+	port_id designated_port;
+	bridge_id designated_root;
+	bridge_id designated_bridge;
+	u32 path_cost;
+	u32 designated_cost;
+	long unsigned int designated_age;
+	struct timer_list forward_delay_timer;
+	struct timer_list hold_timer;
+	struct timer_list message_age_timer;
+	struct kobject kobj;
+	struct callback_head rcu;
+	struct net_bridge_mcast_port multicast_ctx;
+	struct bridge_mcast_stats *mcast_stats;
+	u32 multicast_eht_hosts_limit;
+	u32 multicast_eht_hosts_cnt;
+	struct hlist_head mglist;
+	char sysfs_name[16];
+	struct netpoll *np;
+	int hwdom;
+	int offload_count;
+	struct netdev_phys_item_id ppid;
+	u16 group_fwd_mask;
+	u16 backup_redirected_cnt;
+	struct bridge_stp_xstats stp_xstats;
+};
+
+struct br_tunnel_info {
+	__be64 tunnel_id;
+	struct metadata_dst *tunnel_dst;
+	long: 32;
+};
+
+struct net_bridge_vlan {
+	struct rhash_head vnode;
+	struct rhash_head tnode;
+	u16 vid;
+	u16 flags;
+	u16 priv_flags;
+	u8 state;
+	struct pcpu_sw_netstats *stats;
+	union {
+		struct net_bridge *br;
+		struct net_bridge_port *port;
+	};
+	union {
+		refcount_t refcnt;
+		struct net_bridge_vlan *brvlan;
+	};
+	long: 32;
+	struct br_tunnel_info tinfo;
+	union {
+		struct net_bridge_mcast br_mcast_ctx;
+		struct net_bridge_mcast_port port_mcast_ctx;
+	};
+	u16 msti;
+	struct list_head vlist;
+	struct callback_head rcu;
+};
+
+struct net_bridge_vlan_group {
+	struct rhashtable vlan_hash;
+	struct rhashtable tunnel_hash;
+	struct list_head vlan_list;
+	u16 num_vlans;
+	u16 pvid;
+	u8 pvid_state;
+};
+
+enum {
+	BR_FDB_LOCAL = 0,
+	BR_FDB_STATIC = 1,
+	BR_FDB_STICKY = 2,
+	BR_FDB_ADDED_BY_USER = 3,
+	BR_FDB_ADDED_BY_EXT_LEARN = 4,
+	BR_FDB_OFFLOADED = 5,
+	BR_FDB_NOTIFY = 6,
+	BR_FDB_NOTIFY_INACTIVE = 7,
+	BR_FDB_LOCKED = 8,
+	BR_FDB_DYNAMIC_LEARNED = 9,
+};
+
+struct net_bridge_fdb_key {
+	mac_addr addr;
+	u16 vlan_id;
+};
+
+struct net_bridge_fdb_entry {
+	struct rhash_head rhnode;
+	struct net_bridge_port *dst;
+	struct net_bridge_fdb_key key;
+	struct hlist_node fdb_node;
+	long unsigned int flags;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long unsigned int updated;
+	long unsigned int used;
+	struct callback_head rcu;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct net_bridge_fdb_flush_desc {
+	long unsigned int flags;
+	long unsigned int flags_mask;
+	int port_ifindex;
+	u16 vlan_id;
+};
+
+enum switchdev_attr_id {
+	SWITCHDEV_ATTR_ID_UNDEFINED = 0,
+	SWITCHDEV_ATTR_ID_PORT_STP_STATE = 1,
+	SWITCHDEV_ATTR_ID_PORT_MST_STATE = 2,
+	SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS = 3,
+	SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS = 4,
+	SWITCHDEV_ATTR_ID_PORT_MROUTER = 5,
+	SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME = 6,
+	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING = 7,
+	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_PROTOCOL = 8,
+	SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED = 9,
+	SWITCHDEV_ATTR_ID_BRIDGE_MROUTER = 10,
+	SWITCHDEV_ATTR_ID_BRIDGE_MST = 11,
+	SWITCHDEV_ATTR_ID_MRP_PORT_ROLE = 12,
+	SWITCHDEV_ATTR_ID_VLAN_MSTI = 13,
+};
+
+struct switchdev_attr {
+	struct net_device *orig_dev;
+	enum switchdev_attr_id id;
+	u32 flags;
+	void *complete_priv;
+	void (*complete)(struct net_device *, int, void *);
+	union {
+		u8 stp_state;
+		struct switchdev_mst_state mst_state;
+		struct switchdev_brport_flags brport_flags;
+		bool mrouter;
+		clock_t ageing_time;
+		bool vlan_filtering;
+		u16 vlan_protocol;
+		bool mst;
+		bool mc_disabled;
+		u8 mrp_port_role;
+		struct switchdev_vlan_msti vlan_msti;
+	} u;
+};
+
+enum net_bridge_opts {
+	BROPT_VLAN_ENABLED = 0,
+	BROPT_VLAN_STATS_ENABLED = 1,
+	BROPT_NF_CALL_IPTABLES = 2,
+	BROPT_NF_CALL_IP6TABLES = 3,
+	BROPT_NF_CALL_ARPTABLES = 4,
+	BROPT_GROUP_ADDR_SET = 5,
+	BROPT_MULTICAST_ENABLED = 6,
+	BROPT_MULTICAST_QUERY_USE_IFADDR = 7,
+	BROPT_MULTICAST_STATS_ENABLED = 8,
+	BROPT_HAS_IPV6_ADDR = 9,
+	BROPT_NEIGH_SUPPRESS_ENABLED = 10,
+	BROPT_MTU_SET_BY_USER = 11,
+	BROPT_VLAN_STATS_PER_PORT = 12,
+	BROPT_NO_LL_LEARN = 13,
+	BROPT_VLAN_BRIDGE_BINDING = 14,
+	BROPT_MCAST_VLAN_SNOOPING_ENABLED = 15,
+	BROPT_MST_ENABLED = 16,
+};
+
+struct br_config_bpdu {
+	unsigned int topology_change: 1;
+	unsigned int topology_change_ack: 1;
+	bridge_id root;
+	int root_path_cost;
+	bridge_id bridge_id;
+	port_id port_id;
+	int message_age;
+	int max_age;
+	int hello_time;
+	int forward_delay;
+};
+
+enum {
+	IFLA_BR_UNSPEC = 0,
+	IFLA_BR_FORWARD_DELAY = 1,
+	IFLA_BR_HELLO_TIME = 2,
+	IFLA_BR_MAX_AGE = 3,
+	IFLA_BR_AGEING_TIME = 4,
+	IFLA_BR_STP_STATE = 5,
+	IFLA_BR_PRIORITY = 6,
+	IFLA_BR_VLAN_FILTERING = 7,
+	IFLA_BR_VLAN_PROTOCOL = 8,
+	IFLA_BR_GROUP_FWD_MASK = 9,
+	IFLA_BR_ROOT_ID = 10,
+	IFLA_BR_BRIDGE_ID = 11,
+	IFLA_BR_ROOT_PORT = 12,
+	IFLA_BR_ROOT_PATH_COST = 13,
+	IFLA_BR_TOPOLOGY_CHANGE = 14,
+	IFLA_BR_TOPOLOGY_CHANGE_DETECTED = 15,
+	IFLA_BR_HELLO_TIMER = 16,
+	IFLA_BR_TCN_TIMER = 17,
+	IFLA_BR_TOPOLOGY_CHANGE_TIMER = 18,
+	IFLA_BR_GC_TIMER = 19,
+	IFLA_BR_GROUP_ADDR = 20,
+	IFLA_BR_FDB_FLUSH = 21,
+	IFLA_BR_MCAST_ROUTER = 22,
+	IFLA_BR_MCAST_SNOOPING = 23,
+	IFLA_BR_MCAST_QUERY_USE_IFADDR = 24,
+	IFLA_BR_MCAST_QUERIER = 25,
+	IFLA_BR_MCAST_HASH_ELASTICITY = 26,
+	IFLA_BR_MCAST_HASH_MAX = 27,
+	IFLA_BR_MCAST_LAST_MEMBER_CNT = 28,
+	IFLA_BR_MCAST_STARTUP_QUERY_CNT = 29,
+	IFLA_BR_MCAST_LAST_MEMBER_INTVL = 30,
+	IFLA_BR_MCAST_MEMBERSHIP_INTVL = 31,
+	IFLA_BR_MCAST_QUERIER_INTVL = 32,
+	IFLA_BR_MCAST_QUERY_INTVL = 33,
+	IFLA_BR_MCAST_QUERY_RESPONSE_INTVL = 34,
+	IFLA_BR_MCAST_STARTUP_QUERY_INTVL = 35,
+	IFLA_BR_NF_CALL_IPTABLES = 36,
+	IFLA_BR_NF_CALL_IP6TABLES = 37,
+	IFLA_BR_NF_CALL_ARPTABLES = 38,
+	IFLA_BR_VLAN_DEFAULT_PVID = 39,
+	IFLA_BR_PAD = 40,
+	IFLA_BR_VLAN_STATS_ENABLED = 41,
+	IFLA_BR_MCAST_STATS_ENABLED = 42,
+	IFLA_BR_MCAST_IGMP_VERSION = 43,
+	IFLA_BR_MCAST_MLD_VERSION = 44,
+	IFLA_BR_VLAN_STATS_PER_PORT = 45,
+	IFLA_BR_MULTI_BOOLOPT = 46,
+	IFLA_BR_MCAST_QUERIER_STATE = 47,
+	IFLA_BR_FDB_N_LEARNED = 48,
+	IFLA_BR_FDB_MAX_LEARNED = 49,
+	__IFLA_BR_MAX = 50,
+};
+
+enum {
+	IFLA_BRPORT_UNSPEC = 0,
+	IFLA_BRPORT_STATE = 1,
+	IFLA_BRPORT_PRIORITY = 2,
+	IFLA_BRPORT_COST = 3,
+	IFLA_BRPORT_MODE = 4,
+	IFLA_BRPORT_GUARD = 5,
+	IFLA_BRPORT_PROTECT = 6,
+	IFLA_BRPORT_FAST_LEAVE = 7,
+	IFLA_BRPORT_LEARNING = 8,
+	IFLA_BRPORT_UNICAST_FLOOD = 9,
+	IFLA_BRPORT_PROXYARP = 10,
+	IFLA_BRPORT_LEARNING_SYNC = 11,
+	IFLA_BRPORT_PROXYARP_WIFI = 12,
+	IFLA_BRPORT_ROOT_ID = 13,
+	IFLA_BRPORT_BRIDGE_ID = 14,
+	IFLA_BRPORT_DESIGNATED_PORT = 15,
+	IFLA_BRPORT_DESIGNATED_COST = 16,
+	IFLA_BRPORT_ID = 17,
+	IFLA_BRPORT_NO = 18,
+	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
+	IFLA_BRPORT_CONFIG_PENDING = 20,
+	IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
+	IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
+	IFLA_BRPORT_HOLD_TIMER = 23,
+	IFLA_BRPORT_FLUSH = 24,
+	IFLA_BRPORT_MULTICAST_ROUTER = 25,
+	IFLA_BRPORT_PAD = 26,
+	IFLA_BRPORT_MCAST_FLOOD = 27,
+	IFLA_BRPORT_MCAST_TO_UCAST = 28,
+	IFLA_BRPORT_VLAN_TUNNEL = 29,
+	IFLA_BRPORT_BCAST_FLOOD = 30,
+	IFLA_BRPORT_GROUP_FWD_MASK = 31,
+	IFLA_BRPORT_NEIGH_SUPPRESS = 32,
+	IFLA_BRPORT_ISOLATED = 33,
+	IFLA_BRPORT_BACKUP_PORT = 34,
+	IFLA_BRPORT_MRP_RING_OPEN = 35,
+	IFLA_BRPORT_MRP_IN_OPEN = 36,
+	IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT = 37,
+	IFLA_BRPORT_MCAST_EHT_HOSTS_CNT = 38,
+	IFLA_BRPORT_LOCKED = 39,
+	IFLA_BRPORT_MAB = 40,
+	IFLA_BRPORT_MCAST_N_GROUPS = 41,
+	IFLA_BRPORT_MCAST_MAX_GROUPS = 42,
+	IFLA_BRPORT_NEIGH_VLAN_SUPPRESS = 43,
+	IFLA_BRPORT_BACKUP_NHID = 44,
+	__IFLA_BRPORT_MAX = 45,
+};
+
+enum {
+	IFLA_STATS_UNSPEC = 0,
+	IFLA_STATS_LINK_64 = 1,
+	IFLA_STATS_LINK_XSTATS = 2,
+	IFLA_STATS_LINK_XSTATS_SLAVE = 3,
+	IFLA_STATS_LINK_OFFLOAD_XSTATS = 4,
+	IFLA_STATS_AF_SPEC = 5,
+	__IFLA_STATS_MAX = 6,
+};
+
+enum {
+	LINK_XSTATS_TYPE_UNSPEC = 0,
+	LINK_XSTATS_TYPE_BRIDGE = 1,
+	LINK_XSTATS_TYPE_BOND = 2,
+	__LINK_XSTATS_TYPE_MAX = 3,
+};
+
+struct rtnl_af_ops {
+	struct list_head list;
+	int family;
+	int (*fill_link_af)(struct sk_buff *, const struct net_device *, u32);
+	size_t (*get_link_af_size)(const struct net_device *, u32);
+	int (*validate_link_af)(const struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
+	int (*set_link_af)(struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
+	int (*fill_stats_af)(struct sk_buff *, const struct net_device *);
+	size_t (*get_stats_af_size)(const struct net_device *);
+};
+
+enum {
+	IFLA_BRIDGE_FLAGS = 0,
+	IFLA_BRIDGE_MODE = 1,
+	IFLA_BRIDGE_VLAN_INFO = 2,
+	IFLA_BRIDGE_VLAN_TUNNEL_INFO = 3,
+	IFLA_BRIDGE_MRP = 4,
+	IFLA_BRIDGE_CFM = 5,
+	IFLA_BRIDGE_MST = 6,
+	__IFLA_BRIDGE_MAX = 7,
+};
+
+struct bridge_vlan_info {
+	__u16 flags;
+	__u16 vid;
+};
+
+struct bridge_vlan_xstats {
+	__u64 rx_bytes;
+	__u64 rx_packets;
+	__u64 tx_bytes;
+	__u64 tx_packets;
+	__u16 vid;
+	__u16 flags;
+	__u32 pad2;
+};
+
+enum {
+	BRIDGE_XSTATS_UNSPEC = 0,
+	BRIDGE_XSTATS_VLAN = 1,
+	BRIDGE_XSTATS_MCAST = 2,
+	BRIDGE_XSTATS_PAD = 3,
+	BRIDGE_XSTATS_STP = 4,
+	__BRIDGE_XSTATS_MAX = 5,
+};
+
+struct br_boolopt_multi {
+	__u32 optval;
+	__u32 optmask;
+};
+
+enum {
+	BR_GROUPFWD_STP = 1,
+	BR_GROUPFWD_MACPAUSE = 2,
+	BR_GROUPFWD_LACP = 4,
+};
+
+struct vtunnel_info {
+	u32 tunid;
+	u16 vid;
+	u16 flags;
+};
+
+enum br_boolopt_id {
+	BR_BOOLOPT_NO_LL_LEARN = 0,
+	BR_BOOLOPT_MCAST_VLAN_SNOOPING = 1,
+	BR_BOOLOPT_MST_ENABLE = 2,
+	BR_BOOLOPT_MAX = 3,
+};
+
+struct net_bridge_mcast_gc {
+	struct hlist_node gc_node;
+	void (*destroy)(struct net_bridge_mcast_gc *);
+};
+
+struct net_bridge_port_group;
+
+struct net_bridge_group_src {
+	struct hlist_node node;
+	struct br_ip addr;
+	struct net_bridge_port_group *pg;
+	u8 flags;
+	u8 src_query_rexmit_cnt;
+	struct timer_list timer;
+	struct net_bridge *br;
+	struct net_bridge_mcast_gc mcast_gc;
+	struct callback_head rcu;
+};
+
+struct net_bridge_port_group_sg_key {
+	struct net_bridge_port *port;
+	struct br_ip addr;
+};
+
+struct net_bridge_port_group {
+	struct net_bridge_port_group *next;
+	struct net_bridge_port_group_sg_key key;
+	unsigned char eth_addr[6];
+	unsigned char flags;
+	unsigned char filter_mode;
+	unsigned char grp_query_rexmit_cnt;
+	unsigned char rt_protocol;
+	struct hlist_head src_list;
+	unsigned int src_ents;
+	struct timer_list timer;
+	struct timer_list rexmit_timer;
+	struct hlist_node mglist;
+	struct rb_root eht_set_tree;
+	struct rb_root eht_host_tree;
+	struct rhash_head rhnode;
+	struct net_bridge_mcast_gc mcast_gc;
+	struct callback_head rcu;
+};
+
+union net_bridge_eht_addr {
+	__be32 ip4;
+	struct in6_addr ip6;
+};
+
+struct net_bridge_group_eht_host {
+	struct rb_node rb_node;
+	union net_bridge_eht_addr h_addr;
+	struct hlist_head set_entries;
+	unsigned int num_entries;
+	unsigned char filter_mode;
+	struct net_bridge_port_group *pg;
+};
+
+struct net_bridge_group_eht_set;
+
+struct net_bridge_group_eht_set_entry {
+	struct rb_node rb_node;
+	struct hlist_node host_list;
+	union net_bridge_eht_addr h_addr;
+	struct timer_list timer;
+	struct net_bridge *br;
+	struct net_bridge_group_eht_set *eht_set;
+	struct net_bridge_group_eht_host *h_parent;
+	struct net_bridge_mcast_gc mcast_gc;
+};
+
+struct net_bridge_group_eht_set {
+	struct rb_node rb_node;
+	union net_bridge_eht_addr src_addr;
+	struct rb_root entry_tree;
+	struct timer_list timer;
+	struct net_bridge_port_group *pg;
+	struct net_bridge *br;
+	struct net_bridge_mcast_gc mcast_gc;
+};
+
+struct br_vlan_msg {
+	__u8 family;
+	__u8 reserved1;
+	__u16 reserved2;
+	__u32 ifindex;
+};
+
+enum {
+	BRIDGE_VLANDB_UNSPEC = 0,
+	BRIDGE_VLANDB_ENTRY = 1,
+	BRIDGE_VLANDB_GLOBAL_OPTIONS = 2,
+	__BRIDGE_VLANDB_MAX = 3,
+};
+
+enum {
+	BRIDGE_VLANDB_ENTRY_UNSPEC = 0,
+	BRIDGE_VLANDB_ENTRY_INFO = 1,
+	BRIDGE_VLANDB_ENTRY_RANGE = 2,
+	BRIDGE_VLANDB_ENTRY_STATE = 3,
+	BRIDGE_VLANDB_ENTRY_TUNNEL_INFO = 4,
+	BRIDGE_VLANDB_ENTRY_STATS = 5,
+	BRIDGE_VLANDB_ENTRY_MCAST_ROUTER = 6,
+	BRIDGE_VLANDB_ENTRY_MCAST_N_GROUPS = 7,
+	BRIDGE_VLANDB_ENTRY_MCAST_MAX_GROUPS = 8,
+	BRIDGE_VLANDB_ENTRY_NEIGH_SUPPRESS = 9,
+	__BRIDGE_VLANDB_ENTRY_MAX = 10,
+};
+
+enum {
+	BRIDGE_VLANDB_TINFO_UNSPEC = 0,
+	BRIDGE_VLANDB_TINFO_ID = 1,
+	BRIDGE_VLANDB_TINFO_CMD = 2,
+	__BRIDGE_VLANDB_TINFO_MAX = 3,
+};
+
+enum {
+	BRIDGE_VLANDB_GOPTS_UNSPEC = 0,
+	BRIDGE_VLANDB_GOPTS_ID = 1,
+	BRIDGE_VLANDB_GOPTS_RANGE = 2,
+	BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING = 3,
+	BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION = 4,
+	BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION = 5,
+	BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT = 6,
+	BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT = 7,
+	BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL = 8,
+	BRIDGE_VLANDB_GOPTS_PAD = 9,
+	BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL = 10,
+	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL = 11,
+	BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL = 12,
+	BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL = 13,
+	BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL = 14,
+	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER = 15,
+	BRIDGE_VLANDB_GOPTS_MCAST_ROUTER_PORTS = 16,
+	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_STATE = 17,
+	BRIDGE_VLANDB_GOPTS_MSTI = 18,
+	__BRIDGE_VLANDB_GOPTS_MAX = 19,
+};
+
+enum {
+	MDB_RTR_TYPE_DISABLED = 0,
+	MDB_RTR_TYPE_TEMP_QUERY = 1,
+	MDB_RTR_TYPE_PERM = 2,
+	MDB_RTR_TYPE_TEMP = 3,
+};
+
+enum {
+	BR_VLFLAG_PER_PORT_STATS = 1,
+	BR_VLFLAG_ADDED_BY_SWITCHDEV = 2,
+	BR_VLFLAG_MCAST_ENABLED = 4,
+	BR_VLFLAG_GLOBAL_MCAST_ENABLED = 8,
+	BR_VLFLAG_NEIGH_SUPPRESS_ENABLED = 16,
+};
+
+struct dim_cq_moder;
+
+struct dim_irq_moder {
+	u8 profile_flags;
+	u8 coal_flags;
+	u8 dim_rx_mode;
+	u8 dim_tx_mode;
+	struct dim_cq_moder *rx_profile;
+	struct dim_cq_moder *tx_profile;
+	void (*rx_dim_work)(struct work_struct *);
+	void (*tx_dim_work)(struct work_struct *);
+};
+
+enum devlink_command {
+	DEVLINK_CMD_UNSPEC = 0,
+	DEVLINK_CMD_GET = 1,
+	DEVLINK_CMD_SET = 2,
+	DEVLINK_CMD_NEW = 3,
+	DEVLINK_CMD_DEL = 4,
+	DEVLINK_CMD_PORT_GET = 5,
+	DEVLINK_CMD_PORT_SET = 6,
+	DEVLINK_CMD_PORT_NEW = 7,
+	DEVLINK_CMD_PORT_DEL = 8,
+	DEVLINK_CMD_PORT_SPLIT = 9,
+	DEVLINK_CMD_PORT_UNSPLIT = 10,
+	DEVLINK_CMD_SB_GET = 11,
+	DEVLINK_CMD_SB_SET = 12,
+	DEVLINK_CMD_SB_NEW = 13,
+	DEVLINK_CMD_SB_DEL = 14,
+	DEVLINK_CMD_SB_POOL_GET = 15,
+	DEVLINK_CMD_SB_POOL_SET = 16,
+	DEVLINK_CMD_SB_POOL_NEW = 17,
+	DEVLINK_CMD_SB_POOL_DEL = 18,
+	DEVLINK_CMD_SB_PORT_POOL_GET = 19,
+	DEVLINK_CMD_SB_PORT_POOL_SET = 20,
+	DEVLINK_CMD_SB_PORT_POOL_NEW = 21,
+	DEVLINK_CMD_SB_PORT_POOL_DEL = 22,
+	DEVLINK_CMD_SB_TC_POOL_BIND_GET = 23,
+	DEVLINK_CMD_SB_TC_POOL_BIND_SET = 24,
+	DEVLINK_CMD_SB_TC_POOL_BIND_NEW = 25,
+	DEVLINK_CMD_SB_TC_POOL_BIND_DEL = 26,
+	DEVLINK_CMD_SB_OCC_SNAPSHOT = 27,
+	DEVLINK_CMD_SB_OCC_MAX_CLEAR = 28,
+	DEVLINK_CMD_ESWITCH_GET = 29,
+	DEVLINK_CMD_ESWITCH_SET = 30,
+	DEVLINK_CMD_DPIPE_TABLE_GET = 31,
+	DEVLINK_CMD_DPIPE_ENTRIES_GET = 32,
+	DEVLINK_CMD_DPIPE_HEADERS_GET = 33,
+	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET = 34,
+	DEVLINK_CMD_RESOURCE_SET = 35,
+	DEVLINK_CMD_RESOURCE_DUMP = 36,
+	DEVLINK_CMD_RELOAD = 37,
+	DEVLINK_CMD_PARAM_GET = 38,
+	DEVLINK_CMD_PARAM_SET = 39,
+	DEVLINK_CMD_PARAM_NEW = 40,
+	DEVLINK_CMD_PARAM_DEL = 41,
+	DEVLINK_CMD_REGION_GET = 42,
+	DEVLINK_CMD_REGION_SET = 43,
+	DEVLINK_CMD_REGION_NEW = 44,
+	DEVLINK_CMD_REGION_DEL = 45,
+	DEVLINK_CMD_REGION_READ = 46,
+	DEVLINK_CMD_PORT_PARAM_GET = 47,
+	DEVLINK_CMD_PORT_PARAM_SET = 48,
+	DEVLINK_CMD_PORT_PARAM_NEW = 49,
+	DEVLINK_CMD_PORT_PARAM_DEL = 50,
+	DEVLINK_CMD_INFO_GET = 51,
+	DEVLINK_CMD_HEALTH_REPORTER_GET = 52,
+	DEVLINK_CMD_HEALTH_REPORTER_SET = 53,
+	DEVLINK_CMD_HEALTH_REPORTER_RECOVER = 54,
+	DEVLINK_CMD_HEALTH_REPORTER_DIAGNOSE = 55,
+	DEVLINK_CMD_HEALTH_REPORTER_DUMP_GET = 56,
+	DEVLINK_CMD_HEALTH_REPORTER_DUMP_CLEAR = 57,
+	DEVLINK_CMD_FLASH_UPDATE = 58,
+	DEVLINK_CMD_FLASH_UPDATE_END = 59,
+	DEVLINK_CMD_FLASH_UPDATE_STATUS = 60,
+	DEVLINK_CMD_TRAP_GET = 61,
+	DEVLINK_CMD_TRAP_SET = 62,
+	DEVLINK_CMD_TRAP_NEW = 63,
+	DEVLINK_CMD_TRAP_DEL = 64,
+	DEVLINK_CMD_TRAP_GROUP_GET = 65,
+	DEVLINK_CMD_TRAP_GROUP_SET = 66,
+	DEVLINK_CMD_TRAP_GROUP_NEW = 67,
+	DEVLINK_CMD_TRAP_GROUP_DEL = 68,
+	DEVLINK_CMD_TRAP_POLICER_GET = 69,
+	DEVLINK_CMD_TRAP_POLICER_SET = 70,
+	DEVLINK_CMD_TRAP_POLICER_NEW = 71,
+	DEVLINK_CMD_TRAP_POLICER_DEL = 72,
+	DEVLINK_CMD_HEALTH_REPORTER_TEST = 73,
+	DEVLINK_CMD_RATE_GET = 74,
+	DEVLINK_CMD_RATE_SET = 75,
+	DEVLINK_CMD_RATE_NEW = 76,
+	DEVLINK_CMD_RATE_DEL = 77,
+	DEVLINK_CMD_LINECARD_GET = 78,
+	DEVLINK_CMD_LINECARD_SET = 79,
+	DEVLINK_CMD_LINECARD_NEW = 80,
+	DEVLINK_CMD_LINECARD_DEL = 81,
+	DEVLINK_CMD_SELFTESTS_GET = 82,
+	DEVLINK_CMD_SELFTESTS_RUN = 83,
+	DEVLINK_CMD_NOTIFY_FILTER_SET = 84,
+	__DEVLINK_CMD_MAX = 85,
+	DEVLINK_CMD_MAX = 84,
+};
+
+enum devlink_eswitch_encap_mode {
+	DEVLINK_ESWITCH_ENCAP_MODE_NONE = 0,
+	DEVLINK_ESWITCH_ENCAP_MODE_BASIC = 1,
+};
+
+enum devlink_attr_selftest_id {
+	DEVLINK_ATTR_SELFTEST_ID_UNSPEC = 0,
+	DEVLINK_ATTR_SELFTEST_ID_FLASH = 1,
+	__DEVLINK_ATTR_SELFTEST_ID_MAX = 2,
+	DEVLINK_ATTR_SELFTEST_ID_MAX = 1,
+};
+
+enum devlink_selftest_status {
+	DEVLINK_SELFTEST_STATUS_SKIP = 0,
+	DEVLINK_SELFTEST_STATUS_PASS = 1,
+	DEVLINK_SELFTEST_STATUS_FAIL = 2,
+};
+
+enum devlink_trap_action {
+	DEVLINK_TRAP_ACTION_DROP = 0,
+	DEVLINK_TRAP_ACTION_TRAP = 1,
+	DEVLINK_TRAP_ACTION_MIRROR = 2,
+};
+
+enum devlink_trap_type {
+	DEVLINK_TRAP_TYPE_DROP = 0,
+	DEVLINK_TRAP_TYPE_EXCEPTION = 1,
+	DEVLINK_TRAP_TYPE_CONTROL = 2,
+};
+
+enum devlink_reload_action {
+	DEVLINK_RELOAD_ACTION_UNSPEC = 0,
+	DEVLINK_RELOAD_ACTION_DRIVER_REINIT = 1,
+	DEVLINK_RELOAD_ACTION_FW_ACTIVATE = 2,
+	__DEVLINK_RELOAD_ACTION_MAX = 3,
+	DEVLINK_RELOAD_ACTION_MAX = 2,
+};
+
+enum devlink_reload_limit {
+	DEVLINK_RELOAD_LIMIT_UNSPEC = 0,
+	DEVLINK_RELOAD_LIMIT_NO_RESET = 1,
+	__DEVLINK_RELOAD_LIMIT_MAX = 2,
+	DEVLINK_RELOAD_LIMIT_MAX = 1,
+};
+
+enum devlink_attr {
+	DEVLINK_ATTR_UNSPEC = 0,
+	DEVLINK_ATTR_BUS_NAME = 1,
+	DEVLINK_ATTR_DEV_NAME = 2,
+	DEVLINK_ATTR_PORT_INDEX = 3,
+	DEVLINK_ATTR_PORT_TYPE = 4,
+	DEVLINK_ATTR_PORT_DESIRED_TYPE = 5,
+	DEVLINK_ATTR_PORT_NETDEV_IFINDEX = 6,
+	DEVLINK_ATTR_PORT_NETDEV_NAME = 7,
+	DEVLINK_ATTR_PORT_IBDEV_NAME = 8,
+	DEVLINK_ATTR_PORT_SPLIT_COUNT = 9,
+	DEVLINK_ATTR_PORT_SPLIT_GROUP = 10,
+	DEVLINK_ATTR_SB_INDEX = 11,
+	DEVLINK_ATTR_SB_SIZE = 12,
+	DEVLINK_ATTR_SB_INGRESS_POOL_COUNT = 13,
+	DEVLINK_ATTR_SB_EGRESS_POOL_COUNT = 14,
+	DEVLINK_ATTR_SB_INGRESS_TC_COUNT = 15,
+	DEVLINK_ATTR_SB_EGRESS_TC_COUNT = 16,
+	DEVLINK_ATTR_SB_POOL_INDEX = 17,
+	DEVLINK_ATTR_SB_POOL_TYPE = 18,
+	DEVLINK_ATTR_SB_POOL_SIZE = 19,
+	DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE = 20,
+	DEVLINK_ATTR_SB_THRESHOLD = 21,
+	DEVLINK_ATTR_SB_TC_INDEX = 22,
+	DEVLINK_ATTR_SB_OCC_CUR = 23,
+	DEVLINK_ATTR_SB_OCC_MAX = 24,
+	DEVLINK_ATTR_ESWITCH_MODE = 25,
+	DEVLINK_ATTR_ESWITCH_INLINE_MODE = 26,
+	DEVLINK_ATTR_DPIPE_TABLES = 27,
+	DEVLINK_ATTR_DPIPE_TABLE = 28,
+	DEVLINK_ATTR_DPIPE_TABLE_NAME = 29,
+	DEVLINK_ATTR_DPIPE_TABLE_SIZE = 30,
+	DEVLINK_ATTR_DPIPE_TABLE_MATCHES = 31,
+	DEVLINK_ATTR_DPIPE_TABLE_ACTIONS = 32,
+	DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED = 33,
+	DEVLINK_ATTR_DPIPE_ENTRIES = 34,
+	DEVLINK_ATTR_DPIPE_ENTRY = 35,
+	DEVLINK_ATTR_DPIPE_ENTRY_INDEX = 36,
+	DEVLINK_ATTR_DPIPE_ENTRY_MATCH_VALUES = 37,
+	DEVLINK_ATTR_DPIPE_ENTRY_ACTION_VALUES = 38,
+	DEVLINK_ATTR_DPIPE_ENTRY_COUNTER = 39,
+	DEVLINK_ATTR_DPIPE_MATCH = 40,
+	DEVLINK_ATTR_DPIPE_MATCH_VALUE = 41,
+	DEVLINK_ATTR_DPIPE_MATCH_TYPE = 42,
+	DEVLINK_ATTR_DPIPE_ACTION = 43,
+	DEVLINK_ATTR_DPIPE_ACTION_VALUE = 44,
+	DEVLINK_ATTR_DPIPE_ACTION_TYPE = 45,
+	DEVLINK_ATTR_DPIPE_VALUE = 46,
+	DEVLINK_ATTR_DPIPE_VALUE_MASK = 47,
+	DEVLINK_ATTR_DPIPE_VALUE_MAPPING = 48,
+	DEVLINK_ATTR_DPIPE_HEADERS = 49,
+	DEVLINK_ATTR_DPIPE_HEADER = 50,
+	DEVLINK_ATTR_DPIPE_HEADER_NAME = 51,
+	DEVLINK_ATTR_DPIPE_HEADER_ID = 52,
+	DEVLINK_ATTR_DPIPE_HEADER_FIELDS = 53,
+	DEVLINK_ATTR_DPIPE_HEADER_GLOBAL = 54,
+	DEVLINK_ATTR_DPIPE_HEADER_INDEX = 55,
+	DEVLINK_ATTR_DPIPE_FIELD = 56,
+	DEVLINK_ATTR_DPIPE_FIELD_NAME = 57,
+	DEVLINK_ATTR_DPIPE_FIELD_ID = 58,
+	DEVLINK_ATTR_DPIPE_FIELD_BITWIDTH = 59,
+	DEVLINK_ATTR_DPIPE_FIELD_MAPPING_TYPE = 60,
+	DEVLINK_ATTR_PAD = 61,
+	DEVLINK_ATTR_ESWITCH_ENCAP_MODE = 62,
+	DEVLINK_ATTR_RESOURCE_LIST = 63,
+	DEVLINK_ATTR_RESOURCE = 64,
+	DEVLINK_ATTR_RESOURCE_NAME = 65,
+	DEVLINK_ATTR_RESOURCE_ID = 66,
+	DEVLINK_ATTR_RESOURCE_SIZE = 67,
+	DEVLINK_ATTR_RESOURCE_SIZE_NEW = 68,
+	DEVLINK_ATTR_RESOURCE_SIZE_VALID = 69,
+	DEVLINK_ATTR_RESOURCE_SIZE_MIN = 70,
+	DEVLINK_ATTR_RESOURCE_SIZE_MAX = 71,
+	DEVLINK_ATTR_RESOURCE_SIZE_GRAN = 72,
+	DEVLINK_ATTR_RESOURCE_UNIT = 73,
+	DEVLINK_ATTR_RESOURCE_OCC = 74,
+	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_ID = 75,
+	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_UNITS = 76,
+	DEVLINK_ATTR_PORT_FLAVOUR = 77,
+	DEVLINK_ATTR_PORT_NUMBER = 78,
+	DEVLINK_ATTR_PORT_SPLIT_SUBPORT_NUMBER = 79,
+	DEVLINK_ATTR_PARAM = 80,
+	DEVLINK_ATTR_PARAM_NAME = 81,
+	DEVLINK_ATTR_PARAM_GENERIC = 82,
+	DEVLINK_ATTR_PARAM_TYPE = 83,
+	DEVLINK_ATTR_PARAM_VALUES_LIST = 84,
+	DEVLINK_ATTR_PARAM_VALUE = 85,
+	DEVLINK_ATTR_PARAM_VALUE_DATA = 86,
+	DEVLINK_ATTR_PARAM_VALUE_CMODE = 87,
+	DEVLINK_ATTR_REGION_NAME = 88,
+	DEVLINK_ATTR_REGION_SIZE = 89,
+	DEVLINK_ATTR_REGION_SNAPSHOTS = 90,
+	DEVLINK_ATTR_REGION_SNAPSHOT = 91,
+	DEVLINK_ATTR_REGION_SNAPSHOT_ID = 92,
+	DEVLINK_ATTR_REGION_CHUNKS = 93,
+	DEVLINK_ATTR_REGION_CHUNK = 94,
+	DEVLINK_ATTR_REGION_CHUNK_DATA = 95,
+	DEVLINK_ATTR_REGION_CHUNK_ADDR = 96,
+	DEVLINK_ATTR_REGION_CHUNK_LEN = 97,
+	DEVLINK_ATTR_INFO_DRIVER_NAME = 98,
+	DEVLINK_ATTR_INFO_SERIAL_NUMBER = 99,
+	DEVLINK_ATTR_INFO_VERSION_FIXED = 100,
+	DEVLINK_ATTR_INFO_VERSION_RUNNING = 101,
+	DEVLINK_ATTR_INFO_VERSION_STORED = 102,
+	DEVLINK_ATTR_INFO_VERSION_NAME = 103,
+	DEVLINK_ATTR_INFO_VERSION_VALUE = 104,
+	DEVLINK_ATTR_SB_POOL_CELL_SIZE = 105,
+	DEVLINK_ATTR_FMSG = 106,
+	DEVLINK_ATTR_FMSG_OBJ_NEST_START = 107,
+	DEVLINK_ATTR_FMSG_PAIR_NEST_START = 108,
+	DEVLINK_ATTR_FMSG_ARR_NEST_START = 109,
+	DEVLINK_ATTR_FMSG_NEST_END = 110,
+	DEVLINK_ATTR_FMSG_OBJ_NAME = 111,
+	DEVLINK_ATTR_FMSG_OBJ_VALUE_TYPE = 112,
+	DEVLINK_ATTR_FMSG_OBJ_VALUE_DATA = 113,
+	DEVLINK_ATTR_HEALTH_REPORTER = 114,
+	DEVLINK_ATTR_HEALTH_REPORTER_NAME = 115,
+	DEVLINK_ATTR_HEALTH_REPORTER_STATE = 116,
+	DEVLINK_ATTR_HEALTH_REPORTER_ERR_COUNT = 117,
+	DEVLINK_ATTR_HEALTH_REPORTER_RECOVER_COUNT = 118,
+	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS = 119,
+	DEVLINK_ATTR_HEALTH_REPORTER_GRACEFUL_PERIOD = 120,
+	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_RECOVER = 121,
+	DEVLINK_ATTR_FLASH_UPDATE_FILE_NAME = 122,
+	DEVLINK_ATTR_FLASH_UPDATE_COMPONENT = 123,
+	DEVLINK_ATTR_FLASH_UPDATE_STATUS_MSG = 124,
+	DEVLINK_ATTR_FLASH_UPDATE_STATUS_DONE = 125,
+	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TOTAL = 126,
+	DEVLINK_ATTR_PORT_PCI_PF_NUMBER = 127,
+	DEVLINK_ATTR_PORT_PCI_VF_NUMBER = 128,
+	DEVLINK_ATTR_STATS = 129,
+	DEVLINK_ATTR_TRAP_NAME = 130,
+	DEVLINK_ATTR_TRAP_ACTION = 131,
+	DEVLINK_ATTR_TRAP_TYPE = 132,
+	DEVLINK_ATTR_TRAP_GENERIC = 133,
+	DEVLINK_ATTR_TRAP_METADATA = 134,
+	DEVLINK_ATTR_TRAP_GROUP_NAME = 135,
+	DEVLINK_ATTR_RELOAD_FAILED = 136,
+	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS_NS = 137,
+	DEVLINK_ATTR_NETNS_FD = 138,
+	DEVLINK_ATTR_NETNS_PID = 139,
+	DEVLINK_ATTR_NETNS_ID = 140,
+	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_DUMP = 141,
+	DEVLINK_ATTR_TRAP_POLICER_ID = 142,
+	DEVLINK_ATTR_TRAP_POLICER_RATE = 143,
+	DEVLINK_ATTR_TRAP_POLICER_BURST = 144,
+	DEVLINK_ATTR_PORT_FUNCTION = 145,
+	DEVLINK_ATTR_INFO_BOARD_SERIAL_NUMBER = 146,
+	DEVLINK_ATTR_PORT_LANES = 147,
+	DEVLINK_ATTR_PORT_SPLITTABLE = 148,
+	DEVLINK_ATTR_PORT_EXTERNAL = 149,
+	DEVLINK_ATTR_PORT_CONTROLLER_NUMBER = 150,
+	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TIMEOUT = 151,
+	DEVLINK_ATTR_FLASH_UPDATE_OVERWRITE_MASK = 152,
+	DEVLINK_ATTR_RELOAD_ACTION = 153,
+	DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED = 154,
+	DEVLINK_ATTR_RELOAD_LIMITS = 155,
+	DEVLINK_ATTR_DEV_STATS = 156,
+	DEVLINK_ATTR_RELOAD_STATS = 157,
+	DEVLINK_ATTR_RELOAD_STATS_ENTRY = 158,
+	DEVLINK_ATTR_RELOAD_STATS_LIMIT = 159,
+	DEVLINK_ATTR_RELOAD_STATS_VALUE = 160,
+	DEVLINK_ATTR_REMOTE_RELOAD_STATS = 161,
+	DEVLINK_ATTR_RELOAD_ACTION_INFO = 162,
+	DEVLINK_ATTR_RELOAD_ACTION_STATS = 163,
+	DEVLINK_ATTR_PORT_PCI_SF_NUMBER = 164,
+	DEVLINK_ATTR_RATE_TYPE = 165,
+	DEVLINK_ATTR_RATE_TX_SHARE = 166,
+	DEVLINK_ATTR_RATE_TX_MAX = 167,
+	DEVLINK_ATTR_RATE_NODE_NAME = 168,
+	DEVLINK_ATTR_RATE_PARENT_NODE_NAME = 169,
+	DEVLINK_ATTR_REGION_MAX_SNAPSHOTS = 170,
+	DEVLINK_ATTR_LINECARD_INDEX = 171,
+	DEVLINK_ATTR_LINECARD_STATE = 172,
+	DEVLINK_ATTR_LINECARD_TYPE = 173,
+	DEVLINK_ATTR_LINECARD_SUPPORTED_TYPES = 174,
+	DEVLINK_ATTR_NESTED_DEVLINK = 175,
+	DEVLINK_ATTR_SELFTESTS = 176,
+	DEVLINK_ATTR_RATE_TX_PRIORITY = 177,
+	DEVLINK_ATTR_RATE_TX_WEIGHT = 178,
+	DEVLINK_ATTR_REGION_DIRECT = 179,
+	__DEVLINK_ATTR_MAX = 180,
+	DEVLINK_ATTR_MAX = 179,
+};
+
+enum devlink_dpipe_field_mapping_type {
+	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE = 0,
+	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX = 1,
+};
+
+enum devlink_port_function_attr {
+	DEVLINK_PORT_FUNCTION_ATTR_UNSPEC = 0,
+	DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR = 1,
+	DEVLINK_PORT_FN_ATTR_STATE = 2,
+	DEVLINK_PORT_FN_ATTR_OPSTATE = 3,
+	DEVLINK_PORT_FN_ATTR_CAPS = 4,
+	DEVLINK_PORT_FN_ATTR_DEVLINK = 5,
+	DEVLINK_PORT_FN_ATTR_MAX_IO_EQS = 6,
+	__DEVLINK_PORT_FUNCTION_ATTR_MAX = 7,
+	DEVLINK_PORT_FUNCTION_ATTR_MAX = 6,
+};
+
+struct devlink_dev_stats {
+	u32 reload_stats[6];
+	u32 remote_reload_stats[6];
+};
+
+struct devlink_dpipe_headers;
+
+struct devlink_ops;
+
+struct devlink_rel;
+
+struct devlink {
+	u32 index;
+	struct xarray ports;
+	struct list_head rate_list;
+	struct list_head sb_list;
+	struct list_head dpipe_table_list;
+	struct list_head resource_list;
+	struct xarray params;
+	struct list_head region_list;
+	struct list_head reporter_list;
+	struct devlink_dpipe_headers *dpipe_headers;
+	struct list_head trap_list;
+	struct list_head trap_group_list;
+	struct list_head trap_policer_list;
+	struct list_head linecard_list;
+	const struct devlink_ops *ops;
+	struct xarray snapshot_ids;
+	struct devlink_dev_stats stats;
+	struct device *dev;
+	possible_net_t _net;
+	struct mutex lock;
+	struct lock_class_key lock_key;
+	u8 reload_failed: 1;
+	refcount_t refcount;
+	struct rcu_work rwork;
+	struct devlink_rel *rel;
+	struct xarray nested_rels;
+	char priv[0];
+};
+
+enum rdma_driver_id {
+	RDMA_DRIVER_UNKNOWN = 0,
+	RDMA_DRIVER_MLX5 = 1,
+	RDMA_DRIVER_MLX4 = 2,
+	RDMA_DRIVER_CXGB3 = 3,
+	RDMA_DRIVER_CXGB4 = 4,
+	RDMA_DRIVER_MTHCA = 5,
+	RDMA_DRIVER_BNXT_RE = 6,
+	RDMA_DRIVER_OCRDMA = 7,
+	RDMA_DRIVER_NES = 8,
+	RDMA_DRIVER_I40IW = 9,
+	RDMA_DRIVER_IRDMA = 9,
+	RDMA_DRIVER_VMW_PVRDMA = 10,
+	RDMA_DRIVER_QEDR = 11,
+	RDMA_DRIVER_HNS = 12,
+	RDMA_DRIVER_USNIC = 13,
+	RDMA_DRIVER_RXE = 14,
+	RDMA_DRIVER_HFI1 = 15,
+	RDMA_DRIVER_QIB = 16,
+	RDMA_DRIVER_EFA = 17,
+	RDMA_DRIVER_SIW = 18,
+	RDMA_DRIVER_ERDMA = 19,
+	RDMA_DRIVER_MANA = 20,
+};
+
+enum ib_cq_notify_flags {
+	IB_CQ_SOLICITED = 1,
+	IB_CQ_NEXT_COMP = 2,
+	IB_CQ_SOLICITED_MASK = 3,
+	IB_CQ_REPORT_MISSED_EVENTS = 4,
+};
+
+struct ib_mad;
+
+enum rdma_link_layer {
+	IB_LINK_LAYER_UNSPECIFIED = 0,
+	IB_LINK_LAYER_INFINIBAND = 1,
+	IB_LINK_LAYER_ETHERNET = 2,
+};
+
+enum rdma_netdev_t {
+	RDMA_NETDEV_OPA_VNIC = 0,
+	RDMA_NETDEV_IPOIB = 1,
+};
+
+enum ib_srq_attr_mask {
+	IB_SRQ_MAX_WR = 1,
+	IB_SRQ_LIMIT = 2,
+};
+
+struct uverbs_attr_bundle;
+
+enum ib_mr_type {
+	IB_MR_TYPE_MEM_REG = 0,
+	IB_MR_TYPE_SG_GAPS = 1,
+	IB_MR_TYPE_DM = 2,
+	IB_MR_TYPE_USER = 3,
+	IB_MR_TYPE_DMA = 4,
+	IB_MR_TYPE_INTEGRITY = 5,
+};
+
+enum ib_uverbs_advise_mr_advice {
+	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH = 0,
+	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE = 1,
+	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT = 2,
+};
+
+struct rdma_cm_id;
+
+struct iw_cm_id;
+
+struct iw_cm_conn_param;
+
+enum rdma_nl_dev_type {
+	RDMA_DEVICE_TYPE_SMI = 1,
+};
+
+struct ib_qp;
+
+struct ib_send_wr;
+
+struct ib_recv_wr;
+
+struct ib_cq;
+
+struct ib_wc;
+
+struct ib_srq;
+
+struct ib_grh;
+
+struct ib_device_attr;
+
+struct ib_udata;
+
+struct ib_device_modify;
+
+struct ib_port_attr;
+
+struct ib_port_modify;
+
+struct ib_port_immutable;
+
+struct rdma_netdev_alloc_params;
+
+union ib_gid;
+
+struct ib_gid_attr;
+
+struct ib_ucontext;
+
+struct rdma_user_mmap_entry;
+
+struct ib_pd;
+
+struct ib_ah;
+
+struct rdma_ah_init_attr;
+
+struct rdma_ah_attr;
+
+struct ib_srq_init_attr;
+
+struct ib_srq_attr;
+
+struct ib_qp_init_attr;
+
+struct ib_qp_attr;
+
+struct ib_cq_init_attr;
+
+struct ib_mr;
+
+struct ib_sge;
+
+struct ib_mr_status;
+
+struct ib_mw;
+
+struct ib_xrcd;
+
+struct ib_flow;
+
+struct ib_flow_attr;
+
+struct ib_flow_action;
+
+struct ib_wq;
+
+struct ib_wq_init_attr;
+
+struct ib_wq_attr;
+
+struct ib_rwq_ind_table;
+
+struct ib_rwq_ind_table_init_attr;
+
+struct ib_dm;
+
+struct ib_dm_alloc_attr;
+
+struct ib_dm_mr_attr;
+
+struct ib_counters;
+
+struct ib_counters_read_attr;
+
+struct rdma_hw_stats;
+
+struct rdma_counter;
+
+struct ib_device_ops {
+	struct module *owner;
+	enum rdma_driver_id driver_id;
+	u32 uverbs_abi_ver;
+	unsigned int uverbs_no_driver_id_binding: 1;
+	const struct attribute_group *device_group;
+	const struct attribute_group **port_groups;
+	int (*post_send)(struct ib_qp *, const struct ib_send_wr *, const struct ib_send_wr **);
+	int (*post_recv)(struct ib_qp *, const struct ib_recv_wr *, const struct ib_recv_wr **);
+	void (*drain_rq)(struct ib_qp *);
+	void (*drain_sq)(struct ib_qp *);
+	int (*poll_cq)(struct ib_cq *, int, struct ib_wc *);
+	int (*peek_cq)(struct ib_cq *, int);
+	int (*req_notify_cq)(struct ib_cq *, enum ib_cq_notify_flags);
+	int (*post_srq_recv)(struct ib_srq *, const struct ib_recv_wr *, const struct ib_recv_wr **);
+	int (*process_mad)(struct ib_device *, int, u32, const struct ib_wc *, const struct ib_grh *, const struct ib_mad *, struct ib_mad *, size_t *, u16 *);
+	int (*query_device)(struct ib_device *, struct ib_device_attr *, struct ib_udata *);
+	int (*modify_device)(struct ib_device *, int, struct ib_device_modify *);
+	void (*get_dev_fw_str)(struct ib_device *, char *);
+	const struct cpumask * (*get_vector_affinity)(struct ib_device *, int);
+	int (*query_port)(struct ib_device *, u32, struct ib_port_attr *);
+	int (*modify_port)(struct ib_device *, u32, int, struct ib_port_modify *);
+	int (*get_port_immutable)(struct ib_device *, u32, struct ib_port_immutable *);
+	enum rdma_link_layer (*get_link_layer)(struct ib_device *, u32);
+	struct net_device * (*get_netdev)(struct ib_device *, u32);
+	struct net_device * (*alloc_rdma_netdev)(struct ib_device *, u32, enum rdma_netdev_t, const char *, unsigned char, void (*)(struct net_device *));
+	int (*rdma_netdev_get_params)(struct ib_device *, u32, enum rdma_netdev_t, struct rdma_netdev_alloc_params *);
+	int (*query_gid)(struct ib_device *, u32, int, union ib_gid *);
+	int (*add_gid)(const struct ib_gid_attr *, void **);
+	int (*del_gid)(const struct ib_gid_attr *, void **);
+	int (*query_pkey)(struct ib_device *, u32, u16, u16 *);
+	int (*alloc_ucontext)(struct ib_ucontext *, struct ib_udata *);
+	void (*dealloc_ucontext)(struct ib_ucontext *);
+	int (*mmap)(struct ib_ucontext *, struct vm_area_struct *);
+	void (*mmap_free)(struct rdma_user_mmap_entry *);
+	void (*disassociate_ucontext)(struct ib_ucontext *);
+	int (*alloc_pd)(struct ib_pd *, struct ib_udata *);
+	int (*dealloc_pd)(struct ib_pd *, struct ib_udata *);
+	int (*create_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
+	int (*create_user_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
+	int (*modify_ah)(struct ib_ah *, struct rdma_ah_attr *);
+	int (*query_ah)(struct ib_ah *, struct rdma_ah_attr *);
+	int (*destroy_ah)(struct ib_ah *, u32);
+	int (*create_srq)(struct ib_srq *, struct ib_srq_init_attr *, struct ib_udata *);
+	int (*modify_srq)(struct ib_srq *, struct ib_srq_attr *, enum ib_srq_attr_mask, struct ib_udata *);
+	int (*query_srq)(struct ib_srq *, struct ib_srq_attr *);
+	int (*destroy_srq)(struct ib_srq *, struct ib_udata *);
+	int (*create_qp)(struct ib_qp *, struct ib_qp_init_attr *, struct ib_udata *);
+	int (*modify_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_udata *);
+	int (*query_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_qp_init_attr *);
+	int (*destroy_qp)(struct ib_qp *, struct ib_udata *);
+	int (*create_cq)(struct ib_cq *, const struct ib_cq_init_attr *, struct uverbs_attr_bundle *);
+	int (*modify_cq)(struct ib_cq *, u16, u16);
+	int (*destroy_cq)(struct ib_cq *, struct ib_udata *);
+	int (*resize_cq)(struct ib_cq *, int, struct ib_udata *);
+	struct ib_mr * (*get_dma_mr)(struct ib_pd *, int);
+	struct ib_mr * (*reg_user_mr)(struct ib_pd *, u64, u64, u64, int, struct ib_udata *);
+	struct ib_mr * (*reg_user_mr_dmabuf)(struct ib_pd *, u64, u64, u64, int, int, struct uverbs_attr_bundle *);
+	struct ib_mr * (*rereg_user_mr)(struct ib_mr *, int, u64, u64, u64, int, struct ib_pd *, struct ib_udata *);
+	int (*dereg_mr)(struct ib_mr *, struct ib_udata *);
+	struct ib_mr * (*alloc_mr)(struct ib_pd *, enum ib_mr_type, u32);
+	struct ib_mr * (*alloc_mr_integrity)(struct ib_pd *, u32, u32);
+	int (*advise_mr)(struct ib_pd *, enum ib_uverbs_advise_mr_advice, u32, struct ib_sge *, u32, struct uverbs_attr_bundle *);
+	int (*map_mr_sg)(struct ib_mr *, struct scatterlist *, int, unsigned int *);
+	int (*check_mr_status)(struct ib_mr *, u32, struct ib_mr_status *);
+	int (*alloc_mw)(struct ib_mw *, struct ib_udata *);
+	int (*dealloc_mw)(struct ib_mw *);
+	int (*attach_mcast)(struct ib_qp *, union ib_gid *, u16);
+	int (*detach_mcast)(struct ib_qp *, union ib_gid *, u16);
+	int (*alloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
+	int (*dealloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
+	struct ib_flow * (*create_flow)(struct ib_qp *, struct ib_flow_attr *, struct ib_udata *);
+	int (*destroy_flow)(struct ib_flow *);
+	int (*destroy_flow_action)(struct ib_flow_action *);
+	int (*set_vf_link_state)(struct ib_device *, int, u32, int);
+	int (*get_vf_config)(struct ib_device *, int, u32, struct ifla_vf_info *);
+	int (*get_vf_stats)(struct ib_device *, int, u32, struct ifla_vf_stats *);
+	int (*get_vf_guid)(struct ib_device *, int, u32, struct ifla_vf_guid *, struct ifla_vf_guid *);
+	int (*set_vf_guid)(struct ib_device *, int, u32, u64, int);
+	struct ib_wq * (*create_wq)(struct ib_pd *, struct ib_wq_init_attr *, struct ib_udata *);
+	int (*destroy_wq)(struct ib_wq *, struct ib_udata *);
+	int (*modify_wq)(struct ib_wq *, struct ib_wq_attr *, u32, struct ib_udata *);
+	int (*create_rwq_ind_table)(struct ib_rwq_ind_table *, struct ib_rwq_ind_table_init_attr *, struct ib_udata *);
+	int (*destroy_rwq_ind_table)(struct ib_rwq_ind_table *);
+	struct ib_dm * (*alloc_dm)(struct ib_device *, struct ib_ucontext *, struct ib_dm_alloc_attr *, struct uverbs_attr_bundle *);
+	int (*dealloc_dm)(struct ib_dm *, struct uverbs_attr_bundle *);
+	struct ib_mr * (*reg_dm_mr)(struct ib_pd *, struct ib_dm *, struct ib_dm_mr_attr *, struct uverbs_attr_bundle *);
+	int (*create_counters)(struct ib_counters *, struct uverbs_attr_bundle *);
+	int (*destroy_counters)(struct ib_counters *);
+	int (*read_counters)(struct ib_counters *, struct ib_counters_read_attr *, struct uverbs_attr_bundle *);
+	int (*map_mr_sg_pi)(struct ib_mr *, struct scatterlist *, int, unsigned int *, struct scatterlist *, int, unsigned int *);
+	struct rdma_hw_stats * (*alloc_hw_device_stats)(struct ib_device *);
+	struct rdma_hw_stats * (*alloc_hw_port_stats)(struct ib_device *, u32);
+	int (*get_hw_stats)(struct ib_device *, struct rdma_hw_stats *, u32, int);
+	int (*modify_hw_stat)(struct ib_device *, u32, unsigned int, bool);
+	int (*fill_res_mr_entry)(struct sk_buff *, struct ib_mr *);
+	int (*fill_res_mr_entry_raw)(struct sk_buff *, struct ib_mr *);
+	int (*fill_res_cq_entry)(struct sk_buff *, struct ib_cq *);
+	int (*fill_res_cq_entry_raw)(struct sk_buff *, struct ib_cq *);
+	int (*fill_res_qp_entry)(struct sk_buff *, struct ib_qp *);
+	int (*fill_res_qp_entry_raw)(struct sk_buff *, struct ib_qp *);
+	int (*fill_res_cm_id_entry)(struct sk_buff *, struct rdma_cm_id *);
+	int (*fill_res_srq_entry)(struct sk_buff *, struct ib_srq *);
+	int (*fill_res_srq_entry_raw)(struct sk_buff *, struct ib_srq *);
+	int (*enable_driver)(struct ib_device *);
+	void (*dealloc_driver)(struct ib_device *);
+	void (*iw_add_ref)(struct ib_qp *);
+	void (*iw_rem_ref)(struct ib_qp *);
+	struct ib_qp * (*iw_get_qp)(struct ib_device *, int);
+	int (*iw_connect)(struct iw_cm_id *, struct iw_cm_conn_param *);
+	int (*iw_accept)(struct iw_cm_id *, struct iw_cm_conn_param *);
+	int (*iw_reject)(struct iw_cm_id *, const void *, u8);
+	int (*iw_create_listen)(struct iw_cm_id *, int);
+	int (*iw_destroy_listen)(struct iw_cm_id *);
+	int (*counter_bind_qp)(struct rdma_counter *, struct ib_qp *);
+	int (*counter_unbind_qp)(struct ib_qp *);
+	int (*counter_dealloc)(struct rdma_counter *);
+	struct rdma_hw_stats * (*counter_alloc_stats)(struct rdma_counter *);
+	int (*counter_update_stats)(struct rdma_counter *);
+	int (*fill_stat_mr_entry)(struct sk_buff *, struct ib_mr *);
+	int (*query_ucontext)(struct ib_ucontext *, struct uverbs_attr_bundle *);
+	int (*get_numa_node)(struct ib_device *);
+	struct ib_device * (*add_sub_dev)(struct ib_device *, enum rdma_nl_dev_type, const char *);
+	void (*del_sub_dev)(struct ib_device *);
+	size_t size_ib_ah;
+	size_t size_ib_counters;
+	size_t size_ib_cq;
+	size_t size_ib_mw;
+	size_t size_ib_pd;
+	size_t size_ib_qp;
+	size_t size_ib_rwq_ind_table;
+	size_t size_ib_srq;
+	size_t size_ib_ucontext;
+	size_t size_ib_xrcd;
+};
+
+struct ib_core_device {
+	struct device dev;
+	possible_net_t rdma_net;
+	struct kobject *ports_kobj;
+	struct list_head port_list;
+	struct ib_device *owner;
+	long: 32;
+};
+
+enum ib_atomic_cap {
+	IB_ATOMIC_NONE = 0,
+	IB_ATOMIC_HCA = 1,
+	IB_ATOMIC_GLOB = 2,
+};
+
+struct ib_odp_caps {
+	uint64_t general_caps;
+	struct {
+		uint32_t rc_odp_caps;
+		uint32_t uc_odp_caps;
+		uint32_t ud_odp_caps;
+		uint32_t xrc_odp_caps;
+	} per_transport_caps;
+};
+
+struct ib_rss_caps {
+	u32 supported_qpts;
+	u32 max_rwq_indirection_tables;
+	u32 max_rwq_indirection_table_size;
+};
+
+struct ib_tm_caps {
+	u32 max_rndv_hdr_size;
+	u32 max_num_tags;
+	u32 flags;
+	u32 max_ops;
+	u32 max_sge;
+};
+
+struct ib_cq_caps {
+	u16 max_cq_moderation_count;
+	u16 max_cq_moderation_period;
+};
+
+struct ib_device_attr {
+	u64 fw_ver;
+	__be64 sys_image_guid;
+	u64 max_mr_size;
+	u64 page_size_cap;
+	u32 vendor_id;
+	u32 vendor_part_id;
+	u32 hw_ver;
+	int max_qp;
+	int max_qp_wr;
+	long: 32;
+	u64 device_cap_flags;
+	u64 kernel_cap_flags;
+	int max_send_sge;
+	int max_recv_sge;
+	int max_sge_rd;
+	int max_cq;
+	int max_cqe;
+	int max_mr;
+	int max_pd;
+	int max_qp_rd_atom;
+	int max_ee_rd_atom;
+	int max_res_rd_atom;
+	int max_qp_init_rd_atom;
+	int max_ee_init_rd_atom;
+	enum ib_atomic_cap atomic_cap;
+	enum ib_atomic_cap masked_atomic_cap;
+	int max_ee;
+	int max_rdd;
+	int max_mw;
+	int max_raw_ipv6_qp;
+	int max_raw_ethy_qp;
+	int max_mcast_grp;
+	int max_mcast_qp_attach;
+	int max_total_mcast_qp_attach;
+	int max_ah;
+	int max_srq;
+	int max_srq_wr;
+	int max_srq_sge;
+	unsigned int max_fast_reg_page_list_len;
+	unsigned int max_pi_fast_reg_page_list_len;
+	u16 max_pkeys;
+	u8 local_ca_ack_delay;
+	int sig_prot_cap;
+	int sig_guard_cap;
+	long: 32;
+	struct ib_odp_caps odp_caps;
+	uint64_t timestamp_mask;
+	uint64_t hca_core_clock;
+	struct ib_rss_caps rss_caps;
+	u32 max_wq_type_rq;
+	u32 raw_packet_caps;
+	struct ib_tm_caps tm_caps;
+	struct ib_cq_caps cq_caps;
+	long: 32;
+	u64 max_dm_size;
+	u32 max_sgl_rd;
+	long: 32;
+};
+
+struct hw_stats_device_data;
+
+struct rdma_restrack_root;
+
+struct uapi_definition;
+
+enum rdma_nl_name_assign_type {
+	RDMA_NAME_ASSIGN_TYPE_UNKNOWN = 0,
+	RDMA_NAME_ASSIGN_TYPE_USER = 1,
+};
+
+struct ib_port_data;
+
+struct rdma_link_ops;
+
+struct ib_device {
+	struct device *dma_device;
+	struct ib_device_ops ops;
+	char name[64];
+	struct callback_head callback_head;
+	struct list_head event_handler_list;
+	struct rw_semaphore event_handler_rwsem;
+	spinlock_t qp_open_list_lock;
+	struct rw_semaphore client_data_rwsem;
+	struct xarray client_data;
+	struct mutex unregistration_lock;
+	rwlock_t cache_lock;
+	struct ib_port_data *port_data;
+	int num_comp_vectors;
+	union {
+		struct device dev;
+		struct ib_core_device coredev;
+	};
+	const struct attribute_group *groups[4];
+	u64 uverbs_cmd_mask;
+	char node_desc[64];
+	__be64 node_guid;
+	u32 local_dma_lkey;
+	u16 is_switch: 1;
+	u16 kverbs_provider: 1;
+	u16 use_cq_dim: 1;
+	u8 node_type;
+	u32 phys_port_cnt;
+	long: 32;
+	struct ib_device_attr attrs;
+	struct hw_stats_device_data *hw_stats_data;
+	struct rdmacg_device cg_device;
+	u32 index;
+	spinlock_t cq_pools_lock;
+	struct list_head cq_pools[3];
+	struct rdma_restrack_root *res;
+	const struct uapi_definition *driver_def;
+	refcount_t refcount;
+	struct completion unreg_completion;
+	struct work_struct unregistration_work;
+	const struct rdma_link_ops *link_ops;
+	struct mutex compat_devs_mutex;
+	struct xarray compat_devs;
+	char iw_ifname[16];
+	u32 iw_driver_flags;
+	u32 lag_flags;
+	struct mutex subdev_lock;
+	struct list_head subdev_list_head;
+	enum rdma_nl_dev_type type;
+	struct ib_device *parent;
+	struct list_head subdev_list;
+	enum rdma_nl_name_assign_type name_assign_type;
+};
+
+struct devlink_port_new_attrs {
+	enum devlink_port_flavour flavour;
+	unsigned int port_index;
+	u32 controller;
+	u32 sfnum;
+	u16 pfnum;
+	u8 port_index_valid: 1;
+	u8 controller_valid: 1;
+	u8 sfnum_valid: 1;
+};
+
+struct devlink_dpipe_field {
+	const char *name;
+	unsigned int id;
+	unsigned int bitwidth;
+	enum devlink_dpipe_field_mapping_type mapping_type;
+};
+
+struct devlink_dpipe_header {
+	const char *name;
+	unsigned int id;
+	struct devlink_dpipe_field *fields;
+	unsigned int fields_count;
+	bool global;
+};
+
+struct devlink_dpipe_headers {
+	struct devlink_dpipe_header **headers;
+	unsigned int headers_count;
+};
+
+struct devlink_flash_update_params {
+	const struct firmware *fw;
+	const char *component;
+	u32 overwrite_mask;
+};
+
+struct devlink_trap_policer {
+	u32 id;
+	long: 32;
+	u64 init_rate;
+	u64 init_burst;
+	u64 max_rate;
+	u64 min_rate;
+	u64 max_burst;
+	u64 min_burst;
+};
+
+struct devlink_trap_group {
+	const char *name;
+	u16 id;
+	bool generic;
+	u32 init_policer_id;
+};
+
+struct devlink_trap {
+	enum devlink_trap_type type;
+	enum devlink_trap_action init_action;
+	bool generic;
+	u16 id;
+	const char *name;
+	u16 init_group_id;
+	u32 metadata_cap;
+};
+
+struct devlink_ops {
+	u32 supported_flash_update_params;
+	long unsigned int reload_actions;
+	long unsigned int reload_limits;
+	int (*reload_down)(struct devlink *, bool, enum devlink_reload_action, enum devlink_reload_limit, struct netlink_ext_ack *);
+	int (*reload_up)(struct devlink *, enum devlink_reload_action, enum devlink_reload_limit, u32 *, struct netlink_ext_ack *);
+	int (*sb_pool_get)(struct devlink *, unsigned int, u16, struct devlink_sb_pool_info *);
+	int (*sb_pool_set)(struct devlink *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
+	int (*sb_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *);
+	int (*sb_port_pool_set)(struct devlink_port *, unsigned int, u16, u32, struct netlink_ext_ack *);
+	int (*sb_tc_pool_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
+	int (*sb_tc_pool_bind_set)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
+	int (*sb_occ_snapshot)(struct devlink *, unsigned int);
+	int (*sb_occ_max_clear)(struct devlink *, unsigned int);
+	int (*sb_occ_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *, u32 *);
+	int (*sb_occ_tc_port_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
+	int (*eswitch_mode_get)(struct devlink *, u16 *);
+	int (*eswitch_mode_set)(struct devlink *, u16, struct netlink_ext_ack *);
+	int (*eswitch_inline_mode_get)(struct devlink *, u8 *);
+	int (*eswitch_inline_mode_set)(struct devlink *, u8, struct netlink_ext_ack *);
+	int (*eswitch_encap_mode_get)(struct devlink *, enum devlink_eswitch_encap_mode *);
+	int (*eswitch_encap_mode_set)(struct devlink *, enum devlink_eswitch_encap_mode, struct netlink_ext_ack *);
+	int (*info_get)(struct devlink *, struct devlink_info_req *, struct netlink_ext_ack *);
+	int (*flash_update)(struct devlink *, struct devlink_flash_update_params *, struct netlink_ext_ack *);
+	int (*trap_init)(struct devlink *, const struct devlink_trap *, void *);
+	void (*trap_fini)(struct devlink *, const struct devlink_trap *, void *);
+	int (*trap_action_set)(struct devlink *, const struct devlink_trap *, enum devlink_trap_action, struct netlink_ext_ack *);
+	int (*trap_group_init)(struct devlink *, const struct devlink_trap_group *);
+	int (*trap_group_set)(struct devlink *, const struct devlink_trap_group *, const struct devlink_trap_policer *, struct netlink_ext_ack *);
+	int (*trap_group_action_set)(struct devlink *, const struct devlink_trap_group *, enum devlink_trap_action, struct netlink_ext_ack *);
+	int (*trap_drop_counter_get)(struct devlink *, const struct devlink_trap *, u64 *);
+	int (*trap_policer_init)(struct devlink *, const struct devlink_trap_policer *);
+	void (*trap_policer_fini)(struct devlink *, const struct devlink_trap_policer *);
+	int (*trap_policer_set)(struct devlink *, const struct devlink_trap_policer *, u64, u64, struct netlink_ext_ack *);
+	int (*trap_policer_counter_get)(struct devlink *, const struct devlink_trap_policer *, u64 *);
+	int (*port_new)(struct devlink *, const struct devlink_port_new_attrs *, struct netlink_ext_ack *, struct devlink_port **);
+	int (*rate_leaf_tx_share_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
+	int (*rate_leaf_tx_max_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
+	int (*rate_leaf_tx_priority_set)(struct devlink_rate *, void *, u32, struct netlink_ext_ack *);
+	int (*rate_leaf_tx_weight_set)(struct devlink_rate *, void *, u32, struct netlink_ext_ack *);
+	int (*rate_node_tx_share_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
+	int (*rate_node_tx_max_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
+	int (*rate_node_tx_priority_set)(struct devlink_rate *, void *, u32, struct netlink_ext_ack *);
+	int (*rate_node_tx_weight_set)(struct devlink_rate *, void *, u32, struct netlink_ext_ack *);
+	int (*rate_node_new)(struct devlink_rate *, void **, struct netlink_ext_ack *);
+	int (*rate_node_del)(struct devlink_rate *, void *, struct netlink_ext_ack *);
+	int (*rate_leaf_parent_set)(struct devlink_rate *, struct devlink_rate *, void *, void *, struct netlink_ext_ack *);
+	int (*rate_node_parent_set)(struct devlink_rate *, struct devlink_rate *, void *, void *, struct netlink_ext_ack *);
+	bool (*selftest_check)(struct devlink *, unsigned int, struct netlink_ext_ack *);
+	enum devlink_selftest_status (*selftest_run)(struct devlink *, unsigned int, struct netlink_ext_ack *);
+};
+
+struct irq_poll;
+
+typedef int irq_poll_fn(struct irq_poll *, int);
+
+struct irq_poll {
+	struct list_head list;
+	long unsigned int state;
+	int weight;
+	irq_poll_fn *poll;
+};
+
+struct dim_cq_moder {
+	u16 usec;
+	u16 pkts;
+	u16 comps;
+	u8 cq_period_mode;
+	struct callback_head rcu;
+};
+
+struct dim_sample {
+	ktime_t time;
+	u32 pkt_ctr;
+	u32 byte_ctr;
+	u16 event_ctr;
+	u32 comp_ctr;
+};
+
+struct dim_stats {
+	int ppms;
+	int bpms;
+	int epms;
+	int cpms;
+	int cpe_ratio;
+};
+
+struct dim {
+	u8 state;
+	struct dim_stats prev_stats;
+	struct dim_sample start_sample;
+	struct dim_sample measuring_sample;
+	struct work_struct work;
+	void *priv;
+	u8 profile_ix;
+	u8 mode;
+	u8 tune_state;
+	u8 steps_right;
+	u8 steps_left;
+	u8 tired;
+	long: 32;
+};
+
+enum ib_uverbs_write_cmds {
+	IB_USER_VERBS_CMD_GET_CONTEXT = 0,
+	IB_USER_VERBS_CMD_QUERY_DEVICE = 1,
+	IB_USER_VERBS_CMD_QUERY_PORT = 2,
+	IB_USER_VERBS_CMD_ALLOC_PD = 3,
+	IB_USER_VERBS_CMD_DEALLOC_PD = 4,
+	IB_USER_VERBS_CMD_CREATE_AH = 5,
+	IB_USER_VERBS_CMD_MODIFY_AH = 6,
+	IB_USER_VERBS_CMD_QUERY_AH = 7,
+	IB_USER_VERBS_CMD_DESTROY_AH = 8,
+	IB_USER_VERBS_CMD_REG_MR = 9,
+	IB_USER_VERBS_CMD_REG_SMR = 10,
+	IB_USER_VERBS_CMD_REREG_MR = 11,
+	IB_USER_VERBS_CMD_QUERY_MR = 12,
+	IB_USER_VERBS_CMD_DEREG_MR = 13,
+	IB_USER_VERBS_CMD_ALLOC_MW = 14,
+	IB_USER_VERBS_CMD_BIND_MW = 15,
+	IB_USER_VERBS_CMD_DEALLOC_MW = 16,
+	IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL = 17,
+	IB_USER_VERBS_CMD_CREATE_CQ = 18,
+	IB_USER_VERBS_CMD_RESIZE_CQ = 19,
+	IB_USER_VERBS_CMD_DESTROY_CQ = 20,
+	IB_USER_VERBS_CMD_POLL_CQ = 21,
+	IB_USER_VERBS_CMD_PEEK_CQ = 22,
+	IB_USER_VERBS_CMD_REQ_NOTIFY_CQ = 23,
+	IB_USER_VERBS_CMD_CREATE_QP = 24,
+	IB_USER_VERBS_CMD_QUERY_QP = 25,
+	IB_USER_VERBS_CMD_MODIFY_QP = 26,
+	IB_USER_VERBS_CMD_DESTROY_QP = 27,
+	IB_USER_VERBS_CMD_POST_SEND = 28,
+	IB_USER_VERBS_CMD_POST_RECV = 29,
+	IB_USER_VERBS_CMD_ATTACH_MCAST = 30,
+	IB_USER_VERBS_CMD_DETACH_MCAST = 31,
+	IB_USER_VERBS_CMD_CREATE_SRQ = 32,
+	IB_USER_VERBS_CMD_MODIFY_SRQ = 33,
+	IB_USER_VERBS_CMD_QUERY_SRQ = 34,
+	IB_USER_VERBS_CMD_DESTROY_SRQ = 35,
+	IB_USER_VERBS_CMD_POST_SRQ_RECV = 36,
+	IB_USER_VERBS_CMD_OPEN_XRCD = 37,
+	IB_USER_VERBS_CMD_CLOSE_XRCD = 38,
+	IB_USER_VERBS_CMD_CREATE_XSRQ = 39,
+	IB_USER_VERBS_CMD_OPEN_QP = 40,
+};
+
+enum ib_uverbs_wc_opcode {
+	IB_UVERBS_WC_SEND = 0,
+	IB_UVERBS_WC_RDMA_WRITE = 1,
+	IB_UVERBS_WC_RDMA_READ = 2,
+	IB_UVERBS_WC_COMP_SWAP = 3,
+	IB_UVERBS_WC_FETCH_ADD = 4,
+	IB_UVERBS_WC_BIND_MW = 5,
+	IB_UVERBS_WC_LOCAL_INV = 6,
+	IB_UVERBS_WC_TSO = 7,
+	IB_UVERBS_WC_FLUSH = 8,
+	IB_UVERBS_WC_ATOMIC_WRITE = 9,
+};
+
+enum ib_uverbs_create_qp_mask {
+	IB_UVERBS_CREATE_QP_MASK_IND_TABLE = 1,
+};
+
+enum ib_uverbs_wr_opcode {
+	IB_UVERBS_WR_RDMA_WRITE = 0,
+	IB_UVERBS_WR_RDMA_WRITE_WITH_IMM = 1,
+	IB_UVERBS_WR_SEND = 2,
+	IB_UVERBS_WR_SEND_WITH_IMM = 3,
+	IB_UVERBS_WR_RDMA_READ = 4,
+	IB_UVERBS_WR_ATOMIC_CMP_AND_SWP = 5,
+	IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD = 6,
+	IB_UVERBS_WR_LOCAL_INV = 7,
+	IB_UVERBS_WR_BIND_MW = 8,
+	IB_UVERBS_WR_SEND_WITH_INV = 9,
+	IB_UVERBS_WR_TSO = 10,
+	IB_UVERBS_WR_RDMA_READ_WITH_INV = 11,
+	IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
+	IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
+	IB_UVERBS_WR_FLUSH = 14,
+	IB_UVERBS_WR_ATOMIC_WRITE = 15,
+};
+
+enum ib_uverbs_device_cap_flags {
+	IB_UVERBS_DEVICE_RESIZE_MAX_WR = 1ULL,
+	IB_UVERBS_DEVICE_BAD_PKEY_CNTR = 2ULL,
+	IB_UVERBS_DEVICE_BAD_QKEY_CNTR = 4ULL,
+	IB_UVERBS_DEVICE_RAW_MULTI = 8ULL,
+	IB_UVERBS_DEVICE_AUTO_PATH_MIG = 16ULL,
+	IB_UVERBS_DEVICE_CHANGE_PHY_PORT = 32ULL,
+	IB_UVERBS_DEVICE_UD_AV_PORT_ENFORCE = 64ULL,
+	IB_UVERBS_DEVICE_CURR_QP_STATE_MOD = 128ULL,
+	IB_UVERBS_DEVICE_SHUTDOWN_PORT = 256ULL,
+	IB_UVERBS_DEVICE_PORT_ACTIVE_EVENT = 1024ULL,
+	IB_UVERBS_DEVICE_SYS_IMAGE_GUID = 2048ULL,
+	IB_UVERBS_DEVICE_RC_RNR_NAK_GEN = 4096ULL,
+	IB_UVERBS_DEVICE_SRQ_RESIZE = 8192ULL,
+	IB_UVERBS_DEVICE_N_NOTIFY_CQ = 16384ULL,
+	IB_UVERBS_DEVICE_MEM_WINDOW = 131072ULL,
+	IB_UVERBS_DEVICE_UD_IP_CSUM = 262144ULL,
+	IB_UVERBS_DEVICE_XRC = 1048576ULL,
+	IB_UVERBS_DEVICE_MEM_MGT_EXTENSIONS = 2097152ULL,
+	IB_UVERBS_DEVICE_MEM_WINDOW_TYPE_2A = 8388608ULL,
+	IB_UVERBS_DEVICE_MEM_WINDOW_TYPE_2B = 16777216ULL,
+	IB_UVERBS_DEVICE_RC_IP_CSUM = 33554432ULL,
+	IB_UVERBS_DEVICE_RAW_IP_CSUM = 67108864ULL,
+	IB_UVERBS_DEVICE_MANAGED_FLOW_STEERING = 536870912ULL,
+	IB_UVERBS_DEVICE_RAW_SCATTER_FCS = 17179869184ULL,
+	IB_UVERBS_DEVICE_PCI_WRITE_END_PADDING = 68719476736ULL,
+	IB_UVERBS_DEVICE_FLUSH_GLOBAL = 274877906944ULL,
+	IB_UVERBS_DEVICE_FLUSH_PERSISTENT = 549755813888ULL,
+	IB_UVERBS_DEVICE_ATOMIC_WRITE = 1099511627776ULL,
+};
+
+enum ib_uverbs_raw_packet_caps {
+	IB_UVERBS_RAW_PACKET_CAP_CVLAN_STRIPPING = 1,
+	IB_UVERBS_RAW_PACKET_CAP_SCATTER_FCS = 2,
+	IB_UVERBS_RAW_PACKET_CAP_IP_CSUM = 4,
+	IB_UVERBS_RAW_PACKET_CAP_DELAY_DROP = 8,
+};
+
+enum rdma_nl_counter_mode {
+	RDMA_COUNTER_MODE_NONE = 0,
+	RDMA_COUNTER_MODE_AUTO = 1,
+	RDMA_COUNTER_MODE_MANUAL = 2,
+	RDMA_COUNTER_MODE_MAX = 3,
+};
+
+enum rdma_nl_counter_mask {
+	RDMA_COUNTER_MASK_QP_TYPE = 1,
+	RDMA_COUNTER_MASK_PID = 2,
+};
+
+enum rdma_restrack_type {
+	RDMA_RESTRACK_PD = 0,
+	RDMA_RESTRACK_CQ = 1,
+	RDMA_RESTRACK_QP = 2,
+	RDMA_RESTRACK_CM_ID = 3,
+	RDMA_RESTRACK_MR = 4,
+	RDMA_RESTRACK_CTX = 5,
+	RDMA_RESTRACK_COUNTER = 6,
+	RDMA_RESTRACK_SRQ = 7,
+	RDMA_RESTRACK_MAX = 8,
+};
+
+struct rdma_restrack_entry {
+	bool valid;
+	u8 no_track: 1;
+	struct kref kref;
+	struct completion comp;
+	struct task_struct *task;
+	const char *kern_name;
+	enum rdma_restrack_type type;
+	bool user;
+	u32 id;
+};
+
+struct rdma_link_ops {
+	struct list_head list;
+	const char *type;
+	int (*newlink)(const char *, struct net_device *);
+};
+
+struct auto_mode_param {
+	int qp_type;
+};
+
+struct rdma_counter_mode {
+	enum rdma_nl_counter_mode mode;
+	enum rdma_nl_counter_mask mask;
+	struct auto_mode_param param;
+};
+
+struct rdma_port_counter {
+	struct rdma_counter_mode mode;
+	struct rdma_hw_stats *hstats;
+	unsigned int num_counters;
+	struct mutex lock;
+};
+
+struct rdma_stat_desc;
+
+struct rdma_hw_stats {
+	struct mutex lock;
+	long unsigned int timestamp;
+	long unsigned int lifespan;
+	const struct rdma_stat_desc *descs;
+	long unsigned int *is_disabled;
+	int num_counters;
+	u64 value[0];
+};
+
+struct rdma_counter {
+	struct rdma_restrack_entry res;
+	struct ib_device *device;
+	uint32_t id;
+	struct kref kref;
+	struct rdma_counter_mode mode;
+	struct mutex lock;
+	struct rdma_hw_stats *stats;
+	u32 port;
+};
+
+enum ib_signature_type {
+	IB_SIG_TYPE_NONE = 0,
+	IB_SIG_TYPE_T10_DIF = 1,
+};
+
+enum ib_t10_dif_bg_type {
+	IB_T10DIF_CRC = 0,
+	IB_T10DIF_CSUM = 1,
+};
+
+struct ib_t10_dif_domain {
+	enum ib_t10_dif_bg_type bg_type;
+	u16 pi_interval;
+	u16 bg;
+	u16 app_tag;
+	u32 ref_tag;
+	bool ref_remap;
+	bool app_escape;
+	bool ref_escape;
+	u16 apptag_check_mask;
+};
+
+struct ib_sig_domain {
+	enum ib_signature_type sig_type;
+	union {
+		struct ib_t10_dif_domain dif;
+	} sig;
+};
+
+struct ib_sig_attrs {
+	u8 check_mask;
+	struct ib_sig_domain mem;
+	struct ib_sig_domain wire;
+	int meta_length;
+};
+
+enum ib_sig_err_type {
+	IB_SIG_BAD_GUARD = 0,
+	IB_SIG_BAD_REFTAG = 1,
+	IB_SIG_BAD_APPTAG = 2,
+};
+
+struct ib_sig_err {
+	enum ib_sig_err_type err_type;
+	u32 expected;
+	u32 actual;
+	long: 32;
+	u64 sig_err_offset;
+	u32 key;
+	long: 32;
+};
+
+enum ib_uverbs_access_flags {
+	IB_UVERBS_ACCESS_LOCAL_WRITE = 1,
+	IB_UVERBS_ACCESS_REMOTE_WRITE = 2,
+	IB_UVERBS_ACCESS_REMOTE_READ = 4,
+	IB_UVERBS_ACCESS_REMOTE_ATOMIC = 8,
+	IB_UVERBS_ACCESS_MW_BIND = 16,
+	IB_UVERBS_ACCESS_ZERO_BASED = 32,
+	IB_UVERBS_ACCESS_ON_DEMAND = 64,
+	IB_UVERBS_ACCESS_HUGETLB = 128,
+	IB_UVERBS_ACCESS_FLUSH_GLOBAL = 256,
+	IB_UVERBS_ACCESS_FLUSH_PERSISTENT = 512,
+	IB_UVERBS_ACCESS_RELAXED_ORDERING = 1048576,
+	IB_UVERBS_ACCESS_OPTIONAL_RANGE = 1072693248,
+};
+
+enum ib_uverbs_srq_type {
+	IB_UVERBS_SRQT_BASIC = 0,
+	IB_UVERBS_SRQT_XRC = 1,
+	IB_UVERBS_SRQT_TM = 2,
+};
+
+enum ib_uverbs_wq_type {
+	IB_UVERBS_WQT_RQ = 0,
+};
+
+enum ib_uverbs_wq_flags {
+	IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING = 1,
+	IB_UVERBS_WQ_FLAGS_SCATTER_FCS = 2,
+	IB_UVERBS_WQ_FLAGS_DELAY_DROP = 4,
+	IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING = 8,
+};
+
+enum ib_uverbs_qp_type {
+	IB_UVERBS_QPT_RC = 2,
+	IB_UVERBS_QPT_UC = 3,
+	IB_UVERBS_QPT_UD = 4,
+	IB_UVERBS_QPT_RAW_PACKET = 8,
+	IB_UVERBS_QPT_XRC_INI = 9,
+	IB_UVERBS_QPT_XRC_TGT = 10,
+	IB_UVERBS_QPT_DRIVER = 255,
+};
+
+enum ib_uverbs_qp_create_flags {
+	IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
+	IB_UVERBS_QP_CREATE_SCATTER_FCS = 256,
+	IB_UVERBS_QP_CREATE_CVLAN_STRIPPING = 512,
+	IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING = 2048,
+	IB_UVERBS_QP_CREATE_SQ_SIG_ALL = 4096,
+};
+
+enum ib_uverbs_gid_type {
+	IB_UVERBS_GID_TYPE_IB = 0,
+	IB_UVERBS_GID_TYPE_ROCE_V1 = 1,
+	IB_UVERBS_GID_TYPE_ROCE_V2 = 2,
+};
+
+union ib_gid {
+	u8 raw[16];
+	struct {
+		__be64 subnet_prefix;
+		__be64 interface_id;
+	} global;
+};
+
+enum ib_gid_type {
+	IB_GID_TYPE_IB = 0,
+	IB_GID_TYPE_ROCE = 1,
+	IB_GID_TYPE_ROCE_UDP_ENCAP = 2,
+	IB_GID_TYPE_SIZE = 3,
+};
+
+struct ib_gid_attr {
+	struct net_device *ndev;
+	struct ib_device *device;
+	union ib_gid gid;
+	enum ib_gid_type gid_type;
+	u16 index;
+	u32 port_num;
+	long: 32;
+};
+
+struct ib_cq_init_attr {
+	unsigned int cqe;
+	u32 comp_vector;
+	u32 flags;
+};
+
+struct ib_dm_mr_attr {
+	u64 length;
+	u64 offset;
+	u32 access_flags;
+	long: 32;
+};
+
+struct ib_dm_alloc_attr {
+	u64 length;
+	u32 alignment;
+	u32 flags;
+};
+
+enum ib_mtu {
+	IB_MTU_256 = 1,
+	IB_MTU_512 = 2,
+	IB_MTU_1024 = 3,
+	IB_MTU_2048 = 4,
+	IB_MTU_4096 = 5,
+};
+
+enum ib_port_state {
+	IB_PORT_NOP = 0,
+	IB_PORT_DOWN = 1,
+	IB_PORT_INIT = 2,
+	IB_PORT_ARMED = 3,
+	IB_PORT_ACTIVE = 4,
+	IB_PORT_ACTIVE_DEFER = 5,
+};
+
+struct rdma_stat_desc {
+	const char *name;
+	unsigned int flags;
+	const void *priv;
+};
+
+struct ib_port_attr {
+	u64 subnet_prefix;
+	enum ib_port_state state;
+	enum ib_mtu max_mtu;
+	enum ib_mtu active_mtu;
+	u32 phys_mtu;
+	int gid_tbl_len;
+	unsigned int ip_gids: 1;
+	u32 port_cap_flags;
+	u32 max_msg_sz;
+	u32 bad_pkey_cntr;
+	u32 qkey_viol_cntr;
+	u16 pkey_tbl_len;
+	u32 sm_lid;
+	u32 lid;
+	u8 lmc;
+	u8 max_vl_num;
+	u8 sm_sl;
+	u8 subnet_timeout;
+	u8 init_type_reply;
+	u8 active_width;
+	u16 active_speed;
+	u8 phys_state;
+	u16 port_cap_flags2;
+};
+
+struct ib_device_modify {
+	u64 sys_image_guid;
+	char node_desc[64];
+};
+
+struct ib_port_modify {
+	u32 set_port_cap_mask;
+	u32 clr_port_cap_mask;
+	u8 init_type;
+};
+
+enum ib_event_type {
+	IB_EVENT_CQ_ERR = 0,
+	IB_EVENT_QP_FATAL = 1,
+	IB_EVENT_QP_REQ_ERR = 2,
+	IB_EVENT_QP_ACCESS_ERR = 3,
+	IB_EVENT_COMM_EST = 4,
+	IB_EVENT_SQ_DRAINED = 5,
+	IB_EVENT_PATH_MIG = 6,
+	IB_EVENT_PATH_MIG_ERR = 7,
+	IB_EVENT_DEVICE_FATAL = 8,
+	IB_EVENT_PORT_ACTIVE = 9,
+	IB_EVENT_PORT_ERR = 10,
+	IB_EVENT_LID_CHANGE = 11,
+	IB_EVENT_PKEY_CHANGE = 12,
+	IB_EVENT_SM_CHANGE = 13,
+	IB_EVENT_SRQ_ERR = 14,
+	IB_EVENT_SRQ_LIMIT_REACHED = 15,
+	IB_EVENT_QP_LAST_WQE_REACHED = 16,
+	IB_EVENT_CLIENT_REREGISTER = 17,
+	IB_EVENT_GID_CHANGE = 18,
+	IB_EVENT_WQ_FATAL = 19,
+};
+
+struct ib_ucq_object;
+
+typedef void (*ib_comp_handler)(struct ib_cq *, void *);
+
+enum ib_poll_context {
+	IB_POLL_SOFTIRQ = 0,
+	IB_POLL_WORKQUEUE = 1,
+	IB_POLL_UNBOUND_WORKQUEUE = 2,
+	IB_POLL_LAST_POOL_TYPE = 2,
+	IB_POLL_DIRECT = 3,
+};
+
+struct ib_event;
+
+struct ib_cq {
+	struct ib_device *device;
+	struct ib_ucq_object *uobject;
+	ib_comp_handler comp_handler;
+	void (*event_handler)(struct ib_event *, void *);
+	void *cq_context;
+	int cqe;
+	unsigned int cqe_used;
+	atomic_t usecnt;
+	enum ib_poll_context poll_ctx;
+	struct ib_wc *wc;
+	struct list_head pool_entry;
+	union {
+		struct irq_poll iop;
+		struct work_struct work;
+	};
+	struct workqueue_struct *comp_wq;
+	struct dim *dim;
+	long: 32;
+	ktime_t timestamp;
+	u8 interrupt: 1;
+	u8 shared: 1;
+	unsigned int comp_vector;
+	struct rdma_restrack_entry res;
+	long: 32;
+};
+
+struct ib_uqp_object;
+
+enum ib_qp_type {
+	IB_QPT_SMI = 0,
+	IB_QPT_GSI = 1,
+	IB_QPT_RC = 2,
+	IB_QPT_UC = 3,
+	IB_QPT_UD = 4,
+	IB_QPT_RAW_IPV6 = 5,
+	IB_QPT_RAW_ETHERTYPE = 6,
+	IB_QPT_RAW_PACKET = 8,
+	IB_QPT_XRC_INI = 9,
+	IB_QPT_XRC_TGT = 10,
+	IB_QPT_MAX = 11,
+	IB_QPT_DRIVER = 255,
+	IB_QPT_RESERVED1 = 4096,
+	IB_QPT_RESERVED2 = 4097,
+	IB_QPT_RESERVED3 = 4098,
+	IB_QPT_RESERVED4 = 4099,
+	IB_QPT_RESERVED5 = 4100,
+	IB_QPT_RESERVED6 = 4101,
+	IB_QPT_RESERVED7 = 4102,
+	IB_QPT_RESERVED8 = 4103,
+	IB_QPT_RESERVED9 = 4104,
+	IB_QPT_RESERVED10 = 4105,
+};
+
+struct ib_qp_security;
+
+struct ib_qp {
+	struct ib_device *device;
+	struct ib_pd *pd;
+	struct ib_cq *send_cq;
+	struct ib_cq *recv_cq;
+	spinlock_t mr_lock;
+	int mrs_used;
+	struct list_head rdma_mrs;
+	struct list_head sig_mrs;
+	struct ib_srq *srq;
+	struct completion srq_completion;
+	struct ib_xrcd *xrcd;
+	struct list_head xrcd_list;
+	atomic_t usecnt;
+	struct list_head open_list;
+	struct ib_qp *real_qp;
+	struct ib_uqp_object *uobject;
+	void (*event_handler)(struct ib_event *, void *);
+	void (*registered_event_handler)(struct ib_event *, void *);
+	void *qp_context;
+	const struct ib_gid_attr *av_sgid_attr;
+	const struct ib_gid_attr *alt_path_sgid_attr;
+	u32 qp_num;
+	u32 max_write_sge;
+	u32 max_read_sge;
+	enum ib_qp_type qp_type;
+	struct ib_rwq_ind_table *rwq_ind_tbl;
+	struct ib_qp_security *qp_sec;
+	u32 port;
+	bool integrity_en;
+	struct rdma_restrack_entry res;
+	struct rdma_counter *counter;
+};
+
+struct ib_usrq_object;
+
+enum ib_srq_type {
+	IB_SRQT_BASIC = 0,
+	IB_SRQT_XRC = 1,
+	IB_SRQT_TM = 2,
+};
+
+struct ib_srq {
+	struct ib_device *device;
+	struct ib_pd *pd;
+	struct ib_usrq_object *uobject;
+	void (*event_handler)(struct ib_event *, void *);
+	void *srq_context;
+	enum ib_srq_type srq_type;
+	atomic_t usecnt;
+	struct {
+		struct ib_cq *cq;
+		union {
+			struct {
+				struct ib_xrcd *xrcd;
+				u32 srq_num;
+			} xrc;
+		};
+	} ext;
+	struct rdma_restrack_entry res;
+};
+
+struct ib_uwq_object;
+
+enum ib_wq_state {
+	IB_WQS_RESET = 0,
+	IB_WQS_RDY = 1,
+	IB_WQS_ERR = 2,
+};
+
+enum ib_wq_type {
+	IB_WQT_RQ = 0,
+};
+
+struct ib_wq {
+	struct ib_device *device;
+	struct ib_uwq_object *uobject;
+	void *wq_context;
+	void (*event_handler)(struct ib_event *, void *);
+	struct ib_pd *pd;
+	struct ib_cq *cq;
+	u32 wq_num;
+	enum ib_wq_state state;
+	enum ib_wq_type wq_type;
+	atomic_t usecnt;
+};
+
+struct ib_event {
+	struct ib_device *device;
+	union {
+		struct ib_cq *cq;
+		struct ib_qp *qp;
+		struct ib_srq *srq;
+		struct ib_wq *wq;
+		u32 port_num;
+	} element;
+	enum ib_event_type event;
+};
+
+struct ib_global_route {
+	const struct ib_gid_attr *sgid_attr;
+	long: 32;
+	union ib_gid dgid;
+	u32 flow_label;
+	u8 sgid_index;
+	u8 hop_limit;
+	u8 traffic_class;
+};
+
+struct ib_grh {
+	__be32 version_tclass_flow;
+	__be16 paylen;
+	u8 next_hdr;
+	u8 hop_limit;
+	union ib_gid sgid;
+	union ib_gid dgid;
+};
+
+struct ib_mr_status {
+	u32 fail_status;
+	long: 32;
+	struct ib_sig_err sig_err;
+};
+
+struct rdma_ah_init_attr {
+	struct rdma_ah_attr *ah_attr;
+	u32 flags;
+	struct net_device *xmit_slave;
+};
+
+enum rdma_ah_attr_type {
+	RDMA_AH_ATTR_TYPE_UNDEFINED = 0,
+	RDMA_AH_ATTR_TYPE_IB = 1,
+	RDMA_AH_ATTR_TYPE_ROCE = 2,
+	RDMA_AH_ATTR_TYPE_OPA = 3,
+};
+
+struct ib_ah_attr {
+	u16 dlid;
+	u8 src_path_bits;
+};
+
+struct roce_ah_attr {
+	u8 dmac[6];
+};
+
+struct opa_ah_attr {
+	u32 dlid;
+	u8 src_path_bits;
+	bool make_grd;
+};
+
+struct rdma_ah_attr {
+	struct ib_global_route grh;
+	u8 sl;
+	u8 static_rate;
+	u32 port_num;
+	u8 ah_flags;
+	enum rdma_ah_attr_type type;
+	union {
+		struct ib_ah_attr ib;
+		struct roce_ah_attr roce;
+		struct opa_ah_attr opa;
+	};
+};
+
+enum ib_wc_status {
+	IB_WC_SUCCESS = 0,
+	IB_WC_LOC_LEN_ERR = 1,
+	IB_WC_LOC_QP_OP_ERR = 2,
+	IB_WC_LOC_EEC_OP_ERR = 3,
+	IB_WC_LOC_PROT_ERR = 4,
+	IB_WC_WR_FLUSH_ERR = 5,
+	IB_WC_MW_BIND_ERR = 6,
+	IB_WC_BAD_RESP_ERR = 7,
+	IB_WC_LOC_ACCESS_ERR = 8,
+	IB_WC_REM_INV_REQ_ERR = 9,
+	IB_WC_REM_ACCESS_ERR = 10,
+	IB_WC_REM_OP_ERR = 11,
+	IB_WC_RETRY_EXC_ERR = 12,
+	IB_WC_RNR_RETRY_EXC_ERR = 13,
+	IB_WC_LOC_RDD_VIOL_ERR = 14,
+	IB_WC_REM_INV_RD_REQ_ERR = 15,
+	IB_WC_REM_ABORT_ERR = 16,
+	IB_WC_INV_EECN_ERR = 17,
+	IB_WC_INV_EEC_STATE_ERR = 18,
+	IB_WC_FATAL_ERR = 19,
+	IB_WC_RESP_TIMEOUT_ERR = 20,
+	IB_WC_GENERAL_ERR = 21,
+};
+
+enum ib_wc_opcode {
+	IB_WC_SEND = 0,
+	IB_WC_RDMA_WRITE = 1,
+	IB_WC_RDMA_READ = 2,
+	IB_WC_COMP_SWAP = 3,
+	IB_WC_FETCH_ADD = 4,
+	IB_WC_BIND_MW = 5,
+	IB_WC_LOCAL_INV = 6,
+	IB_WC_LSO = 7,
+	IB_WC_ATOMIC_WRITE = 9,
+	IB_WC_REG_MR = 10,
+	IB_WC_MASKED_COMP_SWAP = 11,
+	IB_WC_MASKED_FETCH_ADD = 12,
+	IB_WC_FLUSH = 8,
+	IB_WC_RECV = 128,
+	IB_WC_RECV_RDMA_WITH_IMM = 129,
+};
+
+struct ib_cqe {
+	void (*done)(struct ib_cq *, struct ib_wc *);
+};
+
+struct ib_wc {
+	union {
+		u64 wr_id;
+		struct ib_cqe *wr_cqe;
+	};
+	enum ib_wc_status status;
+	enum ib_wc_opcode opcode;
+	u32 vendor_err;
+	u32 byte_len;
+	struct ib_qp *qp;
+	union {
+		__be32 imm_data;
+		u32 invalidate_rkey;
+	} ex;
+	u32 src_qp;
+	u32 slid;
+	int wc_flags;
+	u16 pkey_index;
+	u8 sl;
+	u8 dlid_path_bits;
+	u32 port_num;
+	u8 smac[6];
+	u16 vlan_id;
+	u8 network_hdr_type;
+};
+
+struct ib_srq_attr {
+	u32 max_wr;
+	u32 max_sge;
+	u32 srq_limit;
+};
+
+struct ib_xrcd {
+	struct ib_device *device;
+	atomic_t usecnt;
+	struct inode *inode;
+	struct rw_semaphore tgt_qps_rwsem;
+	struct xarray tgt_qps;
+};
+
+struct ib_srq_init_attr {
+	void (*event_handler)(struct ib_event *, void *);
+	void *srq_context;
+	struct ib_srq_attr attr;
+	enum ib_srq_type srq_type;
+	struct {
+		struct ib_cq *cq;
+		union {
+			struct {
+				struct ib_xrcd *xrcd;
+			} xrc;
+			struct {
+				u32 max_num_tags;
+			} tag_matching;
+		};
+	} ext;
+};
+
+struct ib_qp_cap {
+	u32 max_send_wr;
+	u32 max_recv_wr;
+	u32 max_send_sge;
+	u32 max_recv_sge;
+	u32 max_inline_data;
+	u32 max_rdma_ctxs;
+};
+
+enum ib_sig_type {
+	IB_SIGNAL_ALL_WR = 0,
+	IB_SIGNAL_REQ_WR = 1,
+};
+
+struct ib_qp_init_attr {
+	void (*event_handler)(struct ib_event *, void *);
+	void *qp_context;
+	struct ib_cq *send_cq;
+	struct ib_cq *recv_cq;
+	struct ib_srq *srq;
+	struct ib_xrcd *xrcd;
+	struct ib_qp_cap cap;
+	enum ib_sig_type sq_sig_type;
+	enum ib_qp_type qp_type;
+	u32 create_flags;
+	u32 port_num;
+	struct ib_rwq_ind_table *rwq_ind_tbl;
+	u32 source_qpn;
+};
+
+struct ib_uobject;
+
+struct ib_rwq_ind_table {
+	struct ib_device *device;
+	struct ib_uobject *uobject;
+	atomic_t usecnt;
+	u32 ind_tbl_num;
+	u32 log_ind_tbl_size;
+	struct ib_wq **ind_tbl;
+};
+
+enum ib_qp_state {
+	IB_QPS_RESET = 0,
+	IB_QPS_INIT = 1,
+	IB_QPS_RTR = 2,
+	IB_QPS_RTS = 3,
+	IB_QPS_SQD = 4,
+	IB_QPS_SQE = 5,
+	IB_QPS_ERR = 6,
+};
+
+enum ib_mig_state {
+	IB_MIG_MIGRATED = 0,
+	IB_MIG_REARM = 1,
+	IB_MIG_ARMED = 2,
+};
+
+enum ib_mw_type {
+	IB_MW_TYPE_1 = 1,
+	IB_MW_TYPE_2 = 2,
+};
+
+struct ib_qp_attr {
+	enum ib_qp_state qp_state;
+	enum ib_qp_state cur_qp_state;
+	enum ib_mtu path_mtu;
+	enum ib_mig_state path_mig_state;
+	u32 qkey;
+	u32 rq_psn;
+	u32 sq_psn;
+	u32 dest_qp_num;
+	int qp_access_flags;
+	struct ib_qp_cap cap;
+	long: 32;
+	struct rdma_ah_attr ah_attr;
+	struct rdma_ah_attr alt_ah_attr;
+	u16 pkey_index;
+	u16 alt_pkey_index;
+	u8 en_sqd_async_notify;
+	u8 sq_draining;
+	u8 max_rd_atomic;
+	u8 max_dest_rd_atomic;
+	u8 min_rnr_timer;
+	u32 port_num;
+	u8 timeout;
+	u8 retry_cnt;
+	u8 rnr_retry;
+	u32 alt_port_num;
+	u8 alt_timeout;
+	u32 rate_limit;
+	struct net_device *xmit_slave;
+	long: 32;
+};
+
+enum ib_wr_opcode {
+	IB_WR_RDMA_WRITE = 0,
+	IB_WR_RDMA_WRITE_WITH_IMM = 1,
+	IB_WR_SEND = 2,
+	IB_WR_SEND_WITH_IMM = 3,
+	IB_WR_RDMA_READ = 4,
+	IB_WR_ATOMIC_CMP_AND_SWP = 5,
+	IB_WR_ATOMIC_FETCH_AND_ADD = 6,
+	IB_WR_BIND_MW = 8,
+	IB_WR_LSO = 10,
+	IB_WR_SEND_WITH_INV = 9,
+	IB_WR_RDMA_READ_WITH_INV = 11,
+	IB_WR_LOCAL_INV = 7,
+	IB_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
+	IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
+	IB_WR_FLUSH = 14,
+	IB_WR_ATOMIC_WRITE = 15,
+	IB_WR_REG_MR = 32,
+	IB_WR_REG_MR_INTEGRITY = 33,
+	IB_WR_RESERVED1 = 240,
+	IB_WR_RESERVED2 = 241,
+	IB_WR_RESERVED3 = 242,
+	IB_WR_RESERVED4 = 243,
+	IB_WR_RESERVED5 = 244,
+	IB_WR_RESERVED6 = 245,
+	IB_WR_RESERVED7 = 246,
+	IB_WR_RESERVED8 = 247,
+	IB_WR_RESERVED9 = 248,
+	IB_WR_RESERVED10 = 249,
+};
+
+struct ib_sge {
+	u64 addr;
+	u32 length;
+	u32 lkey;
+};
+
+struct ib_send_wr {
+	struct ib_send_wr *next;
+	long: 32;
+	union {
+		u64 wr_id;
+		struct ib_cqe *wr_cqe;
+	};
+	struct ib_sge *sg_list;
+	int num_sge;
+	enum ib_wr_opcode opcode;
+	int send_flags;
+	union {
+		__be32 imm_data;
+		u32 invalidate_rkey;
+	} ex;
+	long: 32;
+};
+
+struct ib_ah {
+	struct ib_device *device;
+	struct ib_pd *pd;
+	struct ib_uobject *uobject;
+	const struct ib_gid_attr *sgid_attr;
+	enum rdma_ah_attr_type type;
+};
+
+struct ib_mr {
+	struct ib_device *device;
+	struct ib_pd *pd;
+	u32 lkey;
+	u32 rkey;
+	u64 iova;
+	u64 length;
+	unsigned int page_size;
+	enum ib_mr_type type;
+	bool need_inval;
+	union {
+		struct ib_uobject *uobject;
+		struct list_head qp_entry;
+	};
+	struct ib_dm *dm;
+	struct ib_sig_attrs *sig_attrs;
+	struct rdma_restrack_entry res;
+};
+
+struct ib_recv_wr {
+	struct ib_recv_wr *next;
+	long: 32;
+	union {
+		u64 wr_id;
+		struct ib_cqe *wr_cqe;
+	};
+	struct ib_sge *sg_list;
+	int num_sge;
+};
+
+struct ib_rdmacg_object {
+	struct rdma_cgroup *cg;
+};
+
+struct ib_uverbs_file;
+
+struct ib_ucontext {
+	struct ib_device *device;
+	struct ib_uverbs_file *ufile;
+	struct ib_rdmacg_object cg_obj;
+	struct rdma_restrack_entry res;
+	struct xarray mmap_xa;
+};
+
+struct uverbs_api_object;
+
+struct ib_uobject {
+	u64 user_handle;
+	struct ib_uverbs_file *ufile;
+	struct ib_ucontext *context;
+	void *object;
+	struct list_head list;
+	struct ib_rdmacg_object cg_obj;
+	int id;
+	struct kref ref;
+	atomic_t usecnt;
+	struct callback_head rcu;
+	const struct uverbs_api_object *uapi_object;
+};
+
+struct ib_udata {
+	const void *inbuf;
+	void *outbuf;
+	size_t inlen;
+	size_t outlen;
+};
+
+struct ib_pd {
+	u32 local_dma_lkey;
+	u32 flags;
+	struct ib_device *device;
+	struct ib_uobject *uobject;
+	atomic_t usecnt;
+	u32 unsafe_global_rkey;
+	struct ib_mr *__internal_mr;
+	struct rdma_restrack_entry res;
+};
+
+struct ib_wq_init_attr {
+	void *wq_context;
+	enum ib_wq_type wq_type;
+	u32 max_wr;
+	u32 max_sge;
+	struct ib_cq *cq;
+	void (*event_handler)(struct ib_event *, void *);
+	u32 create_flags;
+};
+
+struct ib_wq_attr {
+	enum ib_wq_state wq_state;
+	enum ib_wq_state curr_wq_state;
+	u32 flags;
+	u32 flags_mask;
+};
+
+struct ib_rwq_ind_table_init_attr {
+	u32 log_ind_tbl_size;
+	struct ib_wq **ind_tbl;
+};
+
+enum port_pkey_state {
+	IB_PORT_PKEY_NOT_VALID = 0,
+	IB_PORT_PKEY_VALID = 1,
+	IB_PORT_PKEY_LISTED = 2,
+};
+
+struct ib_port_pkey {
+	enum port_pkey_state state;
+	u16 pkey_index;
+	u32 port_num;
+	struct list_head qp_list;
+	struct list_head to_error_list;
+	struct ib_qp_security *sec;
+};
+
+struct ib_ports_pkeys;
+
+struct ib_qp_security {
+	struct ib_qp *qp;
+	struct ib_device *dev;
+	struct mutex mutex;
+	struct ib_ports_pkeys *ports_pkeys;
+	struct list_head shared_qp_list;
+	void *security;
+	bool destroying;
+	atomic_t error_list_count;
+	struct completion error_complete;
+	int error_comps_pending;
+};
+
+struct ib_ports_pkeys {
+	struct ib_port_pkey main;
+	struct ib_port_pkey alt;
+};
+
+struct ib_dm {
+	struct ib_device *device;
+	u32 length;
+	u32 flags;
+	struct ib_uobject *uobject;
+	atomic_t usecnt;
+};
+
+struct ib_mw {
+	struct ib_device *device;
+	struct ib_pd *pd;
+	struct ib_uobject *uobject;
+	u32 rkey;
+	enum ib_mw_type type;
+};
+
+enum ib_flow_attr_type {
+	IB_FLOW_ATTR_NORMAL = 0,
+	IB_FLOW_ATTR_ALL_DEFAULT = 1,
+	IB_FLOW_ATTR_MC_DEFAULT = 2,
+	IB_FLOW_ATTR_SNIFFER = 3,
+};
+
+enum ib_flow_spec_type {
+	IB_FLOW_SPEC_ETH = 32,
+	IB_FLOW_SPEC_IB = 34,
+	IB_FLOW_SPEC_IPV4 = 48,
+	IB_FLOW_SPEC_IPV6 = 49,
+	IB_FLOW_SPEC_ESP = 52,
+	IB_FLOW_SPEC_TCP = 64,
+	IB_FLOW_SPEC_UDP = 65,
+	IB_FLOW_SPEC_VXLAN_TUNNEL = 80,
+	IB_FLOW_SPEC_GRE = 81,
+	IB_FLOW_SPEC_MPLS = 96,
+	IB_FLOW_SPEC_INNER = 256,
+	IB_FLOW_SPEC_ACTION_TAG = 4096,
+	IB_FLOW_SPEC_ACTION_DROP = 4097,
+	IB_FLOW_SPEC_ACTION_HANDLE = 4098,
+	IB_FLOW_SPEC_ACTION_COUNT = 4099,
+};
+
+struct ib_flow_eth_filter {
+	u8 dst_mac[6];
+	u8 src_mac[6];
+	__be16 ether_type;
+	__be16 vlan_tag;
+};
+
+struct ib_flow_spec_eth {
+	u32 type;
+	u16 size;
+	struct ib_flow_eth_filter val;
+	struct ib_flow_eth_filter mask;
+};
+
+struct ib_flow_ib_filter {
+	__be16 dlid;
+	__u8 sl;
+};
+
+struct ib_flow_spec_ib {
+	u32 type;
+	u16 size;
+	struct ib_flow_ib_filter val;
+	struct ib_flow_ib_filter mask;
+};
+
+struct ib_flow_ipv4_filter {
+	__be32 src_ip;
+	__be32 dst_ip;
+	u8 proto;
+	u8 tos;
+	u8 ttl;
+	u8 flags;
+};
+
+struct ib_flow_spec_ipv4 {
+	u32 type;
+	u16 size;
+	struct ib_flow_ipv4_filter val;
+	struct ib_flow_ipv4_filter mask;
+};
+
+struct ib_flow_ipv6_filter {
+	u8 src_ip[16];
+	u8 dst_ip[16];
+	__be32 flow_label;
+	u8 next_hdr;
+	u8 traffic_class;
+	u8 hop_limit;
+} __attribute__((packed));
+
+struct ib_flow_spec_ipv6 {
+	u32 type;
+	u16 size;
+	struct ib_flow_ipv6_filter val;
+	struct ib_flow_ipv6_filter mask;
+};
+
+struct ib_flow_tcp_udp_filter {
+	__be16 dst_port;
+	__be16 src_port;
+};
+
+struct ib_flow_spec_tcp_udp {
+	u32 type;
+	u16 size;
+	struct ib_flow_tcp_udp_filter val;
+	struct ib_flow_tcp_udp_filter mask;
+};
+
+struct ib_flow_tunnel_filter {
+	__be32 tunnel_id;
+};
+
+struct ib_flow_spec_tunnel {
+	u32 type;
+	u16 size;
+	struct ib_flow_tunnel_filter val;
+	struct ib_flow_tunnel_filter mask;
+};
+
+struct ib_flow_esp_filter {
+	__be32 spi;
+	__be32 seq;
+};
+
+struct ib_flow_spec_esp {
+	u32 type;
+	u16 size;
+	struct ib_flow_esp_filter val;
+	struct ib_flow_esp_filter mask;
+};
+
+struct ib_flow_gre_filter {
+	__be16 c_ks_res0_ver;
+	__be16 protocol;
+	__be32 key;
+};
+
+struct ib_flow_spec_gre {
+	u32 type;
+	u16 size;
+	struct ib_flow_gre_filter val;
+	struct ib_flow_gre_filter mask;
+};
+
+struct ib_flow_mpls_filter {
+	__be32 tag;
+};
+
+struct ib_flow_spec_mpls {
+	u32 type;
+	u16 size;
+	struct ib_flow_mpls_filter val;
+	struct ib_flow_mpls_filter mask;
+};
+
+struct ib_flow_spec_action_tag {
+	enum ib_flow_spec_type type;
+	u16 size;
+	u32 tag_id;
+};
+
+struct ib_flow_spec_action_drop {
+	enum ib_flow_spec_type type;
+	u16 size;
+};
+
+struct ib_flow_spec_action_handle {
+	enum ib_flow_spec_type type;
+	u16 size;
+	struct ib_flow_action *act;
+};
+
+enum ib_flow_action_type {
+	IB_FLOW_ACTION_UNSPECIFIED = 0,
+	IB_FLOW_ACTION_ESP = 1,
+};
+
+struct ib_flow_action {
+	struct ib_device *device;
+	struct ib_uobject *uobject;
+	enum ib_flow_action_type type;
+	atomic_t usecnt;
+};
+
+struct ib_flow_spec_action_count {
+	enum ib_flow_spec_type type;
+	u16 size;
+	struct ib_counters *counters;
+};
+
+struct ib_counters {
+	struct ib_device *device;
+	struct ib_uobject *uobject;
+	atomic_t usecnt;
+};
+
+union ib_flow_spec {
+	struct {
+		u32 type;
+		u16 size;
+	};
+	struct ib_flow_spec_eth eth;
+	struct ib_flow_spec_ib ib;
+	struct ib_flow_spec_ipv4 ipv4;
+	struct ib_flow_spec_tcp_udp tcp_udp;
+	struct ib_flow_spec_ipv6 ipv6;
+	struct ib_flow_spec_tunnel tunnel;
+	struct ib_flow_spec_esp esp;
+	struct ib_flow_spec_gre gre;
+	struct ib_flow_spec_mpls mpls;
+	struct ib_flow_spec_action_tag flow_tag;
+	struct ib_flow_spec_action_drop drop;
+	struct ib_flow_spec_action_handle action;
+	struct ib_flow_spec_action_count flow_count;
+};
+
+struct ib_flow_attr {
+	enum ib_flow_attr_type type;
+	u16 size;
+	u16 priority;
+	u32 flags;
+	u8 num_of_specs;
+	u32 port;
+	union ib_flow_spec flows[0];
+};
+
+struct ib_flow {
+	struct ib_qp *qp;
+	struct ib_device *device;
+	struct ib_uobject *uobject;
+};
+
+struct ib_pkey_cache;
+
+struct ib_gid_table;
+
+struct ib_port_cache {
+	u64 subnet_prefix;
+	struct ib_pkey_cache *pkey;
+	struct ib_gid_table *gid;
+	u8 lmc;
+	enum ib_port_state port_state;
+};
+
+struct ib_port_immutable {
+	int pkey_tbl_len;
+	int gid_tbl_len;
+	u32 core_cap_flags;
+	u32 max_mad_size;
+};
+
+struct ib_port;
+
+struct ib_port_data {
+	struct ib_device *ib_dev;
+	struct ib_port_immutable immutable;
+	spinlock_t pkey_list_lock;
+	spinlock_t netdev_lock;
+	struct list_head pkey_list;
+	long: 32;
+	struct ib_port_cache cache;
+	struct net_device *netdev;
+	netdevice_tracker netdev_tracker;
+	struct hlist_node ndev_hash_link;
+	struct rdma_port_counter port_counter;
+	struct ib_port *sysfs;
+};
+
+struct rdma_netdev_alloc_params {
+	size_t sizeof_priv;
+	unsigned int txqs;
+	unsigned int rxqs;
+	void *param;
+	int (*initialize_rdma_netdev)(struct ib_device *, u32, struct net_device *, void *);
+};
+
+struct ib_counters_read_attr {
+	u64 *counters_buff;
+	u32 ncounters;
+	u32 flags;
+};
+
+struct rdma_user_mmap_entry {
+	struct kref ref;
+	struct ib_ucontext *ucontext;
+	long unsigned int start_pgoff;
+	size_t npages;
+	bool driver_removed;
+};
+
+enum devlink_multicast_groups {
+	DEVLINK_MCGRP_CONFIG = 0,
+};
+
+struct devlink_nl_dump_state {
+	long unsigned int instance;
+	int idx;
+	union {
+		struct {
+			u64 start_offset;
+		};
+		struct {
+			u64 dump_ts;
+		};
+	};
+};
+
+typedef int devlink_nl_dump_one_func_t(struct sk_buff *, struct devlink *, struct netlink_callback *, int);
+
+struct devlink_obj_desc {
+	struct callback_head rcu;
+	const char *bus_name;
+	const char *dev_name;
+	unsigned int port_index;
+	bool port_index_valid;
+	long int data[0];
+};
+
+struct devlink_nl_sock_priv {
+	struct devlink_obj_desc *flt;
+	spinlock_t flt_lock;
+};
+
+enum devlink_dpipe_match_type {
+	DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT = 0,
+};
+
+enum devlink_dpipe_action_type {
+	DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY = 0,
+};
+
+enum devlink_dpipe_field_ethernet_id {
+	DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC = 0,
+};
+
+enum devlink_dpipe_field_ipv4_id {
+	DEVLINK_DPIPE_FIELD_IPV4_DST_IP = 0,
+};
+
+enum devlink_dpipe_field_ipv6_id {
+	DEVLINK_DPIPE_FIELD_IPV6_DST_IP = 0,
+};
+
+enum devlink_dpipe_header_id {
+	DEVLINK_DPIPE_HEADER_ETHERNET = 0,
+	DEVLINK_DPIPE_HEADER_IPV4 = 1,
+	DEVLINK_DPIPE_HEADER_IPV6 = 2,
+};
+
+struct devlink_dpipe_match {
+	enum devlink_dpipe_match_type type;
+	unsigned int header_index;
+	struct devlink_dpipe_header *header;
+	unsigned int field_id;
+};
+
+struct devlink_dpipe_action {
+	enum devlink_dpipe_action_type type;
+	unsigned int header_index;
+	struct devlink_dpipe_header *header;
+	unsigned int field_id;
+};
+
+struct devlink_dpipe_value {
+	union {
+		struct devlink_dpipe_action *action;
+		struct devlink_dpipe_match *match;
+	};
+	unsigned int mapping_value;
+	bool mapping_valid;
+	unsigned int value_size;
+	void *value;
+	void *mask;
+};
+
+struct devlink_dpipe_entry {
+	u64 index;
+	struct devlink_dpipe_value *match_values;
+	unsigned int match_values_count;
+	struct devlink_dpipe_value *action_values;
+	unsigned int action_values_count;
+	u64 counter;
+	bool counter_valid;
+	long: 32;
+};
+
+struct devlink_dpipe_dump_ctx {
+	struct genl_info *info;
+	enum devlink_command cmd;
+	struct sk_buff *skb;
+	struct nlattr *nest;
+	void *hdr;
+};
+
+struct devlink_dpipe_table_ops;
+
+struct devlink_dpipe_table {
+	void *priv;
+	struct list_head list;
+	const char *name;
+	bool counters_enabled;
+	bool counter_control_extern;
+	bool resource_valid;
+	long: 32;
+	u64 resource_id;
+	u64 resource_units;
+	const struct devlink_dpipe_table_ops *table_ops;
+	struct callback_head rcu;
+	long: 32;
+};
+
+struct devlink_dpipe_table_ops {
+	int (*actions_dump)(void *, struct sk_buff *);
+	int (*matches_dump)(void *, struct sk_buff *);
+	int (*entries_dump)(void *, bool, struct devlink_dpipe_dump_ctx *);
+	int (*counters_set_update)(void *, bool);
+	u64 (*size_get)(void *);
+};
+
+enum devlink_health_reporter_state {
+	DEVLINK_HEALTH_REPORTER_STATE_HEALTHY = 0,
+	DEVLINK_HEALTH_REPORTER_STATE_ERROR = 1,
+};
+
+struct devlink_health_reporter;
+
+struct devlink_fmsg;
+
+struct devlink_health_reporter_ops {
+	char *name;
+	int (*recover)(struct devlink_health_reporter *, void *, struct netlink_ext_ack *);
+	int (*dump)(struct devlink_health_reporter *, struct devlink_fmsg *, void *, struct netlink_ext_ack *);
+	int (*diagnose)(struct devlink_health_reporter *, struct devlink_fmsg *, struct netlink_ext_ack *);
+	int (*test)(struct devlink_health_reporter *, struct netlink_ext_ack *);
+};
+
+struct devlink_health_reporter {
+	struct list_head list;
+	void *priv;
+	const struct devlink_health_reporter_ops *ops;
+	struct devlink *devlink;
+	struct devlink_port *devlink_port;
+	struct devlink_fmsg *dump_fmsg;
+	long: 32;
+	u64 graceful_period;
+	bool auto_recover;
+	bool auto_dump;
+	u8 health_state;
+	long: 32;
+	u64 dump_ts;
+	u64 dump_real_ts;
+	u64 error_count;
+	u64 recovery_count;
+	u64 last_recovery_ts;
+};
+
+struct devlink_fmsg {
+	struct list_head item_list;
+	int err;
+	bool putting_binary;
+};
+
+struct devlink_fmsg_item {
+	struct list_head list;
+	int attrtype;
+	u8 nla_type;
+	u16 len;
+	int value[0];
+};
+
+struct dsa_stubs {
+	int (*conduit_hwtstamp_validate)(struct net_device *, const struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
+};
+
+struct of_phandle_iterator {
+	const char *cells_name;
+	int cell_count;
+	const struct device_node *parent;
+	const __be32 *list_end;
+	const __be32 *phandle_end;
+	const __be32 *cur;
+	uint32_t cur_count;
+	phandle phandle;
+	struct device_node *node;
+};
+
+struct dsa_link {
+	struct dsa_port *dp;
+	struct dsa_port *link_dp;
+	struct list_head list;
+};
+
+struct dsa_mac_addr {
+	unsigned char addr[6];
+	u16 vid;
+	refcount_t refcount;
+	struct list_head list;
+	struct dsa_db db;
+};
+
+enum {
+	DSA_NOTIFIER_AGEING_TIME = 0,
+	DSA_NOTIFIER_BRIDGE_JOIN = 1,
+	DSA_NOTIFIER_BRIDGE_LEAVE = 2,
+	DSA_NOTIFIER_FDB_ADD = 3,
+	DSA_NOTIFIER_FDB_DEL = 4,
+	DSA_NOTIFIER_HOST_FDB_ADD = 5,
+	DSA_NOTIFIER_HOST_FDB_DEL = 6,
+	DSA_NOTIFIER_LAG_FDB_ADD = 7,
+	DSA_NOTIFIER_LAG_FDB_DEL = 8,
+	DSA_NOTIFIER_LAG_CHANGE = 9,
+	DSA_NOTIFIER_LAG_JOIN = 10,
+	DSA_NOTIFIER_LAG_LEAVE = 11,
+	DSA_NOTIFIER_MDB_ADD = 12,
+	DSA_NOTIFIER_MDB_DEL = 13,
+	DSA_NOTIFIER_HOST_MDB_ADD = 14,
+	DSA_NOTIFIER_HOST_MDB_DEL = 15,
+	DSA_NOTIFIER_VLAN_ADD = 16,
+	DSA_NOTIFIER_VLAN_DEL = 17,
+	DSA_NOTIFIER_HOST_VLAN_ADD = 18,
+	DSA_NOTIFIER_HOST_VLAN_DEL = 19,
+	DSA_NOTIFIER_MTU = 20,
+	DSA_NOTIFIER_TAG_PROTO = 21,
+	DSA_NOTIFIER_TAG_PROTO_CONNECT = 22,
+	DSA_NOTIFIER_TAG_PROTO_DISCONNECT = 23,
+	DSA_NOTIFIER_TAG_8021Q_VLAN_ADD = 24,
+	DSA_NOTIFIER_TAG_8021Q_VLAN_DEL = 25,
+	DSA_NOTIFIER_CONDUIT_STATE_CHANGE = 26,
+};
+
+struct dsa_notifier_tag_proto_info {
+	const struct dsa_device_ops *tag_ops;
+};
+
+struct dsa_notifier_conduit_state_info {
+	const struct net_device *conduit;
+	bool operational;
+};
+
+struct dsa_user_priv {
+	struct sk_buff * (*xmit)(struct sk_buff *, struct net_device *);
+	struct gro_cells gcells;
+	struct dsa_port *dp;
+	struct netpoll *netpoll;
+	struct list_head mall_tc_list;
+};
+
+struct dsa_vlan {
+	u16 vid;
+	refcount_t refcount;
+	struct list_head list;
+};
+
+struct dsa_notifier_ageing_time_info {
+	unsigned int ageing_time;
+};
+
+struct dsa_notifier_bridge_info {
+	const struct dsa_port *dp;
+	struct dsa_bridge bridge;
+	bool tx_fwd_offload;
+	struct netlink_ext_ack *extack;
+};
+
+struct dsa_notifier_fdb_info {
+	const struct dsa_port *dp;
+	const unsigned char *addr;
+	u16 vid;
+	struct dsa_db db;
+};
+
+struct dsa_notifier_lag_fdb_info {
+	struct dsa_lag *lag;
+	const unsigned char *addr;
+	u16 vid;
+	struct dsa_db db;
+};
+
+struct dsa_notifier_mdb_info {
+	const struct dsa_port *dp;
+	const struct switchdev_obj_port_mdb *mdb;
+	struct dsa_db db;
+};
+
+struct dsa_notifier_lag_info {
+	const struct dsa_port *dp;
+	struct dsa_lag lag;
+	struct netdev_lag_upper_info *info;
+	struct netlink_ext_ack *extack;
+};
+
+struct dsa_notifier_vlan_info {
+	const struct dsa_port *dp;
+	const struct switchdev_obj_port_vlan *vlan;
+	struct netlink_ext_ack *extack;
+};
+
+struct dsa_notifier_mtu_info {
+	const struct dsa_port *dp;
+	int mtu;
+};
+
+struct dsa_notifier_tag_8021q_vlan_info {
+	const struct dsa_port *dp;
+	u16 vid;
+};
+
+struct trace_event_raw_dsa_port_addr_op_hw {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	u32 __data_loc_kind;
+	int port;
+	unsigned char addr[6];
+	u16 vid;
+	char db_buf[32];
+	int err;
+	char __data[0];
+};
+
+struct trace_event_raw_dsa_port_addr_op_refcount {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	u32 __data_loc_kind;
+	int port;
+	unsigned char addr[6];
+	u16 vid;
+	char db_buf[32];
+	unsigned int refcount;
+	char __data[0];
+};
+
+struct trace_event_raw_dsa_port_addr_del_not_found {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	u32 __data_loc_kind;
+	int port;
+	unsigned char addr[6];
+	u16 vid;
+	char db_buf[32];
+	char __data[0];
+};
+
+struct trace_event_raw_dsa_lag_fdb_add_hw {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	unsigned char addr[6];
+	u16 vid;
+	char db_buf[32];
+	int err;
+	char __data[0];
+};
+
+struct trace_event_raw_dsa_lag_fdb_add_bump {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	unsigned char addr[6];
+	u16 vid;
+	char db_buf[32];
+	unsigned int refcount;
+	char __data[0];
+};
+
+struct trace_event_raw_dsa_lag_fdb_del_hw {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	unsigned char addr[6];
+	u16 vid;
+	char db_buf[32];
+	int err;
+	char __data[0];
+};
+
+struct trace_event_raw_dsa_lag_fdb_del_drop {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	unsigned char addr[6];
+	u16 vid;
+	char db_buf[32];
+	unsigned int refcount;
+	char __data[0];
+};
+
+struct trace_event_raw_dsa_lag_fdb_del_not_found {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	unsigned char addr[6];
+	u16 vid;
+	char db_buf[32];
+	char __data[0];
+};
+
+struct trace_event_raw_dsa_vlan_op_hw {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	u32 __data_loc_kind;
+	int port;
+	u16 vid;
+	u16 flags;
+	bool changed;
+	int err;
+	char __data[0];
+};
+
+struct trace_event_raw_dsa_vlan_op_refcount {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	u32 __data_loc_kind;
+	int port;
+	u16 vid;
+	u16 flags;
+	bool changed;
+	unsigned int refcount;
+	char __data[0];
+};
+
+struct trace_event_raw_dsa_vlan_del_not_found {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	u32 __data_loc_kind;
+	int port;
+	u16 vid;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_dsa_port_addr_op_hw {
+	u32 dev;
+	const void *dev_ptr_;
+	u32 kind;
+	const void *kind_ptr_;
+};
+
+struct trace_event_data_offsets_dsa_port_addr_op_refcount {
+	u32 dev;
+	const void *dev_ptr_;
+	u32 kind;
+	const void *kind_ptr_;
+};
+
+struct trace_event_data_offsets_dsa_port_addr_del_not_found {
+	u32 dev;
+	const void *dev_ptr_;
+	u32 kind;
+	const void *kind_ptr_;
+};
+
+struct trace_event_data_offsets_dsa_lag_fdb_add_hw {
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+struct trace_event_data_offsets_dsa_lag_fdb_add_bump {
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+struct trace_event_data_offsets_dsa_lag_fdb_del_hw {
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+struct trace_event_data_offsets_dsa_lag_fdb_del_drop {
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+struct trace_event_data_offsets_dsa_lag_fdb_del_not_found {
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+struct trace_event_data_offsets_dsa_vlan_op_hw {
+	u32 dev;
+	const void *dev_ptr_;
+	u32 kind;
+	const void *kind_ptr_;
+};
+
+struct trace_event_data_offsets_dsa_vlan_op_refcount {
+	u32 dev;
+	const void *dev_ptr_;
+	u32 kind;
+	const void *kind_ptr_;
+};
+
+struct trace_event_data_offsets_dsa_vlan_del_not_found {
+	u32 dev;
+	const void *dev_ptr_;
+	u32 kind;
+	const void *kind_ptr_;
+};
+
+typedef void (*btf_trace_dsa_fdb_add_hw)(void *, const struct dsa_port *, const unsigned char *, u16, const struct dsa_db *, int);
+
+typedef void (*btf_trace_dsa_mdb_add_hw)(void *, const struct dsa_port *, const unsigned char *, u16, const struct dsa_db *, int);
+
+typedef void (*btf_trace_dsa_fdb_del_hw)(void *, const struct dsa_port *, const unsigned char *, u16, const struct dsa_db *, int);
+
+typedef void (*btf_trace_dsa_mdb_del_hw)(void *, const struct dsa_port *, const unsigned char *, u16, const struct dsa_db *, int);
+
+typedef void (*btf_trace_dsa_fdb_add_bump)(void *, const struct dsa_port *, const unsigned char *, u16, const struct dsa_db *, const refcount_t *);
+
+typedef void (*btf_trace_dsa_mdb_add_bump)(void *, const struct dsa_port *, const unsigned char *, u16, const struct dsa_db *, const refcount_t *);
+
+typedef void (*btf_trace_dsa_fdb_del_drop)(void *, const struct dsa_port *, const unsigned char *, u16, const struct dsa_db *, const refcount_t *);
+
+typedef void (*btf_trace_dsa_mdb_del_drop)(void *, const struct dsa_port *, const unsigned char *, u16, const struct dsa_db *, const refcount_t *);
+
+typedef void (*btf_trace_dsa_fdb_del_not_found)(void *, const struct dsa_port *, const unsigned char *, u16, const struct dsa_db *);
+
+typedef void (*btf_trace_dsa_mdb_del_not_found)(void *, const struct dsa_port *, const unsigned char *, u16, const struct dsa_db *);
+
+typedef void (*btf_trace_dsa_lag_fdb_add_hw)(void *, const struct net_device *, const unsigned char *, u16, const struct dsa_db *, int);
+
+typedef void (*btf_trace_dsa_lag_fdb_add_bump)(void *, const struct net_device *, const unsigned char *, u16, const struct dsa_db *, const refcount_t *);
+
+typedef void (*btf_trace_dsa_lag_fdb_del_hw)(void *, const struct net_device *, const unsigned char *, u16, const struct dsa_db *, int);
+
+typedef void (*btf_trace_dsa_lag_fdb_del_drop)(void *, const struct net_device *, const unsigned char *, u16, const struct dsa_db *, const refcount_t *);
+
+typedef void (*btf_trace_dsa_lag_fdb_del_not_found)(void *, const struct net_device *, const unsigned char *, u16, const struct dsa_db *);
+
+typedef void (*btf_trace_dsa_vlan_add_hw)(void *, const struct dsa_port *, const struct switchdev_obj_port_vlan *, int);
+
+typedef void (*btf_trace_dsa_vlan_del_hw)(void *, const struct dsa_port *, const struct switchdev_obj_port_vlan *, int);
+
+typedef void (*btf_trace_dsa_vlan_add_bump)(void *, const struct dsa_port *, const struct switchdev_obj_port_vlan *, const refcount_t *);
+
+typedef void (*btf_trace_dsa_vlan_del_drop)(void *, const struct dsa_port *, const struct switchdev_obj_port_vlan *, const refcount_t *);
+
+typedef void (*btf_trace_dsa_vlan_del_not_found)(void *, const struct dsa_port *, const struct switchdev_obj_port_vlan *);
+
+struct strp_stats {
+	long long unsigned int msgs;
+	long long unsigned int bytes;
+	unsigned int mem_fail;
+	unsigned int need_more_hdr;
+	unsigned int msg_too_big;
+	unsigned int msg_timeouts;
+	unsigned int bad_hdr_len;
+	long: 32;
+};
+
+struct strparser;
+
+struct strp_callbacks {
+	int (*parse_msg)(struct strparser *, struct sk_buff *);
+	void (*rcv_msg)(struct strparser *, struct sk_buff *);
+	int (*read_sock_done)(struct strparser *, int);
+	void (*abort_parser)(struct strparser *, int);
+	void (*lock)(struct strparser *);
+	void (*unlock)(struct strparser *);
+};
+
+struct strparser {
+	struct sock *sk;
+	u32 stopped: 1;
+	u32 paused: 1;
+	u32 aborted: 1;
+	u32 interrupted: 1;
+	u32 unrecov_intr: 1;
+	struct sk_buff **skb_nextp;
+	struct sk_buff *skb_head;
+	unsigned int need_bytes;
+	struct delayed_work msg_timer_work;
+	struct work_struct work;
+	struct strp_stats stats;
+	struct strp_callbacks cb;
+};
+
+struct strp_msg {
+	int full_len;
+	int offset;
+};
+
+struct _strp_msg {
+	struct strp_msg strp;
+	int accum_len;
+};
+
+struct vlan_group {
+	unsigned int nr_vlan_devs;
+	struct hlist_node hlist;
+	struct net_device **vlan_devices_arrays[16];
+};
+
+struct vlan_info {
+	struct net_device *real_dev;
+	struct vlan_group grp;
+	struct list_head vid_list;
+	unsigned int nr_vids;
+	struct callback_head rcu;
+};
+
+enum vlan_flags {
+	VLAN_FLAG_REORDER_HDR = 1,
+	VLAN_FLAG_GVRP = 2,
+	VLAN_FLAG_LOOSE_BINDING = 4,
+	VLAN_FLAG_MVRP = 8,
+	VLAN_FLAG_BRIDGE_BINDING = 16,
+};
+
+struct vlan_pcpu_stats {
+	u64_stats_t rx_packets;
+	u64_stats_t rx_bytes;
+	u64_stats_t rx_multicast;
+	u64_stats_t tx_packets;
+	u64_stats_t tx_bytes;
+	struct u64_stats_sync syncp;
+	u32 rx_errors;
+	u32 tx_dropped;
+	long: 32;
+};
+
+struct vlan_priority_tci_mapping {
+	u32 priority;
+	u16 vlan_qos;
+	struct vlan_priority_tci_mapping *next;
+};
+
+struct vlan_dev_priv {
+	unsigned int nr_ingress_mappings;
+	u32 ingress_priority_map[8];
+	unsigned int nr_egress_mappings;
+	struct vlan_priority_tci_mapping *egress_priority_map[16];
+	__be16 vlan_proto;
+	u16 vlan_id;
+	u16 flags;
+	struct net_device *real_dev;
+	netdevice_tracker dev_tracker;
+	unsigned char real_dev_addr[6];
+	struct proc_dir_entry *dent;
+	struct vlan_pcpu_stats *vlan_pcpu_stats;
+	struct netpoll *netpoll;
+};
+
+enum vlan_protos {
+	VLAN_PROTO_8021Q = 0,
+	VLAN_PROTO_8021AD = 1,
+	VLAN_PROTO_NUM = 2,
+};
+
+struct dcbmsg {
+	__u8 dcb_family;
+	__u8 cmd;
+	__u16 dcb_pad;
+};
+
+enum dcbnl_commands {
+	DCB_CMD_UNDEFINED = 0,
+	DCB_CMD_GSTATE = 1,
+	DCB_CMD_SSTATE = 2,
+	DCB_CMD_PGTX_GCFG = 3,
+	DCB_CMD_PGTX_SCFG = 4,
+	DCB_CMD_PGRX_GCFG = 5,
+	DCB_CMD_PGRX_SCFG = 6,
+	DCB_CMD_PFC_GCFG = 7,
+	DCB_CMD_PFC_SCFG = 8,
+	DCB_CMD_SET_ALL = 9,
+	DCB_CMD_GPERM_HWADDR = 10,
+	DCB_CMD_GCAP = 11,
+	DCB_CMD_GNUMTCS = 12,
+	DCB_CMD_SNUMTCS = 13,
+	DCB_CMD_PFC_GSTATE = 14,
+	DCB_CMD_PFC_SSTATE = 15,
+	DCB_CMD_BCN_GCFG = 16,
+	DCB_CMD_BCN_SCFG = 17,
+	DCB_CMD_GAPP = 18,
+	DCB_CMD_SAPP = 19,
+	DCB_CMD_IEEE_SET = 20,
+	DCB_CMD_IEEE_GET = 21,
+	DCB_CMD_GDCBX = 22,
+	DCB_CMD_SDCBX = 23,
+	DCB_CMD_GFEATCFG = 24,
+	DCB_CMD_SFEATCFG = 25,
+	DCB_CMD_CEE_GET = 26,
+	DCB_CMD_IEEE_DEL = 27,
+	__DCB_CMD_ENUM_MAX = 28,
+	DCB_CMD_MAX = 27,
+};
+
+enum dcbnl_attrs {
+	DCB_ATTR_UNDEFINED = 0,
+	DCB_ATTR_IFNAME = 1,
+	DCB_ATTR_STATE = 2,
+	DCB_ATTR_PFC_STATE = 3,
+	DCB_ATTR_PFC_CFG = 4,
+	DCB_ATTR_NUM_TC = 5,
+	DCB_ATTR_PG_CFG = 6,
+	DCB_ATTR_SET_ALL = 7,
+	DCB_ATTR_PERM_HWADDR = 8,
+	DCB_ATTR_CAP = 9,
+	DCB_ATTR_NUMTCS = 10,
+	DCB_ATTR_BCN = 11,
+	DCB_ATTR_APP = 12,
+	DCB_ATTR_IEEE = 13,
+	DCB_ATTR_DCBX = 14,
+	DCB_ATTR_FEATCFG = 15,
+	DCB_ATTR_CEE = 16,
+	__DCB_ATTR_ENUM_MAX = 17,
+	DCB_ATTR_MAX = 16,
+};
+
+enum ieee_attrs {
+	DCB_ATTR_IEEE_UNSPEC = 0,
+	DCB_ATTR_IEEE_ETS = 1,
+	DCB_ATTR_IEEE_PFC = 2,
+	DCB_ATTR_IEEE_APP_TABLE = 3,
+	DCB_ATTR_IEEE_PEER_ETS = 4,
+	DCB_ATTR_IEEE_PEER_PFC = 5,
+	DCB_ATTR_IEEE_PEER_APP = 6,
+	DCB_ATTR_IEEE_MAXRATE = 7,
+	DCB_ATTR_IEEE_QCN = 8,
+	DCB_ATTR_IEEE_QCN_STATS = 9,
+	DCB_ATTR_DCB_BUFFER = 10,
+	DCB_ATTR_DCB_APP_TRUST_TABLE = 11,
+	DCB_ATTR_DCB_REWR_TABLE = 12,
+	__DCB_ATTR_IEEE_MAX = 13,
+};
+
+enum ieee_attrs_app {
+	DCB_ATTR_IEEE_APP_UNSPEC = 0,
+	DCB_ATTR_IEEE_APP = 1,
+	DCB_ATTR_DCB_APP = 2,
+	__DCB_ATTR_IEEE_APP_MAX = 3,
+};
+
+enum cee_attrs {
+	DCB_ATTR_CEE_UNSPEC = 0,
+	DCB_ATTR_CEE_PEER_PG = 1,
+	DCB_ATTR_CEE_PEER_PFC = 2,
+	DCB_ATTR_CEE_PEER_APP_TABLE = 3,
+	DCB_ATTR_CEE_TX_PG = 4,
+	DCB_ATTR_CEE_RX_PG = 5,
+	DCB_ATTR_CEE_PFC = 6,
+	DCB_ATTR_CEE_APP_TABLE = 7,
+	DCB_ATTR_CEE_FEAT = 8,
+	__DCB_ATTR_CEE_MAX = 9,
+};
+
+enum peer_app_attr {
+	DCB_ATTR_CEE_PEER_APP_UNSPEC = 0,
+	DCB_ATTR_CEE_PEER_APP_INFO = 1,
+	DCB_ATTR_CEE_PEER_APP = 2,
+	__DCB_ATTR_CEE_PEER_APP_MAX = 3,
+};
+
+enum dcbnl_pfc_up_attrs {
+	DCB_PFC_UP_ATTR_UNDEFINED = 0,
+	DCB_PFC_UP_ATTR_0 = 1,
+	DCB_PFC_UP_ATTR_1 = 2,
+	DCB_PFC_UP_ATTR_2 = 3,
+	DCB_PFC_UP_ATTR_3 = 4,
+	DCB_PFC_UP_ATTR_4 = 5,
+	DCB_PFC_UP_ATTR_5 = 6,
+	DCB_PFC_UP_ATTR_6 = 7,
+	DCB_PFC_UP_ATTR_7 = 8,
+	DCB_PFC_UP_ATTR_ALL = 9,
+	__DCB_PFC_UP_ATTR_ENUM_MAX = 10,
+	DCB_PFC_UP_ATTR_MAX = 9,
+};
+
+enum dcbnl_pg_attrs {
+	DCB_PG_ATTR_UNDEFINED = 0,
+	DCB_PG_ATTR_TC_0 = 1,
+	DCB_PG_ATTR_TC_1 = 2,
+	DCB_PG_ATTR_TC_2 = 3,
+	DCB_PG_ATTR_TC_3 = 4,
+	DCB_PG_ATTR_TC_4 = 5,
+	DCB_PG_ATTR_TC_5 = 6,
+	DCB_PG_ATTR_TC_6 = 7,
+	DCB_PG_ATTR_TC_7 = 8,
+	DCB_PG_ATTR_TC_MAX = 9,
+	DCB_PG_ATTR_TC_ALL = 10,
+	DCB_PG_ATTR_BW_ID_0 = 11,
+	DCB_PG_ATTR_BW_ID_1 = 12,
+	DCB_PG_ATTR_BW_ID_2 = 13,
+	DCB_PG_ATTR_BW_ID_3 = 14,
+	DCB_PG_ATTR_BW_ID_4 = 15,
+	DCB_PG_ATTR_BW_ID_5 = 16,
+	DCB_PG_ATTR_BW_ID_6 = 17,
+	DCB_PG_ATTR_BW_ID_7 = 18,
+	DCB_PG_ATTR_BW_ID_MAX = 19,
+	DCB_PG_ATTR_BW_ID_ALL = 20,
+	__DCB_PG_ATTR_ENUM_MAX = 21,
+	DCB_PG_ATTR_MAX = 20,
+};
+
+enum dcbnl_tc_attrs {
+	DCB_TC_ATTR_PARAM_UNDEFINED = 0,
+	DCB_TC_ATTR_PARAM_PGID = 1,
+	DCB_TC_ATTR_PARAM_UP_MAPPING = 2,
+	DCB_TC_ATTR_PARAM_STRICT_PRIO = 3,
+	DCB_TC_ATTR_PARAM_BW_PCT = 4,
+	DCB_TC_ATTR_PARAM_ALL = 5,
+	__DCB_TC_ATTR_PARAM_ENUM_MAX = 6,
+	DCB_TC_ATTR_PARAM_MAX = 5,
+};
+
+enum dcbnl_cap_attrs {
+	DCB_CAP_ATTR_UNDEFINED = 0,
+	DCB_CAP_ATTR_ALL = 1,
+	DCB_CAP_ATTR_PG = 2,
+	DCB_CAP_ATTR_PFC = 3,
+	DCB_CAP_ATTR_UP2TC = 4,
+	DCB_CAP_ATTR_PG_TCS = 5,
+	DCB_CAP_ATTR_PFC_TCS = 6,
+	DCB_CAP_ATTR_GSP = 7,
+	DCB_CAP_ATTR_BCN = 8,
+	DCB_CAP_ATTR_DCBX = 9,
+	__DCB_CAP_ATTR_ENUM_MAX = 10,
+	DCB_CAP_ATTR_MAX = 9,
+};
+
+enum dcbnl_numtcs_attrs {
+	DCB_NUMTCS_ATTR_UNDEFINED = 0,
+	DCB_NUMTCS_ATTR_ALL = 1,
+	DCB_NUMTCS_ATTR_PG = 2,
+	DCB_NUMTCS_ATTR_PFC = 3,
+	__DCB_NUMTCS_ATTR_ENUM_MAX = 4,
+	DCB_NUMTCS_ATTR_MAX = 3,
+};
+
+enum dcbnl_bcn_attrs {
+	DCB_BCN_ATTR_UNDEFINED = 0,
+	DCB_BCN_ATTR_RP_0 = 1,
+	DCB_BCN_ATTR_RP_1 = 2,
+	DCB_BCN_ATTR_RP_2 = 3,
+	DCB_BCN_ATTR_RP_3 = 4,
+	DCB_BCN_ATTR_RP_4 = 5,
+	DCB_BCN_ATTR_RP_5 = 6,
+	DCB_BCN_ATTR_RP_6 = 7,
+	DCB_BCN_ATTR_RP_7 = 8,
+	DCB_BCN_ATTR_RP_ALL = 9,
+	DCB_BCN_ATTR_BCNA_0 = 10,
+	DCB_BCN_ATTR_BCNA_1 = 11,
+	DCB_BCN_ATTR_ALPHA = 12,
+	DCB_BCN_ATTR_BETA = 13,
+	DCB_BCN_ATTR_GD = 14,
+	DCB_BCN_ATTR_GI = 15,
+	DCB_BCN_ATTR_TMAX = 16,
+	DCB_BCN_ATTR_TD = 17,
+	DCB_BCN_ATTR_RMIN = 18,
+	DCB_BCN_ATTR_W = 19,
+	DCB_BCN_ATTR_RD = 20,
+	DCB_BCN_ATTR_RU = 21,
+	DCB_BCN_ATTR_WRTT = 22,
+	DCB_BCN_ATTR_RI = 23,
+	DCB_BCN_ATTR_C = 24,
+	DCB_BCN_ATTR_ALL = 25,
+	__DCB_BCN_ATTR_ENUM_MAX = 26,
+	DCB_BCN_ATTR_MAX = 25,
+};
+
+enum dcb_general_attr_values {
+	DCB_ATTR_VALUE_UNDEFINED = 255,
+};
+
+enum dcbnl_app_attrs {
+	DCB_APP_ATTR_UNDEFINED = 0,
+	DCB_APP_ATTR_IDTYPE = 1,
+	DCB_APP_ATTR_ID = 2,
+	DCB_APP_ATTR_PRIORITY = 3,
+	__DCB_APP_ATTR_ENUM_MAX = 4,
+	DCB_APP_ATTR_MAX = 3,
+};
+
+enum dcbnl_featcfg_attrs {
+	DCB_FEATCFG_ATTR_UNDEFINED = 0,
+	DCB_FEATCFG_ATTR_ALL = 1,
+	DCB_FEATCFG_ATTR_PG = 2,
+	DCB_FEATCFG_ATTR_PFC = 3,
+	DCB_FEATCFG_ATTR_APP = 4,
+	__DCB_FEATCFG_ATTR_ENUM_MAX = 5,
+	DCB_FEATCFG_ATTR_MAX = 4,
+};
+
+struct dcb_app_type {
+	int ifindex;
+	struct dcb_app app;
+	struct list_head list;
+	u8 dcbx;
+};
+
+struct dcb_rewr_prio_pcp_map {
+	u16 map[8];
+};
+
+struct dcb_ieee_app_prio_map {
+	u64 map[8];
+};
+
+struct dcb_ieee_app_dscp_map {
+	u8 map[64];
+};
+
+enum dcbevent_notif_type {
+	DCB_APP_EVENT = 1,
+};
+
+struct reply_func {
+	int type;
+	int (*cb)(struct net_device *, struct nlmsghdr *, u32, struct nlattr **, struct sk_buff *);
+};
+
+struct sockaddr_xdp {
+	__u16 sxdp_family;
+	__u16 sxdp_flags;
+	__u32 sxdp_ifindex;
+	__u32 sxdp_queue_id;
+	__u32 sxdp_shared_umem_fd;
+};
+
+struct xdp_ring_offset {
+	__u64 producer;
+	__u64 consumer;
+	__u64 desc;
+	__u64 flags;
+};
+
+struct xdp_mmap_offsets {
+	struct xdp_ring_offset rx;
+	struct xdp_ring_offset tx;
+	struct xdp_ring_offset fr;
+	struct xdp_ring_offset cr;
+};
+
+struct xdp_umem_reg {
+	__u64 addr;
+	__u64 len;
+	__u32 chunk_size;
+	__u32 headroom;
+	__u32 flags;
+	__u32 tx_metadata_len;
+};
+
+struct xdp_statistics {
+	__u64 rx_dropped;
+	__u64 rx_invalid_descs;
+	__u64 tx_invalid_descs;
+	__u64 rx_ring_full;
+	__u64 rx_fill_ring_empty_descs;
+	__u64 tx_ring_empty_descs;
+};
+
+struct xdp_options {
+	__u32 flags;
+};
+
+struct xsk_tx_metadata {
+	__u64 flags;
+	union {
+		struct {
+			__u16 csum_start;
+			__u16 csum_offset;
+		} request;
+		struct {
+			__u64 tx_timestamp;
+		} completion;
+	};
+};
+
+struct net_proto_family {
+	int family;
+	int (*create)(struct net *, struct socket *, int, int);
+	struct module *owner;
+};
+
+struct xdp_sock;
+
+struct xsk_map {
+	struct bpf_map map;
+	spinlock_t lock;
+	atomic_t count;
+	struct xdp_sock *xsk_map[0];
+};
+
+struct xdp_sock {
+	struct sock sk;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct xsk_queue *rx;
+	struct net_device *dev;
+	struct xdp_umem *umem;
+	struct list_head flush_node;
+	struct xsk_buff_pool *pool;
+	u16 queue_id;
+	bool zc;
+	bool sg;
+	enum {
+		XSK_READY = 0,
+		XSK_BOUND = 1,
+		XSK_UNBOUND = 2,
+	} state;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct xsk_queue *tx;
+	struct list_head tx_list;
+	u32 tx_budget_spent;
+	spinlock_t rx_lock;
+	long: 32;
+	u64 rx_dropped;
+	u64 rx_queue_full;
+	struct sk_buff *skb;
+	struct list_head map_list;
+	spinlock_t map_list_lock;
+	struct mutex mutex;
+	struct xsk_queue *fq_tmp;
+	struct xsk_queue *cq_tmp;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct xdp_ring;
+
+struct xsk_queue {
+	u32 ring_mask;
+	u32 nentries;
+	u32 cached_prod;
+	u32 cached_cons;
+	struct xdp_ring *ring;
+	long: 32;
+	u64 invalid_descs;
+	u64 queue_empty_descs;
+	size_t ring_vmalloc_size;
+	long: 32;
+};
+
+struct xdp_ring_offset_v1 {
+	__u64 producer;
+	__u64 consumer;
+	__u64 desc;
+};
+
+struct xdp_mmap_offsets_v1 {
+	struct xdp_ring_offset_v1 rx;
+	struct xdp_ring_offset_v1 tx;
+	struct xdp_ring_offset_v1 fr;
+	struct xdp_ring_offset_v1 cr;
+};
+
+struct xsk_map_node {
+	struct list_head node;
+	struct xsk_map *map;
+	struct xdp_sock **map_entry;
+};
+
+struct xdp_ring {
+	u32 producer;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	u32 pad1;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	u32 consumer;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	u32 pad2;
+	u32 flags;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	u32 pad3;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct xdp_rxtx_ring {
+	struct xdp_ring ptrs;
+	struct xdp_desc desc[0];
+};
+
+struct xdp_umem_ring {
+	struct xdp_ring ptrs;
+	u64 desc[0];
+};
+
+struct parsed_desc {
+	u32 mb;
+	u32 valid;
+};
+
+struct mptcp_mib {
+	long unsigned int mibs[71];
+};
+
+struct socket_alloc {
+	struct socket socket;
+	struct inode vfs_inode;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct mptcp_subflow_context;
+
+struct mptcp_sched_data {
+	bool reinject;
+	u8 subflows;
+	struct mptcp_subflow_context *contexts[8];
+};
+
+struct mptcp_subflow_context {
+	struct list_head node;
+	union {
+		struct {
+			long unsigned int avg_pacing_rate;
+			long: 32;
+			u64 local_key;
+			u64 remote_key;
+			u64 idsn;
+			u64 map_seq;
+			u32 snd_isn;
+			u32 token;
+			u32 rel_write_seq;
+			u32 map_subflow_seq;
+			u32 ssn_offset;
+			u32 map_data_len;
+			__wsum map_data_csum;
+			u32 map_csum_len;
+			u32 request_mptcp: 1;
+			u32 request_join: 1;
+			u32 request_bkup: 1;
+			u32 mp_capable: 1;
+			u32 mp_join: 1;
+			u32 fully_established: 1;
+			u32 pm_notified: 1;
+			u32 conn_finished: 1;
+			u32 map_valid: 1;
+			u32 map_csum_reqd: 1;
+			u32 map_data_fin: 1;
+			u32 mpc_map: 1;
+			u32 backup: 1;
+			u32 send_mp_prio: 1;
+			u32 send_mp_fail: 1;
+			u32 send_fastclose: 1;
+			u32 send_infinite_map: 1;
+			u32 remote_key_valid: 1;
+			u32 disposable: 1;
+			u32 stale: 1;
+			u32 valid_csum_seen: 1;
+			u32 is_mptfo: 1;
+			u32 close_event_done: 1;
+			u32 mpc_drop: 1;
+			u32 __unused: 8;
+			bool data_avail;
+			bool scheduled;
+			bool pm_listener;
+			u32 remote_nonce;
+			long: 32;
+			u64 thmac;
+			u32 local_nonce;
+			u32 remote_token;
+			union {
+				u8 hmac[20];
+				u64 iasn;
+			};
+			s16 local_id;
+			u8 remote_id;
+			u8 reset_seen: 1;
+			u8 reset_transient: 1;
+			u8 reset_reason: 4;
+			u8 stale_count;
+			u32 subflow_id;
+			long int delegated_status;
+			long unsigned int fail_tout;
+			long: 32;
+		};
+		struct {
+			long unsigned int avg_pacing_rate;
+			long: 32;
+			u64 local_key;
+			u64 remote_key;
+			u64 idsn;
+			u64 map_seq;
+			u32 snd_isn;
+			u32 token;
+			u32 rel_write_seq;
+			u32 map_subflow_seq;
+			u32 ssn_offset;
+			u32 map_data_len;
+			__wsum map_data_csum;
+			u32 map_csum_len;
+			u32 request_mptcp: 1;
+			u32 request_join: 1;
+			u32 request_bkup: 1;
+			u32 mp_capable: 1;
+			u32 mp_join: 1;
+			u32 fully_established: 1;
+			u32 pm_notified: 1;
+			u32 conn_finished: 1;
+			u32 map_valid: 1;
+			u32 map_csum_reqd: 1;
+			u32 map_data_fin: 1;
+			u32 mpc_map: 1;
+			u32 backup: 1;
+			u32 send_mp_prio: 1;
+			u32 send_mp_fail: 1;
+			u32 send_fastclose: 1;
+			u32 send_infinite_map: 1;
+			u32 remote_key_valid: 1;
+			u32 disposable: 1;
+			u32 stale: 1;
+			u32 valid_csum_seen: 1;
+			u32 is_mptfo: 1;
+			u32 close_event_done: 1;
+			u32 mpc_drop: 1;
+			u32 __unused: 8;
+			bool data_avail;
+			bool scheduled;
+			bool pm_listener;
+			u32 remote_nonce;
+			long: 32;
+			u64 thmac;
+			u32 local_nonce;
+			u32 remote_token;
+			union {
+				u8 hmac[20];
+				u64 iasn;
+			};
+			s16 local_id;
+			u8 remote_id;
+			u8 reset_seen: 1;
+			u8 reset_transient: 1;
+			u8 reset_reason: 4;
+			u8 stale_count;
+			u32 subflow_id;
+			long int delegated_status;
+			long unsigned int fail_tout;
+			long: 32;
+		} reset;
+	};
+	struct list_head delegated_node;
+	u32 setsockopt_seq;
+	u32 stale_rcv_tstamp;
+	int cached_sndbuf;
+	struct sock *tcp_sock;
+	struct sock *conn;
+	const struct inet_connection_sock_af_ops *icsk_af_ops;
+	void (*tcp_state_change)(struct sock *);
+	void (*tcp_error_report)(struct sock *);
+	struct callback_head rcu;
+};
+
+struct mptcp_sock;
+
+struct mptcp_sched_ops {
+	int (*get_subflow)(struct mptcp_sock *, struct mptcp_sched_data *);
+	char name[16];
+	struct module *owner;
+	struct list_head list;
+	void (*init)(struct mptcp_sock *);
+	void (*release)(struct mptcp_sock *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct mptcp_pm_data {
+	struct mptcp_addr_info local;
+	struct mptcp_addr_info remote;
+	struct list_head anno_list;
+	struct list_head userspace_pm_local_addr_list;
+	spinlock_t lock;
+	u8 addr_signal;
+	bool server_side;
+	bool work_pending;
+	bool accept_addr;
+	bool accept_subflow;
+	bool remote_deny_join_id0;
+	u8 add_addr_signaled;
+	u8 add_addr_accepted;
+	u8 local_addr_used;
+	u8 pm_type;
+	u8 subflows;
+	u8 status;
+	long unsigned int id_avail_bitmap[8];
+	struct mptcp_rm_list rm_list_tx;
+	struct mptcp_rm_list rm_list_rx;
+};
+
+struct mptcp_data_frag;
+
+struct mptcp_sock {
+	struct inet_connection_sock sk;
+	u64 local_key;
+	u64 remote_key;
+	u64 write_seq;
+	u64 bytes_sent;
+	u64 snd_nxt;
+	u64 bytes_received;
+	u64 ack_seq;
+	atomic64_t rcv_wnd_sent;
+	u64 rcv_data_fin_seq;
+	u64 bytes_retrans;
+	u64 bytes_consumed;
+	int rmem_fwd_alloc;
+	int snd_burst;
+	int old_wspace;
+	long: 32;
+	u64 recovery_snd_nxt;
+	u64 bytes_acked;
+	u64 snd_una;
+	u64 wnd_end;
+	u32 last_data_sent;
+	u32 last_data_recv;
+	u32 last_ack_recv;
+	long unsigned int timer_ival;
+	u32 token;
+	int rmem_released;
+	long unsigned int flags;
+	long unsigned int cb_flags;
+	bool recovery;
+	bool can_ack;
+	bool fully_established;
+	bool rcv_data_fin;
+	bool snd_data_fin_enable;
+	bool rcv_fastclose;
+	bool use_64bit_ack;
+	bool csum_enabled;
+	bool allow_infinite_fallback;
+	u8 pending_state;
+	u8 mpc_endpoint_id;
+	u8 recvmsg_inq: 1;
+	u8 cork: 1;
+	u8 nodelay: 1;
+	u8 fastopening: 1;
+	u8 in_accept_queue: 1;
+	u8 free_first: 1;
+	u8 rcvspace_init: 1;
+	u32 notsent_lowat;
+	int keepalive_cnt;
+	int keepalive_idle;
+	int keepalive_intvl;
+	struct work_struct work;
+	struct sk_buff *ooo_last_skb;
+	struct rb_root out_of_order_queue;
+	struct sk_buff_head receive_queue;
+	struct list_head conn_list;
+	struct list_head rtx_queue;
+	struct mptcp_data_frag *first_pending;
+	struct list_head join_list;
+	struct sock *first;
+	struct mptcp_pm_data pm;
+	struct mptcp_sched_ops *sched;
+	long: 32;
+	struct {
+		u32 space;
+		u32 copied;
+		u64 time;
+		u64 rtt_us;
+	} rcvq_space;
+	u8 scaling_ratio;
+	u32 subflow_id;
+	u32 setsockopt_seq;
+	char ca_name[16];
+	long: 32;
+};
+
+struct mptcp_options_received {
+	u64 sndr_key;
+	u64 rcvr_key;
+	u64 data_ack;
+	u64 data_seq;
+	u32 subflow_seq;
+	u16 data_len;
+	__sum16 csum;
+	u16 suboptions;
+	u32 token;
+	u32 nonce;
+	u16 use_map: 1;
+	u16 dsn64: 1;
+	u16 data_fin: 1;
+	u16 use_ack: 1;
+	u16 ack64: 1;
+	u16 mpc_map: 1;
+	u16 reset_reason: 4;
+	u16 reset_transient: 1;
+	u16 echo: 1;
+	u16 backup: 1;
+	u16 deny_join_id0: 1;
+	u16 __unused: 2;
+	u8 join_id;
+	u64 thmac;
+	u8 hmac[20];
+	struct mptcp_addr_info addr;
+	struct mptcp_rm_list rm_list;
+	u64 ahmac;
+	u64 fail_seq;
+};
+
+enum mptcp_pm_type {
+	MPTCP_PM_TYPE_KERNEL = 0,
+	MPTCP_PM_TYPE_USERSPACE = 1,
+	__MPTCP_PM_TYPE_NR = 2,
+	__MPTCP_PM_TYPE_MAX = 1,
+};
+
+struct mptcp_pm_local {
+	struct mptcp_addr_info addr;
+	u8 flags;
+	int ifindex;
+};
+
+struct mptcp_data_frag {
+	struct list_head list;
+	u64 data_seq;
+	u16 data_len;
+	u16 offset;
+	u16 overhead;
+	u16 already_sent;
+	struct page *page;
+	long: 32;
+};
+
+struct mptcp_subflow_request_sock {
+	struct tcp_request_sock sk;
+	u16 mp_capable: 1;
+	u16 mp_join: 1;
+	u16 backup: 1;
+	u16 request_bkup: 1;
+	u16 csum_reqd: 1;
+	u16 allow_join_id0: 1;
+	u8 local_id;
+	u8 remote_id;
+	long: 32;
+	u64 local_key;
+	u64 idsn;
+	u32 token;
+	u32 ssn_offset;
+	u64 thmac;
+	u32 local_nonce;
+	u32 remote_nonce;
+	struct mptcp_sock *msk;
+	struct hlist_nulls_node token_node;
+	long: 32;
+};
+
+struct mptcp_delegated_action {
+	struct napi_struct napi;
+	struct list_head head;
+};
+
+enum linux_mptcp_mib_field {
+	MPTCP_MIB_NUM = 0,
+	MPTCP_MIB_MPCAPABLEPASSIVE = 1,
+	MPTCP_MIB_MPCAPABLEACTIVE = 2,
+	MPTCP_MIB_MPCAPABLEACTIVEACK = 3,
+	MPTCP_MIB_MPCAPABLEPASSIVEACK = 4,
+	MPTCP_MIB_MPCAPABLEPASSIVEFALLBACK = 5,
+	MPTCP_MIB_MPCAPABLEACTIVEFALLBACK = 6,
+	MPTCP_MIB_MPCAPABLEACTIVEDROP = 7,
+	MPTCP_MIB_MPCAPABLEACTIVEDISABLED = 8,
+	MPTCP_MIB_MPCAPABLEENDPATTEMPT = 9,
+	MPTCP_MIB_TOKENFALLBACKINIT = 10,
+	MPTCP_MIB_RETRANSSEGS = 11,
+	MPTCP_MIB_JOINNOTOKEN = 12,
+	MPTCP_MIB_JOINSYNRX = 13,
+	MPTCP_MIB_JOINSYNBACKUPRX = 14,
+	MPTCP_MIB_JOINSYNACKRX = 15,
+	MPTCP_MIB_JOINSYNACKBACKUPRX = 16,
+	MPTCP_MIB_JOINSYNACKMAC = 17,
+	MPTCP_MIB_JOINACKRX = 18,
+	MPTCP_MIB_JOINACKMAC = 19,
+	MPTCP_MIB_JOINSYNTX = 20,
+	MPTCP_MIB_JOINSYNTXCREATSKERR = 21,
+	MPTCP_MIB_JOINSYNTXBINDERR = 22,
+	MPTCP_MIB_JOINSYNTXCONNECTERR = 23,
+	MPTCP_MIB_DSSNOMATCH = 24,
+	MPTCP_MIB_DSSCORRUPTIONFALLBACK = 25,
+	MPTCP_MIB_DSSCORRUPTIONRESET = 26,
+	MPTCP_MIB_INFINITEMAPTX = 27,
+	MPTCP_MIB_INFINITEMAPRX = 28,
+	MPTCP_MIB_DSSTCPMISMATCH = 29,
+	MPTCP_MIB_DATACSUMERR = 30,
+	MPTCP_MIB_OFOQUEUETAIL = 31,
+	MPTCP_MIB_OFOQUEUE = 32,
+	MPTCP_MIB_OFOMERGE = 33,
+	MPTCP_MIB_NODSSWINDOW = 34,
+	MPTCP_MIB_DUPDATA = 35,
+	MPTCP_MIB_ADDADDR = 36,
+	MPTCP_MIB_ADDADDRTX = 37,
+	MPTCP_MIB_ADDADDRTXDROP = 38,
+	MPTCP_MIB_ECHOADD = 39,
+	MPTCP_MIB_ECHOADDTX = 40,
+	MPTCP_MIB_ECHOADDTXDROP = 41,
+	MPTCP_MIB_PORTADD = 42,
+	MPTCP_MIB_ADDADDRDROP = 43,
+	MPTCP_MIB_JOINPORTSYNRX = 44,
+	MPTCP_MIB_JOINPORTSYNACKRX = 45,
+	MPTCP_MIB_JOINPORTACKRX = 46,
+	MPTCP_MIB_MISMATCHPORTSYNRX = 47,
+	MPTCP_MIB_MISMATCHPORTACKRX = 48,
+	MPTCP_MIB_RMADDR = 49,
+	MPTCP_MIB_RMADDRDROP = 50,
+	MPTCP_MIB_RMADDRTX = 51,
+	MPTCP_MIB_RMADDRTXDROP = 52,
+	MPTCP_MIB_RMSUBFLOW = 53,
+	MPTCP_MIB_MPPRIOTX = 54,
+	MPTCP_MIB_MPPRIORX = 55,
+	MPTCP_MIB_MPFAILTX = 56,
+	MPTCP_MIB_MPFAILRX = 57,
+	MPTCP_MIB_MPFASTCLOSETX = 58,
+	MPTCP_MIB_MPFASTCLOSERX = 59,
+	MPTCP_MIB_MPRSTTX = 60,
+	MPTCP_MIB_MPRSTRX = 61,
+	MPTCP_MIB_RCVPRUNED = 62,
+	MPTCP_MIB_SUBFLOWSTALE = 63,
+	MPTCP_MIB_SUBFLOWRECOVER = 64,
+	MPTCP_MIB_SNDWNDSHARED = 65,
+	MPTCP_MIB_RCVWNDSHARED = 66,
+	MPTCP_MIB_RCVWNDCONFLICTUPDATE = 67,
+	MPTCP_MIB_RCVWNDCONFLICT = 68,
+	MPTCP_MIB_CURRESTAB = 69,
+	MPTCP_MIB_BLACKHOLE = 70,
+	__MPTCP_MIB_MAX = 71,
+};
+
+enum mapping_status {
+	MAPPING_OK = 0,
+	MAPPING_INVALID = 1,
+	MAPPING_EMPTY = 2,
+	MAPPING_DATA_FIN = 3,
+	MAPPING_DUMMY = 4,
+	MAPPING_BAD_CSUM = 5,
+};
+
+enum {
+	INET_ULP_INFO_UNSPEC = 0,
+	INET_ULP_INFO_NAME = 1,
+	INET_ULP_INFO_TLS = 2,
+	INET_ULP_INFO_MPTCP = 3,
+	__INET_ULP_INFO_MAX = 4,
+};
+
+struct tcpvegas_info {
+	__u32 tcpv_enabled;
+	__u32 tcpv_rttcnt;
+	__u32 tcpv_rtt;
+	__u32 tcpv_minrtt;
+};
+
+struct tcp_dctcp_info {
+	__u16 dctcp_enabled;
+	__u16 dctcp_ce_state;
+	__u32 dctcp_alpha;
+	__u32 dctcp_ab_ecn;
+	__u32 dctcp_ab_tot;
+};
+
+struct tcp_bbr_info {
+	__u32 bbr_bw_lo;
+	__u32 bbr_bw_hi;
+	__u32 bbr_min_rtt;
+	__u32 bbr_pacing_gain;
+	__u32 bbr_cwnd_gain;
+	__u32 bbr_bw_hi_lsb;
+	__u32 bbr_bw_hi_msb;
+	__u32 bbr_bw_lo_lsb;
+	__u32 bbr_bw_lo_msb;
+	__u8 bbr_mode;
+	__u8 bbr_phase;
+	__u8 unused1;
+	__u8 bbr_version;
+	__u32 bbr_inflight_lo;
+	__u32 bbr_inflight_hi;
+	__u32 bbr_extra_acked;
+};
+
+union tcp_cc_info {
+	struct tcpvegas_info vegas;
+	struct tcp_dctcp_info dctcp;
+	struct tcp_bbr_info bbr;
+};
+
+enum {
+	MPTCP_SUBFLOW_ATTR_UNSPEC = 0,
+	MPTCP_SUBFLOW_ATTR_TOKEN_REM = 1,
+	MPTCP_SUBFLOW_ATTR_TOKEN_LOC = 2,
+	MPTCP_SUBFLOW_ATTR_RELWRITE_SEQ = 3,
+	MPTCP_SUBFLOW_ATTR_MAP_SEQ = 4,
+	MPTCP_SUBFLOW_ATTR_MAP_SFSEQ = 5,
+	MPTCP_SUBFLOW_ATTR_SSN_OFFSET = 6,
+	MPTCP_SUBFLOW_ATTR_MAP_DATALEN = 7,
+	MPTCP_SUBFLOW_ATTR_FLAGS = 8,
+	MPTCP_SUBFLOW_ATTR_ID_REM = 9,
+	MPTCP_SUBFLOW_ATTR_ID_LOC = 10,
+	MPTCP_SUBFLOW_ATTR_PAD = 11,
+	__MPTCP_SUBFLOW_ATTR_MAX = 12,
+};
+
+struct linger {
+	int l_onoff;
+	int l_linger;
+};
+
+struct so_timestamping {
+	int flags;
+	int bind_phc;
+};
+
+struct mptcp_info {
+	__u8 mptcpi_subflows;
+	__u8 mptcpi_add_addr_signal;
+	__u8 mptcpi_add_addr_accepted;
+	__u8 mptcpi_subflows_max;
+	__u8 mptcpi_add_addr_signal_max;
+	__u8 mptcpi_add_addr_accepted_max;
+	__u32 mptcpi_flags;
+	__u32 mptcpi_token;
+	__u64 mptcpi_write_seq;
+	__u64 mptcpi_snd_una;
+	__u64 mptcpi_rcv_nxt;
+	__u8 mptcpi_local_addr_used;
+	__u8 mptcpi_local_addr_max;
+	__u8 mptcpi_csum_enabled;
+	__u32 mptcpi_retransmits;
+	__u64 mptcpi_bytes_retrans;
+	__u64 mptcpi_bytes_sent;
+	__u64 mptcpi_bytes_received;
+	__u64 mptcpi_bytes_acked;
+	__u8 mptcpi_subflows_total;
+	__u8 reserved[3];
+	__u32 mptcpi_last_data_sent;
+	__u32 mptcpi_last_data_recv;
+	__u32 mptcpi_last_ack_recv;
+};
+
+struct mptcp_subflow_data {
+	__u32 size_subflow_data;
+	__u32 num_subflows;
+	__u32 size_kernel;
+	__u32 size_user;
+};
+
+struct mptcp_subflow_addrs {
+	union {
+		__kernel_sa_family_t sa_family;
+		struct sockaddr sa_local;
+		struct sockaddr_in sin_local;
+		struct sockaddr_in6 sin6_local;
+		struct __kernel_sockaddr_storage ss_local;
+	};
+	union {
+		struct sockaddr sa_remote;
+		struct sockaddr_in sin_remote;
+		struct sockaddr_in6 sin6_remote;
+		struct __kernel_sockaddr_storage ss_remote;
+	};
+};
+
+struct mptcp_subflow_info {
+	__u32 id;
+	struct mptcp_subflow_addrs addrs;
+};
+
+struct mptcp_full_info {
+	__u32 size_tcpinfo_kernel;
+	__u32 size_tcpinfo_user;
+	__u32 size_sfinfo_kernel;
+	__u32 size_sfinfo_user;
+	__u32 num_subflows;
+	__u32 size_arrays_user;
+	__u64 subflow_info;
+	__u64 tcp_info;
+	struct mptcp_info mptcp_info;
+};
+
+struct tcp_info {
+	__u8 tcpi_state;
+	__u8 tcpi_ca_state;
+	__u8 tcpi_retransmits;
+	__u8 tcpi_probes;
+	__u8 tcpi_backoff;
+	__u8 tcpi_options;
+	__u8 tcpi_snd_wscale: 4;
+	__u8 tcpi_rcv_wscale: 4;
+	__u8 tcpi_delivery_rate_app_limited: 1;
+	__u8 tcpi_fastopen_client_fail: 2;
+	__u32 tcpi_rto;
+	__u32 tcpi_ato;
+	__u32 tcpi_snd_mss;
+	__u32 tcpi_rcv_mss;
+	__u32 tcpi_unacked;
+	__u32 tcpi_sacked;
+	__u32 tcpi_lost;
+	__u32 tcpi_retrans;
+	__u32 tcpi_fackets;
+	__u32 tcpi_last_data_sent;
+	__u32 tcpi_last_ack_sent;
+	__u32 tcpi_last_data_recv;
+	__u32 tcpi_last_ack_recv;
+	__u32 tcpi_pmtu;
+	__u32 tcpi_rcv_ssthresh;
+	__u32 tcpi_rtt;
+	__u32 tcpi_rttvar;
+	__u32 tcpi_snd_ssthresh;
+	__u32 tcpi_snd_cwnd;
+	__u32 tcpi_advmss;
+	__u32 tcpi_reordering;
+	__u32 tcpi_rcv_rtt;
+	__u32 tcpi_rcv_space;
+	__u32 tcpi_total_retrans;
+	__u64 tcpi_pacing_rate;
+	__u64 tcpi_max_pacing_rate;
+	__u64 tcpi_bytes_acked;
+	__u64 tcpi_bytes_received;
+	__u32 tcpi_segs_out;
+	__u32 tcpi_segs_in;
+	__u32 tcpi_notsent_bytes;
+	__u32 tcpi_min_rtt;
+	__u32 tcpi_data_segs_in;
+	__u32 tcpi_data_segs_out;
+	__u64 tcpi_delivery_rate;
+	__u64 tcpi_busy_time;
+	__u64 tcpi_rwnd_limited;
+	__u64 tcpi_sndbuf_limited;
+	__u32 tcpi_delivered;
+	__u32 tcpi_delivered_ce;
+	__u64 tcpi_bytes_sent;
+	__u64 tcpi_bytes_retrans;
+	__u32 tcpi_dsack_dups;
+	__u32 tcpi_reord_seen;
+	__u32 tcpi_rcv_ooopack;
+	__u32 tcpi_snd_wnd;
+	__u32 tcpi_rcv_wnd;
+	__u32 tcpi_rehash;
+	__u16 tcpi_total_rto;
+	__u16 tcpi_total_rto_recoveries;
+	__u32 tcpi_total_rto_time;
+};
+
+enum {
+	MPTCP_PM_ADDR_ATTR_UNSPEC = 0,
+	MPTCP_PM_ADDR_ATTR_FAMILY = 1,
+	MPTCP_PM_ADDR_ATTR_ID = 2,
+	MPTCP_PM_ADDR_ATTR_ADDR4 = 3,
+	MPTCP_PM_ADDR_ATTR_ADDR6 = 4,
+	MPTCP_PM_ADDR_ATTR_PORT = 5,
+	MPTCP_PM_ADDR_ATTR_FLAGS = 6,
+	MPTCP_PM_ADDR_ATTR_IF_IDX = 7,
+	__MPTCP_PM_ADDR_ATTR_MAX = 8,
+};
+
+enum {
+	MPTCP_PM_ENDPOINT_ADDR = 1,
+	__MPTCP_PM_ENDPOINT_MAX = 2,
+};
+
+enum {
+	MPTCP_PM_ATTR_UNSPEC = 0,
+	MPTCP_PM_ATTR_ADDR = 1,
+	MPTCP_PM_ATTR_RCV_ADD_ADDRS = 2,
+	MPTCP_PM_ATTR_SUBFLOWS = 3,
+	MPTCP_PM_ATTR_TOKEN = 4,
+	MPTCP_PM_ATTR_LOC_ID = 5,
+	MPTCP_PM_ATTR_ADDR_REMOTE = 6,
+	__MPTCP_ATTR_AFTER_LAST = 7,
+};
+
+enum {
+	MPTCP_PM_CMD_UNSPEC = 0,
+	MPTCP_PM_CMD_ADD_ADDR = 1,
+	MPTCP_PM_CMD_DEL_ADDR = 2,
+	MPTCP_PM_CMD_GET_ADDR = 3,
+	MPTCP_PM_CMD_FLUSH_ADDRS = 4,
+	MPTCP_PM_CMD_SET_LIMITS = 5,
+	MPTCP_PM_CMD_GET_LIMITS = 6,
+	MPTCP_PM_CMD_SET_FLAGS = 7,
+	MPTCP_PM_CMD_ANNOUNCE = 8,
+	MPTCP_PM_CMD_REMOVE = 9,
+	MPTCP_PM_CMD_SUBFLOW_CREATE = 10,
+	MPTCP_PM_CMD_SUBFLOW_DESTROY = 11,
+	__MPTCP_PM_CMD_AFTER_LAST = 12,
+};
+
+struct tls_crypto_info {
+	__u16 version;
+	__u16 cipher_type;
+};
+
+struct tls12_crypto_info_aes_gcm_128 {
+	struct tls_crypto_info info;
+	unsigned char iv[8];
+	unsigned char key[16];
+	unsigned char salt[4];
+	unsigned char rec_seq[8];
+};
+
+struct tls12_crypto_info_aes_gcm_256 {
+	struct tls_crypto_info info;
+	unsigned char iv[8];
+	unsigned char key[32];
+	unsigned char salt[4];
+	unsigned char rec_seq[8];
+};
+
+struct tls12_crypto_info_chacha20_poly1305 {
+	struct tls_crypto_info info;
+	unsigned char iv[12];
+	unsigned char key[32];
+	unsigned char salt[0];
+	unsigned char rec_seq[8];
+};
+
+struct tls12_crypto_info_sm4_gcm {
+	struct tls_crypto_info info;
+	unsigned char iv[8];
+	unsigned char key[16];
+	unsigned char salt[4];
+	unsigned char rec_seq[8];
+};
+
+struct tls12_crypto_info_sm4_ccm {
+	struct tls_crypto_info info;
+	unsigned char iv[8];
+	unsigned char key[16];
+	unsigned char salt[4];
+	unsigned char rec_seq[8];
+};
+
+struct tls_prot_info {
+	u16 version;
+	u16 cipher_type;
+	u16 prepend_size;
+	u16 tag_size;
+	u16 overhead_size;
+	u16 iv_size;
+	u16 salt_size;
+	u16 rec_seq_size;
+	u16 aad_size;
+	u16 tail_size;
+};
+
+struct cipher_context {
+	char iv[20];
+	char rec_seq[8];
+};
+
+union tls_crypto_context {
+	struct tls_crypto_info info;
+	union {
+		struct tls12_crypto_info_aes_gcm_128 aes_gcm_128;
+		struct tls12_crypto_info_aes_gcm_256 aes_gcm_256;
+		struct tls12_crypto_info_chacha20_poly1305 chacha20_poly1305;
+		struct tls12_crypto_info_sm4_gcm sm4_gcm;
+		struct tls12_crypto_info_sm4_ccm sm4_ccm;
+	};
+};
+
+struct tls_context {
+	struct tls_prot_info prot_info;
+	u8 tx_conf: 3;
+	u8 rx_conf: 3;
+	u8 zerocopy_sendfile: 1;
+	u8 rx_no_pad: 1;
+	int (*push_pending_record)(struct sock *, int);
+	void (*sk_write_space)(struct sock *);
+	void *priv_ctx_tx;
+	void *priv_ctx_rx;
+	struct net_device *netdev;
+	struct cipher_context tx;
+	struct cipher_context rx;
+	struct scatterlist *partially_sent_record;
+	u16 partially_sent_offset;
+	bool splicing_pages;
+	bool pending_open_record_frags;
+	struct mutex tx_lock;
+	long unsigned int flags;
+	struct proto *sk_proto;
+	struct sock *sk;
+	void (*sk_destruct)(struct sock *);
+	union tls_crypto_context crypto_send;
+	union tls_crypto_context crypto_recv;
+	struct list_head list;
+	refcount_t refcount;
+	struct callback_head rcu;
+};
+
+enum {
+	TLS_RECORD_TYPE_CHANGE_CIPHER_SPEC = 20,
+	TLS_RECORD_TYPE_ALERT = 21,
+	TLS_RECORD_TYPE_HANDSHAKE = 22,
+	TLS_RECORD_TYPE_DATA = 23,
+	TLS_RECORD_TYPE_HEARTBEAT = 24,
+	TLS_RECORD_TYPE_TLS12_CID = 25,
+	TLS_RECORD_TYPE_ACK = 26,
+};
+
+struct handshake_proto;
+
+struct handshake_req {
+	struct list_head hr_list;
+	struct rhash_head hr_rhash;
+	long unsigned int hr_flags;
+	const struct handshake_proto *hr_proto;
+	struct sock *hr_sk;
+	void (*hr_odestruct)(struct sock *);
+	char hr_priv[0];
+};
+
+struct handshake_proto {
+	int hp_handler_class;
+	size_t hp_privsize;
+	long unsigned int hp_flags;
+	int (*hp_accept)(struct handshake_req *, struct genl_info *, int);
+	void (*hp_done)(struct handshake_req *, unsigned int, struct genl_info *);
+	void (*hp_destroy)(struct handshake_req *);
+};
+
+enum {
+	TLS_ALERT_LEVEL_WARNING = 1,
+	TLS_ALERT_LEVEL_FATAL = 2,
+};
+
+enum {
+	TLS_ALERT_DESC_CLOSE_NOTIFY = 0,
+	TLS_ALERT_DESC_UNEXPECTED_MESSAGE = 10,
+	TLS_ALERT_DESC_BAD_RECORD_MAC = 20,
+	TLS_ALERT_DESC_RECORD_OVERFLOW = 22,
+	TLS_ALERT_DESC_HANDSHAKE_FAILURE = 40,
+	TLS_ALERT_DESC_BAD_CERTIFICATE = 42,
+	TLS_ALERT_DESC_UNSUPPORTED_CERTIFICATE = 43,
+	TLS_ALERT_DESC_CERTIFICATE_REVOKED = 44,
+	TLS_ALERT_DESC_CERTIFICATE_EXPIRED = 45,
+	TLS_ALERT_DESC_CERTIFICATE_UNKNOWN = 46,
+	TLS_ALERT_DESC_ILLEGAL_PARAMETER = 47,
+	TLS_ALERT_DESC_UNKNOWN_CA = 48,
+	TLS_ALERT_DESC_ACCESS_DENIED = 49,
+	TLS_ALERT_DESC_DECODE_ERROR = 50,
+	TLS_ALERT_DESC_DECRYPT_ERROR = 51,
+	TLS_ALERT_DESC_TOO_MANY_CIDS_REQUESTED = 52,
+	TLS_ALERT_DESC_PROTOCOL_VERSION = 70,
+	TLS_ALERT_DESC_INSUFFICIENT_SECURITY = 71,
+	TLS_ALERT_DESC_INTERNAL_ERROR = 80,
+	TLS_ALERT_DESC_INAPPROPRIATE_FALLBACK = 86,
+	TLS_ALERT_DESC_USER_CANCELED = 90,
+	TLS_ALERT_DESC_MISSING_EXTENSION = 109,
+	TLS_ALERT_DESC_UNSUPPORTED_EXTENSION = 110,
+	TLS_ALERT_DESC_UNRECOGNIZED_NAME = 112,
+	TLS_ALERT_DESC_BAD_CERTIFICATE_STATUS_RESPONSE = 113,
+	TLS_ALERT_DESC_UNKNOWN_PSK_IDENTITY = 115,
+	TLS_ALERT_DESC_CERTIFICATE_REQUIRED = 116,
+	TLS_ALERT_DESC_NO_APPLICATION_PROTOCOL = 120,
+};
+
+struct trace_event_raw_handshake_event_class {
+	struct trace_entry ent;
+	const void *req;
+	const void *sk;
+	unsigned int netns_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_handshake_fd_class {
+	struct trace_entry ent;
+	const void *req;
+	const void *sk;
+	int fd;
+	unsigned int netns_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_handshake_error_class {
+	struct trace_entry ent;
+	const void *req;
+	const void *sk;
+	int err;
+	unsigned int netns_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_handshake_alert_class {
+	struct trace_entry ent;
+	__u8 saddr[28];
+	__u8 daddr[28];
+	unsigned int netns_ino;
+	long unsigned int level;
+	long unsigned int description;
+	char __data[0];
+};
+
+struct trace_event_raw_handshake_complete {
+	struct trace_entry ent;
+	const void *req;
+	const void *sk;
+	int status;
+	unsigned int netns_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_tls_contenttype {
+	struct trace_entry ent;
+	__u8 saddr[28];
+	__u8 daddr[28];
+	unsigned int netns_ino;
+	long unsigned int type;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_handshake_event_class {};
+
+struct trace_event_data_offsets_handshake_fd_class {};
+
+struct trace_event_data_offsets_handshake_error_class {};
+
+struct trace_event_data_offsets_handshake_alert_class {};
+
+struct trace_event_data_offsets_handshake_complete {};
+
+struct trace_event_data_offsets_tls_contenttype {};
+
+typedef void (*btf_trace_handshake_submit)(void *, const struct net *, const struct handshake_req *, const struct sock *);
+
+typedef void (*btf_trace_handshake_submit_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);
+
+typedef void (*btf_trace_handshake_cancel)(void *, const struct net *, const struct handshake_req *, const struct sock *);
+
+typedef void (*btf_trace_handshake_cancel_none)(void *, const struct net *, const struct handshake_req *, const struct sock *);
+
+typedef void (*btf_trace_handshake_cancel_busy)(void *, const struct net *, const struct handshake_req *, const struct sock *);
+
+typedef void (*btf_trace_handshake_destruct)(void *, const struct net *, const struct handshake_req *, const struct sock *);
+
+typedef void (*btf_trace_handshake_complete)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);
+
+typedef void (*btf_trace_handshake_notify_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);
+
+typedef void (*btf_trace_handshake_cmd_accept)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);
+
+typedef void (*btf_trace_handshake_cmd_accept_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);
+
+typedef void (*btf_trace_handshake_cmd_done)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);
+
+typedef void (*btf_trace_handshake_cmd_done_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);
+
+typedef void (*btf_trace_tls_contenttype)(void *, const struct sock *, unsigned char);
+
+typedef void (*btf_trace_tls_alert_send)(void *, const struct sock *, unsigned char, unsigned char);
+
+typedef void (*btf_trace_tls_alert_recv)(void *, const struct sock *, unsigned char, unsigned char);
+
+struct fdt_errtabent {
+	const char *str;
+};
+
+typedef __be64 fdt64_t;
+
+struct fdt_reserve_entry {
+	fdt64_t address;
+	fdt64_t size;
+};
+
+struct fdt_node_header {
+	fdt32_t tag;
+	char name[0];
+};
+
+struct fdt_property {
+	fdt32_t tag;
+	fdt32_t len;
+	fdt32_t nameoff;
+	char data[0];
+};
+
+enum {
+	ASSUME_PERFECT = 255,
+	ASSUME_VALID_DTB = 1,
+	ASSUME_VALID_INPUT = 2,
+	ASSUME_LATEST = 4,
+	ASSUME_NO_ROLLBACK = 8,
+	ASSUME_LIBFDT_ORDER = 16,
+	ASSUME_LIBFDT_FLAWLESS = 32,
+};
+
+enum {
+	LOGIC_PIO_INDIRECT = 0,
+	LOGIC_PIO_CPU_MMIO = 1,
+};
+
+struct logic_pio_host_ops;
+
+struct logic_pio_hwaddr {
+	struct list_head list;
+	struct fwnode_handle *fwnode;
+	resource_size_t hw_start;
+	resource_size_t io_start;
+	resource_size_t size;
+	long unsigned int flags;
+	void *hostdata;
+	const struct logic_pio_host_ops *ops;
+};
+
+struct logic_pio_host_ops {
+	u32 (*in)(void *, long unsigned int, size_t);
+	void (*out)(void *, long unsigned int, u32, size_t);
+	u32 (*ins)(void *, long unsigned int, void *, size_t, unsigned int);
+	void (*outs)(void *, long unsigned int, const void *, size_t, unsigned int);
+};
+
+struct trace_event_raw_initcall_level {
+	struct trace_entry ent;
+	u32 __data_loc_level;
+	char __data[0];
+};
+
+struct trace_event_raw_initcall_start {
+	struct trace_entry ent;
+	initcall_t func;
+	char __data[0];
+};
+
+struct trace_event_raw_initcall_finish {
+	struct trace_entry ent;
+	initcall_t func;
+	int ret;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_initcall_level {
+	u32 level;
+	const void *level_ptr_;
+};
+
+struct trace_event_data_offsets_initcall_start {};
+
+struct trace_event_data_offsets_initcall_finish {};
+
+typedef void (*btf_trace_initcall_level)(void *, const char *);
+
+typedef void (*btf_trace_initcall_start)(void *, initcall_t);
+
+typedef void (*btf_trace_initcall_finish)(void *, initcall_t, int);
+
+struct blacklist_entry {
+	struct list_head next;
+	char *buf;
+};
+
+enum cpu_led_event {
+	CPU_LED_IDLE_START = 0,
+	CPU_LED_IDLE_END = 1,
+	CPU_LED_START = 2,
+	CPU_LED_STOP = 3,
+	CPU_LED_HALTED = 4,
+};
+
+struct elf32_rel {
+	Elf32_Addr r_offset;
+	Elf32_Word r_info;
+};
+
+typedef struct elf32_rel Elf32_Rel;
+
+struct perf_callchain_entry_ctx {
+	struct perf_callchain_entry *entry;
+	u32 max_stack;
+	u32 nr;
+	short int contexts;
+	bool contexts_maxed;
+};
+
+struct frame_tail {
+	struct frame_tail *fp;
+	long unsigned int sp;
+	long unsigned int lr;
+};
+
+enum {
+	SPECTRE_UNAFFECTED = 0,
+	SPECTRE_MITIGATED = 1,
+	SPECTRE_VULNERABLE = 2,
+};
+
+enum {
+	__SPECTRE_V2_METHOD_BPIALL = 0,
+	__SPECTRE_V2_METHOD_ICIALLU = 1,
+	__SPECTRE_V2_METHOD_SMC = 2,
+	__SPECTRE_V2_METHOD_HVC = 3,
+	__SPECTRE_V2_METHOD_LOOP8 = 4,
+};
+
+enum {
+	SPECTRE_V2_METHOD_BPIALL = 1,
+	SPECTRE_V2_METHOD_ICIALLU = 2,
+	SPECTRE_V2_METHOD_SMC = 4,
+	SPECTRE_V2_METHOD_HVC = 8,
+	SPECTRE_V2_METHOD_LOOP8 = 16,
+};
+
+struct gen_pool;
+
+typedef long unsigned int (*genpool_algo_t)(long unsigned int *, long unsigned int, long unsigned int, unsigned int, void *, struct gen_pool *, long unsigned int);
+
+struct gen_pool {
+	spinlock_t lock;
+	struct list_head chunks;
+	int min_alloc_order;
+	genpool_algo_t algo;
+	void *data;
+	const char *name;
+};
+
+struct l2x0_regs;
+
+struct outer_cache_fns {
+	void (*inv_range)(long unsigned int, long unsigned int);
+	void (*clean_range)(long unsigned int, long unsigned int);
+	void (*flush_range)(long unsigned int, long unsigned int);
+	void (*flush_all)();
+	void (*disable)();
+	void (*sync)();
+	void (*resume)();
+	void (*write_sec)(long unsigned int, unsigned int);
+	void (*configure)(const struct l2x0_regs *);
+};
+
+struct l2x0_regs {
+	long unsigned int phy_base;
+	long unsigned int aux_ctrl;
+	long unsigned int tag_latency;
+	long unsigned int data_latency;
+	long unsigned int filter_start;
+	long unsigned int filter_end;
+	long unsigned int prefetch_ctrl;
+	long unsigned int pwr_ctrl;
+	long unsigned int ctrl;
+	long unsigned int aux2_ctrl;
+};
+
+struct arm_dma_alloc_args {
+	struct device *dev;
+	size_t size;
+	gfp_t gfp;
+	pgprot_t prot;
+	const void *caller;
+	bool want_vaddr;
+	int coherent_flag;
+};
+
+struct arm_dma_free_args {
+	struct device *dev;
+	size_t size;
+	void *cpu_addr;
+	struct page *page;
+	bool want_vaddr;
+};
+
+struct arm_dma_allocator {
+	void * (*alloc)(struct arm_dma_alloc_args *, struct page **);
+	void (*free)(struct arm_dma_free_args *);
+};
+
+struct arm_dma_buffer {
+	struct list_head list;
+	void *virt;
+	struct arm_dma_allocator *allocator;
+};
+
+struct cma;
+
+struct ptdesc {
+	long unsigned int __page_flags;
+	union {
+		struct callback_head pt_rcu_head;
+		struct list_head pt_list;
+		struct {
+			long unsigned int _pt_pad_1;
+			pgtable_t pmd_huge_pte;
+		};
+	};
+	long unsigned int __page_mapping;
+	union {
+		long unsigned int pt_index;
+		struct mm_struct *pt_mm;
+		atomic_t pt_frag_refcount;
+	};
+	union {
+		long unsigned int _pt_pad_2;
+		spinlock_t ptl;
+	};
+	unsigned int __page_type;
+	atomic_t __page_refcount;
+	long unsigned int pt_memcg_data;
+};
+
+struct cpu_cache_fns {
+	void (*flush_icache_all)();
+	void (*flush_kern_all)();
+	void (*flush_kern_louis)();
+	void (*flush_user_all)();
+	void (*flush_user_range)(long unsigned int, long unsigned int, unsigned int);
+	void (*coherent_kern_range)(long unsigned int, long unsigned int);
+	int (*coherent_user_range)(long unsigned int, long unsigned int);
+	void (*flush_kern_dcache_area)(void *, size_t);
+	void (*dma_map_area)(const void *, size_t, int);
+	void (*dma_unmap_area)(const void *, size_t, int);
+	void (*dma_flush_range)(const void *, const void *);
+};
+
+struct cpu_user_fns {
+	void (*cpu_clear_user_highpage)(struct page *, long unsigned int);
+	void (*cpu_copy_user_highpage)(struct page *, struct page *, long unsigned int, struct vm_area_struct *);
+};
+
+struct l2c_init_data {
+	const char *type;
+	unsigned int way_size_0;
+	unsigned int num_lock;
+	void (*of_parse)(const struct device_node *, u32 *, u32 *);
+	void (*enable)(void *, unsigned int);
+	void (*fixup)(void *, u32, struct outer_cache_fns *);
+	void (*save)(void *);
+	void (*configure)(void *);
+	void (*unlock)(void *, unsigned int);
+	struct outer_cache_fns outer_cache;
+};
+
+struct clone_args {
+	__u64 flags;
+	__u64 pidfd;
+	__u64 child_tid;
+	__u64 parent_tid;
+	__u64 exit_signal;
+	__u64 stack;
+	__u64 stack_size;
+	__u64 tls;
+	__u64 set_tid;
+	__u64 set_tid_size;
+	__u64 cgroup;
+};
+
+struct multiprocess_signals {
+	sigset_t signal;
+	struct hlist_node node;
+};
+
+typedef int (*proc_visitor)(struct task_struct *, void *);
+
+struct fd_range {
+	unsigned int from;
+	unsigned int to;
+};
+
+enum {
+	FUTEX_STATE_OK = 0,
+	FUTEX_STATE_EXITING = 1,
+	FUTEX_STATE_DEAD = 2,
+};
+
+struct trace_event_raw_task_newtask {
+	struct trace_entry ent;
+	pid_t pid;
+	char comm[16];
+	long unsigned int clone_flags;
+	short int oom_score_adj;
+	char __data[0];
+};
+
+struct trace_event_raw_task_rename {
+	struct trace_entry ent;
+	pid_t pid;
+	char oldcomm[16];
+	char newcomm[16];
+	short int oom_score_adj;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_task_newtask {};
+
+struct trace_event_data_offsets_task_rename {};
+
+typedef void (*btf_trace_task_newtask)(void *, struct task_struct *, long unsigned int);
+
+typedef void (*btf_trace_task_rename)(void *, struct task_struct *, const char *);
+
+struct audit_context;
+
+enum {
+	IORES_DESC_NONE = 0,
+	IORES_DESC_CRASH_KERNEL = 1,
+	IORES_DESC_ACPI_TABLES = 2,
+	IORES_DESC_ACPI_NV_STORAGE = 3,
+	IORES_DESC_PERSISTENT_MEMORY = 4,
+	IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
+	IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
+	IORES_DESC_RESERVED = 7,
+	IORES_DESC_SOFT_RESERVED = 8,
+	IORES_DESC_CXL = 9,
+};
+
+typedef resource_size_t (*resource_alignf)(void *, const struct resource *, resource_size_t, resource_size_t);
+
+struct resource_constraint {
+	resource_size_t min;
+	resource_size_t max;
+	resource_size_t align;
+	resource_alignf alignf;
+	void *alignf_data;
+};
+
+enum {
+	REGION_INTERSECTS = 0,
+	REGION_DISJOINT = 1,
+	REGION_MIXED = 2,
+};
+
+struct pseudo_fs_context {
+	const struct super_operations *ops;
+	const struct xattr_handler * const *xattr;
+	const struct dentry_operations *dops;
+	long unsigned int magic;
+};
+
+enum {
+	MAX_IORES_LEVEL = 5,
+};
+
+struct region_devres {
+	struct resource *parent;
+	resource_size_t start;
+	resource_size_t n;
+};
+
+struct siginfo {
+	union {
+		struct {
+			int si_signo;
+			int si_errno;
+			int si_code;
+			union __sifields _sifields;
+		};
+		int _si_pad[32];
+	};
+};
+
+typedef struct siginfo siginfo_t;
+
+typedef struct {
+	rwlock_t *lock;
+} class_write_lock_irq_t;
+
+typedef class_mutex_t class_mutex_intr_t;
+
+enum {
+	FOLL_WRITE = 1,
+	FOLL_GET = 2,
+	FOLL_DUMP = 4,
+	FOLL_FORCE = 8,
+	FOLL_NOWAIT = 16,
+	FOLL_NOFAULT = 32,
+	FOLL_HWPOISON = 64,
+	FOLL_ANON = 128,
+	FOLL_LONGTERM = 256,
+	FOLL_SPLIT_PMD = 512,
+	FOLL_PCI_P2PDMA = 1024,
+	FOLL_INTERRUPTIBLE = 2048,
+	FOLL_HONOR_NUMA_FAULT = 4096,
+};
+
+typedef struct task_struct *class_task_lock_t;
+
+struct ptrace_peeksiginfo_args {
+	__u64 off;
+	__u32 flags;
+	__s32 nr;
+};
+
+struct ptrace_syscall_info {
+	__u8 op;
+	__u8 pad[3];
+	__u32 arch;
+	__u64 instruction_pointer;
+	__u64 stack_pointer;
+	union {
+		struct {
+			__u64 nr;
+			__u64 args[6];
+		} entry;
+		struct {
+			__s64 rval;
+			__u8 is_error;
+			long: 32;
+		} exit;
+		struct {
+			__u64 nr;
+			__u64 args[6];
+			__u32 ret_data;
+			long: 32;
+		} seccomp;
+	};
+};
+
+enum {
+	KTW_FREEZABLE = 1,
+};
+
+struct kthread_delayed_work {
+	struct kthread_work work;
+	struct timer_list timer;
+};
+
+struct kthread_create_info {
+	char *full_name;
+	int (*threadfn)(void *);
+	void *data;
+	int node;
+	struct task_struct *result;
+	struct completion *done;
+	struct list_head list;
+};
+
+struct kthread {
+	long unsigned int flags;
+	unsigned int cpu;
+	int result;
+	int (*threadfn)(void *);
+	void *data;
+	struct completion parked;
+	struct completion exited;
+	struct cgroup_subsys_state *blkcg_css;
+	char *full_name;
+};
+
+enum KTHREAD_BITS {
+	KTHREAD_IS_PER_CPU = 0,
+	KTHREAD_SHOULD_STOP = 1,
+	KTHREAD_SHOULD_PARK = 2,
+};
+
+struct kthread_flush_work {
+	struct kthread_work work;
+	struct completion done;
+};
+
+enum reboot_type {
+	BOOT_TRIPLE = 116,
+	BOOT_KBD = 107,
+	BOOT_BIOS = 98,
+	BOOT_ACPI = 97,
+	BOOT_EFI = 101,
+	BOOT_CF9_FORCE = 112,
+	BOOT_CF9_SAFE = 113,
+};
+
+enum sys_off_mode {
+	SYS_OFF_MODE_POWER_OFF_PREPARE = 0,
+	SYS_OFF_MODE_POWER_OFF = 1,
+	SYS_OFF_MODE_RESTART_PREPARE = 2,
+	SYS_OFF_MODE_RESTART = 3,
+};
+
+struct sys_off_data {
+	int mode;
+	void *cb_data;
+	const char *cmd;
+	struct device *dev;
+};
+
+struct sys_off_handler {
+	struct notifier_block nb;
+	int (*sys_off_cb)(struct sys_off_data *);
+	void *cb_data;
+	enum sys_off_mode mode;
+	bool blocking;
+	void *list;
+	struct device *dev;
+};
+
+struct ksignal {
+	struct k_sigaction ka;
+	kernel_siginfo_t info;
+	int sig;
+};
+
+enum vhost_task_flags {
+	VHOST_TASK_FLAGS_STOP = 0,
+	VHOST_TASK_FLAGS_KILLED = 1,
+};
+
+struct vhost_task {
+	bool (*fn)(void *);
+	void (*handle_sigkill)(void *);
+	void *data;
+	struct completion exited;
+	long unsigned int flags;
+	struct task_struct *task;
+	struct mutex exit_mutex;
+};
+
+enum uclamp_id {
+	UCLAMP_MIN = 0,
+	UCLAMP_MAX = 1,
+	UCLAMP_CNT = 2,
+};
+
+enum cpu_idle_type {
+	__CPU_NOT_IDLE = 0,
+	CPU_IDLE = 1,
+	CPU_NEWLY_IDLE = 2,
+	CPU_MAX_IDLE_TYPES = 3,
+};
+
+enum {
+	SD_BALANCE_NEWIDLE = 1,
+	SD_BALANCE_EXEC = 2,
+	SD_BALANCE_FORK = 4,
+	SD_BALANCE_WAKE = 8,
+	SD_WAKE_AFFINE = 16,
+	SD_ASYM_CPUCAPACITY = 32,
+	SD_ASYM_CPUCAPACITY_FULL = 64,
+	SD_SHARE_CPUCAPACITY = 128,
+	SD_CLUSTER = 256,
+	SD_SHARE_LLC = 512,
+	SD_SERIALIZE = 1024,
+	SD_ASYM_PACKING = 2048,
+	SD_PREFER_SIBLING = 4096,
+	SD_OVERLAP = 8192,
+	SD_NUMA = 16384,
+};
+
+struct cpuidle_state_usage {
+	long long unsigned int disable;
+	long long unsigned int usage;
+	u64 time_ns;
+	long long unsigned int above;
+	long long unsigned int below;
+	long long unsigned int rejected;
+};
+
+struct cpuidle_device;
+
+struct cpuidle_driver;
+
+struct cpuidle_state {
+	char name[16];
+	char desc[32];
+	s64 exit_latency_ns;
+	s64 target_residency_ns;
+	unsigned int flags;
+	unsigned int exit_latency;
+	int power_usage;
+	unsigned int target_residency;
+	int (*enter)(struct cpuidle_device *, struct cpuidle_driver *, int);
+	int (*enter_dead)(struct cpuidle_device *, int);
+	int (*enter_s2idle)(struct cpuidle_device *, struct cpuidle_driver *, int);
+	long: 32;
+};
+
+struct cpuidle_state_kobj;
+
+struct cpuidle_driver_kobj;
+
+struct cpuidle_device_kobj;
+
+struct cpuidle_device {
+	unsigned int registered: 1;
+	unsigned int enabled: 1;
+	unsigned int poll_time_limit: 1;
+	unsigned int cpu;
+	ktime_t next_hrtimer;
+	int last_state_idx;
+	long: 32;
+	u64 last_residency_ns;
+	u64 poll_limit_ns;
+	u64 forced_idle_latency_limit_ns;
+	struct cpuidle_state_usage states_usage[10];
+	struct cpuidle_state_kobj *kobjs[10];
+	struct cpuidle_driver_kobj *kobj_driver;
+	struct cpuidle_device_kobj *kobj_dev;
+	struct list_head device_list;
+};
+
+struct cpuidle_driver {
+	const char *name;
+	struct module *owner;
+	unsigned int bctimer: 1;
+	long: 32;
+	struct cpuidle_state states[10];
+	int state_count;
+	int safe_state_index;
+	struct cpumask *cpumask;
+	const char *governor;
+};
+
+enum sched_tunable_scaling {
+	SCHED_TUNABLESCALING_NONE = 0,
+	SCHED_TUNABLESCALING_LOG = 1,
+	SCHED_TUNABLESCALING_LINEAR = 2,
+	SCHED_TUNABLESCALING_END = 3,
+};
+
+struct asym_cap_data {
+	struct list_head link;
+	struct callback_head rcu;
+	long unsigned int capacity;
+	long unsigned int cpus[0];
+};
+
+struct energy_env {
+	long unsigned int task_busy_time;
+	long unsigned int pd_busy_time;
+	long unsigned int cpu_cap;
+	long unsigned int pd_cap;
+};
+
+enum fbq_type {
+	regular = 0,
+	remote = 1,
+	all = 2,
+};
+
+enum group_type {
+	group_has_spare = 0,
+	group_fully_busy = 1,
+	group_misfit_task = 2,
+	group_smt_balance = 3,
+	group_asym_packing = 4,
+	group_imbalanced = 5,
+	group_overloaded = 6,
+};
+
+enum migration_type {
+	migrate_load = 0,
+	migrate_util = 1,
+	migrate_task = 2,
+	migrate_misfit = 3,
+};
+
+struct lb_env {
+	struct sched_domain *sd;
+	struct rq *src_rq;
+	int src_cpu;
+	int dst_cpu;
+	struct rq *dst_rq;
+	struct cpumask *dst_grpmask;
+	int new_dst_cpu;
+	enum cpu_idle_type idle;
+	long int imbalance;
+	struct cpumask *cpus;
+	unsigned int flags;
+	unsigned int loop;
+	unsigned int loop_break;
+	unsigned int loop_max;
+	enum fbq_type fbq_type;
+	enum migration_type migration_type;
+	struct list_head tasks;
+};
+
+struct sg_lb_stats {
+	long unsigned int avg_load;
+	long unsigned int group_load;
+	long unsigned int group_capacity;
+	long unsigned int group_util;
+	long unsigned int group_runnable;
+	unsigned int sum_nr_running;
+	unsigned int sum_h_nr_running;
+	unsigned int idle_cpus;
+	unsigned int group_weight;
+	enum group_type group_type;
+	unsigned int group_asym_packing;
+	unsigned int group_smt_balance;
+	long unsigned int group_misfit_task_load;
+};
+
+struct sd_lb_stats {
+	struct sched_group *busiest;
+	struct sched_group *local;
+	long unsigned int total_load;
+	long unsigned int total_capacity;
+	long unsigned int avg_load;
+	unsigned int prefer_sibling;
+	struct sg_lb_stats busiest_stat;
+	struct sg_lb_stats local_stat;
+};
+
+struct ww_mutex {
+	struct mutex base;
+	struct ww_acquire_ctx *ctx;
+};
+
+struct ww_acquire_ctx {
+	struct task_struct *task;
+	long unsigned int stamp;
+	unsigned int acquired;
+	short unsigned int wounded;
+	short unsigned int is_wait_die;
+};
+
+struct trace_event_raw_contention_begin {
+	struct trace_entry ent;
+	void *lock_addr;
+	unsigned int flags;
+	char __data[0];
+};
+
+struct trace_event_raw_contention_end {
+	struct trace_entry ent;
+	void *lock_addr;
+	int ret;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_contention_begin {};
+
+struct trace_event_data_offsets_contention_end {};
+
+typedef void (*btf_trace_contention_begin)(void *, void *, unsigned int);
+
+typedef void (*btf_trace_contention_end)(void *, void *, int);
+
+struct mutex_waiter {
+	struct list_head list;
+	struct task_struct *task;
+	struct ww_acquire_ctx *ww_ctx;
+};
+
+struct prb_data_block {
+	long unsigned int id;
+	char data[0];
+};
+
+enum {
+	IRQD_TRIGGER_MASK = 15,
+	IRQD_SETAFFINITY_PENDING = 256,
+	IRQD_ACTIVATED = 512,
+	IRQD_NO_BALANCING = 1024,
+	IRQD_PER_CPU = 2048,
+	IRQD_AFFINITY_SET = 4096,
+	IRQD_LEVEL = 8192,
+	IRQD_WAKEUP_STATE = 16384,
+	IRQD_MOVE_PCNTXT = 32768,
+	IRQD_IRQ_DISABLED = 65536,
+	IRQD_IRQ_MASKED = 131072,
+	IRQD_IRQ_INPROGRESS = 262144,
+	IRQD_WAKEUP_ARMED = 524288,
+	IRQD_FORWARDED_TO_VCPU = 1048576,
+	IRQD_AFFINITY_MANAGED = 2097152,
+	IRQD_IRQ_STARTED = 4194304,
+	IRQD_MANAGED_SHUTDOWN = 8388608,
+	IRQD_SINGLE_TARGET = 16777216,
+	IRQD_DEFAULT_TRIGGER_SET = 33554432,
+	IRQD_CAN_RESERVE = 67108864,
+	IRQD_HANDLE_ENFORCE_IRQCTX = 134217728,
+	IRQD_AFFINITY_ON_ACTIVATE = 268435456,
+	IRQD_IRQ_ENABLED_ON_SUSPEND = 536870912,
+	IRQD_RESEND_WHEN_IN_PROGRESS = 1073741824,
+};
+
+enum {
+	IRQTF_RUNTHREAD = 0,
+	IRQTF_WARNED = 1,
+	IRQTF_AFFINITY = 2,
+	IRQTF_FORCED_THREAD = 3,
+	IRQTF_READY = 4,
+};
+
+enum {
+	IRQS_AUTODETECT = 1,
+	IRQS_SPURIOUS_DISABLED = 2,
+	IRQS_POLL_INPROGRESS = 8,
+	IRQS_ONESHOT = 32,
+	IRQS_REPLAY = 64,
+	IRQS_WAITING = 128,
+	IRQS_PENDING = 512,
+	IRQS_SUSPENDED = 2048,
+	IRQS_TIMINGS = 4096,
+	IRQS_NMI = 8192,
+	IRQS_SYSFS = 16384,
+};
+
+enum {
+	_IRQ_DEFAULT_INIT_FLAGS = 3072,
+	_IRQ_PER_CPU = 512,
+	_IRQ_LEVEL = 256,
+	_IRQ_NOPROBE = 1024,
+	_IRQ_NOREQUEST = 2048,
+	_IRQ_NOTHREAD = 65536,
+	_IRQ_NOAUTOEN = 4096,
+	_IRQ_MOVE_PCNTXT = 16384,
+	_IRQ_NO_BALANCING = 8192,
+	_IRQ_NESTED_THREAD = 32768,
+	_IRQ_PER_CPU_DEVID = 131072,
+	_IRQ_IS_POLLED = 262144,
+	_IRQ_DISABLE_UNLAZY = 524288,
+	_IRQ_HIDDEN = 1048576,
+	_IRQ_NO_DEBUG = 2097152,
+	_IRQF_MODIFY_MASK = 2096911,
+};
+
+struct arch_msi_msg_addr_lo {
+	u32 address_lo;
+};
+
+typedef struct arch_msi_msg_addr_lo arch_msi_msg_addr_lo_t;
+
+struct arch_msi_msg_addr_hi {
+	u32 address_hi;
+};
+
+typedef struct arch_msi_msg_addr_hi arch_msi_msg_addr_hi_t;
+
+struct arch_msi_msg_data {
+	u32 data;
+};
+
+typedef struct arch_msi_msg_data arch_msi_msg_data_t;
+
+struct msi_msg {
+	union {
+		u32 address_lo;
+		arch_msi_msg_addr_lo_t arch_addr_lo;
+	};
+	union {
+		u32 address_hi;
+		arch_msi_msg_addr_hi_t arch_addr_hi;
+	};
+	union {
+		u32 data;
+		arch_msi_msg_data_t arch_data;
+	};
+};
+
+struct pci_msi_desc {
+	union {
+		u32 msi_mask;
+		u32 msix_ctrl;
+	};
+	struct {
+		u8 is_msix: 1;
+		u8 multiple: 3;
+		u8 multi_cap: 3;
+		u8 can_mask: 1;
+		u8 is_64: 1;
+		u8 is_virtual: 1;
+		unsigned int default_irq;
+	} msi_attrib;
+	union {
+		u8 mask_pos;
+		void *mask_base;
+	};
+};
+
+union msi_domain_cookie {
+	u64 value;
+	void *ptr;
+	void *iobase;
+};
+
+union msi_instance_cookie {
+	u64 value;
+	void *ptr;
+};
+
+struct msi_desc_data {
+	union msi_domain_cookie dcookie;
+	union msi_instance_cookie icookie;
+};
+
+struct msi_desc {
+	unsigned int irq;
+	unsigned int nvec_used;
+	struct device *dev;
+	struct msi_msg msg;
+	struct irq_affinity_desc *affinity;
+	struct device_attribute *sysfs_attrs;
+	void (*write_msi_msg)(struct msi_desc *, void *);
+	void *write_msi_msg_data;
+	u16 msi_index;
+	long: 32;
+	union {
+		struct pci_msi_desc pci;
+		struct msi_desc_data data;
+	};
+};
+
+enum {
+	IRQ_STARTUP_NORMAL = 0,
+	IRQ_STARTUP_MANAGED = 1,
+	IRQ_STARTUP_ABORT = 2,
+};
+
+enum {
+	AFFINITY = 0,
+	AFFINITY_LIST = 1,
+	EFFECTIVE = 2,
+	EFFECTIVE_LIST = 3,
+};
+
+typedef void (*call_rcu_func_t)(struct callback_head *, rcu_callback_t);
+
+enum ftrace_dump_mode {
+	DUMP_NONE = 0,
+	DUMP_ALL = 1,
+	DUMP_ORIG = 2,
+	DUMP_PARAM = 3,
+};
+
+struct rcu_gp_oldstate {
+	long unsigned int rgos_norm;
+	long unsigned int rgos_exp;
+};
+
+struct swait_queue {
+	struct task_struct *task;
+	struct list_head task_list;
+};
+
+enum tick_dep_bits {
+	TICK_DEP_BIT_POSIX_TIMER = 0,
+	TICK_DEP_BIT_PERF_EVENTS = 1,
+	TICK_DEP_BIT_SCHED = 2,
+	TICK_DEP_BIT_CLOCK_UNSTABLE = 3,
+	TICK_DEP_BIT_RCU = 4,
+	TICK_DEP_BIT_RCU_EXP = 5,
+};
+
+struct rt_mutex {
+	struct rt_mutex_base rtmutex;
+};
+
+struct rcu_exp_work {
+	long unsigned int rew_s;
+	struct kthread_work rew_work;
+};
+
+struct rcu_node {
+	raw_spinlock_t lock;
+	long unsigned int gp_seq;
+	long unsigned int gp_seq_needed;
+	long unsigned int completedqs;
+	long unsigned int qsmask;
+	long unsigned int rcu_gp_init_mask;
+	long unsigned int qsmaskinit;
+	long unsigned int qsmaskinitnext;
+	long unsigned int expmask;
+	long unsigned int expmaskinit;
+	long unsigned int expmaskinitnext;
+	struct kthread_worker *exp_kworker;
+	long unsigned int cbovldmask;
+	long unsigned int ffmask;
+	long unsigned int grpmask;
+	int grplo;
+	int grphi;
+	u8 grpnum;
+	u8 level;
+	bool wait_blkd_tasks;
+	struct rcu_node *parent;
+	struct list_head blkd_tasks;
+	struct list_head *gp_tasks;
+	struct list_head *exp_tasks;
+	struct list_head *boost_tasks;
+	struct rt_mutex boost_mtx;
+	long unsigned int boost_time;
+	struct mutex kthread_mutex;
+	struct task_struct *boost_kthread_task;
+	unsigned int boost_kthread_status;
+	long unsigned int n_boosts;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	raw_spinlock_t fqslock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	spinlock_t exp_lock;
+	long unsigned int exp_seq_rq;
+	wait_queue_head_t exp_wq[4];
+	struct rcu_exp_work rew;
+	bool exp_need_flush;
+	raw_spinlock_t exp_poll_lock;
+	long unsigned int exp_seq_poll_rq;
+	struct work_struct exp_poll_wq;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+union rcu_noqs {
+	struct {
+		u8 norm;
+		u8 exp;
+	} b;
+	u16 s;
+};
+
+struct rcu_snap_record {
+	long unsigned int gp_seq;
+	long: 32;
+	u64 cputime_irq;
+	u64 cputime_softirq;
+	u64 cputime_system;
+	long unsigned int nr_hardirqs;
+	unsigned int nr_softirqs;
+	long long unsigned int nr_csw;
+	long unsigned int jiffies;
+	long: 32;
+};
+
+struct rcu_data {
+	long unsigned int gp_seq;
+	long unsigned int gp_seq_needed;
+	union rcu_noqs cpu_no_qs;
+	bool core_needs_qs;
+	bool beenonline;
+	bool gpwrap;
+	bool cpu_started;
+	struct rcu_node *mynode;
+	long unsigned int grpmask;
+	long unsigned int ticks_this_gp;
+	struct irq_work defer_qs_iw;
+	bool defer_qs_iw_pending;
+	struct work_struct strict_work;
+	struct rcu_segcblist cblist;
+	long int qlen_last_fqs_check;
+	long unsigned int n_cbs_invoked;
+	long unsigned int n_force_qs_snap;
+	long int blimit;
+	int watching_snap;
+	bool rcu_need_heavy_qs;
+	bool rcu_urgent_qs;
+	bool rcu_forced_tick;
+	bool rcu_forced_tick_exp;
+	long unsigned int barrier_seq_snap;
+	struct callback_head barrier_head;
+	int exp_watching_snap;
+	struct task_struct *rcu_cpu_kthread_task;
+	unsigned int rcu_cpu_kthread_status;
+	char rcu_cpu_has_work;
+	long unsigned int rcuc_activity;
+	unsigned int softirq_snap;
+	struct irq_work rcu_iw;
+	bool rcu_iw_pending;
+	long unsigned int rcu_iw_gp_seq;
+	long unsigned int rcu_ofl_gp_seq;
+	short int rcu_ofl_gp_state;
+	long unsigned int rcu_onl_gp_seq;
+	short int rcu_onl_gp_state;
+	long unsigned int last_fqs_resched;
+	long unsigned int last_sched_clock;
+	struct rcu_snap_record snap_record;
+	long int lazy_len;
+	int cpu;
+};
+
+struct sr_wait_node {
+	atomic_t inuse;
+	struct llist_node node;
+};
+
+struct rcu_state {
+	struct rcu_node node[1];
+	struct rcu_node *level[2];
+	int ncpus;
+	int n_online_cpus;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long unsigned int gp_seq;
+	long unsigned int gp_max;
+	struct task_struct *gp_kthread;
+	struct swait_queue_head gp_wq;
+	short int gp_flags;
+	short int gp_state;
+	long unsigned int gp_wake_time;
+	long unsigned int gp_wake_seq;
+	long unsigned int gp_seq_polled;
+	long unsigned int gp_seq_polled_snap;
+	long unsigned int gp_seq_polled_exp_snap;
+	struct mutex barrier_mutex;
+	atomic_t barrier_cpu_count;
+	struct completion barrier_completion;
+	long unsigned int barrier_sequence;
+	raw_spinlock_t barrier_lock;
+	struct mutex exp_mutex;
+	struct mutex exp_wake_mutex;
+	long unsigned int expedited_sequence;
+	atomic_t expedited_need_qs;
+	struct swait_queue_head expedited_wq;
+	int ncpus_snap;
+	u8 cbovld;
+	u8 cbovldnext;
+	long unsigned int jiffies_force_qs;
+	long unsigned int jiffies_kick_kthreads;
+	long unsigned int n_force_qs;
+	long unsigned int gp_start;
+	long unsigned int gp_end;
+	long unsigned int gp_activity;
+	long unsigned int gp_req_activity;
+	long unsigned int jiffies_stall;
+	int nr_fqs_jiffies_stall;
+	long unsigned int jiffies_resched;
+	long unsigned int n_force_qs_gpstart;
+	const char *name;
+	char abbr;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	arch_spinlock_t ofl_lock;
+	struct llist_head srs_next;
+	struct llist_node *srs_wait_tail;
+	struct llist_node *srs_done_tail;
+	struct sr_wait_node srs_wait_nodes[5];
+	struct work_struct srs_cleanup_work;
+	atomic_t srs_cleanups_pending;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct kvfree_rcu_bulk_data {
+	struct list_head list;
+	struct rcu_gp_oldstate gp_snap;
+	long unsigned int nr_records;
+	void *records[0];
+};
+
+struct kfree_rcu_cpu;
+
+struct kfree_rcu_cpu_work {
+	struct rcu_work rcu_work;
+	struct callback_head *head_free;
+	struct rcu_gp_oldstate head_free_gp_snap;
+	struct list_head bulk_head_free[2];
+	struct kfree_rcu_cpu *krcp;
+};
+
+struct kfree_rcu_cpu {
+	struct callback_head *head;
+	long unsigned int head_gp_snap;
+	atomic_t head_count;
+	struct list_head bulk_head[2];
+	atomic_t bulk_count[2];
+	struct kfree_rcu_cpu_work krw_arr[2];
+	raw_spinlock_t lock;
+	struct delayed_work monitor_work;
+	bool initialized;
+	struct delayed_work page_cache_work;
+	atomic_t backoff_page_cache_fill;
+	atomic_t work_in_progress;
+	long: 32;
+	struct hrtimer hrtimer;
+	struct llist_head bkvcache;
+	int nr_bkv_objs;
+};
+
+struct module_use {
+	struct list_head source_list;
+	struct list_head target_list;
+	struct module *source;
+	struct module *target;
+};
+
+struct module_sect_attr {
+	struct bin_attribute battr;
+	long unsigned int address;
+};
+
+struct module_sect_attrs {
+	struct attribute_group grp;
+	unsigned int nsections;
+	struct module_sect_attr attrs[0];
+};
+
+struct module_notes_attrs {
+	struct kobject *dir;
+	unsigned int notes;
+	struct bin_attribute attrs[0];
+};
+
+struct timezone {
+	int tz_minuteswest;
+	int tz_dsttime;
+};
+
+struct ktime_timestamps {
+	u64 mono;
+	u64 boot;
+	u64 real;
+};
+
+struct system_time_snapshot {
+	u64 cycles;
+	ktime_t real;
+	ktime_t raw;
+	enum clocksource_ids cs_id;
+	unsigned int clock_was_set_seq;
+	u8 cs_was_changed_seq;
+	long: 32;
+};
+
+struct system_device_crosststamp {
+	ktime_t device;
+	ktime_t sys_realtime;
+	ktime_t sys_monoraw;
+};
+
+struct system_counterval_t {
+	u64 cycles;
+	enum clocksource_ids cs_id;
+	bool use_nsecs;
+};
+
+struct tk_read_base {
+	struct clocksource *clock;
+	long: 32;
+	u64 mask;
+	u64 cycle_last;
+	u32 mult;
+	u32 shift;
+	u64 xtime_nsec;
+	ktime_t base;
+	u64 base_real;
+};
+
+struct timekeeper {
+	struct tk_read_base tkr_mono;
+	struct tk_read_base tkr_raw;
+	u64 xtime_sec;
+	long unsigned int ktime_sec;
+	long: 32;
+	struct timespec64 wall_to_monotonic;
+	ktime_t offs_real;
+	ktime_t offs_boot;
+	ktime_t offs_tai;
+	s32 tai_offset;
+	unsigned int clock_was_set_seq;
+	u8 cs_was_changed_seq;
+	long: 32;
+	ktime_t next_leap_ktime;
+	u64 raw_sec;
+	struct timespec64 monotonic_to_boot;
+	u64 cycle_interval;
+	u64 xtime_interval;
+	s64 xtime_remainder;
+	u64 raw_interval;
+	u64 ntp_tick;
+	s64 ntp_error;
+	u32 ntp_error_shift;
+	u32 ntp_err_mult;
+	u32 skip_second_overflow;
+	long: 32;
+};
+
+enum timekeeping_adv_mode {
+	TK_ADV_TICK = 0,
+	TK_ADV_FREQ = 1,
+};
+
+struct tk_fast {
+	seqcount_latch_t seq;
+	long: 32;
+	struct tk_read_base base[2];
+};
+
+struct tick_sched {
+	long unsigned int flags;
+	unsigned int stalled_jiffies;
+	long unsigned int last_tick_jiffies;
+	long: 32;
+	struct hrtimer sched_timer;
+	ktime_t last_tick;
+	ktime_t next_tick;
+	long unsigned int idle_jiffies;
+	long: 32;
+	ktime_t idle_waketime;
+	unsigned int got_idle_tick;
+	seqcount_t idle_sleeptime_seq;
+	ktime_t idle_entrytime;
+	long unsigned int last_jiffies;
+	long: 32;
+	u64 timer_expires_base;
+	u64 timer_expires;
+	u64 next_timer;
+	ktime_t idle_expires;
+	long unsigned int idle_calls;
+	long unsigned int idle_sleeps;
+	ktime_t idle_exittime;
+	ktime_t idle_sleeptime;
+	ktime_t iowait_sleeptime;
+	atomic_t tick_dep_mask;
+	long unsigned int check_clocks;
+};
+
+struct timer_list_iter {
+	int cpu;
+	bool second_pass;
+	u64 now;
+};
+
+struct posix_clock;
+
+struct posix_clock_context;
+
+struct posix_clock_operations {
+	struct module *owner;
+	int (*clock_adjtime)(struct posix_clock *, struct __kernel_timex *);
+	int (*clock_gettime)(struct posix_clock *, struct timespec64 *);
+	int (*clock_getres)(struct posix_clock *, struct timespec64 *);
+	int (*clock_settime)(struct posix_clock *, const struct timespec64 *);
+	long int (*ioctl)(struct posix_clock_context *, unsigned int, long unsigned int);
+	int (*open)(struct posix_clock_context *, fmode_t);
+	__poll_t (*poll)(struct posix_clock_context *, struct file *, poll_table *);
+	int (*release)(struct posix_clock_context *);
+	ssize_t (*read)(struct posix_clock_context *, uint, char *, size_t);
+};
+
+struct posix_clock {
+	struct posix_clock_operations ops;
+	struct cdev cdev;
+	struct device *dev;
+	struct rw_semaphore rwsem;
+	bool zombie;
+};
+
+struct posix_clock_context {
+	struct posix_clock *clk;
+	void *private_clkdata;
+};
+
+struct posix_clock_desc {
+	struct file *fp;
+	struct posix_clock *clk;
+};
+
+enum tick_broadcast_mode {
+	TICK_BROADCAST_OFF = 0,
+	TICK_BROADCAST_ON = 1,
+	TICK_BROADCAST_FORCE = 2,
+};
+
+enum tick_broadcast_state {
+	TICK_BROADCAST_EXIT = 0,
+	TICK_BROADCAST_ENTER = 1,
+};
+
+struct clock_read_data {
+	u64 epoch_ns;
+	u64 epoch_cyc;
+	u64 sched_clock_mask;
+	u64 (*read_sched_clock)();
+	u32 mult;
+	u32 shift;
+	long: 32;
+};
+
+struct clock_data {
+	seqcount_latch_t seq;
+	long: 32;
+	struct clock_read_data read_data[2];
+	ktime_t wrap_kt;
+	long unsigned int rate;
+	u64 (*actual_read_sched_clock)();
+};
+
+struct futex_waitv {
+	__u64 val;
+	__u64 uaddr;
+	__u32 flags;
+	__u32 __reserved;
+};
+
+struct futex_vector {
+	struct futex_waitv w;
+	struct futex_q q;
+};
+
+enum kernfs_root_flag {
+	KERNFS_ROOT_CREATE_DEACTIVATED = 1,
+	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2,
+	KERNFS_ROOT_SUPPORT_EXPORTOP = 4,
+	KERNFS_ROOT_SUPPORT_USER_XATTR = 8,
+};
+
+struct kernfs_syscall_ops {
+	int (*show_options)(struct seq_file *, struct kernfs_root *);
+	int (*mkdir)(struct kernfs_node *, const char *, umode_t);
+	int (*rmdir)(struct kernfs_node *);
+	int (*rename)(struct kernfs_node *, struct kernfs_node *, const char *);
+	int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *);
+};
+
+struct kernfs_fs_context {
+	struct kernfs_root *root;
+	void *ns_tag;
+	long unsigned int magic;
+	bool new_sb_created;
+};
+
+enum {
+	CGRP_NOTIFY_ON_RELEASE = 0,
+	CGRP_CPUSET_CLONE_CHILDREN = 1,
+	CGRP_FREEZE = 2,
+	CGRP_FROZEN = 3,
+	CGRP_KILL = 4,
+};
+
+struct cgroup_of_peak {
+	long unsigned int value;
+	struct list_head list;
+};
+
+struct cgroup_fs_context {
+	struct kernfs_fs_context kfc;
+	struct cgroup_root *root;
+	struct cgroup_namespace *ns;
+	unsigned int flags;
+	bool cpuset_clone_children;
+	bool none;
+	bool all_ss;
+	u16 subsys_mask;
+	char *name;
+	char *release_agent;
+};
+
+struct cgroup_pidlist;
+
+struct cgroup_file_ctx {
+	struct cgroup_namespace *ns;
+	struct {
+		void *trigger;
+	} psi;
+	struct {
+		bool started;
+		struct css_task_iter iter;
+	} procs;
+	struct {
+		struct cgroup_pidlist *pidlist;
+	} procs1;
+	struct cgroup_of_peak peak;
+};
+
+struct cgrp_cset_link {
+	struct cgroup *cgrp;
+	struct css_set *cset;
+	struct list_head cset_link;
+	struct list_head cgrp_link;
+};
+
+struct cgroup_mgctx {
+	struct list_head preloaded_src_csets;
+	struct list_head preloaded_dst_csets;
+	struct cgroup_taskset tset;
+	u16 ss_mask;
+};
+
+enum {
+	PROC_ROOT_INO = 1,
+	PROC_IPC_INIT_INO = 4026531839,
+	PROC_UTS_INIT_INO = 4026531838,
+	PROC_USER_INIT_INO = 4026531837,
+	PROC_PID_INIT_INO = 4026531836,
+	PROC_CGROUP_INIT_INO = 4026531835,
+	PROC_TIME_INIT_INO = 4026531834,
+};
+
+struct trace_event_raw_cgroup_root {
+	struct trace_entry ent;
+	int root;
+	u16 ss_mask;
+	u32 __data_loc_name;
+	char __data[0];
+};
+
+struct trace_event_raw_cgroup {
+	struct trace_entry ent;
+	int root;
+	int level;
+	u64 id;
+	u32 __data_loc_path;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_cgroup_migrate {
+	struct trace_entry ent;
+	int dst_root;
+	int dst_level;
+	u64 dst_id;
+	int pid;
+	u32 __data_loc_dst_path;
+	u32 __data_loc_comm;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_cgroup_event {
+	struct trace_entry ent;
+	int root;
+	int level;
+	u64 id;
+	u32 __data_loc_path;
+	int val;
+	char __data[0];
+};
+
+struct trace_event_raw_cgroup_rstat {
+	struct trace_entry ent;
+	int root;
+	int level;
+	u64 id;
+	int cpu;
+	bool contended;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_cgroup_root {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_cgroup {
+	u32 path;
+	const void *path_ptr_;
+};
+
+struct trace_event_data_offsets_cgroup_migrate {
+	u32 dst_path;
+	const void *dst_path_ptr_;
+	u32 comm;
+	const void *comm_ptr_;
+};
+
+struct trace_event_data_offsets_cgroup_event {
+	u32 path;
+	const void *path_ptr_;
+};
+
+struct trace_event_data_offsets_cgroup_rstat {};
+
+typedef void (*btf_trace_cgroup_setup_root)(void *, struct cgroup_root *);
+
+typedef void (*btf_trace_cgroup_destroy_root)(void *, struct cgroup_root *);
+
+typedef void (*btf_trace_cgroup_remount)(void *, struct cgroup_root *);
+
+typedef void (*btf_trace_cgroup_mkdir)(void *, struct cgroup *, const char *);
+
+typedef void (*btf_trace_cgroup_rmdir)(void *, struct cgroup *, const char *);
+
+typedef void (*btf_trace_cgroup_release)(void *, struct cgroup *, const char *);
+
+typedef void (*btf_trace_cgroup_rename)(void *, struct cgroup *, const char *);
+
+typedef void (*btf_trace_cgroup_freeze)(void *, struct cgroup *, const char *);
+
+typedef void (*btf_trace_cgroup_unfreeze)(void *, struct cgroup *, const char *);
+
+typedef void (*btf_trace_cgroup_attach_task)(void *, struct cgroup *, const char *, struct task_struct *, bool);
+
+typedef void (*btf_trace_cgroup_transfer_tasks)(void *, struct cgroup *, const char *, struct task_struct *, bool);
+
+typedef void (*btf_trace_cgroup_notify_populated)(void *, struct cgroup *, const char *, int);
+
+typedef void (*btf_trace_cgroup_notify_frozen)(void *, struct cgroup *, const char *, int);
+
+typedef void (*btf_trace_cgroup_rstat_lock_contended)(void *, struct cgroup *, int, bool);
+
+typedef void (*btf_trace_cgroup_rstat_locked)(void *, struct cgroup *, int, bool);
+
+typedef void (*btf_trace_cgroup_rstat_unlock)(void *, struct cgroup *, int, bool);
+
+typedef void (*btf_trace_cgroup_rstat_cpu_lock_contended)(void *, struct cgroup *, int, bool);
+
+typedef void (*btf_trace_cgroup_rstat_cpu_lock_contended_fastpath)(void *, struct cgroup *, int, bool);
+
+typedef void (*btf_trace_cgroup_rstat_cpu_locked)(void *, struct cgroup *, int, bool);
+
+typedef void (*btf_trace_cgroup_rstat_cpu_locked_fastpath)(void *, struct cgroup *, int, bool);
+
+typedef void (*btf_trace_cgroup_rstat_cpu_unlock)(void *, struct cgroup *, int, bool);
+
+typedef void (*btf_trace_cgroup_rstat_cpu_unlock_fastpath)(void *, struct cgroup *, int, bool);
+
+enum cgroup_opt_features {
+	OPT_FEATURE_COUNT = 0,
+};
+
+enum cgroup2_param {
+	Opt_nsdelegate = 0,
+	Opt_favordynmods = 1,
+	Opt_memory_localevents = 2,
+	Opt_memory_recursiveprot = 3,
+	Opt_memory_hugetlb_accounting = 4,
+	Opt_pids_localevents = 5,
+	nr__cgroup2_params = 6,
+};
+
+struct idmap_key {
+	bool map_up;
+	u32 id;
+	u32 count;
+};
+
+struct rchan;
+
+struct rchan_buf {
+	void *start;
+	void *data;
+	size_t offset;
+	size_t subbufs_produced;
+	size_t subbufs_consumed;
+	struct rchan *chan;
+	wait_queue_head_t read_wait;
+	struct irq_work wakeup_work;
+	struct dentry *dentry;
+	struct kref kref;
+	struct page **page_array;
+	unsigned int page_count;
+	unsigned int finalized;
+	size_t *padding;
+	size_t prev_padding;
+	size_t bytes_consumed;
+	size_t early_bytes;
+	unsigned int cpu;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct rchan_callbacks;
+
+struct rchan {
+	u32 version;
+	size_t subbuf_size;
+	size_t n_subbufs;
+	size_t alloc_size;
+	const struct rchan_callbacks *cb;
+	struct kref kref;
+	void *private_data;
+	size_t last_toobig;
+	struct rchan_buf **buf;
+	int is_global;
+	struct list_head list;
+	struct dentry *parent;
+	int has_base_filename;
+	char base_filename[255];
+};
+
+struct rchan_callbacks {
+	int (*subbuf_start)(struct rchan_buf *, void *, void *, size_t);
+	struct dentry * (*create_buf_file)(const char *, struct dentry *, umode_t, struct rchan_buf *, int *);
+	int (*remove_buf_file)(struct dentry *);
+};
+
+struct rchan_percpu_buf_dispatcher {
+	struct rchan_buf *buf;
+	struct dentry *dentry;
+};
+
+typedef bool (*smp_cond_func_t)(int, void *);
+
+enum die_val {
+	DIE_UNUSED = 0,
+	DIE_OOPS = 1,
+};
+
+struct trace_export {
+	struct trace_export *next;
+	void (*write)(struct trace_export *, const void *, unsigned int);
+	int flags;
+};
+
+enum trace_iter_flags {
+	TRACE_FILE_LAT_FMT = 1,
+	TRACE_FILE_ANNOTATE = 2,
+	TRACE_FILE_TIME_IN_NS = 4,
+};
+
+enum trace_flag_type {
+	TRACE_FLAG_IRQS_OFF = 1,
+	TRACE_FLAG_IRQS_NOSUPPORT = 2,
+	TRACE_FLAG_NEED_RESCHED = 4,
+	TRACE_FLAG_HARDIRQ = 8,
+	TRACE_FLAG_SOFTIRQ = 16,
+	TRACE_FLAG_PREEMPT_RESCHED = 32,
+	TRACE_FLAG_NMI = 64,
+	TRACE_FLAG_BH_OFF = 128,
+};
+
+enum event_trigger_type {
+	ETT_NONE = 0,
+	ETT_TRACE_ONOFF = 1,
+	ETT_SNAPSHOT = 2,
+	ETT_STACKTRACE = 4,
+	ETT_EVENT_ENABLE = 8,
+	ETT_EVENT_HIST = 16,
+	ETT_HIST_ENABLE = 32,
+	ETT_EVENT_EPROBE = 64,
+};
+
+struct ftrace_entry {
+	struct trace_entry ent;
+	long unsigned int ip;
+	long unsigned int parent_ip;
+};
+
+struct stack_entry {
+	struct trace_entry ent;
+	int size;
+	long unsigned int caller[0];
+};
+
+struct bprint_entry {
+	struct trace_entry ent;
+	long unsigned int ip;
+	const char *fmt;
+	u32 buf[0];
+};
+
+struct print_entry {
+	struct trace_entry ent;
+	long unsigned int ip;
+	char buf[0];
+};
+
+struct raw_data_entry {
+	struct trace_entry ent;
+	unsigned int id;
+	char buf[0];
+};
+
+struct bputs_entry {
+	struct trace_entry ent;
+	long unsigned int ip;
+	const char *str;
+};
+
+struct func_repeats_entry {
+	struct trace_entry ent;
+	long unsigned int ip;
+	long unsigned int parent_ip;
+	u16 count;
+	u16 top_delta_ts;
+	u32 bottom_delta_ts;
+};
+
+typedef bool (*cond_update_fn_t)(struct trace_array *, void *);
+
+enum {
+	TRACE_ARRAY_FL_GLOBAL = 1,
+	TRACE_ARRAY_FL_BOOT = 2,
+};
+
+struct trace_parser {
+	bool cont;
+	char *buffer;
+	unsigned int idx;
+	unsigned int size;
+};
+
+enum trace_iterator_flags {
+	TRACE_ITER_PRINT_PARENT = 1,
+	TRACE_ITER_SYM_OFFSET = 2,
+	TRACE_ITER_SYM_ADDR = 4,
+	TRACE_ITER_VERBOSE = 8,
+	TRACE_ITER_RAW = 16,
+	TRACE_ITER_HEX = 32,
+	TRACE_ITER_BIN = 64,
+	TRACE_ITER_BLOCK = 128,
+	TRACE_ITER_FIELDS = 256,
+	TRACE_ITER_PRINTK = 512,
+	TRACE_ITER_ANNOTATE = 1024,
+	TRACE_ITER_USERSTACKTRACE = 2048,
+	TRACE_ITER_SYM_USEROBJ = 4096,
+	TRACE_ITER_PRINTK_MSGONLY = 8192,
+	TRACE_ITER_CONTEXT_INFO = 16384,
+	TRACE_ITER_LATENCY_FMT = 32768,
+	TRACE_ITER_RECORD_CMD = 65536,
+	TRACE_ITER_RECORD_TGID = 131072,
+	TRACE_ITER_OVERWRITE = 262144,
+	TRACE_ITER_STOP_ON_FREE = 524288,
+	TRACE_ITER_IRQ_INFO = 1048576,
+	TRACE_ITER_MARKERS = 2097152,
+	TRACE_ITER_EVENT_FORK = 4194304,
+	TRACE_ITER_TRACE_PRINTK = 8388608,
+	TRACE_ITER_PAUSE_ON_TRACE = 16777216,
+	TRACE_ITER_HASH_PTR = 33554432,
+	TRACE_ITER_STACKTRACE = 67108864,
+};
+
+struct trace_min_max_param {
+	struct mutex *lock;
+	u64 *val;
+	u64 *min;
+	u64 *max;
+};
+
+struct pipe_wait {
+	struct trace_iterator *iter;
+	int wait_index;
+};
+
+struct ftrace_stack {
+	long unsigned int calls[1024];
+};
+
+struct ftrace_stacks {
+	struct ftrace_stack stacks[4];
+};
+
+struct trace_buffer_struct {
+	int nesting;
+	char buffer[4096];
+};
+
+struct ftrace_buffer_info {
+	struct trace_iterator iter;
+	void *spare;
+	unsigned int spare_cpu;
+	unsigned int spare_size;
+	unsigned int read;
+};
+
+struct err_info {
+	const char **errs;
+	u8 type;
+	u16 pos;
+	u64 ts;
+};
+
+struct tracing_log_err {
+	struct list_head list;
+	struct err_info info;
+	char loc[128];
+	char *cmd;
+	long: 32;
+};
+
+struct buffer_ref {
+	struct trace_buffer *buffer;
+	void *page;
+	int cpu;
+	refcount_t refcount;
+};
+
+enum {
+	TRACE_NOP_OPT_ACCEPT = 1,
+	TRACE_NOP_OPT_REFUSE = 2,
+};
+
+struct ftrace_event_field {
+	struct list_head link;
+	const char *name;
+	const char *type;
+	int filter_type;
+	int offset;
+	int size;
+	int is_signed;
+	int len;
+};
+
+struct filter_pred;
+
+struct prog_entry {
+	int target;
+	int when_to_branch;
+	struct filter_pred *pred;
+};
+
+struct regex;
+
+typedef int (*regex_match_func)(char *, struct regex *, int);
+
+struct regex {
+	char pattern[256];
+	int len;
+	int field_len;
+	regex_match_func match;
+};
+
+enum regex_type {
+	MATCH_FULL = 0,
+	MATCH_FRONT_ONLY = 1,
+	MATCH_MIDDLE_ONLY = 2,
+	MATCH_END_ONLY = 3,
+	MATCH_GLOB = 4,
+	MATCH_INDEX = 5,
+};
+
+enum filter_op_ids {
+	OP_GLOB = 0,
+	OP_NE = 1,
+	OP_EQ = 2,
+	OP_LE = 3,
+	OP_LT = 4,
+	OP_GE = 5,
+	OP_GT = 6,
+	OP_BAND = 7,
+	OP_MAX = 8,
+};
+
+enum filter_pred_fn {
+	FILTER_PRED_FN_NOP = 0,
+	FILTER_PRED_FN_64 = 1,
+	FILTER_PRED_FN_64_CPUMASK = 2,
+	FILTER_PRED_FN_S64 = 3,
+	FILTER_PRED_FN_U64 = 4,
+	FILTER_PRED_FN_32 = 5,
+	FILTER_PRED_FN_32_CPUMASK = 6,
+	FILTER_PRED_FN_S32 = 7,
+	FILTER_PRED_FN_U32 = 8,
+	FILTER_PRED_FN_16 = 9,
+	FILTER_PRED_FN_16_CPUMASK = 10,
+	FILTER_PRED_FN_S16 = 11,
+	FILTER_PRED_FN_U16 = 12,
+	FILTER_PRED_FN_8 = 13,
+	FILTER_PRED_FN_8_CPUMASK = 14,
+	FILTER_PRED_FN_S8 = 15,
+	FILTER_PRED_FN_U8 = 16,
+	FILTER_PRED_FN_COMM = 17,
+	FILTER_PRED_FN_STRING = 18,
+	FILTER_PRED_FN_STRLOC = 19,
+	FILTER_PRED_FN_STRRELLOC = 20,
+	FILTER_PRED_FN_PCHAR_USER = 21,
+	FILTER_PRED_FN_PCHAR = 22,
+	FILTER_PRED_FN_CPU = 23,
+	FILTER_PRED_FN_CPU_CPUMASK = 24,
+	FILTER_PRED_FN_CPUMASK = 25,
+	FILTER_PRED_FN_CPUMASK_CPU = 26,
+	FILTER_PRED_FN_FUNCTION = 27,
+	FILTER_PRED_FN_ = 28,
+	FILTER_PRED_TEST_VISITED = 29,
+};
+
+struct filter_pred {
+	struct regex *regex;
+	struct cpumask *mask;
+	short unsigned int *ops;
+	struct ftrace_event_field *field;
+	u64 val;
+	u64 val2;
+	enum filter_pred_fn fn_num;
+	int offset;
+	int not;
+	int op;
+};
+
+enum {
+	FILT_ERR_NONE = 0,
+	FILT_ERR_INVALID_OP = 1,
+	FILT_ERR_TOO_MANY_OPEN = 2,
+	FILT_ERR_TOO_MANY_CLOSE = 3,
+	FILT_ERR_MISSING_QUOTE = 4,
+	FILT_ERR_MISSING_BRACE_OPEN = 5,
+	FILT_ERR_MISSING_BRACE_CLOSE = 6,
+	FILT_ERR_OPERAND_TOO_LONG = 7,
+	FILT_ERR_EXPECT_STRING = 8,
+	FILT_ERR_EXPECT_DIGIT = 9,
+	FILT_ERR_ILLEGAL_FIELD_OP = 10,
+	FILT_ERR_FIELD_NOT_FOUND = 11,
+	FILT_ERR_ILLEGAL_INTVAL = 12,
+	FILT_ERR_BAD_SUBSYS_FILTER = 13,
+	FILT_ERR_TOO_MANY_PREDS = 14,
+	FILT_ERR_INVALID_FILTER = 15,
+	FILT_ERR_INVALID_CPULIST = 16,
+	FILT_ERR_IP_FIELD_ONLY = 17,
+	FILT_ERR_INVALID_VALUE = 18,
+	FILT_ERR_NO_FUNCTION = 19,
+	FILT_ERR_ERRNO = 20,
+	FILT_ERR_NO_FILTER = 21,
+};
+
+struct filter_parse_error {
+	int lasterr;
+	int lasterr_pos;
+};
+
+typedef int (*parse_pred_fn)(const char *, void *, int, struct filter_parse_error *, struct filter_pred **);
+
+enum {
+	INVERT = 1,
+	PROCESS_AND = 2,
+	PROCESS_OR = 4,
+};
+
+struct ustring_buffer {
+	char buffer[1024];
+};
+
+enum {
+	TOO_MANY_CLOSE = -1,
+	TOO_MANY_OPEN = -2,
+	MISSING_QUOTE = -3,
+};
+
+struct filter_list {
+	struct list_head list;
+	struct event_filter *filter;
+};
+
+struct btf_param {
+	__u32 name_off;
+	__u32 type;
+};
+
+struct eprobe_trace_entry_head {
+	struct trace_entry ent;
+};
+
+enum {
+	EVENT_TRIGGER_FL_PROBE = 1,
+};
+
+struct event_trigger_ops;
+
+struct event_command;
+
+struct event_trigger_data {
+	long unsigned int count;
+	int ref;
+	int flags;
+	struct event_trigger_ops *ops;
+	struct event_command *cmd_ops;
+	struct event_filter *filter;
+	char *filter_str;
+	void *private_data;
+	bool paused;
+	bool paused_tmp;
+	struct list_head list;
+	char *name;
+	struct list_head named_list;
+	struct event_trigger_data *named_data;
+};
+
+struct event_trigger_ops {
+	void (*trigger)(struct event_trigger_data *, struct trace_buffer *, void *, struct ring_buffer_event *);
+	int (*init)(struct event_trigger_data *);
+	void (*free)(struct event_trigger_data *);
+	int (*print)(struct seq_file *, struct event_trigger_data *);
+};
+
+struct event_command {
+	struct list_head list;
+	char *name;
+	enum event_trigger_type trigger_type;
+	int flags;
+	int (*parse)(struct event_command *, struct trace_event_file *, char *, char *, char *);
+	int (*reg)(char *, struct event_trigger_data *, struct trace_event_file *);
+	void (*unreg)(char *, struct event_trigger_data *, struct trace_event_file *);
+	void (*unreg_all)(struct trace_event_file *);
+	int (*set_filter)(char *, struct event_trigger_data *, struct trace_event_file *);
+	struct event_trigger_ops * (*get_trigger_ops)(char *, char *);
+};
+
+enum event_command_flags {
+	EVENT_CMD_FL_POST_TRIGGER = 1,
+	EVENT_CMD_FL_NEEDS_REC = 2,
+};
+
+struct dyn_event;
+
+struct dyn_event_operations {
+	struct list_head list;
+	int (*create)(const char *);
+	int (*show)(struct seq_file *, struct dyn_event *);
+	bool (*is_busy)(struct dyn_event *);
+	int (*free)(struct dyn_event *);
+	bool (*match)(const char *, const char *, int, const char **, struct dyn_event *);
+};
+
+struct dyn_event {
+	struct list_head list;
+	struct dyn_event_operations *ops;
+};
+
+typedef int (*print_type_func_t)(struct trace_seq *, void *, void *);
+
+enum fetch_op {
+	FETCH_OP_NOP = 0,
+	FETCH_OP_REG = 1,
+	FETCH_OP_STACK = 2,
+	FETCH_OP_STACKP = 3,
+	FETCH_OP_RETVAL = 4,
+	FETCH_OP_IMM = 5,
+	FETCH_OP_COMM = 6,
+	FETCH_OP_ARG = 7,
+	FETCH_OP_FOFFS = 8,
+	FETCH_OP_DATA = 9,
+	FETCH_OP_EDATA = 10,
+	FETCH_OP_DEREF = 11,
+	FETCH_OP_UDEREF = 12,
+	FETCH_OP_ST_RAW = 13,
+	FETCH_OP_ST_MEM = 14,
+	FETCH_OP_ST_UMEM = 15,
+	FETCH_OP_ST_STRING = 16,
+	FETCH_OP_ST_USTRING = 17,
+	FETCH_OP_ST_SYMSTR = 18,
+	FETCH_OP_ST_EDATA = 19,
+	FETCH_OP_MOD_BF = 20,
+	FETCH_OP_LP_ARRAY = 21,
+	FETCH_OP_TP_ARG = 22,
+	FETCH_OP_END = 23,
+	FETCH_NOP_SYMBOL = 24,
+};
+
+struct fetch_insn {
+	enum fetch_op op;
+	union {
+		unsigned int param;
+		struct {
+			unsigned int size;
+			int offset;
+		};
+		struct {
+			unsigned char basesize;
+			unsigned char lshift;
+			unsigned char rshift;
+		};
+		long unsigned int immediate;
+		void *data;
+	};
+};
+
+struct fetch_type {
+	const char *name;
+	size_t size;
+	bool is_signed;
+	bool is_string;
+	print_type_func_t print;
+	const char *fmt;
+	const char *fmttype;
+};
+
+struct probe_arg {
+	struct fetch_insn *code;
+	bool dynamic;
+	unsigned int offset;
+	unsigned int count;
+	const char *name;
+	const char *comm;
+	char *fmt;
+	const struct fetch_type *type;
+};
+
+struct probe_entry_arg {
+	struct fetch_insn *code;
+	unsigned int size;
+};
+
+struct trace_uprobe_filter {
+	rwlock_t rwlock;
+	int nr_systemwide;
+	struct list_head perf_events;
+};
+
+struct trace_probe_event {
+	unsigned int flags;
+	struct trace_event_class class;
+	struct trace_event_call call;
+	struct list_head files;
+	struct list_head probes;
+	struct trace_uprobe_filter filter[0];
+};
+
+struct trace_probe {
+	struct list_head list;
+	struct trace_probe_event *event;
+	ssize_t size;
+	unsigned int nr_args;
+	struct probe_entry_arg *entry_arg;
+	struct probe_arg args[0];
+};
+
+struct event_file_link {
+	struct trace_event_file *file;
+	struct list_head list;
+};
+
+struct traceprobe_parse_context {
+	struct trace_event_call *event;
+	const char *funcname;
+	const struct btf_type *proto;
+	const struct btf_param *params;
+	s32 nr_params;
+	struct btf *btf;
+	const struct btf_type *last_type;
+	u32 last_bitoffs;
+	u32 last_bitsize;
+	struct trace_probe *tp;
+	unsigned int flags;
+	int offset;
+};
+
+enum probe_print_type {
+	PROBE_PRINT_NORMAL = 0,
+	PROBE_PRINT_RETURN = 1,
+	PROBE_PRINT_EVENT = 2,
+};
+
+enum {
+	TP_ERR_FILE_NOT_FOUND = 0,
+	TP_ERR_NO_REGULAR_FILE = 1,
+	TP_ERR_BAD_REFCNT = 2,
+	TP_ERR_REFCNT_OPEN_BRACE = 3,
+	TP_ERR_BAD_REFCNT_SUFFIX = 4,
+	TP_ERR_BAD_UPROBE_OFFS = 5,
+	TP_ERR_BAD_MAXACT_TYPE = 6,
+	TP_ERR_BAD_MAXACT = 7,
+	TP_ERR_MAXACT_TOO_BIG = 8,
+	TP_ERR_BAD_PROBE_ADDR = 9,
+	TP_ERR_NON_UNIQ_SYMBOL = 10,
+	TP_ERR_BAD_RETPROBE = 11,
+	TP_ERR_NO_TRACEPOINT = 12,
+	TP_ERR_BAD_ADDR_SUFFIX = 13,
+	TP_ERR_NO_GROUP_NAME = 14,
+	TP_ERR_GROUP_TOO_LONG = 15,
+	TP_ERR_BAD_GROUP_NAME = 16,
+	TP_ERR_NO_EVENT_NAME = 17,
+	TP_ERR_EVENT_TOO_LONG = 18,
+	TP_ERR_BAD_EVENT_NAME = 19,
+	TP_ERR_EVENT_EXIST = 20,
+	TP_ERR_RETVAL_ON_PROBE = 21,
+	TP_ERR_NO_RETVAL = 22,
+	TP_ERR_BAD_STACK_NUM = 23,
+	TP_ERR_BAD_ARG_NUM = 24,
+	TP_ERR_BAD_VAR = 25,
+	TP_ERR_BAD_REG_NAME = 26,
+	TP_ERR_BAD_MEM_ADDR = 27,
+	TP_ERR_BAD_IMM = 28,
+	TP_ERR_IMMSTR_NO_CLOSE = 29,
+	TP_ERR_FILE_ON_KPROBE = 30,
+	TP_ERR_BAD_FILE_OFFS = 31,
+	TP_ERR_SYM_ON_UPROBE = 32,
+	TP_ERR_TOO_MANY_OPS = 33,
+	TP_ERR_DEREF_NEED_BRACE = 34,
+	TP_ERR_BAD_DEREF_OFFS = 35,
+	TP_ERR_DEREF_OPEN_BRACE = 36,
+	TP_ERR_COMM_CANT_DEREF = 37,
+	TP_ERR_BAD_FETCH_ARG = 38,
+	TP_ERR_ARRAY_NO_CLOSE = 39,
+	TP_ERR_BAD_ARRAY_SUFFIX = 40,
+	TP_ERR_BAD_ARRAY_NUM = 41,
+	TP_ERR_ARRAY_TOO_BIG = 42,
+	TP_ERR_BAD_TYPE = 43,
+	TP_ERR_BAD_STRING = 44,
+	TP_ERR_BAD_SYMSTRING = 45,
+	TP_ERR_BAD_BITFIELD = 46,
+	TP_ERR_ARG_NAME_TOO_LONG = 47,
+	TP_ERR_NO_ARG_NAME = 48,
+	TP_ERR_BAD_ARG_NAME = 49,
+	TP_ERR_USED_ARG_NAME = 50,
+	TP_ERR_ARG_TOO_LONG = 51,
+	TP_ERR_NO_ARG_BODY = 52,
+	TP_ERR_BAD_INSN_BNDRY = 53,
+	TP_ERR_FAIL_REG_PROBE = 54,
+	TP_ERR_DIFF_PROBE_TYPE = 55,
+	TP_ERR_DIFF_ARG_TYPE = 56,
+	TP_ERR_SAME_PROBE = 57,
+	TP_ERR_NO_EVENT_INFO = 58,
+	TP_ERR_BAD_ATTACH_EVENT = 59,
+	TP_ERR_BAD_ATTACH_ARG = 60,
+	TP_ERR_NO_EP_FILTER = 61,
+	TP_ERR_NOSUP_BTFARG = 62,
+	TP_ERR_NO_BTFARG = 63,
+	TP_ERR_NO_BTF_ENTRY = 64,
+	TP_ERR_BAD_VAR_ARGS = 65,
+	TP_ERR_NOFENTRY_ARGS = 66,
+	TP_ERR_DOUBLE_ARGS = 67,
+	TP_ERR_ARGS_2LONG = 68,
+	TP_ERR_ARGIDX_2BIG = 69,
+	TP_ERR_NO_PTR_STRCT = 70,
+	TP_ERR_NOSUP_DAT_ARG = 71,
+	TP_ERR_BAD_HYPHEN = 72,
+	TP_ERR_NO_BTF_FIELD = 73,
+	TP_ERR_BAD_BTF_TID = 74,
+	TP_ERR_BAD_TYPE4STR = 75,
+	TP_ERR_NEED_STRING_TYPE = 76,
+};
+
+struct trace_eprobe {
+	const char *event_system;
+	const char *event_name;
+	char *filter_str;
+	struct trace_event_call *event;
+	struct dyn_event devent;
+	struct trace_probe tp;
+};
+
+struct eprobe_data {
+	struct trace_event_file *file;
+	struct trace_eprobe *ep;
+};
+
+enum error_detector {
+	ERROR_DETECTOR_KFENCE = 0,
+	ERROR_DETECTOR_KASAN = 1,
+	ERROR_DETECTOR_WARN = 2,
+};
+
+struct trace_event_raw_error_report_template {
+	struct trace_entry ent;
+	enum error_detector error_detector;
+	long unsigned int id;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_error_report_template {};
+
+typedef void (*btf_trace_error_report_end)(void *, enum error_detector, long unsigned int);
+
+enum dynevent_type {
+	DYNEVENT_TYPE_SYNTH = 1,
+	DYNEVENT_TYPE_KPROBE = 2,
+	DYNEVENT_TYPE_NONE = 3,
+};
+
+struct dynevent_cmd;
+
+typedef int (*dynevent_create_fn_t)(struct dynevent_cmd *);
+
+struct dynevent_cmd {
+	struct seq_buf seq;
+	const char *event_name;
+	unsigned int n_fields;
+	enum dynevent_type type;
+	dynevent_create_fn_t run_command;
+	void *private_data;
+};
+
+typedef int (*dynevent_check_arg_fn_t)(void *);
+
+struct dynevent_arg {
+	const char *str;
+	char separator;
+};
+
+struct dynevent_arg_pair {
+	const char *lhs;
+	const char *rhs;
+	char operator;
+	char separator;
+};
+
+struct trace_probe_log {
+	const char *subsystem;
+	const char **argv;
+	int argc;
+	int index;
+};
+
+enum bpf_cmd {
+	BPF_MAP_CREATE = 0,
+	BPF_MAP_LOOKUP_ELEM = 1,
+	BPF_MAP_UPDATE_ELEM = 2,
+	BPF_MAP_DELETE_ELEM = 3,
+	BPF_MAP_GET_NEXT_KEY = 4,
+	BPF_PROG_LOAD = 5,
+	BPF_OBJ_PIN = 6,
+	BPF_OBJ_GET = 7,
+	BPF_PROG_ATTACH = 8,
+	BPF_PROG_DETACH = 9,
+	BPF_PROG_TEST_RUN = 10,
+	BPF_PROG_RUN = 10,
+	BPF_PROG_GET_NEXT_ID = 11,
+	BPF_MAP_GET_NEXT_ID = 12,
+	BPF_PROG_GET_FD_BY_ID = 13,
+	BPF_MAP_GET_FD_BY_ID = 14,
+	BPF_OBJ_GET_INFO_BY_FD = 15,
+	BPF_PROG_QUERY = 16,
+	BPF_RAW_TRACEPOINT_OPEN = 17,
+	BPF_BTF_LOAD = 18,
+	BPF_BTF_GET_FD_BY_ID = 19,
+	BPF_TASK_FD_QUERY = 20,
+	BPF_MAP_LOOKUP_AND_DELETE_ELEM = 21,
+	BPF_MAP_FREEZE = 22,
+	BPF_BTF_GET_NEXT_ID = 23,
+	BPF_MAP_LOOKUP_BATCH = 24,
+	BPF_MAP_LOOKUP_AND_DELETE_BATCH = 25,
+	BPF_MAP_UPDATE_BATCH = 26,
+	BPF_MAP_DELETE_BATCH = 27,
+	BPF_LINK_CREATE = 28,
+	BPF_LINK_UPDATE = 29,
+	BPF_LINK_GET_FD_BY_ID = 30,
+	BPF_LINK_GET_NEXT_ID = 31,
+	BPF_ENABLE_STATS = 32,
+	BPF_ITER_CREATE = 33,
+	BPF_LINK_DETACH = 34,
+	BPF_PROG_BIND_MAP = 35,
+	BPF_TOKEN_CREATE = 36,
+	__MAX_BPF_CMD = 37,
+};
+
+struct btf_enum {
+	__u32 name_off;
+	__s32 val;
+};
+
+struct bpf_mount_opts {
+	kuid_t uid;
+	kgid_t gid;
+	umode_t mode;
+	long: 32;
+	u64 delegate_cmds;
+	u64 delegate_maps;
+	u64 delegate_progs;
+	u64 delegate_attachs;
+};
+
+struct bpf_preload_info {
+	char link_name[16];
+	struct bpf_link *link;
+};
+
+struct bpf_preload_ops {
+	int (*preload)(struct bpf_preload_info *);
+	struct module *owner;
+};
+
+enum bpf_type {
+	BPF_TYPE_UNSPEC = 0,
+	BPF_TYPE_PROG = 1,
+	BPF_TYPE_MAP = 2,
+	BPF_TYPE_LINK = 3,
+};
+
+struct map_iter {
+	void *key;
+	bool done;
+};
+
+struct bpffs_btf_enums {
+	const struct btf *btf;
+	const struct btf_type *cmd_t;
+	const struct btf_type *map_t;
+	const struct btf_type *prog_t;
+	const struct btf_type *attach_t;
+};
+
+enum {
+	OPT_UID = 0,
+	OPT_GID = 1,
+	OPT_MODE = 2,
+	OPT_DELEGATE_CMDS = 3,
+	OPT_DELEGATE_MAPS = 4,
+	OPT_DELEGATE_PROGS = 5,
+	OPT_DELEGATE_ATTACHS = 6,
+};
+
+struct bpf_spin_lock {
+	__u32 val;
+};
+
+struct bpf_timer {
+	__u64 __opaque[2];
+};
+
+struct bpf_wq {
+	__u64 __opaque[2];
+};
+
+struct bpf_dynptr {
+	__u64 __opaque[2];
+};
+
+struct bpf_list_head {
+	__u64 __opaque[2];
+};
+
+struct bpf_list_node {
+	__u64 __opaque[3];
+};
+
+struct bpf_rb_root {
+	__u64 __opaque[2];
+};
+
+struct bpf_rb_node {
+	__u64 __opaque[4];
+};
+
+struct bpf_refcount {
+	__u32 __opaque[1];
+};
+
+struct bpf_pidns_info {
+	__u32 pid;
+	__u32 tgid;
+};
+
+enum {
+	BPF_F_TIMER_ABS = 1,
+	BPF_F_TIMER_CPU_PIN = 2,
+};
+
+enum bpf_kfunc_flags {
+	BPF_F_PAD_ZEROS = 1,
+};
+
+struct btf_id_dtor_kfunc {
+	u32 btf_id;
+	u32 kfunc_btf_id;
+};
+
+struct bpf_rb_node_kern {
+	struct rb_node rb_node;
+	void *owner;
+};
+
+struct bpf_list_node_kern {
+	struct list_head list_head;
+	void *owner;
+	long: 32;
+};
+
+struct bpf_dynptr_kern {
+	void *data;
+	u32 size;
+	u32 offset;
+	long: 32;
+};
+
+typedef u64 (*btf_bpf_map_lookup_elem)(struct bpf_map *, void *);
+
+typedef u64 (*btf_bpf_map_update_elem)(struct bpf_map *, void *, void *, u64);
+
+typedef u64 (*btf_bpf_map_delete_elem)(struct bpf_map *, void *);
+
+typedef u64 (*btf_bpf_map_push_elem)(struct bpf_map *, void *, u64);
+
+typedef u64 (*btf_bpf_map_pop_elem)(struct bpf_map *, void *);
+
+typedef u64 (*btf_bpf_map_peek_elem)(struct bpf_map *, void *);
+
+typedef u64 (*btf_bpf_map_lookup_percpu_elem)(struct bpf_map *, void *, u32);
+
+typedef u64 (*btf_bpf_get_smp_processor_id)();
+
+typedef u64 (*btf_bpf_get_numa_node_id)();
+
+typedef u64 (*btf_bpf_ktime_get_ns)();
+
+typedef u64 (*btf_bpf_ktime_get_boot_ns)();
+
+typedef u64 (*btf_bpf_ktime_get_coarse_ns)();
+
+typedef u64 (*btf_bpf_ktime_get_tai_ns)();
+
+typedef u64 (*btf_bpf_get_current_pid_tgid)();
+
+typedef u64 (*btf_bpf_get_current_uid_gid)();
+
+typedef u64 (*btf_bpf_get_current_comm)(char *, u32);
+
+typedef u64 (*btf_bpf_spin_lock)(struct bpf_spin_lock *);
+
+typedef u64 (*btf_bpf_spin_unlock)(struct bpf_spin_lock *);
+
+typedef u64 (*btf_bpf_jiffies64)();
+
+typedef u64 (*btf_bpf_get_current_cgroup_id)();
+
+typedef u64 (*btf_bpf_get_current_ancestor_cgroup_id)(int);
+
+typedef u64 (*btf_bpf_strtol)(const char *, size_t, u64, s64 *);
+
+typedef u64 (*btf_bpf_strtoul)(const char *, size_t, u64, u64 *);
+
+typedef u64 (*btf_bpf_strncmp)(const char *, u32, const char *);
+
+typedef u64 (*btf_bpf_get_ns_current_pid_tgid)(u64, u64, struct bpf_pidns_info *, u32);
+
+typedef u64 (*btf_bpf_event_output_data)(void *, struct bpf_map *, u64, void *, u64);
+
+typedef u64 (*btf_bpf_copy_from_user)(void *, u32, const void *);
+
+typedef u64 (*btf_bpf_copy_from_user_task)(void *, u32, const void *, struct task_struct *, u64);
+
+typedef u64 (*btf_bpf_per_cpu_ptr)(const void *, u32);
+
+typedef u64 (*btf_bpf_this_cpu_ptr)(const void *);
+
+struct bpf_bprintf_buffers {
+	char bin_args[512];
+	char buf[1024];
+};
+
+typedef u64 (*btf_bpf_snprintf)(char *, u32, char *, const void *, u32);
+
+struct bpf_async_cb {
+	struct bpf_map *map;
+	struct bpf_prog *prog;
+	void *callback_fn;
+	void *value;
+	union {
+		struct callback_head rcu;
+		struct work_struct delete_work;
+	};
+	u64 flags;
+};
+
+struct bpf_hrtimer {
+	struct bpf_async_cb cb;
+	struct hrtimer timer;
+	atomic_t cancelling;
+	long: 32;
+};
+
+struct bpf_work {
+	struct bpf_async_cb cb;
+	struct work_struct work;
+	struct work_struct delete_work;
+};
+
+struct bpf_async_kern {
+	union {
+		struct bpf_async_cb *cb;
+		struct bpf_hrtimer *timer;
+		struct bpf_work *work;
+	};
+	struct bpf_spin_lock lock;
+};
+
+enum bpf_async_type {
+	BPF_ASYNC_TYPE_TIMER = 0,
+	BPF_ASYNC_TYPE_WQ = 1,
+};
+
+typedef u64 (*btf_bpf_timer_init)(struct bpf_async_kern *, struct bpf_map *, u64);
+
+typedef u64 (*btf_bpf_timer_set_callback)(struct bpf_async_kern *, void *, struct bpf_prog_aux *);
+
+typedef u64 (*btf_bpf_timer_start)(struct bpf_async_kern *, u64, u64);
+
+typedef u64 (*btf_bpf_timer_cancel)(struct bpf_async_kern *);
+
+typedef u64 (*btf_bpf_kptr_xchg)(void *, void *);
+
+typedef u64 (*btf_bpf_dynptr_from_mem)(void *, u32, u64, struct bpf_dynptr_kern *);
+
+typedef u64 (*btf_bpf_dynptr_read)(void *, u32, const struct bpf_dynptr_kern *, u32, u64);
+
+typedef u64 (*btf_bpf_dynptr_write)(const struct bpf_dynptr_kern *, u32, void *, u32, u64);
+
+typedef u64 (*btf_bpf_dynptr_data)(const struct bpf_dynptr_kern *, u32, u32);
+
+typedef u64 (*btf_bpf_current_task_under_cgroup)(struct bpf_map *, u32);
+
+struct bpf_throw_ctx {
+	struct bpf_prog_aux *aux;
+	long: 32;
+	u64 sp;
+	u64 bp;
+	int cnt;
+	long: 32;
+};
+
+struct bpf_iter_bits {
+	__u64 __opaque[2];
+};
+
+struct bpf_iter_bits_kern {
+	union {
+		__u64 *bits;
+		__u64 bits_copy;
+	};
+	int nr_bits;
+	int bit;
+};
+
+struct bpf_iter_seq_prog_info {
+	u32 prog_id;
+};
+
+struct bpf_iter__bpf_prog {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct bpf_prog *prog;
+	};
+};
+
+struct pcpu_freelist_node;
+
+struct pcpu_freelist_head {
+	struct pcpu_freelist_node *first;
+	raw_spinlock_t lock;
+};
+
+struct pcpu_freelist_node {
+	struct pcpu_freelist_node *next;
+};
+
+struct pcpu_freelist {
+	struct pcpu_freelist_head *freelist;
+	struct pcpu_freelist_head extralist;
+};
+
+enum bpf_lru_list_type {
+	BPF_LRU_LIST_T_ACTIVE = 0,
+	BPF_LRU_LIST_T_INACTIVE = 1,
+	BPF_LRU_LIST_T_FREE = 2,
+	BPF_LRU_LOCAL_LIST_T_FREE = 3,
+	BPF_LRU_LOCAL_LIST_T_PENDING = 4,
+};
+
+struct bpf_lru_node {
+	struct list_head list;
+	u16 cpu;
+	u8 type;
+	u8 ref;
+};
+
+struct bpf_lru_list {
+	struct list_head lists[3];
+	unsigned int counts[2];
+	struct list_head *next_inactive_rotation;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	raw_spinlock_t lock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct bpf_lru_locallist {
+	struct list_head lists[2];
+	u16 next_steal;
+	raw_spinlock_t lock;
+};
+
+struct bpf_common_lru {
+	struct bpf_lru_list lru_list;
+	struct bpf_lru_locallist *local_list;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+typedef bool (*del_from_htab_func)(void *, struct bpf_lru_node *);
+
+struct bpf_lru {
+	union {
+		struct bpf_common_lru common_lru;
+		struct bpf_lru_list *percpu_lru;
+	};
+	del_from_htab_func del_from_htab;
+	void *del_arg;
+	unsigned int hash_offset;
+	unsigned int nr_scans;
+	bool percpu;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct bpf_lpm_trie_key_hdr {
+	__u32 prefixlen;
+};
+
+struct bpf_lpm_trie_key_u8 {
+	union {
+		struct bpf_lpm_trie_key_hdr hdr;
+		__u32 prefixlen;
+	};
+	__u8 data[0];
+};
+
+struct lpm_trie_node {
+	struct callback_head rcu;
+	struct lpm_trie_node *child[2];
+	u32 prefixlen;
+	u32 flags;
+	u8 data[0];
+};
+
+struct lpm_trie {
+	struct bpf_map map;
+	struct lpm_trie_node *root;
+	size_t n_entries;
+	size_t max_prefixlen;
+	size_t data_size;
+	spinlock_t lock;
+	long: 32;
+};
+
+enum {
+	BPF_RB_NO_WAKEUP = 1,
+	BPF_RB_FORCE_WAKEUP = 2,
+};
+
+enum {
+	BPF_RB_AVAIL_DATA = 0,
+	BPF_RB_RING_SIZE = 1,
+	BPF_RB_CONS_POS = 2,
+	BPF_RB_PROD_POS = 3,
+};
+
+enum {
+	BPF_RINGBUF_BUSY_BIT = 2147483648,
+	BPF_RINGBUF_DISCARD_BIT = 1073741824,
+	BPF_RINGBUF_HDR_SZ = 8,
+};
+
+struct bpf_ringbuf {
+	wait_queue_head_t waitq;
+	struct irq_work work;
+	long: 32;
+	u64 mask;
+	struct page **pages;
+	int nr_pages;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	raw_spinlock_t spinlock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	atomic_t busy;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long unsigned int consumer_pos;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long unsigned int producer_pos;
+	long unsigned int pending_pos;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	char data[0];
+};
+
+struct bpf_ringbuf_map {
+	struct bpf_map map;
+	struct bpf_ringbuf *rb;
+	long: 32;
+};
+
+struct bpf_ringbuf_hdr {
+	u32 len;
+	u32 pg_off;
+};
+
+typedef u64 (*btf_bpf_ringbuf_reserve)(struct bpf_map *, u64, u64);
+
+typedef u64 (*btf_bpf_ringbuf_submit)(void *, u64);
+
+typedef u64 (*btf_bpf_ringbuf_discard)(void *, u64);
+
+typedef u64 (*btf_bpf_ringbuf_output)(struct bpf_map *, void *, u64, u64);
+
+typedef u64 (*btf_bpf_ringbuf_query)(struct bpf_map *, u64);
+
+typedef u64 (*btf_bpf_ringbuf_reserve_dynptr)(struct bpf_map *, u32, u64, struct bpf_dynptr_kern *);
+
+typedef u64 (*btf_bpf_ringbuf_submit_dynptr)(struct bpf_dynptr_kern *, u64);
+
+typedef u64 (*btf_bpf_ringbuf_discard_dynptr)(struct bpf_dynptr_kern *, u64);
+
+typedef u64 (*btf_bpf_user_ringbuf_drain)(struct bpf_map *, void *, void *, u64);
+
+struct bpf_tramp_link;
+
+struct bpf_tramp_links {
+	struct bpf_tramp_link *links[38];
+	int nr_links;
+};
+
+struct bpf_tramp_link {
+	struct bpf_link link;
+	struct hlist_node tramp_hlist;
+	u64 cookie;
+};
+
+struct bpf_tramp_run_ctx;
+
+typedef u64 (*bpf_trampoline_enter_t)(struct bpf_prog *, struct bpf_tramp_run_ctx *);
+
+struct bpf_tramp_run_ctx {
+	struct bpf_run_ctx run_ctx;
+	u64 bpf_cookie;
+	struct bpf_run_ctx *saved_run_ctx;
+	long: 32;
+};
+
+typedef void (*bpf_trampoline_exit_t)(struct bpf_prog *, u64, struct bpf_tramp_run_ctx *);
+
+struct bpf_attach_target_info {
+	struct btf_func_model fmodel;
+	long int tgt_addr;
+	struct module *tgt_mod;
+	const char *tgt_name;
+	const struct btf_type *tgt_type;
+};
+
+enum perf_record_ksymbol_type {
+	PERF_RECORD_KSYMBOL_TYPE_UNKNOWN = 0,
+	PERF_RECORD_KSYMBOL_TYPE_BPF = 1,
+	PERF_RECORD_KSYMBOL_TYPE_OOL = 2,
+	PERF_RECORD_KSYMBOL_TYPE_MAX = 3,
+};
+
+enum {
+	BPF_F_INGRESS = 1,
+	BPF_F_BROADCAST = 8,
+	BPF_F_EXCLUDE_INGRESS = 16,
+};
+
+struct bpf_cpumap_val {
+	__u32 qsize;
+	union {
+		int fd;
+		__u32 id;
+	} bpf_prog;
+};
+
+struct bpf_cpu_map_entry;
+
+struct xdp_bulk_queue {
+	void *q[8];
+	struct list_head flush_node;
+	struct bpf_cpu_map_entry *obj;
+	unsigned int count;
+};
+
+struct bpf_cpu_map_entry {
+	u32 cpu;
+	int map_id;
+	struct xdp_bulk_queue *bulkq;
+	struct ptr_ring *queue;
+	struct task_struct *kthread;
+	struct bpf_cpumap_val value;
+	struct bpf_prog *prog;
+	struct completion kthread_running;
+	struct rcu_work free_work;
+};
+
+struct bpf_cpu_map {
+	struct bpf_map map;
+	struct bpf_cpu_map_entry **cpu_map;
+	long: 32;
+};
+
+enum bpf_stack_build_id_status {
+	BPF_STACK_BUILD_ID_EMPTY = 0,
+	BPF_STACK_BUILD_ID_VALID = 1,
+	BPF_STACK_BUILD_ID_IP = 2,
+};
+
+struct bpf_stack_build_id {
+	__s32 status;
+	unsigned char build_id[20];
+	union {
+		__u64 offset;
+		__u64 ip;
+	};
+};
+
+enum {
+	BPF_F_SKIP_FIELD_MASK = 255,
+	BPF_F_USER_STACK = 256,
+	BPF_F_FAST_STACK_CMP = 512,
+	BPF_F_REUSE_STACKID = 1024,
+	BPF_F_USER_BUILD_ID = 2048,
+};
+
+enum perf_callchain_context {
+	PERF_CONTEXT_HV = 18446744073709551584ULL,
+	PERF_CONTEXT_KERNEL = 18446744073709551488ULL,
+	PERF_CONTEXT_USER = 18446744073709551104ULL,
+	PERF_CONTEXT_GUEST = 18446744073709549568ULL,
+	PERF_CONTEXT_GUEST_KERNEL = 18446744073709549440ULL,
+	PERF_CONTEXT_GUEST_USER = 18446744073709549056ULL,
+	PERF_CONTEXT_MAX = 18446744073709547521ULL,
+};
+
+struct stack_map_bucket {
+	struct pcpu_freelist_node fnode;
+	u32 hash;
+	u32 nr;
+	long: 32;
+	u64 data[0];
+};
+
+struct bpf_stack_map {
+	struct bpf_map map;
+	void *elems;
+	struct pcpu_freelist freelist;
+	u32 n_buckets;
+	struct stack_map_bucket *buckets[0];
+	long: 32;
+};
+
+typedef u64 (*btf_bpf_get_stackid)(struct pt_regs *, struct bpf_map *, u64);
+
+typedef u64 (*btf_bpf_get_stackid_pe)(struct bpf_perf_event_data_kern *, struct bpf_map *, u64);
+
+typedef u64 (*btf_bpf_get_stack)(struct pt_regs *, void *, u32, u64);
+
+typedef u64 (*btf_bpf_get_stack_sleepable)(struct pt_regs *, void *, u32, u64);
+
+typedef u64 (*btf_bpf_get_task_stack)(struct task_struct *, void *, u32, u64);
+
+typedef u64 (*btf_bpf_get_task_stack_sleepable)(struct task_struct *, void *, u32, u64);
+
+typedef u64 (*btf_bpf_get_stack_pe)(struct bpf_perf_event_data_kern *, void *, u32, u64);
+
+struct bpf_struct_ops {
+	const struct bpf_verifier_ops *verifier_ops;
+	int (*init)(struct btf *);
+	int (*check_member)(const struct btf_type *, const struct btf_member *, const struct bpf_prog *);
+	int (*init_member)(const struct btf_type *, const struct btf_member *, void *, const void *);
+	int (*reg)(void *, struct bpf_link *);
+	void (*unreg)(void *, struct bpf_link *);
+	int (*update)(void *, void *, struct bpf_link *);
+	int (*validate)(void *);
+	void *cfi_stubs;
+	struct module *owner;
+	const char *name;
+	struct btf_func_model func_models[64];
+};
+
+struct bpf_struct_ops_arg_info {
+	struct bpf_ctx_arg_aux *info;
+	u32 cnt;
+};
+
+struct bpf_struct_ops_desc {
+	struct bpf_struct_ops *st_ops;
+	const struct btf_type *type;
+	const struct btf_type *value_type;
+	u32 type_id;
+	u32 value_id;
+	struct bpf_struct_ops_arg_info *arg_info;
+};
+
+enum bpf_struct_ops_state {
+	BPF_STRUCT_OPS_STATE_INIT = 0,
+	BPF_STRUCT_OPS_STATE_INUSE = 1,
+	BPF_STRUCT_OPS_STATE_TOBEFREE = 2,
+	BPF_STRUCT_OPS_STATE_READY = 3,
+};
+
+struct bpf_struct_ops_common_value {
+	refcount_t refcnt;
+	enum bpf_struct_ops_state state;
+};
+
+struct bpf_struct_ops_value {
+	struct bpf_struct_ops_common_value common;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	char data[0];
+};
+
+struct bpf_struct_ops_map {
+	struct bpf_map map;
+	struct callback_head rcu;
+	const struct bpf_struct_ops_desc *st_ops_desc;
+	struct mutex lock;
+	struct bpf_link **links;
+	u32 links_cnt;
+	u32 image_pages_cnt;
+	void *image_pages[8];
+	struct btf *btf;
+	struct bpf_struct_ops_value *uvalue;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct bpf_struct_ops_value kvalue;
+};
+
+struct bpf_struct_ops_link {
+	struct bpf_link link;
+	struct bpf_map *map;
+	wait_queue_head_t wait_hup;
+};
+
+enum {
+	IDX_MODULE_ID = 0,
+	IDX_ST_OPS_COMMON_VALUE_ID = 1,
+};
+
+enum bpf_core_relo_kind {
+	BPF_CORE_FIELD_BYTE_OFFSET = 0,
+	BPF_CORE_FIELD_BYTE_SIZE = 1,
+	BPF_CORE_FIELD_EXISTS = 2,
+	BPF_CORE_FIELD_SIGNED = 3,
+	BPF_CORE_FIELD_LSHIFT_U64 = 4,
+	BPF_CORE_FIELD_RSHIFT_U64 = 5,
+	BPF_CORE_TYPE_ID_LOCAL = 6,
+	BPF_CORE_TYPE_ID_TARGET = 7,
+	BPF_CORE_TYPE_EXISTS = 8,
+	BPF_CORE_TYPE_SIZE = 9,
+	BPF_CORE_ENUMVAL_EXISTS = 10,
+	BPF_CORE_ENUMVAL_VALUE = 11,
+	BPF_CORE_TYPE_MATCHES = 12,
+};
+
+struct bpf_core_relo {
+	__u32 insn_off;
+	__u32 type_id;
+	__u32 access_str_off;
+	enum bpf_core_relo_kind kind;
+};
+
+struct btf_enum64 {
+	__u32 name_off;
+	__u32 val_lo32;
+	__u32 val_hi32;
+};
+
+struct bpf_core_cand {
+	const struct btf *btf;
+	__u32 id;
+};
+
+struct bpf_core_cand_list {
+	struct bpf_core_cand *cands;
+	int len;
+};
+
+struct bpf_core_accessor {
+	__u32 type_id;
+	__u32 idx;
+	const char *name;
+};
+
+struct bpf_core_spec {
+	const struct btf *btf;
+	struct bpf_core_accessor spec[64];
+	__u32 root_type_id;
+	enum bpf_core_relo_kind relo_kind;
+	int len;
+	int raw_spec[64];
+	int raw_len;
+	__u32 bit_offset;
+};
+
+struct bpf_core_relo_res {
+	__u64 orig_val;
+	__u64 new_val;
+	bool poison;
+	bool validate;
+	bool fail_memsz_adjust;
+	__u32 orig_sz;
+	__u32 orig_type_id;
+	__u32 new_sz;
+	__u32 new_type_id;
+	long: 32;
+};
+
+enum perf_event_task_context {
+	perf_invalid_context = -1,
+	perf_hw_context = 0,
+	perf_sw_context = 1,
+	perf_nr_task_contexts = 2,
+};
+
+enum perf_branch_sample_type {
+	PERF_SAMPLE_BRANCH_USER = 1,
+	PERF_SAMPLE_BRANCH_KERNEL = 2,
+	PERF_SAMPLE_BRANCH_HV = 4,
+	PERF_SAMPLE_BRANCH_ANY = 8,
+	PERF_SAMPLE_BRANCH_ANY_CALL = 16,
+	PERF_SAMPLE_BRANCH_ANY_RETURN = 32,
+	PERF_SAMPLE_BRANCH_IND_CALL = 64,
+	PERF_SAMPLE_BRANCH_ABORT_TX = 128,
+	PERF_SAMPLE_BRANCH_IN_TX = 256,
+	PERF_SAMPLE_BRANCH_NO_TX = 512,
+	PERF_SAMPLE_BRANCH_COND = 1024,
+	PERF_SAMPLE_BRANCH_CALL_STACK = 2048,
+	PERF_SAMPLE_BRANCH_IND_JUMP = 4096,
+	PERF_SAMPLE_BRANCH_CALL = 8192,
+	PERF_SAMPLE_BRANCH_NO_FLAGS = 16384,
+	PERF_SAMPLE_BRANCH_NO_CYCLES = 32768,
+	PERF_SAMPLE_BRANCH_TYPE_SAVE = 65536,
+	PERF_SAMPLE_BRANCH_HW_INDEX = 131072,
+	PERF_SAMPLE_BRANCH_PRIV_SAVE = 262144,
+	PERF_SAMPLE_BRANCH_COUNTERS = 524288,
+	PERF_SAMPLE_BRANCH_MAX = 1048576,
+};
+
+enum perf_event_read_format {
+	PERF_FORMAT_TOTAL_TIME_ENABLED = 1,
+	PERF_FORMAT_TOTAL_TIME_RUNNING = 2,
+	PERF_FORMAT_ID = 4,
+	PERF_FORMAT_GROUP = 8,
+	PERF_FORMAT_LOST = 16,
+	PERF_FORMAT_MAX = 32,
+};
+
+enum perf_event_ioc_flags {
+	PERF_IOC_FLAG_GROUP = 1,
+};
+
+struct perf_ns_link_info {
+	__u64 dev;
+	__u64 ino;
+};
+
+enum {
+	NET_NS_INDEX = 0,
+	UTS_NS_INDEX = 1,
+	IPC_NS_INDEX = 2,
+	PID_NS_INDEX = 3,
+	USER_NS_INDEX = 4,
+	MNT_NS_INDEX = 5,
+	CGROUP_NS_INDEX = 6,
+	NR_NAMESPACES = 7,
+};
+
+enum perf_bpf_event_type {
+	PERF_BPF_EVENT_UNKNOWN = 0,
+	PERF_BPF_EVENT_PROG_LOAD = 1,
+	PERF_BPF_EVENT_PROG_UNLOAD = 2,
+	PERF_BPF_EVENT_MAX = 3,
+};
+
+enum perf_pmu_scope {
+	PERF_PMU_SCOPE_NONE = 0,
+	PERF_PMU_SCOPE_CORE = 1,
+	PERF_PMU_SCOPE_DIE = 2,
+	PERF_PMU_SCOPE_CLUSTER = 3,
+	PERF_PMU_SCOPE_PKG = 4,
+	PERF_PMU_SCOPE_SYS_WIDE = 5,
+	PERF_PMU_MAX_SCOPE = 6,
+};
+
+enum perf_addr_filter_action_t {
+	PERF_ADDR_FILTER_ACTION_STOP = 0,
+	PERF_ADDR_FILTER_ACTION_START = 1,
+	PERF_ADDR_FILTER_ACTION_FILTER = 2,
+};
+
+struct perf_addr_filter {
+	struct list_head entry;
+	struct path path;
+	long unsigned int offset;
+	long unsigned int size;
+	enum perf_addr_filter_action_t action;
+};
+
+struct swevent_hlist {
+	struct hlist_head heads[256];
+	struct callback_head callback_head;
+};
+
+struct pmu_event_list {
+	raw_spinlock_t lock;
+	struct list_head list;
+};
+
+struct perf_cpu_context {
+	struct perf_event_context ctx;
+	struct perf_event_context *task_ctx;
+	int online;
+	int heap_size;
+	struct perf_event **heap;
+	struct perf_event *heap_default[2];
+};
+
+struct perf_pmu_events_attr {
+	struct device_attribute attr;
+	u64 id;
+	const char *event_str;
+	long: 32;
+};
+
+struct match_token {
+	int token;
+	const char *pattern;
+};
+
+enum {
+	MAX_OPT_ARGS = 3,
+};
+
+struct min_heap_char {
+	int nr;
+	int size;
+	char *data;
+	char preallocated[0];
+};
+
+typedef struct min_heap_char min_heap_char;
+
+struct min_heap_callbacks {
+	bool (*less)(const void *, const void *, void *);
+	void (*swp)(void *, void *, void *);
+};
+
+typedef int (*remote_function_f)(void *);
+
+struct remote_function_call {
+	struct task_struct *p;
+	remote_function_f func;
+	void *info;
+	int ret;
+};
+
+enum event_type_t {
+	EVENT_FLEXIBLE = 1,
+	EVENT_PINNED = 2,
+	EVENT_TIME = 4,
+	EVENT_FROZEN = 8,
+	EVENT_CPU = 16,
+	EVENT_CGROUP = 32,
+	EVENT_ALL = 3,
+	EVENT_TIME_FROZEN = 12,
+};
+
+typedef void (*event_f)(struct perf_event *, struct perf_cpu_context *, struct perf_event_context *, void *);
+
+struct event_function_struct {
+	struct perf_event *event;
+	event_f func;
+	void *data;
+};
+
+struct __group_key {
+	int cpu;
+	struct pmu *pmu;
+	struct cgroup *cgroup;
+};
+
+struct stop_event_data {
+	struct perf_event *event;
+	unsigned int restart;
+};
+
+struct perf_event_min_heap {
+	int nr;
+	int size;
+	struct perf_event **data;
+	struct perf_event *preallocated[0];
+};
+
+struct perf_read_data {
+	struct perf_event *event;
+	bool group;
+	int ret;
+};
+
+struct perf_read_event {
+	struct perf_event_header header;
+	u32 pid;
+	u32 tid;
+};
+
+typedef void perf_iterate_f(struct perf_event *, void *);
+
+struct remote_output {
+	struct perf_buffer *rb;
+	int err;
+};
+
+struct perf_task_event {
+	struct task_struct *task;
+	struct perf_event_context *task_ctx;
+	struct {
+		struct perf_event_header header;
+		u32 pid;
+		u32 ppid;
+		u32 tid;
+		u32 ptid;
+		u64 time;
+	} event_id;
+};
+
+struct perf_comm_event {
+	struct task_struct *task;
+	char *comm;
+	int comm_size;
+	struct {
+		struct perf_event_header header;
+		u32 pid;
+		u32 tid;
+	} event_id;
+};
+
+struct perf_namespaces_event {
+	struct task_struct *task;
+	long: 32;
+	struct {
+		struct perf_event_header header;
+		u32 pid;
+		u32 tid;
+		u64 nr_namespaces;
+		struct perf_ns_link_info link_info[7];
+	} event_id;
+};
+
+struct perf_mmap_event {
+	struct vm_area_struct *vma;
+	const char *file_name;
+	int file_size;
+	int maj;
+	int min;
+	long: 32;
+	u64 ino;
+	u64 ino_generation;
+	u32 prot;
+	u32 flags;
+	u8 build_id[20];
+	u32 build_id_size;
+	struct {
+		struct perf_event_header header;
+		u32 pid;
+		u32 tid;
+		u64 start;
+		u64 len;
+		u64 pgoff;
+	} event_id;
+};
+
+struct perf_switch_event {
+	struct task_struct *task;
+	struct task_struct *next_prev;
+	struct {
+		struct perf_event_header header;
+		u32 next_prev_pid;
+		u32 next_prev_tid;
+	} event_id;
+};
+
+struct perf_ksymbol_event {
+	const char *name;
+	int name_len;
+	struct {
+		struct perf_event_header header;
+		u64 addr;
+		u32 len;
+		u16 ksym_type;
+		u16 flags;
+	} event_id;
+};
+
+struct perf_bpf_event {
+	struct bpf_prog *prog;
+	struct {
+		struct perf_event_header header;
+		u16 type;
+		u16 flags;
+		u32 id;
+		u8 tag[8];
+	} event_id;
+};
+
+struct perf_text_poke_event {
+	const void *old_bytes;
+	const void *new_bytes;
+	size_t pad;
+	u16 old_len;
+	u16 new_len;
+	struct {
+		struct perf_event_header header;
+		u64 addr;
+	} event_id;
+};
+
+struct swevent_htable {
+	struct swevent_hlist *swevent_hlist;
+	struct mutex hlist_mutex;
+	int hlist_refcount;
+};
+
+enum perf_probe_config {
+	PERF_PROBE_CONFIG_IS_RETPROBE = 1,
+	PERF_UPROBE_REF_CTR_OFFSET_BITS = 32,
+	PERF_UPROBE_REF_CTR_OFFSET_SHIFT = 32,
+};
+
+enum {
+	IF_ACT_NONE = -1,
+	IF_ACT_FILTER = 0,
+	IF_ACT_START = 1,
+	IF_ACT_STOP = 2,
+	IF_SRC_FILE = 3,
+	IF_SRC_KERNEL = 4,
+	IF_SRC_FILEADDR = 5,
+	IF_SRC_KERNELADDR = 6,
+};
+
+enum {
+	IF_STATE_ACTION = 0,
+	IF_STATE_SOURCE = 1,
+	IF_STATE_END = 2,
+};
+
+struct perf_aux_event {
+	struct perf_event_header header;
+	u64 hw_id;
+};
+
+struct perf_aux_event___2 {
+	struct perf_event_header header;
+	u32 pid;
+	u32 tid;
+};
+
+struct perf_aux_event___3 {
+	struct perf_event_header header;
+	u64 offset;
+	u64 size;
+	u64 flags;
+};
+
+typedef union {
+} release_pages_arg;
+
+struct trace_event_raw_mm_lru_insertion {
+	struct trace_entry ent;
+	struct folio *folio;
+	long unsigned int pfn;
+	enum lru_list lru;
+	long unsigned int flags;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_lru_activate {
+	struct trace_entry ent;
+	struct folio *folio;
+	long unsigned int pfn;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_mm_lru_insertion {};
+
+struct trace_event_data_offsets_mm_lru_activate {};
+
+typedef void (*btf_trace_mm_lru_insertion)(void *, struct folio *);
+
+typedef void (*btf_trace_mm_lru_activate)(void *, struct folio *);
+
+struct cpu_fbatches {
+	local_lock_t lock;
+	struct folio_batch lru_add;
+	struct folio_batch lru_deactivate_file;
+	struct folio_batch lru_deactivate;
+	struct folio_batch lru_lazyfree;
+	struct folio_batch lru_activate;
+	local_lock_t lock_irq;
+	struct folio_batch lru_move_tail;
+};
+
+typedef void (*move_fn_t)(struct lruvec *, struct folio *);
+
+typedef struct kmem_cache *kmem_buckets[14];
+
+enum wb_state {
+	WB_registered = 0,
+	WB_writeback_running = 1,
+	WB_has_dirty_io = 2,
+	WB_start_all = 3,
+};
+
+struct wb_stats {
+	long unsigned int nr_dirty;
+	long unsigned int nr_io;
+	long unsigned int nr_more_io;
+	long unsigned int nr_dirty_time;
+	long unsigned int nr_writeback;
+	long unsigned int nr_reclaimable;
+	long unsigned int nr_dirtied;
+	long unsigned int nr_written;
+	long unsigned int dirty_thresh;
+	long unsigned int wb_thresh;
+};
+
+struct reciprocal_value {
+	u32 m;
+	u8 sh1;
+	u8 sh2;
+};
+
+struct kmem_cache_order_objects {
+	unsigned int x;
+};
+
+struct kmem_cache_cpu;
+
+struct kmem_cache_node;
+
+struct kmem_cache {
+	struct kmem_cache_cpu *cpu_slab;
+	slab_flags_t flags;
+	long unsigned int min_partial;
+	unsigned int size;
+	unsigned int object_size;
+	struct reciprocal_value reciprocal_size;
+	unsigned int offset;
+	unsigned int cpu_partial;
+	unsigned int cpu_partial_slabs;
+	struct kmem_cache_order_objects oo;
+	struct kmem_cache_order_objects min;
+	gfp_t allocflags;
+	int refcount;
+	void (*ctor)(void *);
+	unsigned int inuse;
+	unsigned int align;
+	unsigned int red_left_pad;
+	const char *name;
+	struct list_head list;
+	struct kobject kobj;
+	long unsigned int random;
+	unsigned int *random_seq;
+	struct kmem_cache_node *node[1];
+};
+
+struct slab {
+	long unsigned int __page_flags;
+	struct kmem_cache *slab_cache;
+	union {
+		struct {
+			union {
+				struct list_head slab_list;
+				struct {
+					struct slab *next;
+					int slabs;
+				};
+			};
+			union {
+				struct {
+					void *freelist;
+					union {
+						long unsigned int counters;
+						struct {
+							unsigned int inuse: 16;
+							unsigned int objects: 15;
+							unsigned int frozen: 1;
+						};
+					};
+				};
+			};
+		};
+		struct callback_head callback_head;
+	};
+	unsigned int __page_type;
+	atomic_t __page_refcount;
+	long unsigned int obj_exts;
+};
+
+enum slab_state {
+	DOWN = 0,
+	PARTIAL = 1,
+	UP = 2,
+	FULL = 3,
+};
+
+struct kmalloc_info_struct {
+	const char *name[3];
+	unsigned int size;
+};
+
+struct kmem_obj_info {
+	void *kp_ptr;
+	struct slab *kp_slab;
+	void *kp_objp;
+	long unsigned int kp_data_offset;
+	struct kmem_cache *kp_slab_cache;
+	void *kp_ret;
+	void *kp_stack[16];
+	void *kp_free_stack[16];
+};
+
+struct trace_event_raw_kmem_cache_alloc {
+	struct trace_entry ent;
+	long unsigned int call_site;
+	const void *ptr;
+	size_t bytes_req;
+	size_t bytes_alloc;
+	long unsigned int gfp_flags;
+	int node;
+	bool accounted;
+	char __data[0];
+};
+
+struct trace_event_raw_kmalloc {
+	struct trace_entry ent;
+	long unsigned int call_site;
+	const void *ptr;
+	size_t bytes_req;
+	size_t bytes_alloc;
+	long unsigned int gfp_flags;
+	int node;
+	char __data[0];
+};
+
+struct trace_event_raw_kfree {
+	struct trace_entry ent;
+	long unsigned int call_site;
+	const void *ptr;
+	char __data[0];
+};
+
+struct trace_event_raw_kmem_cache_free {
+	struct trace_entry ent;
+	long unsigned int call_site;
+	const void *ptr;
+	u32 __data_loc_name;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_page_free {
+	struct trace_entry ent;
+	long unsigned int pfn;
+	unsigned int order;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_page_free_batched {
+	struct trace_entry ent;
+	long unsigned int pfn;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_page_alloc {
+	struct trace_entry ent;
+	long unsigned int pfn;
+	unsigned int order;
+	long unsigned int gfp_flags;
+	int migratetype;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_page {
+	struct trace_entry ent;
+	long unsigned int pfn;
+	unsigned int order;
+	int migratetype;
+	int percpu_refill;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_page_pcpu_drain {
+	struct trace_entry ent;
+	long unsigned int pfn;
+	unsigned int order;
+	int migratetype;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_page_alloc_extfrag {
+	struct trace_entry ent;
+	long unsigned int pfn;
+	int alloc_order;
+	int fallback_order;
+	int alloc_migratetype;
+	int fallback_migratetype;
+	int change_ownership;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_alloc_contig_migrate_range_info {
+	struct trace_entry ent;
+	long unsigned int start;
+	long unsigned int end;
+	long unsigned int nr_migrated;
+	long unsigned int nr_reclaimed;
+	long unsigned int nr_mapped;
+	int migratetype;
+	char __data[0];
+};
+
+struct trace_event_raw_rss_stat {
+	struct trace_entry ent;
+	unsigned int mm_id;
+	unsigned int curr;
+	int member;
+	long int size;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_kmem_cache_alloc {};
+
+struct trace_event_data_offsets_kmalloc {};
+
+struct trace_event_data_offsets_kfree {};
+
+struct trace_event_data_offsets_kmem_cache_free {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_mm_page_free {};
+
+struct trace_event_data_offsets_mm_page_free_batched {};
+
+struct trace_event_data_offsets_mm_page_alloc {};
+
+struct trace_event_data_offsets_mm_page {};
+
+struct trace_event_data_offsets_mm_page_pcpu_drain {};
+
+struct trace_event_data_offsets_mm_page_alloc_extfrag {};
+
+struct trace_event_data_offsets_mm_alloc_contig_migrate_range_info {};
+
+struct trace_event_data_offsets_rss_stat {};
+
+typedef void (*btf_trace_kmem_cache_alloc)(void *, long unsigned int, const void *, struct kmem_cache *, gfp_t, int);
+
+typedef void (*btf_trace_kmalloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);
+
+typedef void (*btf_trace_kfree)(void *, long unsigned int, const void *);
+
+typedef void (*btf_trace_kmem_cache_free)(void *, long unsigned int, const void *, const struct kmem_cache *);
+
+typedef void (*btf_trace_mm_page_free)(void *, struct page *, unsigned int);
+
+typedef void (*btf_trace_mm_page_free_batched)(void *, struct page *);
+
+typedef void (*btf_trace_mm_page_alloc)(void *, struct page *, unsigned int, gfp_t, int);
+
+typedef void (*btf_trace_mm_page_alloc_zone_locked)(void *, struct page *, unsigned int, int, int);
+
+typedef void (*btf_trace_mm_page_pcpu_drain)(void *, struct page *, unsigned int, int);
+
+typedef void (*btf_trace_mm_page_alloc_extfrag)(void *, struct page *, int, int, int, int);
+
+typedef void (*btf_trace_mm_alloc_contig_migrate_range_info)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);
+
+typedef void (*btf_trace_rss_stat)(void *, struct mm_struct *, int);
+
+struct list_lru_memcg {
+	struct callback_head rcu;
+	struct list_lru_one node[0];
+};
+
+struct list_lru_memcg_table {
+	struct list_lru_memcg *mlru;
+	struct mem_cgroup *memcg;
+};
+
+typedef struct {
+	u64 val;
+} pfn_t;
+
+typedef unsigned int zap_flags_t;
+
+enum mthp_stat_item {
+	MTHP_STAT_ANON_FAULT_ALLOC = 0,
+	MTHP_STAT_ANON_FAULT_FALLBACK = 1,
+	MTHP_STAT_ANON_FAULT_FALLBACK_CHARGE = 2,
+	MTHP_STAT_SWPOUT = 3,
+	MTHP_STAT_SWPOUT_FALLBACK = 4,
+	MTHP_STAT_SHMEM_ALLOC = 5,
+	MTHP_STAT_SHMEM_FALLBACK = 6,
+	MTHP_STAT_SHMEM_FALLBACK_CHARGE = 7,
+	MTHP_STAT_SPLIT = 8,
+	MTHP_STAT_SPLIT_FAILED = 9,
+	MTHP_STAT_SPLIT_DEFERRED = 10,
+	MTHP_STAT_NR_ANON = 11,
+	MTHP_STAT_NR_ANON_PARTIALLY_MAPPED = 12,
+	__MTHP_STAT_COUNT = 13,
+};
+
+struct zap_details {
+	struct folio *single_folio;
+	bool even_cows;
+	zap_flags_t zap_flags;
+};
+
+struct follow_pfnmap_args {
+	struct vm_area_struct *vma;
+	long unsigned int address;
+	spinlock_t *lock;
+	pte_t *ptep;
+	long unsigned int pfn;
+	pgprot_t pgprot;
+	bool writable;
+	bool special;
+};
+
+typedef long unsigned int pte_marker;
+
+typedef int rmap_t;
+
+enum rmap_level {
+	RMAP_LEVEL_PTE = 0,
+	RMAP_LEVEL_PMD = 1,
+};
+
+struct unlink_vma_file_batch {
+	int count;
+	struct vm_area_struct *vmas[8];
+};
+
+typedef int fpb_t;
+
+enum tlb_flush_reason {
+	TLB_FLUSH_ON_TASK_SWITCH = 0,
+	TLB_REMOTE_SHOOTDOWN = 1,
+	TLB_LOCAL_SHOOTDOWN = 2,
+	TLB_LOCAL_MM_SHOOTDOWN = 3,
+	TLB_REMOTE_SEND_IPI = 4,
+	NR_TLB_FLUSH_REASONS = 5,
+};
+
+struct anon_vma_chain {
+	struct vm_area_struct *vma;
+	struct anon_vma *anon_vma;
+	struct list_head same_vma;
+	struct rb_node rb;
+	long unsigned int rb_subtree_last;
+};
+
+struct rmap_walk_control {
+	void *arg;
+	bool try_lock;
+	bool contended;
+	bool (*rmap_one)(struct folio *, struct vm_area_struct *, long unsigned int, void *);
+	int (*done)(struct folio *);
+	struct anon_vma * (*anon_lock)(struct folio *, struct rmap_walk_control *);
+	bool (*invalid_vma)(struct vm_area_struct *, void *);
+};
+
+struct trace_event_raw_tlb_flush {
+	struct trace_entry ent;
+	int reason;
+	long unsigned int pages;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_tlb_flush {};
+
+typedef void (*btf_trace_tlb_flush)(void *, int, long unsigned int);
+
+struct trace_event_raw_mm_migrate_pages {
+	struct trace_entry ent;
+	long unsigned int succeeded;
+	long unsigned int failed;
+	long unsigned int thp_succeeded;
+	long unsigned int thp_failed;
+	long unsigned int thp_split;
+	long unsigned int large_folio_split;
+	enum migrate_mode mode;
+	int reason;
+	char __data[0];
+};
+
+struct trace_event_raw_mm_migrate_pages_start {
+	struct trace_entry ent;
+	enum migrate_mode mode;
+	int reason;
+	char __data[0];
+};
+
+struct trace_event_raw_migration_pte {
+	struct trace_entry ent;
+	long unsigned int addr;
+	long unsigned int pte;
+	int order;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_mm_migrate_pages {};
+
+struct trace_event_data_offsets_mm_migrate_pages_start {};
+
+struct trace_event_data_offsets_migration_pte {};
+
+typedef void (*btf_trace_mm_migrate_pages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, enum migrate_mode, int);
+
+typedef void (*btf_trace_mm_migrate_pages_start)(void *, enum migrate_mode, int);
+
+typedef void (*btf_trace_set_migration_pte)(void *, long unsigned int, long unsigned int, int);
+
+typedef void (*btf_trace_remove_migration_pte)(void *, long unsigned int, long unsigned int, int);
+
+struct folio_referenced_arg {
+	int mapcount;
+	int referenced;
+	long unsigned int vm_flags;
+	struct mem_cgroup *memcg;
+};
+
+struct memblock_type {
+	long unsigned int cnt;
+	long unsigned int max;
+	phys_addr_t total_size;
+	struct memblock_region *regions;
+	char *name;
+};
+
+struct memblock {
+	bool bottom_up;
+	phys_addr_t current_limit;
+	struct memblock_type memory;
+	struct memblock_type reserved;
+};
+
+struct reserve_mem_table {
+	char name[16];
+	phys_addr_t start;
+	phys_addr_t size;
+};
+
+typedef int cydp_t;
+
+struct madvise_walk_private {
+	struct mmu_gather *tlb;
+	bool pageout;
+};
+
+struct sysinfo {
+	__kernel_long_t uptime;
+	__kernel_ulong_t loads[3];
+	__kernel_ulong_t totalram;
+	__kernel_ulong_t freeram;
+	__kernel_ulong_t sharedram;
+	__kernel_ulong_t bufferram;
+	__kernel_ulong_t totalswap;
+	__kernel_ulong_t freeswap;
+	__u16 procs;
+	__u16 pad;
+	__kernel_ulong_t totalhigh;
+	__kernel_ulong_t freehigh;
+	__u32 mem_unit;
+	char _f[8];
+};
+
+union swap_header {
+	struct {
+		char reserved[4086];
+		char magic[10];
+	} magic;
+	struct {
+		char bootbits[1024];
+		__u32 version;
+		__u32 last_page;
+		__u32 nr_badpages;
+		unsigned char sws_uuid[16];
+		unsigned char sws_volume[16];
+		__u32 padding[117];
+		__u32 badpages[1];
+	} info;
+};
+
+struct swap_extent {
+	struct rb_node rb_node;
+	long unsigned int start_page;
+	long unsigned int nr_pages;
+	long: 32;
+	sector_t start_block;
+};
+
+enum vm_stat_item {
+	NR_DIRTY_THRESHOLD = 0,
+	NR_DIRTY_BG_THRESHOLD = 1,
+	NR_MEMMAP_PAGES = 2,
+	NR_MEMMAP_BOOT_PAGES = 3,
+	NR_VM_STAT_ITEMS = 4,
+};
+
+struct lruvec_stats_percpu {
+	long int state[30];
+	long int state_prev[30];
+};
+
+struct lruvec_stats {
+	long int state[30];
+	long int state_local[30];
+	long int state_pending[30];
+};
+
+struct memcg_vmstats {
+	long int state[37];
+	long unsigned int events[15];
+	long int state_local[37];
+	long unsigned int events_local[15];
+	long int state_pending[37];
+	long unsigned int events_pending[15];
+	atomic64_t stats_updates;
+};
+
+struct memcg_vmstats_percpu {
+	unsigned int stats_updates;
+	struct memcg_vmstats_percpu *parent;
+	struct memcg_vmstats *vmstats;
+	long int state[37];
+	long unsigned int events[15];
+	long int state_prev[37];
+	long unsigned int events_prev[15];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct slabobj_ext {
+	struct obj_cgroup *objcg;
+	long: 32;
+};
+
+struct memory_stat {
+	const char *name;
+	unsigned int idx;
+};
+
+struct memcg_stock_pcp {
+	local_lock_t stock_lock;
+	struct mem_cgroup *cached;
+	unsigned int nr_pages;
+	struct obj_cgroup *cached_objcg;
+	struct pglist_data *cached_pgdat;
+	unsigned int nr_bytes;
+	int nr_slab_reclaimable_b;
+	int nr_slab_unreclaimable_b;
+	struct work_struct work;
+	long unsigned int flags;
+};
+
+enum {
+	MEMORY_RECLAIM_SWAPPINESS = 0,
+	MEMORY_RECLAIM_NULL = 1,
+};
+
+struct uncharge_gather {
+	struct mem_cgroup *memcg;
+	long unsigned int nr_memory;
+	long unsigned int pgpgout;
+	long unsigned int nr_kmem;
+	int nid;
+};
+
+typedef struct kobject *kobj_probe_t(dev_t, int *, void *);
+
+struct char_device_struct {
+	struct char_device_struct *next;
+	unsigned int major;
+	unsigned int baseminor;
+	int minorct;
+	char name[64];
+	struct cdev *cdev;
+};
+
+typedef short unsigned int ushort;
+
+struct core_vma_metadata;
+
+struct coredump_params {
+	const kernel_siginfo_t *siginfo;
+	struct file *file;
+	long unsigned int limit;
+	long unsigned int mm_flags;
+	int cpu;
+	long: 32;
+	loff_t written;
+	loff_t pos;
+	loff_t to_skip;
+	int vma_count;
+	size_t vma_data_size;
+	struct core_vma_metadata *vma_meta;
+	long: 32;
+};
+
+struct core_vma_metadata {
+	long unsigned int start;
+	long unsigned int end;
+	long unsigned int flags;
+	long unsigned int dump_size;
+	long unsigned int pgoff;
+	struct file *file;
+};
+
+struct open_flags {
+	int open_flag;
+	umode_t mode;
+	int acc_mode;
+	int intent;
+	int lookup_flags;
+};
+
+struct user_arg_ptr {
+	union {
+		const char * const *native;
+	} ptr;
+};
+
+struct file_clone_range {
+	__s64 src_fd;
+	__u64 src_offset;
+	__u64 src_length;
+	__u64 dest_offset;
+};
+
+struct fsuuid2 {
+	__u8 len;
+	__u8 uuid[16];
+};
+
+struct fs_sysfs_path {
+	__u8 len;
+	__u8 name[128];
+};
+
+struct fsxattr {
+	__u32 fsx_xflags;
+	__u32 fsx_extsize;
+	__u32 fsx_nextents;
+	__u32 fsx_projid;
+	__u32 fsx_cowextsize;
+	unsigned char fsx_pad[8];
+};
+
+struct fiemap_extent;
+
+struct fiemap_extent_info {
+	unsigned int fi_flags;
+	unsigned int fi_extents_mapped;
+	unsigned int fi_extents_max;
+	struct fiemap_extent *fi_extents_start;
+};
+
+struct space_resv {
+	__s16 l_type;
+	__s16 l_whence;
+	long: 32;
+	__s64 l_start;
+	__s64 l_len;
+	__s32 l_sysid;
+	__u32 l_pid;
+	__s32 l_pad[4];
+};
+
+struct fiemap_extent {
+	__u64 fe_logical;
+	__u64 fe_physical;
+	__u64 fe_length;
+	__u64 fe_reserved64[2];
+	__u32 fe_flags;
+	__u32 fe_reserved[3];
+};
+
+struct fiemap {
+	__u64 fm_start;
+	__u64 fm_length;
+	__u32 fm_flags;
+	__u32 fm_mapped_extents;
+	__u32 fm_extent_count;
+	__u32 fm_reserved;
+	struct fiemap_extent fm_extents[0];
+};
+
+typedef struct {
+	long unsigned int fds_bits[32];
+} __kernel_fd_set;
+
+typedef __kernel_fd_set fd_set;
+
+struct poll_table_entry {
+	struct file *filp;
+	__poll_t key;
+	wait_queue_entry_t wait;
+	wait_queue_head_t *wait_address;
+};
+
+struct poll_table_page;
+
+struct poll_wqueues {
+	poll_table pt;
+	struct poll_table_page *table;
+	struct task_struct *polling_task;
+	int triggered;
+	int error;
+	int inline_index;
+	struct poll_table_entry inline_entries[18];
+};
+
+struct poll_table_page {
+	struct poll_table_page *next;
+	struct poll_table_entry *entry;
+	struct poll_table_entry entries[0];
+};
+
+enum poll_time_type {
+	PT_TIMEVAL = 0,
+	PT_OLD_TIMEVAL = 1,
+	PT_TIMESPEC = 2,
+	PT_OLD_TIMESPEC = 3,
+};
+
+typedef struct {
+	long unsigned int *in;
+	long unsigned int *out;
+	long unsigned int *ex;
+	long unsigned int *res_in;
+	long unsigned int *res_out;
+	long unsigned int *res_ex;
+} fd_set_bits;
+
+struct sigset_argpack {
+	sigset_t *p;
+	size_t size;
+};
+
+struct sel_arg_struct {
+	long unsigned int n;
+	fd_set *inp;
+	fd_set *outp;
+	fd_set *exp;
+	struct __kernel_old_timeval *tvp;
+};
+
+struct poll_list {
+	struct poll_list *next;
+	unsigned int len;
+	struct pollfd entries[0];
+};
+
+struct simple_transaction_argresp {
+	ssize_t size;
+	char data[0];
+};
+
+enum utf8_normalization {
+	UTF8_NFDI = 0,
+	UTF8_NFDICF = 1,
+	UTF8_NMAX = 2,
+};
+
+struct stashed_operations {
+	void (*put_data)(void *);
+	int (*init_inode)(struct inode *, void *);
+};
+
+enum {
+	DIR_OFFSET_MIN = 2,
+};
+
+struct simple_attr {
+	int (*get)(void *, u64 *);
+	int (*set)(void *, u64);
+	char get_buf[24];
+	char set_buf[24];
+	void *data;
+	const char *fmt;
+	struct mutex mutex;
+};
+
+enum legacy_fs_param {
+	LEGACY_FS_UNSET_PARAMS = 0,
+	LEGACY_FS_MONOLITHIC_PARAMS = 1,
+	LEGACY_FS_INDIVIDUAL_PARAMS = 2,
+};
+
+struct legacy_fs_context {
+	char *legacy_data;
+	size_t data_size;
+	enum legacy_fs_param param_type;
+};
+
+struct file_handle {
+	__u32 handle_bytes;
+	int handle_type;
+	unsigned char f_handle[0];
+};
+
+struct inotify_inode_mark {
+	struct fsnotify_mark fsn_mark;
+	int wd;
+};
+
+struct fanotify_event_metadata {
+	__u32 event_len;
+	__u8 vers;
+	__u8 reserved;
+	__u16 metadata_len;
+	__u64 mask;
+	__s32 fd;
+	__s32 pid;
+};
+
+struct fanotify_event_info_header {
+	__u8 info_type;
+	__u8 pad;
+	__u16 len;
+};
+
+struct fanotify_event_info_fid {
+	struct fanotify_event_info_header hdr;
+	__kernel_fsid_t fsid;
+	unsigned char handle[0];
+};
+
+struct fanotify_event_info_pidfd {
+	struct fanotify_event_info_header hdr;
+	__s32 pidfd;
+};
+
+struct fanotify_event_info_error {
+	struct fanotify_event_info_header hdr;
+	__s32 error;
+	__u32 error_count;
+};
+
+struct fanotify_response {
+	__s32 fd;
+	__u32 response;
+};
+
+struct fan_fsid {
+	struct super_block *sb;
+	__kernel_fsid_t id;
+	bool weak;
+};
+
+struct kioctx;
+
+struct kioctx_table {
+	struct callback_head rcu;
+	unsigned int nr;
+	struct kioctx *table[0];
+};
+
+typedef __kernel_ulong_t aio_context_t;
+
+enum {
+	IOCB_CMD_PREAD = 0,
+	IOCB_CMD_PWRITE = 1,
+	IOCB_CMD_FSYNC = 2,
+	IOCB_CMD_FDSYNC = 3,
+	IOCB_CMD_POLL = 5,
+	IOCB_CMD_NOOP = 6,
+	IOCB_CMD_PREADV = 7,
+	IOCB_CMD_PWRITEV = 8,
+};
+
+struct io_event {
+	__u64 data;
+	__u64 obj;
+	__s64 res;
+	__s64 res2;
+};
+
+struct iocb {
+	__u64 aio_data;
+	__u32 aio_key;
+	__kernel_rwf_t aio_rw_flags;
+	__u16 aio_lio_opcode;
+	__s16 aio_reqprio;
+	__u32 aio_fildes;
+	__u64 aio_buf;
+	__u64 aio_nbytes;
+	__s64 aio_offset;
+	__u64 aio_reserved2;
+	__u32 aio_flags;
+	__u32 aio_resfd;
+};
+
+typedef int kiocb_cancel_fn(struct kiocb *);
+
+struct aio_ring {
+	unsigned int id;
+	unsigned int nr;
+	unsigned int head;
+	unsigned int tail;
+	unsigned int magic;
+	unsigned int compat_features;
+	unsigned int incompat_features;
+	unsigned int header_length;
+	struct io_event io_events[0];
+};
+
+struct kioctx_cpu;
+
+struct ctx_rq_wait;
+
+struct kioctx {
+	struct percpu_ref users;
+	atomic_t dead;
+	struct percpu_ref reqs;
+	long unsigned int user_id;
+	struct kioctx_cpu *cpu;
+	unsigned int req_batch;
+	unsigned int max_reqs;
+	unsigned int nr_events;
+	long unsigned int mmap_base;
+	long unsigned int mmap_size;
+	struct folio **ring_folios;
+	long int nr_pages;
+	struct rcu_work free_rwork;
+	struct ctx_rq_wait *rq_wait;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct {
+		atomic_t reqs_available;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+	};
+	struct {
+		spinlock_t ctx_lock;
+		struct list_head active_reqs;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+	};
+	struct {
+		struct mutex ring_lock;
+		wait_queue_head_t wait;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+	};
+	struct {
+		unsigned int tail;
+		unsigned int completed_events;
+		spinlock_t completion_lock;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+		long: 32;
+	};
+	struct folio *internal_folios[8];
+	struct file *aio_ring_file;
+	unsigned int id;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct kioctx_cpu {
+	unsigned int reqs_available;
+};
+
+struct ctx_rq_wait {
+	struct completion comp;
+	atomic_t count;
+};
+
+struct fsync_iocb {
+	struct file *file;
+	struct work_struct work;
+	bool datasync;
+	struct cred *creds;
+};
+
+struct poll_iocb {
+	struct file *file;
+	struct wait_queue_head *head;
+	__poll_t events;
+	bool cancelled;
+	bool work_scheduled;
+	bool work_need_resched;
+	struct wait_queue_entry wait;
+	struct work_struct work;
+};
+
+struct aio_kiocb {
+	union {
+		struct file *ki_filp;
+		struct kiocb rw;
+		struct fsync_iocb fsync;
+		struct poll_iocb poll;
+	};
+	struct kioctx *ki_ctx;
+	kiocb_cancel_fn *ki_cancel;
+	struct io_event ki_res;
+	struct list_head ki_list;
+	refcount_t ki_refcnt;
+	struct eventfd_ctx *ki_eventfd;
+};
+
+struct aio_waiter {
+	struct wait_queue_entry w;
+	size_t min_nr;
+};
+
+struct aio_poll_table {
+	struct poll_table_struct pt;
+	struct aio_kiocb *iocb;
+	bool queued;
+	int error;
+};
+
+struct __aio_sigset {
+	const sigset_t *sigmask;
+	size_t sigsetsize;
+};
+
+struct posix_acl_xattr_entry {
+	__le16 e_tag;
+	__le16 e_perm;
+	__le32 e_id;
+};
+
+struct posix_acl_xattr_header {
+	__le32 a_version;
+};
+
+enum handle_to_path_flags {
+	HANDLE_CHECK_PERMS = 1,
+	HANDLE_CHECK_SUBTREE = 2,
+};
+
+struct handle_to_path_ctx {
+	struct path root;
+	enum handle_to_path_flags flags;
+	unsigned int fh_flags;
+};
+
+struct iomap_dio_ops {
+	int (*end_io)(struct kiocb *, ssize_t, int, unsigned int);
+	void (*submit_io)(const struct iomap_iter *, struct bio *, loff_t);
+	struct bio_set *bio_set;
+};
+
+struct iomap_dio {
+	struct kiocb *iocb;
+	const struct iomap_dio_ops *dops;
+	loff_t i_size;
+	loff_t size;
+	atomic_t ref;
+	unsigned int flags;
+	int error;
+	size_t done_before;
+	bool wait_for_completion;
+	union {
+		struct {
+			struct iov_iter *iter;
+			struct task_struct *waiter;
+		} submit;
+		struct {
+			struct work_struct work;
+		} aio;
+	};
+	long: 32;
+};
+
+struct iomap_swapfile_info {
+	struct iomap iomap;
+	struct swap_info_struct *sis;
+	long: 32;
+	uint64_t lowest_ppage;
+	uint64_t highest_ppage;
+	long unsigned int nr_pages;
+	int nr_extents;
+	struct file *file;
+	long: 32;
+};
+
+typedef long int intptr_t;
+
+struct syscall_info {
+	__u64 sp;
+	struct seccomp_data data;
+};
+
+enum resctrl_conf_type {
+	CDP_NONE = 0,
+	CDP_CODE = 1,
+	CDP_DATA = 2,
+};
+
+typedef struct dentry *instantiate_t(struct dentry *, struct task_struct *, const void *);
+
+enum proc_mem_force {
+	PROC_MEM_FORCE_ALWAYS = 0,
+	PROC_MEM_FORCE_PTRACE = 1,
+	PROC_MEM_FORCE_NEVER = 2,
+};
+
+struct pid_entry {
+	const char *name;
+	unsigned int len;
+	umode_t mode;
+	const struct inode_operations *iop;
+	const struct file_operations *fop;
+	union proc_op op;
+};
+
+struct limit_names {
+	const char *name;
+	const char *unit;
+};
+
+struct map_files_info {
+	long unsigned int start;
+	long unsigned int end;
+	fmode_t mode;
+};
+
+struct tgid_iter {
+	unsigned int tgid;
+	struct task_struct *task;
+};
+
+struct kernfs_root {
+	struct kernfs_node *kn;
+	unsigned int flags;
+	struct idr ino_idr;
+	u32 last_id_lowbits;
+	u32 id_highbits;
+	struct kernfs_syscall_ops *syscall_ops;
+	struct list_head supers;
+	wait_queue_head_t deactivate_waitq;
+	struct rw_semaphore kernfs_rwsem;
+	struct rw_semaphore kernfs_iattr_rwsem;
+	struct rw_semaphore kernfs_supers_rwsem;
+	struct callback_head rcu;
+};
+
+struct kernfs_iattrs {
+	kuid_t ia_uid;
+	kgid_t ia_gid;
+	struct timespec64 ia_atime;
+	struct timespec64 ia_mtime;
+	struct timespec64 ia_ctime;
+	struct simple_xattrs xattrs;
+	atomic_t nr_user_xattrs;
+	atomic_t user_xattr_size;
+};
+
+struct kernfs_super_info {
+	struct super_block *sb;
+	struct kernfs_root *root;
+	const void *ns;
+	struct list_head node;
+};
+
+struct squashfs_fragment_entry {
+	__le64 start_block;
+	__le32 size;
+	unsigned int unused;
+};
+
+struct squashfs_super_block {
+	__le32 s_magic;
+	__le32 inodes;
+	__le32 mkfs_time;
+	__le32 block_size;
+	__le32 fragments;
+	__le16 compression;
+	__le16 block_log;
+	__le16 flags;
+	__le16 no_ids;
+	__le16 s_major;
+	__le16 s_minor;
+	__le64 root_inode;
+	__le64 bytes_used;
+	__le64 id_table_start;
+	__le64 xattr_id_table_start;
+	__le64 inode_table_start;
+	__le64 directory_table_start;
+	__le64 fragment_table_start;
+	__le64 lookup_table_start;
+};
+
+struct squashfs_xattr_id_table {
+	__le64 xattr_table_start;
+	__le32 xattr_ids;
+	__le32 unused;
+};
+
+enum Opt_errors {
+	Opt_errors_continue = 0,
+	Opt_errors_panic = 1,
+};
+
+enum squashfs_param {
+	Opt_errors = 0,
+	Opt_threads = 1,
+};
+
+struct squashfs_mount_opts {
+	enum Opt_errors errors;
+	const struct squashfs_decompressor_thread_ops *thread_ops;
+	int thread_num;
+};
+
+struct squashfs_stream {
+	void *stream;
+	struct mutex mutex;
+};
+
+struct getdents_callback {
+	struct dir_context ctx;
+	char *name;
+	long: 32;
+	u64 ino;
+	int found;
+	int sequence;
+};
+
+enum {
+	Opt_override_compr = 0,
+	Opt_rp_size = 1,
+};
+
+enum {
+	UBIFS_SIMPLE_KEY_FMT = 0,
+};
+
+enum {
+	UBIFS_MST_DIRTY = 1,
+	UBIFS_MST_NO_ORPHS = 2,
+	UBIFS_MST_RCVRY = 4,
+};
+
+struct ubifs_ino_node {
+	struct ubifs_ch ch;
+	__u8 key[16];
+	__le64 creat_sqnum;
+	__le64 size;
+	__le64 atime_sec;
+	__le64 ctime_sec;
+	__le64 mtime_sec;
+	__le32 atime_nsec;
+	__le32 ctime_nsec;
+	__le32 mtime_nsec;
+	__le32 nlink;
+	__le32 uid;
+	__le32 gid;
+	__le32 mode;
+	__le32 flags;
+	__le32 data_len;
+	__le32 xattr_cnt;
+	__le32 xattr_size;
+	__u8 padding1[4];
+	__le32 xattr_names;
+	__le16 compr_type;
+	__u8 padding2[26];
+	__u8 data[0];
+};
+
+enum {
+	ASSACT_REPORT = 0,
+	ASSACT_RO = 1,
+	ASSACT_PANIC = 2,
+};
+
+struct ubifs_unclean_leb {
+	struct list_head list;
+	int lnum;
+	int endpt;
+};
+
+struct ubifs_compressor {
+	int compr_type;
+	struct crypto_comp *cc;
+	struct mutex *comp_mutex;
+	struct mutex *decomp_mutex;
+	const char *name;
+	const char *capi_name;
+};
+
+struct fscrypt_operations;
+
+enum {
+	Opt_fast_unmount = 0,
+	Opt_norm_unmount = 1,
+	Opt_bulk_read = 2,
+	Opt_no_bulk_read = 3,
+	Opt_chk_data_crc = 4,
+	Opt_no_chk_data_crc = 5,
+	Opt_override_compr___2 = 6,
+	Opt_assert = 7,
+	Opt_auth_key = 8,
+	Opt_auth_hash_name = 9,
+	Opt_ignore = 10,
+	Opt_err = 11,
+};
+
+struct idx_node {
+	struct list_head list;
+	int iip;
+	long: 32;
+	union ubifs_key upper_key;
+	struct ubifs_idx_node idx;
+	long: 32;
+};
+
+struct scan_data {
+	int min_space;
+	int pick_free;
+	int lnum;
+	int exclude_index;
+};
+
+struct xattr;
+
+typedef int (*initxattrs)(struct inode *, const struct xattr *, void *);
+
+struct xattr {
+	const char *name;
+	void *value;
+	size_t value_len;
+};
+
+enum file_time_flags {
+	S_ATIME = 1,
+	S_MTIME = 2,
+	S_CTIME = 4,
+	S_VERSION = 8,
+};
+
+struct ovl_inode_params {
+	struct inode *newinode;
+	struct dentry *upperdentry;
+	struct ovl_entry *oe;
+	bool index;
+	char *redirect;
+	char *lowerdata_redirect;
+};
+
+struct renamedata {
+	struct mnt_idmap *old_mnt_idmap;
+	struct inode *old_dir;
+	struct dentry *old_dentry;
+	struct mnt_idmap *new_mnt_idmap;
+	struct inode *new_dir;
+	struct dentry *new_dentry;
+	struct inode **delegated_inode;
+	unsigned int flags;
+};
+
+struct ovl_fb {
+	u8 version;
+	u8 magic;
+	u8 len;
+	u8 flags;
+	u8 type;
+	uuid_t uuid;
+	u32 fid[0];
+} __attribute__((packed));
+
+struct ovl_fh {
+	u8 padding[3];
+	union {
+		struct ovl_fb fb;
+		struct {
+			struct {} __empty_buf;
+			u8 buf[0];
+		};
+	};
+};
+
+struct ovl_cattr {
+	dev_t rdev;
+	umode_t mode;
+	const char *link;
+	struct dentry *hardlink;
+};
+
+struct ovl_copy_up_ctx {
+	struct dentry *parent;
+	struct dentry *dentry;
+	struct path lowerpath;
+	struct kstat stat;
+	struct kstat pstat;
+	const char *link;
+	struct dentry *destdir;
+	struct qstr destname;
+	struct dentry *workdir;
+	const struct ovl_fh *origin_fh;
+	bool origin;
+	bool indexed;
+	bool metacopy;
+	bool metacopy_digest;
+	bool metadata_fsync;
+};
+
+struct ovl_cu_creds {
+	const struct cred *old;
+	struct cred *new;
+};
+
+struct debugfs_blob_wrapper {
+	void *data;
+	long unsigned int size;
+};
+
+struct debugfs_reg32 {
+	char *name;
+	long unsigned int offset;
+};
+
+struct debugfs_regset32 {
+	const struct debugfs_reg32 *regs;
+	int nregs;
+	void *base;
+	struct device *dev;
+};
+
+struct debugfs_u32_array {
+	u32 *array;
+	u32 n_elements;
+};
+
+struct debugfs_devm_entry {
+	int (*read)(struct seq_file *, void *);
+	struct device *dev;
+};
+
+struct msgbuf {
+	__kernel_long_t mtype;
+	char mtext[1];
+};
+
+struct msg;
+
+struct msqid_ds {
+	struct ipc_perm msg_perm;
+	struct msg *msg_first;
+	struct msg *msg_last;
+	__kernel_old_time_t msg_stime;
+	__kernel_old_time_t msg_rtime;
+	__kernel_old_time_t msg_ctime;
+	long unsigned int msg_lcbytes;
+	long unsigned int msg_lqbytes;
+	short unsigned int msg_cbytes;
+	short unsigned int msg_qnum;
+	short unsigned int msg_qbytes;
+	__kernel_ipc_pid_t msg_lspid;
+	__kernel_ipc_pid_t msg_lrpid;
+};
+
+struct msqid64_ds {
+	struct ipc64_perm msg_perm;
+	long unsigned int msg_stime;
+	long unsigned int msg_stime_high;
+	long unsigned int msg_rtime;
+	long unsigned int msg_rtime_high;
+	long unsigned int msg_ctime;
+	long unsigned int msg_ctime_high;
+	long unsigned int msg_cbytes;
+	long unsigned int msg_qnum;
+	long unsigned int msg_qbytes;
+	__kernel_pid_t msg_lspid;
+	__kernel_pid_t msg_lrpid;
+	long unsigned int __unused4;
+	long unsigned int __unused5;
+};
+
+struct msginfo {
+	int msgpool;
+	int msgmap;
+	int msgmax;
+	int msgmnb;
+	int msgmni;
+	int msgssz;
+	int msgtql;
+	short unsigned int msgseg;
+};
+
+struct msg_msgseg;
+
+struct msg_msg {
+	struct list_head m_list;
+	long int m_type;
+	size_t m_ts;
+	struct msg_msgseg *next;
+	void *security;
+};
+
+struct msg_queue {
+	struct kern_ipc_perm q_perm;
+	time64_t q_stime;
+	time64_t q_rtime;
+	time64_t q_ctime;
+	long unsigned int q_cbytes;
+	long unsigned int q_qnum;
+	long unsigned int q_qbytes;
+	struct pid *q_lspid;
+	struct pid *q_lrpid;
+	struct list_head q_messages;
+	struct list_head q_receivers;
+	struct list_head q_senders;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct msg_receiver {
+	struct list_head r_list;
+	struct task_struct *r_tsk;
+	int r_mode;
+	long int r_msgtype;
+	long int r_maxsize;
+	struct msg_msg *r_msg;
+};
+
+struct msg_sender {
+	struct list_head list;
+	struct task_struct *tsk;
+	size_t msgsz;
+};
+
+struct keyctl_dh_params {
+	union {
+		__s32 private;
+		__s32 priv;
+	};
+	__s32 prime;
+	__s32 base;
+};
+
+struct keyctl_kdf_params {
+	char *hashname;
+	char *otherinfo;
+	__u32 otherinfolen;
+	__u32 __spare[8];
+};
+
+struct keyctl_pkey_query {
+	__u32 supported_ops;
+	__u32 key_size;
+	__u16 max_data_size;
+	__u16 max_sig_size;
+	__u16 max_enc_size;
+	__u16 max_dec_size;
+	__u32 __spare[10];
+};
+
+struct keyctl_pkey_params {
+	__s32 key_id;
+	__u32 in_len;
+	union {
+		__u32 out_len;
+		__u32 in2_len;
+	};
+	__u32 __spare[7];
+};
+
+struct user_key_payload {
+	struct callback_head rcu;
+	short unsigned int datalen;
+	long: 32;
+	char data[0];
+};
+
+struct rtattr {
+	short unsigned int rta_len;
+	short unsigned int rta_type;
+};
+
+struct crypto_queue {
+	struct list_head list;
+	struct list_head *backlog;
+	unsigned int qlen;
+	unsigned int max_qlen;
+};
+
+struct crypto_attr_alg {
+	char name[128];
+};
+
+struct crypto_attr_type {
+	u32 type;
+	u32 mask;
+};
+
+enum {
+	CRYPTO_MSG_ALG_REQUEST = 0,
+	CRYPTO_MSG_ALG_REGISTER = 1,
+	CRYPTO_MSG_ALG_LOADED = 2,
+};
+
+struct crypto_larval {
+	struct crypto_alg alg;
+	struct crypto_alg *adult;
+	struct completion completion;
+	u32 mask;
+	bool test_started;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+enum {
+	CRYPTOA_UNSPEC = 0,
+	CRYPTOA_ALG = 1,
+	CRYPTOA_TYPE = 2,
+	__CRYPTOA_MAX = 3,
+};
+
+struct bpf_crypto_type {
+	void * (*alloc_tfm)(const char *);
+	void (*free_tfm)(void *);
+	int (*has_algo)(const char *);
+	int (*setkey)(void *, const u8 *, unsigned int);
+	int (*setauthsize)(void *, unsigned int);
+	int (*encrypt)(void *, const u8 *, u8 *, unsigned int, u8 *);
+	int (*decrypt)(void *, const u8 *, u8 *, unsigned int, u8 *);
+	unsigned int (*ivsize)(void *);
+	unsigned int (*statesize)(void *);
+	u32 (*get_flags)(void *);
+	struct module *owner;
+	char name[14];
+};
+
+struct lskcipher_alg {
+	int (*setkey)(struct crypto_lskcipher *, const u8 *, unsigned int);
+	int (*encrypt)(struct crypto_lskcipher *, const u8 *, u8 *, unsigned int, u8 *, u32);
+	int (*decrypt)(struct crypto_lskcipher *, const u8 *, u8 *, unsigned int, u8 *, u32);
+	int (*init)(struct crypto_lskcipher *);
+	void (*exit)(struct crypto_lskcipher *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct skcipher_alg_common co;
+};
+
+struct crypto_report_hash {
+	char type[64];
+	unsigned int blocksize;
+	unsigned int digestsize;
+};
+
+struct shash_instance {
+	void (*free)(struct shash_instance *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct {
+			char head[128];
+			struct crypto_instance base;
+		} s;
+		struct shash_alg alg;
+	};
+};
+
+struct crypto_shash_spawn {
+	struct crypto_spawn base;
+};
+
+struct acomp_alg {
+	int (*compress)(struct acomp_req *);
+	int (*decompress)(struct acomp_req *);
+	void (*dst_free)(struct scatterlist *);
+	int (*init)(struct crypto_acomp *);
+	void (*exit)(struct crypto_acomp *);
+	unsigned int reqsize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct {
+			struct crypto_alg base;
+		};
+		struct comp_alg_common calg;
+	};
+};
+
+struct crypto_report_acomp {
+	char type[64];
+};
+
+struct crypto_rfc3686_ctx {
+	struct crypto_skcipher *child;
+	u8 nonce[4];
+};
+
+struct crypto_rfc3686_req_ctx {
+	u8 iv[16];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct skcipher_request subreq;
+};
+
+struct crypto_aes_ctx {
+	u32 key_enc[60];
+	u32 key_dec[60];
+	u32 key_length;
+};
+
+struct lzo_ctx {
+	void *lzo_comp_mem;
+};
+
+struct gf128mul_4k {
+	be128 t[256];
+};
+
+struct ghash_ctx {
+	struct gf128mul_4k *gf128;
+};
+
+struct ghash_desc_ctx {
+	u8 buffer[16];
+	u32 bytes;
+};
+
+struct io_uring_sqe;
+
+struct io_uring_cmd {
+	struct file *file;
+	const struct io_uring_sqe *sqe;
+	void (*task_work_cb)(struct io_uring_cmd *, unsigned int);
+	u32 cmd_op;
+	u32 flags;
+	u8 pdu[32];
+};
+
+typedef int (*writepage_t)(struct folio *, struct writeback_control *, void *);
+
+struct io_uring_sqe {
+	__u8 opcode;
+	__u8 flags;
+	__u16 ioprio;
+	__s32 fd;
+	union {
+		__u64 off;
+		__u64 addr2;
+		struct {
+			__u32 cmd_op;
+			__u32 __pad1;
+		};
+	};
+	union {
+		__u64 addr;
+		__u64 splice_off_in;
+		struct {
+			__u32 level;
+			__u32 optname;
+		};
+	};
+	__u32 len;
+	union {
+		__kernel_rwf_t rw_flags;
+		__u32 fsync_flags;
+		__u16 poll_events;
+		__u32 poll32_events;
+		__u32 sync_range_flags;
+		__u32 msg_flags;
+		__u32 timeout_flags;
+		__u32 accept_flags;
+		__u32 cancel_flags;
+		__u32 open_flags;
+		__u32 statx_flags;
+		__u32 fadvise_advice;
+		__u32 splice_flags;
+		__u32 rename_flags;
+		__u32 unlink_flags;
+		__u32 hardlink_flags;
+		__u32 xattr_flags;
+		__u32 msg_ring_flags;
+		__u32 uring_cmd_flags;
+		__u32 waitid_flags;
+		__u32 futex_flags;
+		__u32 install_fd_flags;
+		__u32 nop_flags;
+	};
+	__u64 user_data;
+	union {
+		__u16 buf_index;
+		__u16 buf_group;
+	};
+	__u16 personality;
+	union {
+		__s32 splice_fd_in;
+		__u32 file_index;
+		__u32 optlen;
+		struct {
+			__u16 addr_len;
+			__u16 __pad3[1];
+		};
+	};
+	union {
+		struct {
+			__u64 addr3;
+			__u64 __pad2[1];
+		};
+		__u64 optval;
+		__u8 cmd[0];
+	};
+};
+
+enum {
+	DIO_SHOULD_DIRTY = 1,
+	DIO_IS_SYNC = 2,
+};
+
+struct blkdev_dio {
+	union {
+		struct kiocb *iocb;
+		struct task_struct *waiter;
+	};
+	size_t size;
+	atomic_t ref;
+	unsigned int flags;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct bio bio;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+enum rpm_status {
+	RPM_INVALID = -1,
+	RPM_ACTIVE = 0,
+	RPM_RESUMING = 1,
+	RPM_SUSPENDED = 2,
+	RPM_SUSPENDING = 3,
+};
+
+struct disk_stats {
+	u64 nsecs[4];
+	long unsigned int sectors[4];
+	long unsigned int ios[4];
+	long unsigned int merges[4];
+	long unsigned int io_ticks;
+	local_t in_flight[2];
+	long: 32;
+};
+
+enum stat_group {
+	STAT_READ = 0,
+	STAT_WRITE = 1,
+	STAT_DISCARD = 2,
+	STAT_FLUSH = 3,
+	NR_STAT_GROUPS = 4,
+};
+
+struct blk_plug_cb;
+
+typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);
+
+struct blk_plug_cb {
+	struct list_head list;
+	blk_plug_cb_fn callback;
+	void *data;
+};
+
+enum {
+	BLK_MQ_REQ_NOWAIT = 1,
+	BLK_MQ_REQ_RESERVED = 2,
+	BLK_MQ_REQ_PM = 4,
+};
+
+enum {
+	sysctl_hung_task_timeout_secs = 0,
+};
+
+struct trace_event_raw_block_buffer {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	sector_t sector;
+	size_t size;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_block_rq_requeue {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	sector_t sector;
+	unsigned int nr_sector;
+	short unsigned int ioprio;
+	char rwbs[8];
+	u32 __data_loc_cmd;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_block_rq_completion {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	sector_t sector;
+	unsigned int nr_sector;
+	int error;
+	short unsigned int ioprio;
+	char rwbs[8];
+	u32 __data_loc_cmd;
+	char __data[0];
+};
+
+struct trace_event_raw_block_rq {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	sector_t sector;
+	unsigned int nr_sector;
+	unsigned int bytes;
+	short unsigned int ioprio;
+	char rwbs[8];
+	char comm[16];
+	u32 __data_loc_cmd;
+	char __data[0];
+};
+
+struct trace_event_raw_block_bio_complete {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	sector_t sector;
+	unsigned int nr_sector;
+	int error;
+	char rwbs[8];
+	char __data[0];
+};
+
+struct trace_event_raw_block_bio {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	sector_t sector;
+	unsigned int nr_sector;
+	char rwbs[8];
+	char comm[16];
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_block_plug {
+	struct trace_entry ent;
+	char comm[16];
+	char __data[0];
+};
+
+struct trace_event_raw_block_unplug {
+	struct trace_entry ent;
+	int nr_rq;
+	char comm[16];
+	char __data[0];
+};
+
+struct trace_event_raw_block_split {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	sector_t sector;
+	sector_t new_sector;
+	char rwbs[8];
+	char comm[16];
+	char __data[0];
+};
+
+struct trace_event_raw_block_bio_remap {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	sector_t sector;
+	unsigned int nr_sector;
+	dev_t old_dev;
+	sector_t old_sector;
+	char rwbs[8];
+	char __data[0];
+};
+
+struct trace_event_raw_block_rq_remap {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	sector_t sector;
+	unsigned int nr_sector;
+	dev_t old_dev;
+	sector_t old_sector;
+	unsigned int nr_bios;
+	char rwbs[8];
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_data_offsets_block_buffer {};
+
+struct trace_event_data_offsets_block_rq_requeue {
+	u32 cmd;
+	const void *cmd_ptr_;
+};
+
+struct trace_event_data_offsets_block_rq_completion {
+	u32 cmd;
+	const void *cmd_ptr_;
+};
+
+struct trace_event_data_offsets_block_rq {
+	u32 cmd;
+	const void *cmd_ptr_;
+};
+
+struct trace_event_data_offsets_block_bio_complete {};
+
+struct trace_event_data_offsets_block_bio {};
+
+struct trace_event_data_offsets_block_plug {};
+
+struct trace_event_data_offsets_block_unplug {};
+
+struct trace_event_data_offsets_block_split {};
+
+struct trace_event_data_offsets_block_bio_remap {};
+
+struct trace_event_data_offsets_block_rq_remap {};
+
+typedef void (*btf_trace_block_touch_buffer)(void *, struct buffer_head *);
+
+typedef void (*btf_trace_block_dirty_buffer)(void *, struct buffer_head *);
+
+typedef void (*btf_trace_block_rq_requeue)(void *, struct request *);
+
+typedef void (*btf_trace_block_rq_complete)(void *, struct request *, blk_status_t, unsigned int);
+
+typedef void (*btf_trace_block_rq_error)(void *, struct request *, blk_status_t, unsigned int);
+
+typedef void (*btf_trace_block_rq_insert)(void *, struct request *);
+
+typedef void (*btf_trace_block_rq_issue)(void *, struct request *);
+
+typedef void (*btf_trace_block_rq_merge)(void *, struct request *);
+
+typedef void (*btf_trace_block_io_start)(void *, struct request *);
+
+typedef void (*btf_trace_block_io_done)(void *, struct request *);
+
+typedef void (*btf_trace_block_bio_complete)(void *, struct request_queue *, struct bio *);
+
+typedef void (*btf_trace_block_bio_bounce)(void *, struct bio *);
+
+typedef void (*btf_trace_block_bio_backmerge)(void *, struct bio *);
+
+typedef void (*btf_trace_block_bio_frontmerge)(void *, struct bio *);
+
+typedef void (*btf_trace_block_bio_queue)(void *, struct bio *);
+
+typedef void (*btf_trace_block_getrq)(void *, struct bio *);
+
+typedef void (*btf_trace_block_plug)(void *, struct request_queue *);
+
+typedef void (*btf_trace_block_unplug)(void *, struct request_queue *, unsigned int, bool);
+
+typedef void (*btf_trace_block_split)(void *, struct bio *, unsigned int);
+
+typedef void (*btf_trace_block_bio_remap)(void *, struct bio *, dev_t, sector_t);
+
+typedef void (*btf_trace_block_rq_remap)(void *, struct request *, dev_t, sector_t);
+
+typedef struct blkcg_policy_data *blkcg_pol_alloc_cpd_fn(gfp_t);
+
+typedef void blkcg_pol_free_cpd_fn(struct blkcg_policy_data *);
+
+typedef struct blkg_policy_data *blkcg_pol_alloc_pd_fn(struct gendisk *, struct blkcg *, gfp_t);
+
+typedef void blkcg_pol_init_pd_fn(struct blkg_policy_data *);
+
+typedef void blkcg_pol_online_pd_fn(struct blkg_policy_data *);
+
+typedef void blkcg_pol_offline_pd_fn(struct blkg_policy_data *);
+
+typedef void blkcg_pol_free_pd_fn(struct blkg_policy_data *);
+
+typedef void blkcg_pol_reset_pd_stats_fn(struct blkg_policy_data *);
+
+typedef void blkcg_pol_stat_pd_fn(struct blkg_policy_data *, struct seq_file *);
+
+struct blkcg_policy {
+	int plid;
+	struct cftype *dfl_cftypes;
+	struct cftype *legacy_cftypes;
+	blkcg_pol_alloc_cpd_fn *cpd_alloc_fn;
+	blkcg_pol_free_cpd_fn *cpd_free_fn;
+	blkcg_pol_alloc_pd_fn *pd_alloc_fn;
+	blkcg_pol_init_pd_fn *pd_init_fn;
+	blkcg_pol_online_pd_fn *pd_online_fn;
+	blkcg_pol_offline_pd_fn *pd_offline_fn;
+	blkcg_pol_free_pd_fn *pd_free_fn;
+	blkcg_pol_reset_pd_stats_fn *pd_reset_stats_fn;
+	blkcg_pol_stat_pd_fn *pd_stat_fn;
+};
+
+enum blkg_rwstat_type {
+	BLKG_RWSTAT_READ = 0,
+	BLKG_RWSTAT_WRITE = 1,
+	BLKG_RWSTAT_SYNC = 2,
+	BLKG_RWSTAT_ASYNC = 3,
+	BLKG_RWSTAT_DISCARD = 4,
+	BLKG_RWSTAT_NR = 5,
+	BLKG_RWSTAT_TOTAL = 5,
+};
+
+struct blkg_rwstat {
+	struct percpu_counter cpu_cnt[5];
+	atomic64_t aux_cnt[5];
+};
+
+struct throtl_grp;
+
+struct throtl_qnode {
+	struct list_head node;
+	struct bio_list bios;
+	struct throtl_grp *tg;
+};
+
+struct throtl_service_queue {
+	struct throtl_service_queue *parent_sq;
+	struct list_head queued[2];
+	unsigned int nr_queued[2];
+	struct rb_root_cached pending_tree;
+	unsigned int nr_pending;
+	long unsigned int first_pending_disptime;
+	struct timer_list pending_timer;
+};
+
+struct throtl_grp {
+	struct blkg_policy_data pd;
+	struct rb_node rb_node;
+	struct throtl_data *td;
+	struct throtl_service_queue service_queue;
+	struct throtl_qnode qnode_on_self[2];
+	struct throtl_qnode qnode_on_parent[2];
+	long unsigned int disptime;
+	unsigned int flags;
+	bool has_rules_bps[2];
+	bool has_rules_iops[2];
+	uint64_t bps[2];
+	unsigned int iops[2];
+	uint64_t bytes_disp[2];
+	unsigned int io_disp[2];
+	uint64_t last_bytes_disp[2];
+	unsigned int last_io_disp[2];
+	long long int carryover_bytes[2];
+	int carryover_ios[2];
+	long unsigned int last_check_time;
+	long unsigned int slice_start[2];
+	long unsigned int slice_end[2];
+	long: 32;
+	struct blkg_rwstat stat_bytes;
+	struct blkg_rwstat stat_ios;
+};
+
+typedef bool (*sb_for_each_fn)(struct sbitmap *, unsigned int, void *);
+
+enum rq_qos_id {
+	RQ_QOS_WBT = 0,
+	RQ_QOS_LATENCY = 1,
+	RQ_QOS_COST = 2,
+};
+
+struct rq_qos_ops;
+
+struct rq_qos {
+	const struct rq_qos_ops *ops;
+	struct gendisk *disk;
+	enum rq_qos_id id;
+	struct rq_qos *next;
+};
+
+typedef bool busy_tag_iter_fn(struct request *, void *);
+
+enum {
+	BLK_MQ_S_STOPPED = 0,
+	BLK_MQ_S_TAG_ACTIVE = 1,
+	BLK_MQ_S_SCHED_RESTART = 2,
+	BLK_MQ_S_INACTIVE = 3,
+	BLK_MQ_S_MAX = 4,
+};
+
+enum {
+	BLK_MQ_UNIQUE_TAG_BITS = 16,
+	BLK_MQ_UNIQUE_TAG_MASK = 65535,
+};
+
+enum {
+	BLK_MQ_NO_TAG = 4294967295,
+	BLK_MQ_TAG_MIN = 1,
+	BLK_MQ_TAG_MAX = 4294967294,
+};
+
+struct blk_mq_debugfs_attr;
+
+struct rq_qos_ops {
+	void (*throttle)(struct rq_qos *, struct bio *);
+	void (*track)(struct rq_qos *, struct request *, struct bio *);
+	void (*merge)(struct rq_qos *, struct request *, struct bio *);
+	void (*issue)(struct rq_qos *, struct request *);
+	void (*requeue)(struct rq_qos *, struct request *);
+	void (*done)(struct rq_qos *, struct request *);
+	void (*done_bio)(struct rq_qos *, struct bio *);
+	void (*cleanup)(struct rq_qos *, struct bio *);
+	void (*queue_depth_changed)(struct rq_qos *);
+	void (*exit)(struct rq_qos *);
+	const struct blk_mq_debugfs_attr *debugfs_attrs;
+};
+
+struct mq_inflight {
+	struct block_device *part;
+	unsigned int inflight[2];
+};
+
+struct blk_rq_wait {
+	struct completion done;
+	blk_status_t ret;
+};
+
+struct blk_expired_data {
+	bool has_timedout_rq;
+	long unsigned int next;
+	long unsigned int timeout_start;
+};
+
+struct flush_busy_ctx_data {
+	struct blk_mq_hw_ctx *hctx;
+	struct list_head *list;
+};
+
+struct dispatch_rq_data {
+	struct blk_mq_hw_ctx *hctx;
+	struct request *rq;
+};
+
+enum prep_dispatch {
+	PREP_DISPATCH_OK = 0,
+	PREP_DISPATCH_NO_TAG = 1,
+	PREP_DISPATCH_NO_BUDGET = 2,
+};
+
+struct rq_iter_data {
+	struct blk_mq_hw_ctx *hctx;
+	bool has_rq;
+};
+
+struct blk_mq_qe_pair {
+	struct list_head node;
+	struct request_queue *q;
+	struct elevator_type *type;
+};
+
+struct class_dev_iter {
+	struct klist_iter ki;
+	const struct device_type *type;
+	struct subsys_private *sp;
+};
+
+enum {
+	GENHD_FL_REMOVABLE = 1,
+	GENHD_FL_HIDDEN = 2,
+	GENHD_FL_NO_PART = 4,
+};
+
+struct badblocks {
+	struct device *dev;
+	int count;
+	int unacked_exist;
+	int shift;
+	u64 *page;
+	int changed;
+	seqlock_t lock;
+	sector_t sector;
+	sector_t size;
+};
+
+struct blk_major_name {
+	struct blk_major_name *next;
+	int major;
+	char name[16];
+	void (*probe)(dev_t);
+};
+
+struct parsed_partitions {
+	struct gendisk *disk;
+	char name[32];
+	struct {
+		sector_t from;
+		sector_t size;
+		int flags;
+		bool has_info;
+		struct partition_meta_info info;
+		long: 32;
+	} *parts;
+	int next;
+	int limit;
+	bool access_beyond_eod;
+	char *pp_buf;
+};
+
+typedef struct {
+	struct folio *v;
+} Sector;
+
+struct rq_wait {
+	wait_queue_head_t wait;
+	atomic_t inflight;
+};
+
+struct rq_depth {
+	unsigned int max_depth;
+	int scale_step;
+	bool scaled_max;
+	unsigned int queue_depth;
+	unsigned int default_depth;
+};
+
+typedef bool acquire_inflight_cb_t(struct rq_wait *, void *);
+
+typedef void cleanup_cb_t(struct rq_wait *, void *);
+
+struct rq_qos_wait_data {
+	struct wait_queue_entry wq;
+	struct task_struct *task;
+	struct rq_wait *rqw;
+	acquire_inflight_cb_t *cb;
+	void *private_data;
+	bool got_token;
+};
+
+struct uuidcmp {
+	const char *uuid;
+	int len;
+};
+
+struct blkg_conf_ctx {
+	char *input;
+	char *body;
+	struct block_device *bdev;
+	struct blkcg_gq *blkg;
+};
+
+struct bd_holder_disk {
+	struct list_head list;
+	struct kobject *holder_dir;
+	int refcnt;
+};
+
+typedef struct {
+	__u8 b[16];
+} guid_t;
+
+struct iov_iter_state {
+	size_t iov_offset;
+	size_t count;
+	long unsigned int nr_segs;
+};
+
+typedef u32 compat_size_t;
+
+typedef s32 compat_ssize_t;
+
+typedef u32 compat_uptr_t;
+
+struct compat_iovec {
+	compat_uptr_t iov_base;
+	compat_size_t iov_len;
+};
+
+struct reciprocal_value_adv {
+	u32 m;
+	u8 sh;
+	u8 exp;
+	bool is_wide_m;
+};
+
+struct arc4_ctx {
+	u32 S[256];
+	u32 x;
+	u32 y;
+};
+
+typedef struct {
+	__le64 b;
+	__le64 a;
+} le128;
+
+struct gf128mul_64k {
+	struct gf128mul_4k *t[16];
+};
+
+typedef void sha256_block_fn(struct sha256_state *, const u8 *, int);
+
+struct xxh32_state {
+	uint32_t total_len_32;
+	uint32_t large_len;
+	uint32_t v1;
+	uint32_t v2;
+	uint32_t v3;
+	uint32_t v4;
+	uint32_t mem32[4];
+	uint32_t memsize;
+};
+
+typedef enum {
+	CODES = 0,
+	LENS = 1,
+	DISTS = 2,
+} codetype;
+
+struct inflate_workspace {
+	struct inflate_state inflate_state;
+	unsigned char working_window[32768];
+};
+
+typedef struct tree_desc_s tree_desc;
+
+typedef ZSTD_CDict zstd_cdict;
+
+typedef ZSTD_CStream zstd_cstream;
+
+typedef struct {
+	BYTE tableLog;
+	BYTE maxSymbolValue;
+	BYTE unused[2];
+} HUF_CTableHeader;
+
+struct nodeElt_s {
+	U32 count;
+	U16 parent;
+	BYTE byte;
+	BYTE nbBits;
+};
+
+typedef struct nodeElt_s nodeElt;
+
+typedef struct {
+	FSE_CTable CTable[59];
+	U32 scratchBuffer[41];
+	unsigned int count[13];
+	S16 norm[13];
+} HUF_CompressWeightsWksp;
+
+typedef struct {
+	HUF_CompressWeightsWksp wksp;
+	BYTE bitsToWeight[13];
+	BYTE huffWeight[255];
+} HUF_WriteCTableWksp;
+
+typedef struct {
+	U16 base;
+	U16 curr;
+} rankPos;
+
+typedef nodeElt huffNodeTable[512];
+
+typedef struct {
+	huffNodeTable huffNodeTbl;
+	rankPos rankPosition[192];
+} HUF_buildCTable_wksp_tables;
+
+typedef struct {
+	size_t bitContainer[2];
+	size_t bitPos[2];
+	BYTE *startPtr;
+	BYTE *ptr;
+	BYTE *endPtr;
+} HUF_CStream_t;
+
+typedef enum {
+	HUF_singleStream = 0,
+	HUF_fourStreams = 1,
+} HUF_nbStreams_e;
+
+typedef struct {
+	unsigned int count[256];
+	HUF_CElt CTable[257];
+	union {
+		HUF_buildCTable_wksp_tables buildCTable_wksp;
+		HUF_WriteCTableWksp writeCTable_wksp;
+		U32 hist_wksp[1024];
+	} wksps;
+} HUF_compress_tables_t;
+
+typedef struct {
+	U64 rolling;
+	U64 stopMask;
+} ldmRollingHashState_t;
+
+typedef size_t (*HUF_DecompressUsingDTableFn)(void *, size_t, const void *, size_t, const HUF_DTable *);
+
+typedef struct {
+	BYTE maxTableLog;
+	BYTE tableType;
+	BYTE tableLog;
+	BYTE reserved;
+} DTableDesc;
+
+typedef struct {
+	const BYTE *ip[4];
+	BYTE *op[4];
+	U64 bits[4];
+	const void *dt;
+	const BYTE *ilowest;
+	BYTE *oend;
+	const BYTE *iend[4];
+	long: 32;
+} HUF_DecompressFastArgs;
+
+typedef void (*HUF_DecompressFastLoopFn)(HUF_DecompressFastArgs *);
+
+typedef struct {
+	BYTE nbBits;
+	BYTE byte;
+} HUF_DEltX1;
+
+typedef struct {
+	U32 rankVal[13];
+	U32 rankStart[13];
+	U32 statsWksp[219];
+	BYTE symbols[256];
+	BYTE huffWeight[256];
+} HUF_ReadDTableX1_Workspace;
+
+typedef struct {
+	U16 sequence;
+	BYTE nbBits;
+	BYTE length;
+} HUF_DEltX2;
+
+typedef struct {
+	BYTE symbol;
+} sortedSymbol_t;
+
+typedef U32 rankValCol_t[13];
+
+typedef struct {
+	U32 rankVal[156];
+	U32 rankStats[13];
+	U32 rankStart0[15];
+	sortedSymbol_t sortedSymbol[256];
+	BYTE weightList[256];
+	U32 calleeWksp[219];
+} HUF_ReadDTableX2_Workspace;
+
+typedef struct {
+	U32 tableTime;
+	U32 decode256Time;
+} algo_time_t;
+
+typedef ZSTD_ErrorCode ERR_enum;
+
+typedef unsigned int FSE_DTable;
+
+typedef struct {
+	size_t state;
+	const void *table;
+} FSE_DState_t;
+
+typedef struct {
+	U16 tableLog;
+	U16 fastMode;
+} FSE_DTableHeader;
+
+typedef struct {
+	short unsigned int newState;
+	unsigned char symbol;
+	unsigned char nbBits;
+} FSE_decode_t;
+
+typedef struct {
+	short int ncount[256];
+} FSE_DecompressWksp;
+
+typedef uint64_t vli_type;
+
+enum xz_check {
+	XZ_CHECK_NONE = 0,
+	XZ_CHECK_CRC32 = 1,
+	XZ_CHECK_CRC64 = 4,
+	XZ_CHECK_SHA256 = 10,
+};
+
+struct xz_dec_hash {
+	vli_type unpadded;
+	vli_type uncompressed;
+	uint32_t crc32;
+	long: 32;
+};
+
+struct xz_dec_bcj;
+
+struct xz_dec {
+	enum {
+		SEQ_STREAM_HEADER = 0,
+		SEQ_BLOCK_START = 1,
+		SEQ_BLOCK_HEADER = 2,
+		SEQ_BLOCK_UNCOMPRESS = 3,
+		SEQ_BLOCK_PADDING = 4,
+		SEQ_BLOCK_CHECK = 5,
+		SEQ_INDEX = 6,
+		SEQ_INDEX_PADDING = 7,
+		SEQ_INDEX_CRC32 = 8,
+		SEQ_STREAM_FOOTER = 9,
+	} sequence;
+	uint32_t pos;
+	vli_type vli;
+	size_t in_start;
+	size_t out_start;
+	uint32_t crc32;
+	enum xz_check check_type;
+	enum xz_mode mode;
+	bool allow_buf_error;
+	struct {
+		vli_type compressed;
+		vli_type uncompressed;
+		uint32_t size;
+		long: 32;
+	} block_header;
+	struct {
+		vli_type compressed;
+		vli_type uncompressed;
+		vli_type count;
+		struct xz_dec_hash hash;
+	} block;
+	struct {
+		enum {
+			SEQ_INDEX_COUNT = 0,
+			SEQ_INDEX_UNPADDED = 1,
+			SEQ_INDEX_UNCOMPRESSED = 2,
+		} sequence;
+		long: 32;
+		vli_type size;
+		vli_type count;
+		struct xz_dec_hash hash;
+	} index;
+	struct {
+		size_t pos;
+		size_t size;
+		uint8_t buf[1024];
+	} temp;
+	struct xz_dec_lzma2 *lzma2;
+	struct xz_dec_bcj *bcj;
+	bool bcj_active;
+	long: 32;
+};
+
+struct xz_dec_bcj {
+	enum {
+		BCJ_X86 = 4,
+		BCJ_POWERPC = 5,
+		BCJ_IA64 = 6,
+		BCJ_ARM = 7,
+		BCJ_ARMTHUMB = 8,
+		BCJ_SPARC = 9,
+		BCJ_ARM64 = 10,
+		BCJ_RISCV = 11,
+	} type;
+	enum xz_ret ret;
+	bool single_call;
+	uint32_t pos;
+	uint32_t x86_prev_mask;
+	uint8_t *out;
+	size_t out_pos;
+	size_t out_size;
+	struct {
+		size_t filtered;
+		size_t size;
+		uint8_t buf[16];
+	} temp;
+};
+
+typedef struct {
+	size_t (*Write)(void *, const void *, size_t);
+} ISeqOutStream;
+
+typedef unsigned int CState;
+
+typedef struct {
+	UInt32 price;
+	CState state;
+	int prev1IsChar;
+	int prev2;
+	UInt32 posPrev2;
+	UInt32 backPrev2;
+	UInt32 posPrev;
+	UInt32 backPrev;
+	UInt32 backs[4];
+} COptimal;
+
+typedef struct {
+	UInt16 choice;
+	UInt16 choice2;
+	UInt16 low[128];
+	UInt16 mid[128];
+	UInt16 high[256];
+} CLenEnc;
+
+typedef struct {
+	CLenEnc p;
+	UInt32 prices[4352];
+	UInt32 tableSize;
+	UInt32 counters[16];
+} CLenPriceEnc;
+
+typedef struct {
+	UInt32 range;
+	Byte cache;
+	UInt64 low;
+	UInt64 cacheSize;
+	Byte *buf;
+	Byte *bufLim;
+	Byte *bufBase;
+	ISeqOutStream *outStream;
+	UInt64 processed;
+	SRes res;
+	long: 32;
+} CRangeEnc;
+
+typedef struct {
+	UInt16 *litProbs;
+	UInt16 isMatch[192];
+	UInt16 isRep[12];
+	UInt16 isRepG0[12];
+	UInt16 isRepG1[12];
+	UInt16 isRepG2[12];
+	UInt16 isRep0Long[192];
+	UInt16 posSlotEncoder[256];
+	UInt16 posEncoders[114];
+	UInt16 posAlignEncoder[16];
+	CLenPriceEnc lenEnc;
+	CLenPriceEnc repLenEnc;
+	UInt32 reps[4];
+	UInt32 state;
+} CSaveState;
+
+typedef struct {
+	IMatchFinder matchFinder;
+	void *matchFinderObj;
+	CMatchFinder matchFinderBase;
+	UInt32 optimumEndIndex;
+	UInt32 optimumCurrentIndex;
+	UInt32 longestMatchLength;
+	UInt32 numPairs;
+	UInt32 numAvail;
+	COptimal opt[4096];
+	Byte g_FastPos[2048];
+	UInt32 ProbPrices[128];
+	UInt32 matches[549];
+	UInt32 numFastBytes;
+	UInt32 additionalOffset;
+	UInt32 reps[4];
+	UInt32 state;
+	UInt32 posSlotPrices[256];
+	UInt32 distancesPrices[512];
+	UInt32 alignPrices[16];
+	UInt32 alignPriceCount;
+	UInt32 distTableSize;
+	unsigned int lc;
+	unsigned int lp;
+	unsigned int pb;
+	unsigned int lpMask;
+	unsigned int pbMask;
+	UInt16 *litProbs;
+	UInt16 isMatch[192];
+	UInt16 isRep[12];
+	UInt16 isRepG0[12];
+	UInt16 isRepG1[12];
+	UInt16 isRepG2[12];
+	UInt16 isRep0Long[192];
+	UInt16 posSlotEncoder[256];
+	UInt16 posEncoders[114];
+	UInt16 posAlignEncoder[16];
+	CLenPriceEnc lenEnc;
+	CLenPriceEnc repLenEnc;
+	unsigned int lclp;
+	Bool fastMode;
+	long: 32;
+	CRangeEnc rc;
+	Bool writeEndMark;
+	long: 32;
+	UInt64 nowPos64;
+	UInt32 matchPriceCount;
+	Bool finished;
+	Bool multiThread;
+	SRes result;
+	UInt32 dictSize;
+	UInt32 matchFinderCycles;
+	int needInit;
+	CSaveState saveState;
+} CLzmaEnc;
+
+typedef struct {
+	ISeqOutStream funcTable;
+	Byte *data;
+	SizeT rem;
+	Bool overflow;
+} CSeqOutStreamBuf;
+
+enum dim_tune_state {
+	DIM_PARKING_ON_TOP = 0,
+	DIM_PARKING_TIRED = 1,
+	DIM_GOING_RIGHT = 2,
+	DIM_GOING_LEFT = 3,
+};
+
+enum dim_cq_period_mode {
+	DIM_CQ_PERIOD_MODE_START_FROM_EQE = 0,
+	DIM_CQ_PERIOD_MODE_START_FROM_CQE = 1,
+	DIM_CQ_PERIOD_NUM_MODES = 2,
+};
+
+enum dim_state {
+	DIM_START_MEASURE = 0,
+	DIM_MEASURE_IN_PROGRESS = 1,
+	DIM_APPLY_NEW_PROFILE = 2,
+};
+
+enum dim_stats_state {
+	DIM_STATS_WORSE = 0,
+	DIM_STATS_SAME = 1,
+	DIM_STATS_BETTER = 2,
+};
+
+enum dim_step_result {
+	DIM_STEPPED = 0,
+	DIM_TOO_TIRED = 1,
+	DIM_ON_EDGE = 2,
+};
+
+struct gic_quirk {
+	const char *desc;
+	const char *compatible;
+	const char *property;
+	bool (*init)(void *);
+	u32 iidr;
+	u32 mask;
+};
+
+struct phy_provider {
+	struct device *dev;
+	struct device_node *children;
+	struct module *owner;
+	struct list_head list;
+	struct phy * (*of_xlate)(struct device *, const struct of_phandle_args *);
+};
+
+enum bcm_usb_phy_version {
+	BCM_SR_USB_COMBO_PHY = 0,
+	BCM_SR_USB_HS_PHY = 1,
+};
+
+enum bcm_usb_phy_reg {
+	PLL_CTRL = 0,
+	PHY_CTRL = 1,
+	PHY_PLL_CTRL = 2,
+};
+
+enum pll_ctrl_bits {
+	PLL_RESETB = 0,
+	SSPLL_SUSPEND_EN = 1,
+	PLL_SEQ_START = 2,
+	PLL_LOCK = 3,
+};
+
+enum bcm_usb_phy_ctrl_bits {
+	CORERDY = 0,
+	PHY_RESETB = 1,
+	PHY_PCTL = 2,
+};
+
+struct bcm_usb_phy_cfg {
+	uint32_t type;
+	uint32_t version;
+	void *regs;
+	struct phy *phy;
+	const u8 *offset;
+};
+
+enum bcm_usb_phy_type {
+	USB_HS_PHY = 0,
+	USB_SS_PHY = 1,
+};
+
+struct ns_pinctrl {
+	struct device *dev;
+	unsigned int chipset_flag;
+	struct pinctrl_dev *pctldev;
+	void *base;
+	struct pinctrl_desc pctldesc;
+};
+
+struct ns_pinctrl_group {
+	const char *name;
+	unsigned int *pins;
+	const unsigned int num_pins;
+	unsigned int chipsets;
+};
+
+struct ns_pinctrl_function {
+	const char *name;
+	const char * const *groups;
+	const unsigned int num_groups;
+	unsigned int chipsets;
+};
+
+struct iproc_gpio_chip {
+	struct gpio_chip gc;
+	spinlock_t lock;
+	struct device *dev;
+	void *base;
+	void *intr;
+};
+
+struct mc_subled {
+	unsigned int color_index;
+	unsigned int brightness;
+	unsigned int intensity;
+	unsigned int channel;
+};
+
+struct led_classdev_mc {
+	struct led_classdev led_cdev;
+	unsigned int num_colors;
+	struct mc_subled *subled_info;
+};
+
+struct hotplug_slot_ops;
+
+struct hotplug_slot {
+	const struct hotplug_slot_ops *ops;
+	struct list_head slot_list;
+	struct pci_slot *pci_slot;
+	struct module *owner;
+	const char *mod_name;
+};
+
+enum pci_dev_flags {
+	PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
+	PCI_DEV_FLAGS_NO_D3 = 2,
+	PCI_DEV_FLAGS_ASSIGNED = 4,
+	PCI_DEV_FLAGS_ACS_ENABLED_QUIRK = 8,
+	PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS = 32,
+	PCI_DEV_FLAGS_NO_BUS_RESET = 64,
+	PCI_DEV_FLAGS_NO_PM_RESET = 128,
+	PCI_DEV_FLAGS_VPD_REF_F0 = 256,
+	PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT = 512,
+	PCI_DEV_FLAGS_NO_FLR_RESET = 1024,
+	PCI_DEV_FLAGS_NO_RELAXED_ORDERING = 2048,
+	PCI_DEV_FLAGS_HAS_MSI_MASKING = 4096,
+};
+
+enum pci_bus_flags {
+	PCI_BUS_FLAGS_NO_MSI = 1,
+	PCI_BUS_FLAGS_NO_MMRBC = 2,
+	PCI_BUS_FLAGS_NO_AERSID = 4,
+	PCI_BUS_FLAGS_NO_EXTCFG = 8,
+};
+
+enum pci_bus_speed {
+	PCI_SPEED_33MHz = 0,
+	PCI_SPEED_66MHz = 1,
+	PCI_SPEED_66MHz_PCIX = 2,
+	PCI_SPEED_100MHz_PCIX = 3,
+	PCI_SPEED_133MHz_PCIX = 4,
+	PCI_SPEED_66MHz_PCIX_ECC = 5,
+	PCI_SPEED_100MHz_PCIX_ECC = 6,
+	PCI_SPEED_133MHz_PCIX_ECC = 7,
+	PCI_SPEED_66MHz_PCIX_266 = 9,
+	PCI_SPEED_100MHz_PCIX_266 = 10,
+	PCI_SPEED_133MHz_PCIX_266 = 11,
+	AGP_UNKNOWN = 12,
+	AGP_1X = 13,
+	AGP_2X = 14,
+	AGP_4X = 15,
+	AGP_8X = 16,
+	PCI_SPEED_66MHz_PCIX_533 = 17,
+	PCI_SPEED_100MHz_PCIX_533 = 18,
+	PCI_SPEED_133MHz_PCIX_533 = 19,
+	PCIE_SPEED_2_5GT = 20,
+	PCIE_SPEED_5_0GT = 21,
+	PCIE_SPEED_8_0GT = 22,
+	PCIE_SPEED_16_0GT = 23,
+	PCIE_SPEED_32_0GT = 24,
+	PCIE_SPEED_64_0GT = 25,
+	PCI_SPEED_UNKNOWN = 255,
+};
+
+enum pcie_bus_config_types {
+	PCIE_BUS_TUNE_OFF = 0,
+	PCIE_BUS_DEFAULT = 1,
+	PCIE_BUS_SAFE = 2,
+	PCIE_BUS_PERFORMANCE = 3,
+	PCIE_BUS_PEER2PEER = 4,
+};
+
+enum pci_fixup_pass {
+	pci_fixup_early = 0,
+	pci_fixup_header = 1,
+	pci_fixup_final = 2,
+	pci_fixup_enable = 3,
+	pci_fixup_resume = 4,
+	pci_fixup_suspend = 5,
+	pci_fixup_resume_early = 6,
+	pci_fixup_suspend_late = 7,
+};
+
+struct hotplug_slot_ops {
+	int (*enable_slot)(struct hotplug_slot *);
+	int (*disable_slot)(struct hotplug_slot *);
+	int (*set_attention_status)(struct hotplug_slot *, u8);
+	int (*hardware_test)(struct hotplug_slot *, u32);
+	int (*get_power_status)(struct hotplug_slot *, u8 *);
+	int (*get_attention_status)(struct hotplug_slot *, u8 *);
+	int (*get_latch_status)(struct hotplug_slot *, u8 *);
+	int (*get_adapter_status)(struct hotplug_slot *, u8 *);
+	int (*reset_slot)(struct hotplug_slot *, bool);
+};
+
+enum pci_bar_type {
+	pci_bar_unknown = 0,
+	pci_bar_io = 1,
+	pci_bar_mem32 = 2,
+	pci_bar_mem64 = 3,
+};
+
+struct pci_domain_busn_res {
+	struct list_head list;
+	struct resource res;
+	int domain_nr;
+};
+
+struct dmi_strmatch {
+	unsigned char slot: 7;
+	unsigned char exact_match: 1;
+	char substr[79];
+};
+
+struct dmi_system_id {
+	int (*callback)(const struct dmi_system_id *);
+	const char *ident;
+	struct dmi_strmatch matches[4];
+	void *driver_data;
+};
+
+enum pcie_reset_state {
+	pcie_deassert_reset = 1,
+	pcie_warm_reset = 2,
+	pcie_hot_reset = 3,
+};
+
+enum pcie_link_width {
+	PCIE_LNK_WIDTH_RESRV = 0,
+	PCIE_LNK_X1 = 1,
+	PCIE_LNK_X2 = 2,
+	PCIE_LNK_X4 = 4,
+	PCIE_LNK_X8 = 8,
+	PCIE_LNK_X12 = 12,
+	PCIE_LNK_X16 = 16,
+	PCIE_LNK_X32 = 32,
+	PCIE_LNK_WIDTH_UNKNOWN = 255,
+};
+
+typedef int (*arch_set_vga_state_t)(struct pci_dev *, bool, unsigned int, u32);
+
+struct pcie_tlp_log {
+	u32 dw[4];
+};
+
+struct pci_cap_saved_data {
+	u16 cap_nr;
+	bool cap_extended;
+	unsigned int size;
+	u32 data[0];
+};
+
+struct pci_cap_saved_state {
+	struct hlist_node next;
+	struct pci_cap_saved_data cap;
+};
+
+struct pci_reset_fn_method {
+	int (*reset_fn)(struct pci_dev *, bool);
+	char *name;
+};
+
+struct pci_pme_device {
+	struct list_head list;
+	struct pci_dev *dev;
+};
+
+struct pci_acs {
+	u16 cap;
+	u16 ctrl;
+	u16 fw_ctrl;
+};
+
+struct pci_saved_state {
+	u32 config_space[16];
+	struct pci_cap_saved_data cap[0];
+};
+
+struct pci_dev_resource {
+	struct list_head list;
+	struct resource *res;
+	struct pci_dev *dev;
+	resource_size_t start;
+	resource_size_t end;
+	resource_size_t add_size;
+	resource_size_t min_align;
+	long unsigned int flags;
+};
+
+enum release_type {
+	leaf_only = 0,
+	whole_subtree = 1,
+};
+
+enum enable_type {
+	undefined = -1,
+	user_disabled = 0,
+	auto_disabled = 1,
+	user_enabled = 2,
+	auto_enabled = 3,
+};
+
+struct amba_id {
+	unsigned int id;
+	unsigned int mask;
+	void *data;
+};
+
+struct amba_cs_uci_id {
+	unsigned int devarch;
+	unsigned int devarch_mask;
+	unsigned int devtype;
+	void *data;
+};
+
+struct amba_device {
+	struct device dev;
+	struct resource res;
+	struct clk *pclk;
+	struct device_dma_parameters dma_parms;
+	unsigned int periphid;
+	struct mutex periphid_lock;
+	unsigned int cid;
+	struct amba_cs_uci_id uci;
+	unsigned int irq[9];
+	const char *driver_override;
+	long: 32;
+};
+
+struct amba_driver {
+	struct device_driver drv;
+	int (*probe)(struct amba_device *, const struct amba_id *);
+	void (*remove)(struct amba_device *);
+	void (*shutdown)(struct amba_device *);
+	const struct amba_id *id_table;
+	bool driver_managed_dma;
+};
+
+struct clk_fixed_rate {
+	struct clk_hw hw;
+	long unsigned int fixed_rate;
+	long unsigned int fixed_accuracy;
+	long unsigned int flags;
+};
+
+struct clk_mux {
+	struct clk_hw hw;
+	void *reg;
+	const u32 *table;
+	u32 mask;
+	u8 shift;
+	u8 flags;
+	spinlock_t *lock;
+};
+
+struct clk_gpio {
+	struct clk_hw hw;
+	struct gpio_desc *gpiod;
+};
+
+enum kp_band {
+	KP_BAND_MID = 0,
+	KP_BAND_HIGH = 1,
+	KP_BAND_HIGH_HIGH = 2,
+};
+
+enum vco_freq_range {
+	VCO_LOW = 700000000,
+	VCO_MID = 1200000000,
+	VCO_HIGH = 2200000000,
+	VCO_HIGH_HIGH = 3100000000,
+	VCO_MAX = 4000000000,
+};
+
+struct iproc_pll {
+	void *status_base;
+	void *control_base;
+	void *pwr_base;
+	void *asiu_base;
+	const struct iproc_pll_ctrl *ctrl;
+	const struct iproc_pll_vco_param *vco_param;
+	unsigned int num_vco_entries;
+};
+
+struct iproc_clk {
+	struct clk_hw hw;
+	struct iproc_pll *pll;
+	const struct iproc_clk_ctrl *ctrl;
+};
+
+struct tty_file_private {
+	struct tty_struct *tty;
+	struct file *file;
+	struct list_head list;
+};
+
+struct ldsem_waiter {
+	struct list_head list;
+	struct task_struct *task;
+};
+
+struct lrng_pool {
+	u8 aux_pool[376];
+	atomic_t aux_entropy_bits;
+	atomic_t digestsize;
+	bool initialized;
+	spinlock_t lock;
+};
+
+struct chacha20_block {
+	u32 constants[4];
+	union {
+		u32 u[8];
+		u8 b[32];
+	} key;
+	u32 counter;
+	u32 nonce[3];
+};
+
+struct chacha20_state {
+	struct chacha20_block block;
+};
+
+enum lrng_health_res {
+	lrng_health_pass = 0,
+	lrng_health_fail_use = 1,
+	lrng_health_fail_drop = 2,
+};
+
+struct trace_event_raw_iommu_group_event {
+	struct trace_entry ent;
+	int gid;
+	u32 __data_loc_device;
+	char __data[0];
+};
+
+struct trace_event_raw_iommu_device_event {
+	struct trace_entry ent;
+	u32 __data_loc_device;
+	char __data[0];
+};
+
+struct trace_event_raw_map {
+	struct trace_entry ent;
+	u64 iova;
+	u64 paddr;
+	size_t size;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_unmap {
+	struct trace_entry ent;
+	u64 iova;
+	size_t size;
+	size_t unmapped_size;
+	char __data[0];
+};
+
+struct trace_event_raw_iommu_error {
+	struct trace_entry ent;
+	u32 __data_loc_device;
+	u32 __data_loc_driver;
+	u64 iova;
+	int flags;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_data_offsets_iommu_group_event {
+	u32 device;
+	const void *device_ptr_;
+};
+
+struct trace_event_data_offsets_iommu_device_event {
+	u32 device;
+	const void *device_ptr_;
+};
+
+struct trace_event_data_offsets_map {};
+
+struct trace_event_data_offsets_unmap {};
+
+struct trace_event_data_offsets_iommu_error {
+	u32 device;
+	const void *device_ptr_;
+	u32 driver;
+	const void *driver_ptr_;
+};
+
+typedef void (*btf_trace_add_device_to_group)(void *, int, struct device *);
+
+typedef void (*btf_trace_remove_device_from_group)(void *, int, struct device *);
+
+typedef void (*btf_trace_attach_device_to_domain)(void *, struct device *);
+
+typedef void (*btf_trace_map)(void *, long unsigned int, phys_addr_t, size_t);
+
+typedef void (*btf_trace_unmap)(void *, long unsigned int, size_t, size_t);
+
+typedef void (*btf_trace_io_page_fault)(void *, struct device *, long unsigned int, int);
+
+struct class_attribute {
+	struct attribute attr;
+	ssize_t (*show)(const struct class *, const struct class_attribute *, char *);
+	ssize_t (*store)(const struct class *, const struct class_attribute *, const char *, size_t);
+};
+
+struct class_attribute_string {
+	struct class_attribute attr;
+	char *str;
+};
+
+struct class_interface {
+	struct list_head node;
+	const struct class *class;
+	int (*add_dev)(struct device *);
+	void (*remove_dev)(struct device *);
+};
+
+struct class_compat {
+	struct kobject *kobj;
+};
+
+struct cpu {
+	int node_id;
+	int hotpluggable;
+	struct device dev;
+};
+
+struct cpu_attr {
+	struct device_attribute attr;
+	const struct cpumask * const map;
+};
+
+struct devres_node {
+	struct list_head entry;
+	dr_release_t release;
+	const char *name;
+	size_t size;
+};
+
+struct devres {
+	struct devres_node node;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	u8 data[0];
+};
+
+struct devres_group {
+	struct devres_node node[2];
+	void *id;
+	int color;
+};
+
+struct action_devres {
+	void *data;
+	void (*action)(void *);
+};
+
+struct pages_devres {
+	long unsigned int addr;
+	unsigned int order;
+};
+
+struct container_dev {
+	struct device dev;
+	int (*offline)(struct container_dev *);
+	long: 32;
+};
+
+enum cache_type {
+	CACHE_TYPE_NOCACHE = 0,
+	CACHE_TYPE_INST = 1,
+	CACHE_TYPE_DATA = 2,
+	CACHE_TYPE_SEPARATE = 3,
+	CACHE_TYPE_UNIFIED = 4,
+};
+
+struct cacheinfo {
+	unsigned int id;
+	enum cache_type type;
+	unsigned int level;
+	unsigned int coherency_line_size;
+	unsigned int number_of_sets;
+	unsigned int ways_of_associativity;
+	unsigned int physical_line_partition;
+	unsigned int size;
+	cpumask_t shared_cpu_map;
+	unsigned int attributes;
+	void *fw_token;
+	bool disable_sysfs;
+	void *priv;
+};
+
+struct cpu_cacheinfo {
+	struct cacheinfo *info_list;
+	unsigned int per_cpu_data_slice_size;
+	unsigned int num_levels;
+	unsigned int num_leaves;
+	bool cpu_map_populated;
+	bool early_ci_levels;
+};
+
+struct cache_type_info {
+	const char *size_prop;
+	const char *line_size_props[2];
+	const char *nr_sets_prop;
+};
+
+struct auxiliary_device_id {
+	char name[32];
+	kernel_ulong_t driver_data;
+};
+
+struct auxiliary_device {
+	struct device dev;
+	const char *name;
+	u32 id;
+	struct {
+		struct xarray irqs;
+		struct mutex lock;
+		bool irq_dir_exists;
+	} sysfs;
+	long: 32;
+};
+
+struct auxiliary_driver {
+	int (*probe)(struct auxiliary_device *, const struct auxiliary_device_id *);
+	void (*remove)(struct auxiliary_device *);
+	void (*shutdown)(struct auxiliary_device *);
+	int (*suspend)(struct auxiliary_device *, pm_message_t);
+	int (*resume)(struct auxiliary_device *);
+	const char *name;
+	struct device_driver driver;
+	const struct auxiliary_device_id *id_table;
+};
+
+enum kernel_load_data_id {
+	LOADING_UNKNOWN = 0,
+	LOADING_FIRMWARE = 1,
+	LOADING_MODULE = 2,
+	LOADING_KEXEC_IMAGE = 3,
+	LOADING_KEXEC_INITRAMFS = 4,
+	LOADING_POLICY = 5,
+	LOADING_X509_CERTIFICATE = 6,
+	LOADING_MAX_ID = 7,
+};
+
+enum fw_opt {
+	FW_OPT_UEVENT = 1,
+	FW_OPT_NOWAIT = 2,
+	FW_OPT_USERHELPER = 4,
+	FW_OPT_NO_WARN = 8,
+	FW_OPT_NOCACHE = 16,
+	FW_OPT_NOFALLBACK_SYSFS = 32,
+	FW_OPT_FALLBACK_PLATFORM = 64,
+	FW_OPT_PARTIAL = 128,
+};
+
+enum fw_status {
+	FW_STATUS_UNKNOWN = 0,
+	FW_STATUS_LOADING = 1,
+	FW_STATUS_DONE = 2,
+	FW_STATUS_ABORTED = 3,
+};
+
+struct fw_state {
+	struct completion completion;
+	enum fw_status status;
+};
+
+struct firmware_cache;
+
+struct fw_priv {
+	struct kref ref;
+	struct list_head list;
+	struct firmware_cache *fwc;
+	struct fw_state fw_st;
+	void *data;
+	size_t size;
+	size_t allocated_size;
+	size_t offset;
+	u32 opt_flags;
+	bool is_paged_buf;
+	struct page **pages;
+	int nr_pages;
+	int page_array_size;
+	bool need_uevent;
+	struct list_head pending_list;
+	const char *fw_name;
+};
+
+struct firmware_fallback_config {
+	unsigned int force_sysfs_fallback;
+	unsigned int ignore_sysfs_fallback;
+	int old_timeout;
+	int loading_timeout;
+};
+
+struct fw_sysfs {
+	bool nowait;
+	long: 32;
+	struct device dev;
+	struct fw_priv *fw_priv;
+	struct firmware *fw;
+	void *fw_upload_priv;
+	long: 32;
+};
+
+struct auxiliary_irq_info {
+	struct device_attribute sysfs_attr;
+	char name[11];
+};
+
+struct regcache_rbtree_node {
+	void *block;
+	long unsigned int *cache_present;
+	unsigned int base_reg;
+	unsigned int blklen;
+	struct rb_node node;
+};
+
+struct regcache_rbtree_ctx {
+	struct rb_root root;
+	struct regcache_rbtree_node *cached_rbnode;
+};
+
+struct regmap_range_cfg;
+
+struct regmap_config {
+	const char *name;
+	int reg_bits;
+	int reg_stride;
+	int reg_shift;
+	unsigned int reg_base;
+	int pad_bits;
+	int val_bits;
+	bool (*writeable_reg)(struct device *, unsigned int);
+	bool (*readable_reg)(struct device *, unsigned int);
+	bool (*volatile_reg)(struct device *, unsigned int);
+	bool (*precious_reg)(struct device *, unsigned int);
+	bool (*writeable_noinc_reg)(struct device *, unsigned int);
+	bool (*readable_noinc_reg)(struct device *, unsigned int);
+	int (*reg_read)(void *, unsigned int, unsigned int *);
+	int (*reg_write)(void *, unsigned int, unsigned int);
+	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
+	int (*read)(void *, const void *, size_t, void *, size_t);
+	int (*write)(void *, const void *, size_t);
+	size_t max_raw_read;
+	size_t max_raw_write;
+	bool can_sleep;
+	bool fast_io;
+	bool io_port;
+	bool disable_locking;
+	regmap_lock lock;
+	regmap_unlock unlock;
+	void *lock_arg;
+	unsigned int max_register;
+	bool max_register_is_0;
+	const struct regmap_access_table *wr_table;
+	const struct regmap_access_table *rd_table;
+	const struct regmap_access_table *volatile_table;
+	const struct regmap_access_table *precious_table;
+	const struct regmap_access_table *wr_noinc_table;
+	const struct regmap_access_table *rd_noinc_table;
+	const struct reg_default *reg_defaults;
+	unsigned int num_reg_defaults;
+	enum regcache_type cache_type;
+	const void *reg_defaults_raw;
+	unsigned int num_reg_defaults_raw;
+	long unsigned int read_flag_mask;
+	long unsigned int write_flag_mask;
+	bool zero_flag_mask;
+	bool use_single_read;
+	bool use_single_write;
+	bool use_relaxed_mmio;
+	bool can_multi_write;
+	bool use_hwlock;
+	bool use_raw_spinlock;
+	unsigned int hwlock_id;
+	unsigned int hwlock_mode;
+	enum regmap_endian reg_format_endian;
+	enum regmap_endian val_format_endian;
+	const struct regmap_range_cfg *ranges;
+	unsigned int num_ranges;
+};
+
+struct regmap_range_cfg {
+	const char *name;
+	unsigned int range_min;
+	unsigned int range_max;
+	unsigned int selector_reg;
+	unsigned int selector_mask;
+	int selector_shift;
+	unsigned int window_start;
+	unsigned int window_len;
+};
+
+struct regmap_mmio_context {
+	void *regs;
+	unsigned int val_bytes;
+	bool big_endian;
+	bool attached_clk;
+	struct clk *clk;
+	void (*reg_write)(struct regmap_mmio_context *, unsigned int, unsigned int);
+	unsigned int (*reg_read)(struct regmap_mmio_context *, unsigned int);
+};
+
+struct devcd_entry {
+	struct device devcd_dev;
+	void *data;
+	size_t datalen;
+	struct mutex mutex;
+	bool delete_work;
+	struct module *owner;
+	ssize_t (*read)(char *, loff_t, size_t, void *, size_t);
+	void (*free)(void *);
+	struct delayed_work del_wk;
+	struct device *failing_dev;
+	long: 32;
+};
+
+struct iosys_map {
+	union {
+		void *vaddr_iomem;
+		void *vaddr;
+	};
+	bool is_iomem;
+};
+
+struct dma_buf;
+
+struct dma_buf_attachment;
+
+struct dma_buf_ops {
+	bool cache_sgt_mapping;
+	int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
+	void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
+	int (*pin)(struct dma_buf_attachment *);
+	void (*unpin)(struct dma_buf_attachment *);
+	struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
+	void (*unmap_dma_buf)(struct dma_buf_attachment *, struct sg_table *, enum dma_data_direction);
+	void (*release)(struct dma_buf *);
+	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
+	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
+	int (*mmap)(struct dma_buf *, struct vm_area_struct *);
+	int (*vmap)(struct dma_buf *, struct iosys_map *);
+	void (*vunmap)(struct dma_buf *, struct iosys_map *);
+};
+
+struct dma_buf_poll_cb_t {
+	struct dma_fence_cb cb;
+	wait_queue_head_t *poll;
+	__poll_t active;
+};
+
+struct dma_resv;
+
+struct dma_buf {
+	size_t size;
+	struct file *file;
+	struct list_head attachments;
+	const struct dma_buf_ops *ops;
+	unsigned int vmapping_counter;
+	struct iosys_map vmap_ptr;
+	const char *exp_name;
+	const char *name;
+	spinlock_t name_lock;
+	struct module *owner;
+	struct list_head list_node;
+	void *priv;
+	struct dma_resv *resv;
+	wait_queue_head_t poll;
+	struct dma_buf_poll_cb_t cb_in;
+	struct dma_buf_poll_cb_t cb_out;
+};
+
+struct dma_buf_attach_ops;
+
+struct dma_buf_attachment {
+	struct dma_buf *dmabuf;
+	struct device *dev;
+	struct list_head node;
+	struct sg_table *sgt;
+	enum dma_data_direction dir;
+	bool peer2peer;
+	const struct dma_buf_attach_ops *importer_ops;
+	void *importer_priv;
+	void *priv;
+};
+
+struct dma_resv_list;
+
+struct dma_resv {
+	struct ww_mutex lock;
+	struct dma_resv_list *fences;
+};
+
+struct dma_buf_attach_ops {
+	bool allow_peer2peer;
+	void (*move_notify)(struct dma_buf_attachment *);
+};
+
+struct dma_buf_export_info {
+	const char *exp_name;
+	struct module *owner;
+	const struct dma_buf_ops *ops;
+	size_t size;
+	int flags;
+	struct dma_resv *resv;
+	void *priv;
+};
+
+enum dma_resv_usage {
+	DMA_RESV_USAGE_KERNEL = 0,
+	DMA_RESV_USAGE_WRITE = 1,
+	DMA_RESV_USAGE_READ = 2,
+	DMA_RESV_USAGE_BOOKKEEP = 3,
+};
+
+struct dma_resv_iter {
+	struct dma_resv *obj;
+	enum dma_resv_usage usage;
+	struct dma_fence *fence;
+	enum dma_resv_usage fence_usage;
+	unsigned int index;
+	struct dma_resv_list *fences;
+	unsigned int num_fences;
+	bool is_restarted;
+};
+
+struct dma_buf_sync {
+	__u64 flags;
+};
+
+enum {
+	MTD_OPS_PLACE_OOB = 0,
+	MTD_OPS_AUTO_OOB = 1,
+	MTD_OPS_RAW = 2,
+};
+
+struct mtd_notifier {
+	void (*add)(struct mtd_info *);
+	void (*remove)(struct mtd_info *);
+	struct list_head list;
+};
+
+struct mtd_blktrans_ops;
+
+struct mtd_blktrans_dev {
+	struct mtd_blktrans_ops *tr;
+	struct list_head list;
+	struct mtd_info *mtd;
+	struct mutex lock;
+	int devnum;
+	bool bg_stop;
+	long unsigned int size;
+	int readonly;
+	int open;
+	struct kref ref;
+	struct gendisk *disk;
+	struct attribute_group *disk_attributes;
+	struct request_queue *rq;
+	struct list_head rq_list;
+	struct blk_mq_tag_set *tag_set;
+	spinlock_t queue_lock;
+	void *priv;
+	bool writable;
+};
+
+struct mtd_blktrans_ops {
+	char *name;
+	int major;
+	int part_bits;
+	int blksize;
+	int blkshift;
+	int (*readsect)(struct mtd_blktrans_dev *, long unsigned int, char *);
+	int (*writesect)(struct mtd_blktrans_dev *, long unsigned int, char *);
+	int (*discard)(struct mtd_blktrans_dev *, long unsigned int, unsigned int);
+	void (*background)(struct mtd_blktrans_dev *);
+	int (*getgeo)(struct mtd_blktrans_dev *, struct hd_geometry *);
+	int (*flush)(struct mtd_blktrans_dev *);
+	int (*open)(struct mtd_blktrans_dev *);
+	void (*release)(struct mtd_blktrans_dev *);
+	void (*add_mtd)(struct mtd_blktrans_ops *, struct mtd_info *);
+	void (*remove_dev)(struct mtd_blktrans_dev *);
+	struct list_head devs;
+	struct list_head list;
+	struct module *owner;
+};
+
+struct req_iterator {
+	struct bvec_iter iter;
+	struct bio *bio;
+};
+
+struct chip_probe {
+	char *name;
+	int (*probe_chip)(struct map_info *, __u32, long unsigned int *, struct cfi_private *);
+};
+
+typedef struct mtd_info *cfi_cmdset_fn_t(struct map_info *, int);
+
+enum bcm47xxsflash_type {
+	BCM47XXSFLASH_TYPE_ATMEL = 0,
+	BCM47XXSFLASH_TYPE_ST = 1,
+};
+
+struct bcm47xxsflash {
+	struct bcma_drv_cc *bcma_cc;
+	int (*cc_read)(struct bcm47xxsflash *, u16);
+	void (*cc_write)(struct bcm47xxsflash *, u16, u32);
+	enum bcm47xxsflash_type type;
+	void *window;
+	u32 blocksize;
+	u16 numblocks;
+	u32 size;
+	struct mtd_info mtd;
+};
+
+struct onfi_ext_ecc_info {
+	u8 ecc_bits;
+	u8 codeword_size;
+	__le16 bb_per_lun;
+	__le16 block_endurance;
+	u8 reserved[2];
+};
+
+struct onfi_ext_section {
+	u8 type;
+	u8 length;
+};
+
+struct onfi_ext_param_page {
+	__le16 crc;
+	u8 sig[4];
+	u8 reserved0[10];
+	struct onfi_ext_section sections[8];
+};
+
+struct hynix_read_retry {
+	int nregs;
+	const u8 *regs;
+	u8 values[0];
+};
+
+struct hynix_nand {
+	const struct hynix_read_retry *read_retry;
+};
+
+struct hynix_read_retry_otp {
+	int nregs;
+	const u8 *regs;
+	const u8 *values;
+	int page;
+	int size;
+};
+
+struct spi_mem_driver {
+	struct spi_driver spidrv;
+	int (*probe)(struct spi_mem *);
+	int (*remove)(struct spi_mem *);
+	void (*shutdown)(struct spi_mem *);
+};
+
+struct flash_platform_data {
+	char *name;
+	struct mtd_partition *parts;
+	unsigned int nr_parts;
+	char *type;
+};
+
+struct spi_nor_erase_command {
+	struct list_head list;
+	u32 count;
+	u32 size;
+	u8 opcode;
+};
+
+struct spansion_nor_params {
+	u8 clsr;
+};
+
+struct ubi_notification {
+	struct ubi_device_info di;
+	long: 32;
+	struct ubi_volume_info vi;
+};
+
+struct mtd_dev_param {
+	char name[64];
+	int ubi_num;
+	int vid_hdr_offs;
+	int max_beb_per1024;
+	int enable_fm;
+	int need_resv_pool;
+};
+
+enum {
+	UBI_COMPAT_DELETE = 1,
+	UBI_COMPAT_RO = 2,
+	UBI_COMPAT_PRESERVE = 4,
+	UBI_COMPAT_REJECT = 5,
+};
+
+enum {
+	MSPI_DONE = 1,
+	BSPI_DONE = 2,
+	BSPI_ERR = 4,
+	MSPI_BSPI_DONE = 7,
+};
+
+struct bcm_qspi_soc_intc {
+	void (*bcm_qspi_int_ack)(struct bcm_qspi_soc_intc *, int);
+	void (*bcm_qspi_int_set)(struct bcm_qspi_soc_intc *, int, bool);
+	u32 (*bcm_qspi_get_int_status)(struct bcm_qspi_soc_intc *);
+};
+
+struct bcm_iproc_intc {
+	struct bcm_qspi_soc_intc soc_intc;
+	struct platform_device *pdev;
+	void *int_reg;
+	void *int_status_reg;
+	spinlock_t soclock;
+	bool big_endian;
+};
+
+typedef u32 (*spi_bb_txrx_word_fn)(struct spi_device *, unsigned int, u32, u8, unsigned int);
+
+struct spi_bitbang {
+	struct mutex lock;
+	u8 busy;
+	u8 use_dma;
+	u16 flags;
+	struct spi_controller *ctlr;
+	int (*setup_transfer)(struct spi_device *, struct spi_transfer *);
+	void (*chipselect)(struct spi_device *, int);
+	void (*set_mosi_idle)(struct spi_device *);
+	int (*txrx_bufs)(struct spi_device *, struct spi_transfer *);
+	spi_bb_txrx_word_fn txrx_word[4];
+	int (*set_line_direction)(struct spi_device *, bool);
+};
+
+struct spi_gpio_platform_data {
+	u16 num_chipselect;
+};
+
+struct spi_gpio {
+	struct spi_bitbang bitbang;
+	struct gpio_desc *sck;
+	struct gpio_desc *miso;
+	struct gpio_desc *mosi;
+	struct gpio_desc **cs_gpios;
+};
+
+struct mdiobus_devres {
+	struct mii_bus *mii;
+};
+
+struct platform_device_info {
+	struct device *parent;
+	struct fwnode_handle *fwnode;
+	bool of_node_reused;
+	const char *name;
+	int id;
+	const struct resource *res;
+	unsigned int num_res;
+	const void *data;
+	size_t size_data;
+	long: 32;
+	u64 dma_mask;
+	const struct property_entry *properties;
+	long: 32;
+};
+
+struct fixed_mdio_bus {
+	struct mii_bus *mii_bus;
+	struct list_head phys;
+};
+
+struct fixed_phy {
+	int addr;
+	struct phy_device *phydev;
+	struct fixed_phy_status status;
+	bool no_carrier;
+	int (*link_update)(struct net_device *, struct fixed_phy_status *);
+	struct list_head node;
+	struct gpio_desc *link_gpiod;
+};
+
+struct mdio_mux_mmioreg_state {
+	void *mux_handle;
+	phys_addr_t phys;
+	unsigned int iosize;
+	unsigned int mask;
+};
+
+enum bgmac_dma_ring_type {
+	BGMAC_DMA_RING_TX = 0,
+	BGMAC_DMA_RING_RX = 1,
+};
+
+struct bgmac_rx_header {
+	__le16 len;
+	__le16 flags;
+	__le16 pad[12];
+};
+
+struct bgmac_stat {
+	u8 size;
+	u32 offset;
+	const char *name;
+};
+
+enum usb_phy_interface {
+	USBPHY_INTERFACE_MODE_UNKNOWN = 0,
+	USBPHY_INTERFACE_MODE_UTMI = 1,
+	USBPHY_INTERFACE_MODE_UTMIW = 2,
+	USBPHY_INTERFACE_MODE_ULPI = 3,
+	USBPHY_INTERFACE_MODE_SERIAL = 4,
+	USBPHY_INTERFACE_MODE_HSIC = 5,
+};
+
+struct i2c_board_info {
+	char type[20];
+	short unsigned int flags;
+	short unsigned int addr;
+	const char *dev_name;
+	void *platform_data;
+	struct device_node *of_node;
+	struct fwnode_handle *fwnode;
+	const struct software_node *swnode;
+	const struct resource *resources;
+	unsigned int num_resources;
+	int irq;
+};
+
+struct i2c_devinfo {
+	struct list_head list;
+	int busnum;
+	struct i2c_board_info board_info;
+};
+
+struct trace_event_raw_watchdog_template {
+	struct trace_entry ent;
+	int id;
+	int err;
+	char __data[0];
+};
+
+struct trace_event_raw_watchdog_set_timeout {
+	struct trace_entry ent;
+	int id;
+	unsigned int timeout;
+	int err;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_watchdog_template {};
+
+struct trace_event_data_offsets_watchdog_set_timeout {};
+
+typedef void (*btf_trace_watchdog_start)(void *, struct watchdog_device *, int);
+
+typedef void (*btf_trace_watchdog_ping)(void *, struct watchdog_device *, int);
+
+typedef void (*btf_trace_watchdog_stop)(void *, struct watchdog_device *, int);
+
+typedef void (*btf_trace_watchdog_set_timeout)(void *, struct watchdog_device *, unsigned int, int);
+
+enum arm_smccc_conduit {
+	SMCCC_CONDUIT_NONE = 0,
+	SMCCC_CONDUIT_SMC = 1,
+	SMCCC_CONDUIT_HVC = 2,
+};
+
+struct arm_smccc_res {
+	long unsigned int a0;
+	long unsigned int a1;
+	long unsigned int a2;
+	long unsigned int a3;
+};
+
+enum arch_timer_reg {
+	ARCH_TIMER_REG_CTRL = 0,
+	ARCH_TIMER_REG_CVAL = 1,
+};
+
+enum arch_timer_ppi_nr {
+	ARCH_TIMER_PHYS_SECURE_PPI = 0,
+	ARCH_TIMER_PHYS_NONSECURE_PPI = 1,
+	ARCH_TIMER_VIRT_PPI = 2,
+	ARCH_TIMER_HYP_PPI = 3,
+	ARCH_TIMER_HYP_VIRT_PPI = 4,
+	ARCH_TIMER_MAX_TIMER_PPI = 5,
+};
+
+enum arch_timer_spi_nr {
+	ARCH_TIMER_PHYS_SPI = 0,
+	ARCH_TIMER_VIRT_SPI = 1,
+	ARCH_TIMER_MAX_TIMER_SPI = 2,
+};
+
+struct arch_timer_kvm_info {
+	struct timecounter timecounter;
+	int virtual_irq;
+	int physical_irq;
+};
+
+struct arch_timer_mem_frame {
+	bool valid;
+	phys_addr_t cntbase;
+	size_t size;
+	int phys_irq;
+	int virt_irq;
+};
+
+struct arch_timer_mem {
+	phys_addr_t cntctlbase;
+	size_t size;
+	struct arch_timer_mem_frame frame[8];
+};
+
+struct arch_timer {
+	void *base;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct clock_event_device evt;
+};
+
+enum vesa_blank_mode {
+	VESA_NO_BLANKING = 0,
+	VESA_VSYNC_SUSPEND = 1,
+	VESA_HSYNC_SUSPEND = 2,
+	VESA_POWERDOWN = 3,
+	VESA_BLANK_MAX = 3,
+};
+
+struct reserved_mem_ops;
+
+struct reserved_mem {
+	const char *name;
+	long unsigned int fdt_node;
+	const struct reserved_mem_ops *ops;
+	phys_addr_t base;
+	phys_addr_t size;
+	void *priv;
+};
+
+struct reserved_mem_ops {
+	int (*device_init)(struct reserved_mem *, struct device *);
+	void (*device_release)(struct reserved_mem *, struct device *);
+};
+
+typedef int (*reservedmem_of_init_fn)(struct reserved_mem *);
+
+struct rmem_assigned_device {
+	struct device *dev;
+	struct reserved_mem *rmem;
+	struct list_head list;
+};
+
+struct bcma_sflash_tbl_e {
+	char *name;
+	u32 id;
+	u32 blocksize;
+	u16 numblocks;
+};
+
+union extcon_property_value {
+	int intval;
+};
+
+struct extcon_cable {
+	struct extcon_dev *edev;
+	int cable_index;
+	struct attribute_group attr_g;
+	struct device_attribute attr_name;
+	struct device_attribute attr_state;
+	struct attribute *attrs[3];
+	union extcon_property_value usb_propval[3];
+	union extcon_property_value chg_propval[1];
+	union extcon_property_value jack_propval[1];
+	union extcon_property_value disp_propval[2];
+	long unsigned int usb_bits[1];
+	long unsigned int chg_bits[1];
+	long unsigned int jack_bits[1];
+	long unsigned int disp_bits[1];
+};
+
+struct __extcon_info {
+	unsigned int type;
+	unsigned int id;
+	const char *name;
+};
+
+struct nvmem_cell_lookup {
+	const char *nvmem_name;
+	const char *cell_name;
+	const char *dev_id;
+	const char *con_id;
+	struct list_head node;
+};
+
+enum {
+	NVMEM_ADD = 1,
+	NVMEM_REMOVE = 2,
+	NVMEM_CELL_ADD = 3,
+	NVMEM_CELL_REMOVE = 4,
+	NVMEM_LAYOUT_ADD = 5,
+	NVMEM_LAYOUT_REMOVE = 6,
+};
+
+struct nvmem_device {
+	struct module *owner;
+	long: 32;
+	struct device dev;
+	struct list_head node;
+	int stride;
+	int word_size;
+	int id;
+	struct kref refcnt;
+	size_t size;
+	bool read_only;
+	bool root_only;
+	int flags;
+	enum nvmem_type type;
+	struct bin_attribute eeprom;
+	struct device *base_dev;
+	struct list_head cells;
+	void (*fixup_dt_cell_info)(struct nvmem_device *, struct nvmem_cell_info *);
+	const struct nvmem_keepout *keepout;
+	unsigned int nkeepout;
+	nvmem_reg_read_t reg_read;
+	nvmem_reg_write_t reg_write;
+	struct gpio_desc *wp_gpio;
+	struct nvmem_layout *layout;
+	void *priv;
+	bool sysfs_cells_populated;
+	long: 32;
+};
+
+struct nvmem_cell_table {
+	const char *nvmem_name;
+	const struct nvmem_cell_info *cells;
+	size_t ncells;
+	struct list_head node;
+};
+
+struct nvmem_cell_entry {
+	const char *name;
+	int offset;
+	size_t raw_len;
+	int bytes;
+	int bit_offset;
+	int nbits;
+	nvmem_cell_post_process_t read_post_process;
+	void *priv;
+	struct device_node *np;
+	struct nvmem_device *nvmem;
+	struct list_head node;
+};
+
+struct nvmem_cell {
+	struct nvmem_cell_entry *entry;
+	const char *id;
+	int index;
+};
+
+struct nvmem_layout_driver {
+	struct device_driver driver;
+	int (*probe)(struct nvmem_layout *);
+	void (*remove)(struct nvmem_layout *);
+};
+
+struct __kernel_sock_timeval {
+	__s64 tv_sec;
+	__s64 tv_usec;
+};
+
+struct dmabuf_token {
+	__u32 token_start;
+	__u32 token_count;
+};
+
+struct ucred {
+	__u32 pid;
+	__u32 uid;
+	__u32 gid;
+};
+
+struct sock_fprog {
+	short unsigned int len;
+	struct sock_filter *filter;
+};
+
+enum txtime_flags {
+	SOF_TXTIME_DEADLINE_MODE = 1,
+	SOF_TXTIME_REPORT_ERRORS = 2,
+	SOF_TXTIME_FLAGS_LAST = 2,
+	SOF_TXTIME_FLAGS_MASK = 3,
+};
+
+struct sock_txtime {
+	__kernel_clockid_t clockid;
+	__u32 flags;
+};
+
+typedef short unsigned int mifi_t;
+
+struct sioc_sg_req6 {
+	struct sockaddr_in6 src;
+	struct sockaddr_in6 grp;
+	long unsigned int pktcnt;
+	long unsigned int bytecnt;
+	long unsigned int wrong_if;
+};
+
+struct sioc_mif_req6 {
+	mifi_t mifi;
+	long unsigned int icount;
+	long unsigned int ocount;
+	long unsigned int ibytes;
+	long unsigned int obytes;
+};
+
+enum {
+	TCA_STATS_UNSPEC = 0,
+	TCA_STATS_BASIC = 1,
+	TCA_STATS_RATE_EST = 2,
+	TCA_STATS_QUEUE = 3,
+	TCA_STATS_APP = 4,
+	TCA_STATS_RATE_EST64 = 5,
+	TCA_STATS_PAD = 6,
+	TCA_STATS_BASIC_HW = 7,
+	TCA_STATS_PKT64 = 8,
+	__TCA_STATS_MAX = 9,
+};
+
+struct gnet_stats_basic {
+	__u64 bytes;
+	__u32 packets;
+	long: 32;
+};
+
+struct gnet_stats_rate_est {
+	__u32 bps;
+	__u32 pps;
+};
+
+typedef u64 u_int64_t;
+
+enum {
+	TCA_FLOWER_KEY_CT_FLAGS_NEW = 1,
+	TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED = 2,
+	TCA_FLOWER_KEY_CT_FLAGS_RELATED = 4,
+	TCA_FLOWER_KEY_CT_FLAGS_TRACKED = 8,
+	TCA_FLOWER_KEY_CT_FLAGS_INVALID = 16,
+	TCA_FLOWER_KEY_CT_FLAGS_REPLY = 32,
+	__TCA_FLOWER_KEY_CT_FLAGS_MAX = 33,
+};
+
+enum flow_dissect_ret {
+	FLOW_DISSECT_RET_OUT_GOOD = 0,
+	FLOW_DISSECT_RET_OUT_BAD = 1,
+	FLOW_DISSECT_RET_PROTO_AGAIN = 2,
+	FLOW_DISSECT_RET_IPPROTO_AGAIN = 3,
+	FLOW_DISSECT_RET_CONTINUE = 4,
+};
+
+struct flow_dissector_key_hash {
+	u32 hash;
+};
+
+struct flow_dissector_key_num_of_vlans {
+	u8 num_of_vlans;
+};
+
+struct flow_dissector_key_cfm {
+	u8 mdl_ver;
+	u8 opcode;
+};
+
+struct flow_dissector_key {
+	enum flow_dissector_key_id key_id;
+	size_t offset;
+};
+
+struct flow_keys_basic {
+	struct flow_dissector_key_control control;
+	struct flow_dissector_key_basic basic;
+};
+
+struct flow_keys_digest {
+	u8 data[16];
+};
+
+struct bpf_flow_dissector {
+	struct bpf_flow_keys *flow_keys;
+	const struct sk_buff *skb;
+	const void *data;
+	const void *data_end;
+};
+
+enum ip_conntrack_info {
+	IP_CT_ESTABLISHED = 0,
+	IP_CT_RELATED = 1,
+	IP_CT_NEW = 2,
+	IP_CT_IS_REPLY = 3,
+	IP_CT_ESTABLISHED_REPLY = 3,
+	IP_CT_RELATED_REPLY = 4,
+	IP_CT_NUMBER = 5,
+	IP_CT_UNTRACKED = 7,
+};
+
+union nf_inet_addr {
+	__u32 all[4];
+	__be32 ip;
+	__be32 ip6[4];
+	struct in_addr in;
+	struct in6_addr in6;
+};
+
+struct ip_ct_tcp_state {
+	u_int32_t td_end;
+	u_int32_t td_maxend;
+	u_int32_t td_maxwin;
+	u_int32_t td_maxack;
+	u_int8_t td_scale;
+	u_int8_t flags;
+};
+
+struct ip_ct_tcp {
+	struct ip_ct_tcp_state seen[2];
+	u_int8_t state;
+	u_int8_t last_dir;
+	u_int8_t retrans;
+	u_int8_t last_index;
+	u_int32_t last_seq;
+	u_int32_t last_ack;
+	u_int32_t last_end;
+	u_int16_t last_win;
+	u_int8_t last_wscale;
+	u_int8_t last_flags;
+};
+
+struct nf_ct_event;
+
+struct nf_exp_event;
+
+struct nf_ct_event_notifier {
+	int (*ct_event)(unsigned int, const struct nf_ct_event *);
+	int (*exp_event)(unsigned int, const struct nf_exp_event *);
+};
+
+enum bpf_ret_code {
+	BPF_OK = 0,
+	BPF_DROP = 2,
+	BPF_REDIRECT = 7,
+	BPF_LWT_REROUTE = 128,
+	BPF_FLOW_DISSECTOR_CONTINUE = 129,
+};
+
+enum {
+	BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG = 1,
+	BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL = 2,
+	BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP = 4,
+};
+
+struct gre_base_hdr {
+	__be16 flags;
+	__be16 protocol;
+};
+
+struct gre_full_hdr {
+	struct gre_base_hdr fixed_header;
+	__be16 csum;
+	__be16 reserved1;
+	__be32 key;
+	__be32 seq;
+};
+
+struct pptp_gre_header {
+	struct gre_base_hdr gre_hd;
+	__be16 payload_len;
+	__be16 call_id;
+	__be32 seq;
+	__be32 ack;
+};
+
+struct tipc_basic_hdr {
+	__be32 w[4];
+};
+
+enum dccp_state {
+	DCCP_OPEN = 1,
+	DCCP_REQUESTING = 2,
+	DCCP_LISTEN = 10,
+	DCCP_RESPOND = 3,
+	DCCP_ACTIVE_CLOSEREQ = 4,
+	DCCP_PASSIVE_CLOSE = 8,
+	DCCP_CLOSING = 11,
+	DCCP_TIME_WAIT = 6,
+	DCCP_CLOSED = 7,
+	DCCP_NEW_SYN_RECV = 12,
+	DCCP_PARTOPEN = 14,
+	DCCP_PASSIVE_CLOSEREQ = 15,
+	DCCP_MAX_STATES = 16,
+};
+
+struct pppoe_tag {
+	__be16 tag_type;
+	__be16 tag_len;
+	char tag_data[0];
+};
+
+struct pppoe_hdr {
+	__u8 type: 4;
+	__u8 ver: 4;
+	__u8 code;
+	__be16 sid;
+	__be16 length;
+	struct pppoe_tag tag[0];
+};
+
+struct hsr_tag {
+	__be16 path_and_LSDU_size;
+	__be16 sequence_nr;
+	__be16 encap_proto;
+};
+
+struct mpls_label {
+	__be32 entry;
+};
+
+struct clock_identity {
+	u8 id[8];
+};
+
+struct port_identity {
+	struct clock_identity clock_identity;
+	__be16 port_number;
+};
+
+struct ptp_header {
+	u8 tsmt;
+	u8 ver;
+	__be16 message_length;
+	u8 domain_number;
+	u8 reserved1;
+	u8 flag_field[2];
+	__be64 correction;
+	__be32 reserved2;
+	struct port_identity source_port_identity;
+	__be16 sequence_id;
+	u8 control;
+	u8 log_message_interval;
+} __attribute__((packed));
+
+enum batadv_packettype {
+	BATADV_IV_OGM = 0,
+	BATADV_BCAST = 1,
+	BATADV_CODED = 2,
+	BATADV_ELP = 3,
+	BATADV_OGM2 = 4,
+	BATADV_MCAST = 5,
+	BATADV_UNICAST = 64,
+	BATADV_UNICAST_FRAG = 65,
+	BATADV_UNICAST_4ADDR = 66,
+	BATADV_ICMP = 67,
+	BATADV_UNICAST_TVLV = 68,
+};
+
+struct batadv_unicast_packet {
+	__u8 packet_type;
+	__u8 version;
+	__u8 ttl;
+	__u8 ttvn;
+	__u8 dest[6];
+};
+
+struct nf_conntrack_zone {
+	u16 id;
+	u8 flags;
+	u8 dir;
+};
+
+union nf_conntrack_man_proto {
+	__be16 all;
+	struct {
+		__be16 port;
+	} tcp;
+	struct {
+		__be16 port;
+	} udp;
+	struct {
+		__be16 id;
+	} icmp;
+	struct {
+		__be16 port;
+	} dccp;
+	struct {
+		__be16 port;
+	} sctp;
+	struct {
+		__be16 key;
+	} gre;
+};
+
+struct nf_conntrack_man {
+	union nf_inet_addr u3;
+	union nf_conntrack_man_proto u;
+	u_int16_t l3num;
+};
+
+struct nf_conntrack_tuple {
+	struct nf_conntrack_man src;
+	struct {
+		union nf_inet_addr u3;
+		union {
+			__be16 all;
+			struct {
+				__be16 port;
+			} tcp;
+			struct {
+				__be16 port;
+			} udp;
+			struct {
+				u_int8_t type;
+				u_int8_t code;
+			} icmp;
+			struct {
+				__be16 port;
+			} dccp;
+			struct {
+				__be16 port;
+			} sctp;
+			struct {
+				__be16 key;
+			} gre;
+		} u;
+		u_int8_t protonum;
+		struct {} __nfct_hash_offsetend;
+		u_int8_t dir;
+	} dst;
+};
+
+struct nf_conntrack_tuple_hash {
+	struct hlist_nulls_node hnnode;
+	struct nf_conntrack_tuple tuple;
+};
+
+struct nf_ct_dccp {
+	u_int8_t role[2];
+	u_int8_t state;
+	u_int8_t last_pkt;
+	u_int8_t last_dir;
+	u_int64_t handshake_seq;
+};
+
+enum sctp_conntrack {
+	SCTP_CONNTRACK_NONE = 0,
+	SCTP_CONNTRACK_CLOSED = 1,
+	SCTP_CONNTRACK_COOKIE_WAIT = 2,
+	SCTP_CONNTRACK_COOKIE_ECHOED = 3,
+	SCTP_CONNTRACK_ESTABLISHED = 4,
+	SCTP_CONNTRACK_SHUTDOWN_SENT = 5,
+	SCTP_CONNTRACK_SHUTDOWN_RECD = 6,
+	SCTP_CONNTRACK_SHUTDOWN_ACK_SENT = 7,
+	SCTP_CONNTRACK_HEARTBEAT_SENT = 8,
+	SCTP_CONNTRACK_HEARTBEAT_ACKED = 9,
+	SCTP_CONNTRACK_MAX = 10,
+};
+
+struct ip_ct_sctp {
+	enum sctp_conntrack state;
+	__be32 vtag[2];
+	u8 init[2];
+	u8 last_dir;
+	u8 flags;
+};
+
+struct nf_ct_udp {
+	long unsigned int stream_ts;
+};
+
+struct nf_ct_gre {
+	unsigned int stream_timeout;
+	unsigned int timeout;
+};
+
+union nf_conntrack_proto {
+	struct nf_ct_dccp dccp;
+	struct ip_ct_sctp sctp;
+	struct ip_ct_tcp tcp;
+	struct nf_ct_udp udp;
+	struct nf_ct_gre gre;
+	unsigned int tmpl_padto;
+};
+
+struct nf_ct_ext;
+
+struct nf_conn {
+	struct nf_conntrack ct_general;
+	spinlock_t lock;
+	u32 timeout;
+	struct nf_conntrack_zone zone;
+	struct nf_conntrack_tuple_hash tuplehash[2];
+	long unsigned int status;
+	possible_net_t ct_net;
+	struct hlist_node nat_bysource;
+	struct {} __nfct_init_offset;
+	struct nf_conn *master;
+	u_int32_t mark;
+	struct nf_ct_ext *ext;
+	long: 32;
+	union nf_conntrack_proto proto;
+};
+
+struct nf_conntrack_tuple_mask {
+	struct {
+		union nf_inet_addr u3;
+		union nf_conntrack_man_proto u;
+	} src;
+};
+
+struct nf_ct_ext {
+	u8 offset[7];
+	u8 len;
+	unsigned int gen_id;
+	long: 32;
+	char data[0];
+};
+
+struct nf_conntrack_helper;
+
+struct nf_conntrack_expect {
+	struct hlist_node lnode;
+	struct hlist_node hnode;
+	struct nf_conntrack_tuple tuple;
+	struct nf_conntrack_tuple_mask mask;
+	refcount_t use;
+	unsigned int flags;
+	unsigned int class;
+	void (*expectfn)(struct nf_conn *, struct nf_conntrack_expect *);
+	struct nf_conntrack_helper *helper;
+	struct nf_conn *master;
+	struct timer_list timeout;
+	union nf_inet_addr saved_addr;
+	union nf_conntrack_man_proto saved_proto;
+	enum ip_conntrack_dir dir;
+	struct callback_head rcu;
+};
+
+struct nf_ct_event {
+	struct nf_conn *ct;
+	u32 portid;
+	int report;
+};
+
+struct nf_exp_event {
+	struct nf_conntrack_expect *exp;
+	u32 portid;
+	int report;
+};
+
+struct nf_conn_labels {
+	long unsigned int bits[4];
+};
+
+struct _flow_keys_digest_data {
+	__be16 n_proto;
+	u8 ip_proto;
+	u8 padding;
+	__be32 ports;
+	__be32 src;
+	__be32 dst;
+};
+
+struct netdev_hw_addr {
+	struct list_head list;
+	struct rb_node node;
+	unsigned char addr[32];
+	unsigned char type;
+	bool global_use;
+	int sync_cnt;
+	int refcount;
+	int synced;
+	struct callback_head callback_head;
+};
+
+struct rtnl_link_stats {
+	__u32 rx_packets;
+	__u32 tx_packets;
+	__u32 rx_bytes;
+	__u32 tx_bytes;
+	__u32 rx_errors;
+	__u32 tx_errors;
+	__u32 rx_dropped;
+	__u32 tx_dropped;
+	__u32 multicast;
+	__u32 collisions;
+	__u32 rx_length_errors;
+	__u32 rx_over_errors;
+	__u32 rx_crc_errors;
+	__u32 rx_frame_errors;
+	__u32 rx_fifo_errors;
+	__u32 rx_missed_errors;
+	__u32 tx_aborted_errors;
+	__u32 tx_carrier_errors;
+	__u32 tx_fifo_errors;
+	__u32 tx_heartbeat_errors;
+	__u32 tx_window_errors;
+	__u32 rx_compressed;
+	__u32 tx_compressed;
+	__u32 rx_nohandler;
+};
+
+struct rtnl_link_ifmap {
+	__u64 mem_start;
+	__u64 mem_end;
+	__u64 base_addr;
+	__u16 irq;
+	__u8 dma;
+	__u8 port;
+	long: 32;
+};
+
+enum {
+	IFLA_PROTO_DOWN_REASON_UNSPEC = 0,
+	IFLA_PROTO_DOWN_REASON_MASK = 1,
+	IFLA_PROTO_DOWN_REASON_VALUE = 2,
+	__IFLA_PROTO_DOWN_REASON_CNT = 3,
+	IFLA_PROTO_DOWN_REASON_MAX = 2,
+};
+
+enum {
+	IFLA_INFO_UNSPEC = 0,
+	IFLA_INFO_KIND = 1,
+	IFLA_INFO_DATA = 2,
+	IFLA_INFO_XSTATS = 3,
+	IFLA_INFO_SLAVE_KIND = 4,
+	IFLA_INFO_SLAVE_DATA = 5,
+	__IFLA_INFO_MAX = 6,
+};
+
+enum {
+	IFLA_VF_INFO_UNSPEC = 0,
+	IFLA_VF_INFO = 1,
+	__IFLA_VF_INFO_MAX = 2,
+};
+
+enum {
+	IFLA_VF_UNSPEC = 0,
+	IFLA_VF_MAC = 1,
+	IFLA_VF_VLAN = 2,
+	IFLA_VF_TX_RATE = 3,
+	IFLA_VF_SPOOFCHK = 4,
+	IFLA_VF_LINK_STATE = 5,
+	IFLA_VF_RATE = 6,
+	IFLA_VF_RSS_QUERY_EN = 7,
+	IFLA_VF_STATS = 8,
+	IFLA_VF_TRUST = 9,
+	IFLA_VF_IB_NODE_GUID = 10,
+	IFLA_VF_IB_PORT_GUID = 11,
+	IFLA_VF_VLAN_LIST = 12,
+	IFLA_VF_BROADCAST = 13,
+	__IFLA_VF_MAX = 14,
+};
+
+struct ifla_vf_mac {
+	__u32 vf;
+	__u8 mac[32];
+};
+
+struct ifla_vf_broadcast {
+	__u8 broadcast[32];
+};
+
+struct ifla_vf_vlan {
+	__u32 vf;
+	__u32 vlan;
+	__u32 qos;
+};
+
+enum {
+	IFLA_VF_VLAN_INFO_UNSPEC = 0,
+	IFLA_VF_VLAN_INFO = 1,
+	__IFLA_VF_VLAN_INFO_MAX = 2,
+};
+
+struct ifla_vf_vlan_info {
+	__u32 vf;
+	__u32 vlan;
+	__u32 qos;
+	__be16 vlan_proto;
+};
+
+struct ifla_vf_tx_rate {
+	__u32 vf;
+	__u32 rate;
+};
+
+struct ifla_vf_rate {
+	__u32 vf;
+	__u32 min_tx_rate;
+	__u32 max_tx_rate;
+};
+
+struct ifla_vf_spoofchk {
+	__u32 vf;
+	__u32 setting;
+};
+
+struct ifla_vf_link_state {
+	__u32 vf;
+	__u32 link_state;
+};
+
+struct ifla_vf_rss_query_en {
+	__u32 vf;
+	__u32 setting;
+};
+
+enum {
+	IFLA_VF_STATS_RX_PACKETS = 0,
+	IFLA_VF_STATS_TX_PACKETS = 1,
+	IFLA_VF_STATS_RX_BYTES = 2,
+	IFLA_VF_STATS_TX_BYTES = 3,
+	IFLA_VF_STATS_BROADCAST = 4,
+	IFLA_VF_STATS_MULTICAST = 5,
+	IFLA_VF_STATS_PAD = 6,
+	IFLA_VF_STATS_RX_DROPPED = 7,
+	IFLA_VF_STATS_TX_DROPPED = 8,
+	__IFLA_VF_STATS_MAX = 9,
+};
+
+struct ifla_vf_trust {
+	__u32 vf;
+	__u32 setting;
+};
+
+enum {
+	IFLA_VF_PORT_UNSPEC = 0,
+	IFLA_VF_PORT = 1,
+	__IFLA_VF_PORT_MAX = 2,
+};
+
+enum {
+	IFLA_PORT_UNSPEC = 0,
+	IFLA_PORT_VF = 1,
+	IFLA_PORT_PROFILE = 2,
+	IFLA_PORT_VSI_TYPE = 3,
+	IFLA_PORT_INSTANCE_UUID = 4,
+	IFLA_PORT_HOST_UUID = 5,
+	IFLA_PORT_REQUEST = 6,
+	IFLA_PORT_RESPONSE = 7,
+	__IFLA_PORT_MAX = 8,
+};
+
+struct if_stats_msg {
+	__u8 family;
+	__u8 pad1;
+	__u16 pad2;
+	__u32 ifindex;
+	__u32 filter_mask;
+};
+
+enum {
+	IFLA_STATS_GETSET_UNSPEC = 0,
+	IFLA_STATS_GET_FILTERS = 1,
+	IFLA_STATS_SET_OFFLOAD_XSTATS_L3_STATS = 2,
+	__IFLA_STATS_GETSET_MAX = 3,
+};
+
+enum {
+	IFLA_OFFLOAD_XSTATS_UNSPEC = 0,
+	IFLA_OFFLOAD_XSTATS_CPU_HIT = 1,
+	IFLA_OFFLOAD_XSTATS_HW_S_INFO = 2,
+	IFLA_OFFLOAD_XSTATS_L3_STATS = 3,
+	__IFLA_OFFLOAD_XSTATS_MAX = 4,
+};
+
+enum {
+	IFLA_OFFLOAD_XSTATS_HW_S_INFO_UNSPEC = 0,
+	IFLA_OFFLOAD_XSTATS_HW_S_INFO_REQUEST = 1,
+	IFLA_OFFLOAD_XSTATS_HW_S_INFO_USED = 2,
+	__IFLA_OFFLOAD_XSTATS_HW_S_INFO_MAX = 3,
+};
+
+enum {
+	XDP_ATTACHED_NONE = 0,
+	XDP_ATTACHED_DRV = 1,
+	XDP_ATTACHED_SKB = 2,
+	XDP_ATTACHED_HW = 3,
+	XDP_ATTACHED_MULTI = 4,
+};
+
+enum {
+	IFLA_XDP_UNSPEC = 0,
+	IFLA_XDP_FD = 1,
+	IFLA_XDP_ATTACHED = 2,
+	IFLA_XDP_FLAGS = 3,
+	IFLA_XDP_PROG_ID = 4,
+	IFLA_XDP_DRV_PROG_ID = 5,
+	IFLA_XDP_SKB_PROG_ID = 6,
+	IFLA_XDP_HW_PROG_ID = 7,
+	IFLA_XDP_EXPECTED_FD = 8,
+	__IFLA_XDP_MAX = 9,
+};
+
+enum {
+	IFLA_EVENT_NONE = 0,
+	IFLA_EVENT_REBOOT = 1,
+	IFLA_EVENT_FEATURES = 2,
+	IFLA_EVENT_BONDING_FAILOVER = 3,
+	IFLA_EVENT_NOTIFY_PEERS = 4,
+	IFLA_EVENT_IGMP_RESEND = 5,
+	IFLA_EVENT_BONDING_OPTIONS = 6,
+};
+
+struct br_port_msg {
+	__u8 family;
+	__u32 ifindex;
+};
+
+struct br_mdb_entry {
+	__u32 ifindex;
+	__u8 state;
+	__u8 flags;
+	__u16 vid;
+	struct {
+		union {
+			__be32 ip4;
+			struct in6_addr ip6;
+			unsigned char mac_addr[6];
+		} u;
+		__be16 proto;
+	} addr;
+};
+
+enum {
+	MDBA_SET_ENTRY_UNSPEC = 0,
+	MDBA_SET_ENTRY = 1,
+	MDBA_SET_ENTRY_ATTRS = 2,
+	__MDBA_SET_ENTRY_MAX = 3,
+};
+
+enum {
+	MDBA_GET_ENTRY_UNSPEC = 0,
+	MDBA_GET_ENTRY = 1,
+	MDBA_GET_ENTRY_ATTRS = 2,
+	__MDBA_GET_ENTRY_MAX = 3,
+};
+
+struct rta_cacheinfo {
+	__u32 rta_clntref;
+	__u32 rta_lastuse;
+	__s32 rta_expires;
+	__u32 rta_error;
+	__u32 rta_used;
+	__u32 rta_id;
+	__u32 rta_ts;
+	__u32 rta_tsage;
+};
+
+enum rtnl_kinds {
+	RTNL_KIND_NEW = 0,
+	RTNL_KIND_DEL = 1,
+	RTNL_KIND_GET = 2,
+	RTNL_KIND_SET = 3,
+};
+
+struct rtnl_msg_handler {
+	struct module *owner;
+	int protocol;
+	int msgtype;
+	rtnl_doit_func doit;
+	rtnl_dumpit_func dumpit;
+	int flags;
+};
+
+struct rtnl_link {
+	rtnl_doit_func doit;
+	rtnl_dumpit_func dumpit;
+	struct module *owner;
+	unsigned int flags;
+	struct callback_head rcu;
+};
+
+struct rtnl_newlink_tbs {
+	struct nlattr *tb[66];
+	struct nlattr *attr[51];
+	struct nlattr *slave_attr[45];
+};
+
+struct rtnl_offload_xstats_request_used {
+	bool request;
+	bool used;
+};
+
+struct rtnl_stats_dump_filters {
+	u32 mask[6];
+};
+
+struct rtnl_mdb_dump_ctx {
+	long int idx;
+};
+
+struct ifconf {
+	int ifc_len;
+	union {
+		char *ifcu_buf;
+		struct ifreq *ifcu_req;
+	} ifc_ifcu;
+};
+
+typedef s32 compat_int_t;
+
+typedef u32 compat_ulong_t;
+
+typedef u32 compat_caddr_t;
+
+struct compat_ifmap {
+	compat_ulong_t mem_start;
+	compat_ulong_t mem_end;
+	short unsigned int base_addr;
+	unsigned char irq;
+	unsigned char dma;
+	unsigned char port;
+};
+
+struct compat_ifconf {
+	compat_int_t ifc_len;
+	compat_caddr_t ifcbuf;
+};
+
+struct hwtstamp_config {
+	int flags;
+	int tx_type;
+	int rx_filter;
+};
+
+enum hwtstamp_flags {
+	HWTSTAMP_FLAG_BONDED_PHC_INDEX = 1,
+	HWTSTAMP_FLAG_LAST = 1,
+	HWTSTAMP_FLAG_MASK = 1,
+};
+
+struct fib_notifier_net {
+	struct list_head fib_notifier_ops;
+	struct atomic_notifier_head fib_chain;
+};
+
+struct trace_event_raw_kfree_skb {
+	struct trace_entry ent;
+	void *skbaddr;
+	void *location;
+	void *rx_sk;
+	short unsigned int protocol;
+	enum skb_drop_reason reason;
+	char __data[0];
+};
+
+struct trace_event_raw_consume_skb {
+	struct trace_entry ent;
+	void *skbaddr;
+	void *location;
+	char __data[0];
+};
+
+struct trace_event_raw_skb_copy_datagram_iovec {
+	struct trace_entry ent;
+	const void *skbaddr;
+	int len;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_kfree_skb {};
+
+struct trace_event_data_offsets_consume_skb {};
+
+struct trace_event_data_offsets_skb_copy_datagram_iovec {};
+
+typedef void (*btf_trace_kfree_skb)(void *, struct sk_buff *, void *, enum skb_drop_reason, struct sock *);
+
+typedef void (*btf_trace_consume_skb)(void *, struct sk_buff *, void *);
+
+typedef void (*btf_trace_skb_copy_datagram_iovec)(void *, const struct sk_buff *, int);
+
+struct trace_event_raw_net_dev_start_xmit {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	u16 queue_mapping;
+	const void *skbaddr;
+	bool vlan_tagged;
+	u16 vlan_proto;
+	u16 vlan_tci;
+	u16 protocol;
+	u8 ip_summed;
+	unsigned int len;
+	unsigned int data_len;
+	int network_offset;
+	bool transport_offset_valid;
+	int transport_offset;
+	u8 tx_flags;
+	u16 gso_size;
+	u16 gso_segs;
+	u16 gso_type;
+	char __data[0];
+};
+
+struct trace_event_raw_net_dev_xmit {
+	struct trace_entry ent;
+	void *skbaddr;
+	unsigned int len;
+	int rc;
+	u32 __data_loc_name;
+	char __data[0];
+};
+
+struct trace_event_raw_net_dev_xmit_timeout {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	u32 __data_loc_driver;
+	int queue_index;
+	char __data[0];
+};
+
+struct trace_event_raw_net_dev_template {
+	struct trace_entry ent;
+	void *skbaddr;
+	unsigned int len;
+	u32 __data_loc_name;
+	char __data[0];
+};
+
+struct trace_event_raw_net_dev_rx_verbose_template {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	unsigned int napi_id;
+	u16 queue_mapping;
+	const void *skbaddr;
+	bool vlan_tagged;
+	u16 vlan_proto;
+	u16 vlan_tci;
+	u16 protocol;
+	u8 ip_summed;
+	u32 hash;
+	bool l4_hash;
+	unsigned int len;
+	unsigned int data_len;
+	unsigned int truesize;
+	bool mac_header_valid;
+	int mac_header;
+	unsigned char nr_frags;
+	u16 gso_size;
+	u16 gso_type;
+	char __data[0];
+};
+
+struct trace_event_raw_net_dev_rx_exit_template {
+	struct trace_entry ent;
+	int ret;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_net_dev_start_xmit {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_net_dev_xmit {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_net_dev_xmit_timeout {
+	u32 name;
+	const void *name_ptr_;
+	u32 driver;
+	const void *driver_ptr_;
+};
+
+struct trace_event_data_offsets_net_dev_template {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_net_dev_rx_verbose_template {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_net_dev_rx_exit_template {};
+
+typedef void (*btf_trace_net_dev_start_xmit)(void *, const struct sk_buff *, const struct net_device *);
+
+typedef void (*btf_trace_net_dev_xmit)(void *, struct sk_buff *, int, struct net_device *, unsigned int);
+
+typedef void (*btf_trace_net_dev_xmit_timeout)(void *, struct net_device *, int);
+
+typedef void (*btf_trace_net_dev_queue)(void *, struct sk_buff *);
+
+typedef void (*btf_trace_netif_receive_skb)(void *, struct sk_buff *);
+
+typedef void (*btf_trace_netif_rx)(void *, struct sk_buff *);
+
+typedef void (*btf_trace_napi_gro_frags_entry)(void *, const struct sk_buff *);
+
+typedef void (*btf_trace_napi_gro_receive_entry)(void *, const struct sk_buff *);
+
+typedef void (*btf_trace_netif_receive_skb_entry)(void *, const struct sk_buff *);
+
+typedef void (*btf_trace_netif_receive_skb_list_entry)(void *, const struct sk_buff *);
+
+typedef void (*btf_trace_netif_rx_entry)(void *, const struct sk_buff *);
+
+typedef void (*btf_trace_napi_gro_frags_exit)(void *, int);
+
+typedef void (*btf_trace_napi_gro_receive_exit)(void *, int);
+
+typedef void (*btf_trace_netif_receive_skb_exit)(void *, int);
+
+typedef void (*btf_trace_netif_rx_exit)(void *, int);
+
+typedef void (*btf_trace_netif_receive_skb_list_exit)(void *, int);
+
+struct trace_event_raw_napi_poll {
+	struct trace_entry ent;
+	struct napi_struct *napi;
+	u32 __data_loc_dev_name;
+	int work;
+	int budget;
+	char __data[0];
+};
+
+struct trace_event_raw_dql_stall_detected {
+	struct trace_entry ent;
+	short unsigned int thrs;
+	unsigned int len;
+	long unsigned int last_reap;
+	long unsigned int hist_head;
+	long unsigned int now;
+	long unsigned int hist[4];
+	char __data[0];
+};
+
+struct trace_event_data_offsets_napi_poll {
+	u32 dev_name;
+	const void *dev_name_ptr_;
+};
+
+struct trace_event_data_offsets_dql_stall_detected {};
+
+typedef void (*btf_trace_napi_poll)(void *, struct napi_struct *, int, int);
+
+typedef void (*btf_trace_dql_stall_detected)(void *, short unsigned int, unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int *);
+
+struct trace_event_raw_sock_rcvqueue_full {
+	struct trace_entry ent;
+	int rmem_alloc;
+	unsigned int truesize;
+	int sk_rcvbuf;
+	char __data[0];
+};
+
+struct trace_event_raw_sock_exceed_buf_limit {
+	struct trace_entry ent;
+	char name[32];
+	long int sysctl_mem[3];
+	long int allocated;
+	int sysctl_rmem;
+	int rmem_alloc;
+	int sysctl_wmem;
+	int wmem_alloc;
+	int wmem_queued;
+	int kind;
+	char __data[0];
+};
+
+struct trace_event_raw_inet_sock_set_state {
+	struct trace_entry ent;
+	const void *skaddr;
+	int oldstate;
+	int newstate;
+	__u16 sport;
+	__u16 dport;
+	__u16 family;
+	__u16 protocol;
+	__u8 saddr[4];
+	__u8 daddr[4];
+	__u8 saddr_v6[16];
+	__u8 daddr_v6[16];
+	char __data[0];
+};
+
+struct trace_event_raw_inet_sk_error_report {
+	struct trace_entry ent;
+	int error;
+	__u16 sport;
+	__u16 dport;
+	__u16 family;
+	__u16 protocol;
+	__u8 saddr[4];
+	__u8 daddr[4];
+	__u8 saddr_v6[16];
+	__u8 daddr_v6[16];
+	char __data[0];
+};
+
+struct trace_event_raw_sk_data_ready {
+	struct trace_entry ent;
+	const void *skaddr;
+	__u16 family;
+	__u16 protocol;
+	long unsigned int ip;
+	char __data[0];
+};
+
+struct trace_event_raw_sock_msg_length {
+	struct trace_entry ent;
+	void *sk;
+	__u16 family;
+	__u16 protocol;
+	int ret;
+	int flags;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_sock_rcvqueue_full {};
+
+struct trace_event_data_offsets_sock_exceed_buf_limit {};
+
+struct trace_event_data_offsets_inet_sock_set_state {};
+
+struct trace_event_data_offsets_inet_sk_error_report {};
+
+struct trace_event_data_offsets_sk_data_ready {};
+
+struct trace_event_data_offsets_sock_msg_length {};
+
+typedef void (*btf_trace_sock_rcvqueue_full)(void *, struct sock *, struct sk_buff *);
+
+typedef void (*btf_trace_sock_exceed_buf_limit)(void *, struct sock *, struct proto *, long int, int);
+
+typedef void (*btf_trace_inet_sock_set_state)(void *, const struct sock *, const int, const int);
+
+typedef void (*btf_trace_inet_sk_error_report)(void *, const struct sock *);
+
+typedef void (*btf_trace_sk_data_ready)(void *, const struct sock *);
+
+typedef void (*btf_trace_sock_send_length)(void *, struct sock *, int, int);
+
+typedef void (*btf_trace_sock_recv_length)(void *, struct sock *, int, int);
+
+struct trace_event_raw_udp_fail_queue_rcv_skb {
+	struct trace_entry ent;
+	int rc;
+	__u16 sport;
+	__u16 dport;
+	__u16 family;
+	__u8 saddr[28];
+	__u8 daddr[28];
+	char __data[0];
+};
+
+struct trace_event_data_offsets_udp_fail_queue_rcv_skb {};
+
+typedef void (*btf_trace_udp_fail_queue_rcv_skb)(void *, int, struct sock *, struct sk_buff *);
+
+struct trace_event_raw_tcp_event_sk_skb {
+	struct trace_entry ent;
+	const void *skbaddr;
+	const void *skaddr;
+	int state;
+	__u16 sport;
+	__u16 dport;
+	__u16 family;
+	__u8 saddr[4];
+	__u8 daddr[4];
+	__u8 saddr_v6[16];
+	__u8 daddr_v6[16];
+	char __data[0];
+};
+
+struct trace_event_raw_tcp_send_reset {
+	struct trace_entry ent;
+	const void *skbaddr;
+	const void *skaddr;
+	int state;
+	enum sk_rst_reason reason;
+	__u8 saddr[28];
+	__u8 daddr[28];
+	char __data[0];
+};
+
+struct trace_event_raw_tcp_event_sk {
+	struct trace_entry ent;
+	const void *skaddr;
+	__u16 sport;
+	__u16 dport;
+	__u16 family;
+	__u8 saddr[4];
+	__u8 daddr[4];
+	__u8 saddr_v6[16];
+	__u8 daddr_v6[16];
+	long: 32;
+	__u64 sock_cookie;
+	char __data[0];
+};
+
+struct trace_event_raw_tcp_retransmit_synack {
+	struct trace_entry ent;
+	const void *skaddr;
+	const void *req;
+	__u16 sport;
+	__u16 dport;
+	__u16 family;
+	__u8 saddr[4];
+	__u8 daddr[4];
+	__u8 saddr_v6[16];
+	__u8 daddr_v6[16];
+	char __data[0];
+};
+
+struct trace_event_raw_tcp_probe {
+	struct trace_entry ent;
+	__u8 saddr[28];
+	__u8 daddr[28];
+	__u16 sport;
+	__u16 dport;
+	__u16 family;
+	__u32 mark;
+	__u16 data_len;
+	__u32 snd_nxt;
+	__u32 snd_una;
+	__u32 snd_cwnd;
+	__u32 ssthresh;
+	__u32 snd_wnd;
+	__u32 srtt;
+	__u32 rcv_wnd;
+	long: 32;
+	__u64 sock_cookie;
+	const void *skbaddr;
+	const void *skaddr;
+	char __data[0];
+};
+
+struct trace_event_raw_tcp_event_skb {
+	struct trace_entry ent;
+	const void *skbaddr;
+	__u8 saddr[28];
+	__u8 daddr[28];
+	char __data[0];
+};
+
+struct trace_event_raw_tcp_cong_state_set {
+	struct trace_entry ent;
+	const void *skaddr;
+	__u16 sport;
+	__u16 dport;
+	__u16 family;
+	__u8 saddr[4];
+	__u8 daddr[4];
+	__u8 saddr_v6[16];
+	__u8 daddr_v6[16];
+	__u8 cong_state;
+	char __data[0];
+};
+
+struct trace_event_raw_tcp_hash_event {
+	struct trace_entry ent;
+	__u64 net_cookie;
+	const void *skbaddr;
+	const void *skaddr;
+	int state;
+	__u8 saddr[28];
+	__u8 daddr[28];
+	int l3index;
+	__u16 sport;
+	__u16 dport;
+	__u16 family;
+	bool fin;
+	bool syn;
+	bool rst;
+	bool psh;
+	bool ack;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_tcp_ao_event {
+	struct trace_entry ent;
+	__u64 net_cookie;
+	const void *skbaddr;
+	const void *skaddr;
+	int state;
+	__u8 saddr[28];
+	__u8 daddr[28];
+	int l3index;
+	__u16 sport;
+	__u16 dport;
+	__u16 family;
+	bool fin;
+	bool syn;
+	bool rst;
+	bool psh;
+	bool ack;
+	__u8 keyid;
+	__u8 rnext;
+	__u8 maclen;
+	char __data[0];
+};
+
+struct trace_event_raw_tcp_ao_event_sk {
+	struct trace_entry ent;
+	__u64 net_cookie;
+	const void *skaddr;
+	int state;
+	__u8 saddr[28];
+	__u8 daddr[28];
+	__u16 sport;
+	__u16 dport;
+	__u16 family;
+	__u8 keyid;
+	__u8 rnext;
+	char __data[0];
+};
+
+struct trace_event_raw_tcp_ao_event_sne {
+	struct trace_entry ent;
+	__u64 net_cookie;
+	const void *skaddr;
+	int state;
+	__u8 saddr[28];
+	__u8 daddr[28];
+	__u16 sport;
+	__u16 dport;
+	__u16 family;
+	__u32 new_sne;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_data_offsets_tcp_event_sk_skb {};
+
+struct trace_event_data_offsets_tcp_send_reset {};
+
+struct trace_event_data_offsets_tcp_event_sk {};
+
+struct trace_event_data_offsets_tcp_retransmit_synack {};
+
+struct trace_event_data_offsets_tcp_probe {};
+
+struct trace_event_data_offsets_tcp_event_skb {};
+
+struct trace_event_data_offsets_tcp_cong_state_set {};
+
+struct trace_event_data_offsets_tcp_hash_event {};
+
+struct trace_event_data_offsets_tcp_ao_event {};
+
+struct trace_event_data_offsets_tcp_ao_event_sk {};
+
+struct trace_event_data_offsets_tcp_ao_event_sne {};
+
+typedef void (*btf_trace_tcp_retransmit_skb)(void *, const struct sock *, const struct sk_buff *);
+
+typedef void (*btf_trace_tcp_send_reset)(void *, const struct sock *, const struct sk_buff *, const enum sk_rst_reason);
+
+typedef void (*btf_trace_tcp_receive_reset)(void *, struct sock *);
+
+typedef void (*btf_trace_tcp_destroy_sock)(void *, struct sock *);
+
+typedef void (*btf_trace_tcp_rcv_space_adjust)(void *, struct sock *);
+
+typedef void (*btf_trace_tcp_retransmit_synack)(void *, const struct sock *, const struct request_sock *);
+
+typedef void (*btf_trace_tcp_probe)(void *, struct sock *, struct sk_buff *);
+
+typedef void (*btf_trace_tcp_bad_csum)(void *, const struct sk_buff *);
+
+typedef void (*btf_trace_tcp_cong_state_set)(void *, struct sock *, const u8);
+
+typedef void (*btf_trace_tcp_hash_bad_header)(void *, const struct sock *, const struct sk_buff *);
+
+typedef void (*btf_trace_tcp_hash_md5_required)(void *, const struct sock *, const struct sk_buff *);
+
+typedef void (*btf_trace_tcp_hash_md5_unexpected)(void *, const struct sock *, const struct sk_buff *);
+
+typedef void (*btf_trace_tcp_hash_md5_mismatch)(void *, const struct sock *, const struct sk_buff *);
+
+typedef void (*btf_trace_tcp_hash_ao_required)(void *, const struct sock *, const struct sk_buff *);
+
+typedef void (*btf_trace_tcp_ao_handshake_failure)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);
+
+typedef void (*btf_trace_tcp_ao_wrong_maclen)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);
+
+typedef void (*btf_trace_tcp_ao_mismatch)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);
+
+typedef void (*btf_trace_tcp_ao_key_not_found)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);
+
+typedef void (*btf_trace_tcp_ao_rnext_request)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);
+
+typedef void (*btf_trace_tcp_ao_synack_no_key)(void *, const struct sock *, const __u8, const __u8);
+
+typedef void (*btf_trace_tcp_ao_snd_sne_update)(void *, const struct sock *, __u32);
+
+typedef void (*btf_trace_tcp_ao_rcv_sne_update)(void *, const struct sock *, __u32);
+
+struct trace_event_raw_fib_table_lookup {
+	struct trace_entry ent;
+	u32 tb_id;
+	int err;
+	int oif;
+	int iif;
+	u8 proto;
+	__u8 tos;
+	__u8 scope;
+	__u8 flags;
+	__u8 src[4];
+	__u8 dst[4];
+	__u8 gw4[4];
+	__u8 gw6[16];
+	u16 sport;
+	u16 dport;
+	char name[16];
+	char __data[0];
+};
+
+struct trace_event_data_offsets_fib_table_lookup {};
+
+typedef void (*btf_trace_fib_table_lookup)(void *, u32, const struct flowi4 *, const struct fib_nh_common *, int);
+
+struct trace_event_raw_qdisc_dequeue {
+	struct trace_entry ent;
+	struct Qdisc *qdisc;
+	const struct netdev_queue *txq;
+	int packets;
+	void *skbaddr;
+	int ifindex;
+	u32 handle;
+	u32 parent;
+	long unsigned int txq_state;
+	char __data[0];
+};
+
+struct trace_event_raw_qdisc_enqueue {
+	struct trace_entry ent;
+	struct Qdisc *qdisc;
+	const struct netdev_queue *txq;
+	void *skbaddr;
+	int ifindex;
+	u32 handle;
+	u32 parent;
+	char __data[0];
+};
+
+struct trace_event_raw_qdisc_reset {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	u32 __data_loc_kind;
+	u32 parent;
+	u32 handle;
+	char __data[0];
+};
+
+struct trace_event_raw_qdisc_destroy {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	u32 __data_loc_kind;
+	u32 parent;
+	u32 handle;
+	char __data[0];
+};
+
+struct trace_event_raw_qdisc_create {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	u32 __data_loc_kind;
+	u32 parent;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_qdisc_dequeue {};
+
+struct trace_event_data_offsets_qdisc_enqueue {};
+
+struct trace_event_data_offsets_qdisc_reset {
+	u32 dev;
+	const void *dev_ptr_;
+	u32 kind;
+	const void *kind_ptr_;
+};
+
+struct trace_event_data_offsets_qdisc_destroy {
+	u32 dev;
+	const void *dev_ptr_;
+	u32 kind;
+	const void *kind_ptr_;
+};
+
+struct trace_event_data_offsets_qdisc_create {
+	u32 dev;
+	const void *dev_ptr_;
+	u32 kind;
+	const void *kind_ptr_;
+};
+
+typedef void (*btf_trace_qdisc_dequeue)(void *, struct Qdisc *, const struct netdev_queue *, int, struct sk_buff *);
+
+typedef void (*btf_trace_qdisc_enqueue)(void *, struct Qdisc *, const struct netdev_queue *, struct sk_buff *);
+
+typedef void (*btf_trace_qdisc_reset)(void *, struct Qdisc *);
+
+typedef void (*btf_trace_qdisc_destroy)(void *, struct Qdisc *);
+
+typedef void (*btf_trace_qdisc_create)(void *, const struct Qdisc_ops *, struct net_device *, u32);
+
+struct trace_event_raw_br_fdb_add {
+	struct trace_entry ent;
+	u8 ndm_flags;
+	u32 __data_loc_dev;
+	unsigned char addr[6];
+	u16 vid;
+	u16 nlh_flags;
+	char __data[0];
+};
+
+struct trace_event_raw_br_fdb_external_learn_add {
+	struct trace_entry ent;
+	u32 __data_loc_br_dev;
+	u32 __data_loc_dev;
+	unsigned char addr[6];
+	u16 vid;
+	char __data[0];
+};
+
+struct trace_event_raw_fdb_delete {
+	struct trace_entry ent;
+	u32 __data_loc_br_dev;
+	u32 __data_loc_dev;
+	unsigned char addr[6];
+	u16 vid;
+	char __data[0];
+};
+
+struct trace_event_raw_br_fdb_update {
+	struct trace_entry ent;
+	u32 __data_loc_br_dev;
+	u32 __data_loc_dev;
+	unsigned char addr[6];
+	u16 vid;
+	long unsigned int flags;
+	char __data[0];
+};
+
+struct trace_event_raw_br_mdb_full {
+	struct trace_entry ent;
+	u32 __data_loc_dev;
+	int af;
+	u16 vid;
+	__u8 src[16];
+	__u8 grp[16];
+	__u8 grpmac[6];
+	char __data[0];
+};
+
+struct trace_event_data_offsets_br_fdb_add {
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+struct trace_event_data_offsets_br_fdb_external_learn_add {
+	u32 br_dev;
+	const void *br_dev_ptr_;
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+struct trace_event_data_offsets_fdb_delete {
+	u32 br_dev;
+	const void *br_dev_ptr_;
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+struct trace_event_data_offsets_br_fdb_update {
+	u32 br_dev;
+	const void *br_dev_ptr_;
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+struct trace_event_data_offsets_br_mdb_full {
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+typedef void (*btf_trace_br_fdb_add)(void *, struct ndmsg *, struct net_device *, const unsigned char *, u16, u16);
+
+typedef void (*btf_trace_br_fdb_external_learn_add)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16);
+
+typedef void (*btf_trace_fdb_delete)(void *, struct net_bridge *, struct net_bridge_fdb_entry *);
+
+typedef void (*btf_trace_br_fdb_update)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16, long unsigned int);
+
+typedef void (*btf_trace_br_mdb_full)(void *, const struct net_device *, const struct br_ip *);
+
+struct trace_event_raw_page_pool_release {
+	struct trace_entry ent;
+	const struct page_pool *pool;
+	s32 inflight;
+	u32 hold;
+	u32 release;
+	u64 cnt;
+	char __data[0];
+};
+
+struct trace_event_raw_page_pool_state_release {
+	struct trace_entry ent;
+	const struct page_pool *pool;
+	long unsigned int netmem;
+	u32 release;
+	long unsigned int pfn;
+	char __data[0];
+};
+
+struct trace_event_raw_page_pool_state_hold {
+	struct trace_entry ent;
+	const struct page_pool *pool;
+	long unsigned int netmem;
+	u32 hold;
+	long unsigned int pfn;
+	char __data[0];
+};
+
+struct trace_event_raw_page_pool_update_nid {
+	struct trace_entry ent;
+	const struct page_pool *pool;
+	int pool_nid;
+	int new_nid;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_page_pool_release {};
+
+struct trace_event_data_offsets_page_pool_state_release {};
+
+struct trace_event_data_offsets_page_pool_state_hold {};
+
+struct trace_event_data_offsets_page_pool_update_nid {};
+
+typedef void (*btf_trace_page_pool_release)(void *, const struct page_pool *, s32, u32, u32);
+
+typedef void (*btf_trace_page_pool_state_release)(void *, const struct page_pool *, netmem_ref, u32);
+
+typedef void (*btf_trace_page_pool_state_hold)(void *, const struct page_pool *, netmem_ref, u32);
+
+typedef void (*btf_trace_page_pool_update_nid)(void *, const struct page_pool *, int);
+
+struct trace_event_raw_neigh_create {
+	struct trace_entry ent;
+	u32 family;
+	u32 __data_loc_dev;
+	int entries;
+	u8 created;
+	u8 gc_exempt;
+	u8 primary_key4[4];
+	u8 primary_key6[16];
+	char __data[0];
+};
+
+struct trace_event_raw_neigh_update {
+	struct trace_entry ent;
+	u32 family;
+	u32 __data_loc_dev;
+	u8 lladdr[32];
+	u8 lladdr_len;
+	u8 flags;
+	u8 nud_state;
+	u8 type;
+	u8 dead;
+	int refcnt;
+	__u8 primary_key4[4];
+	__u8 primary_key6[16];
+	long unsigned int confirmed;
+	long unsigned int updated;
+	long unsigned int used;
+	u8 new_lladdr[32];
+	u8 new_state;
+	u32 update_flags;
+	u32 pid;
+	char __data[0];
+};
+
+struct trace_event_raw_neigh__update {
+	struct trace_entry ent;
+	u32 family;
+	u32 __data_loc_dev;
+	u8 lladdr[32];
+	u8 lladdr_len;
+	u8 flags;
+	u8 nud_state;
+	u8 type;
+	u8 dead;
+	int refcnt;
+	__u8 primary_key4[4];
+	__u8 primary_key6[16];
+	long unsigned int confirmed;
+	long unsigned int updated;
+	long unsigned int used;
+	u32 err;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_neigh_create {
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+struct trace_event_data_offsets_neigh_update {
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+struct trace_event_data_offsets_neigh__update {
+	u32 dev;
+	const void *dev_ptr_;
+};
+
+typedef void (*btf_trace_neigh_create)(void *, struct neigh_table *, struct net_device *, const void *, const struct neighbour *, bool);
+
+typedef void (*btf_trace_neigh_update)(void *, struct neighbour *, const u8 *, u8, u32, u32);
+
+typedef void (*btf_trace_neigh_update_done)(void *, struct neighbour *, int);
+
+typedef void (*btf_trace_neigh_timer_handler)(void *, struct neighbour *, int);
+
+typedef void (*btf_trace_neigh_event_send_done)(void *, struct neighbour *, int);
+
+typedef void (*btf_trace_neigh_event_send_dead)(void *, struct neighbour *, int);
+
+typedef void (*btf_trace_neigh_cleanup_and_release)(void *, struct neighbour *, int);
+
+enum {
+	BPF_LOCAL_STORAGE_GET_F_CREATE = 1,
+	BPF_SK_STORAGE_GET_F_CREATE = 1,
+};
+
+struct bpf_local_storage_elem {
+	struct hlist_node map_node;
+	struct hlist_node snode;
+	struct bpf_local_storage *local_storage;
+	struct callback_head rcu;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct bpf_local_storage_data sdata;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct bpf_local_storage_cache {
+	spinlock_t idx_lock;
+	long: 32;
+	u64 idx_usage_counts[16];
+};
+
+enum {
+	SK_DIAG_BPF_STORAGE_REQ_NONE = 0,
+	SK_DIAG_BPF_STORAGE_REQ_MAP_FD = 1,
+	__SK_DIAG_BPF_STORAGE_REQ_MAX = 2,
+};
+
+enum {
+	SK_DIAG_BPF_STORAGE_REP_NONE = 0,
+	SK_DIAG_BPF_STORAGE = 1,
+	__SK_DIAG_BPF_STORAGE_REP_MAX = 2,
+};
+
+enum {
+	SK_DIAG_BPF_STORAGE_NONE = 0,
+	SK_DIAG_BPF_STORAGE_PAD = 1,
+	SK_DIAG_BPF_STORAGE_MAP_ID = 2,
+	SK_DIAG_BPF_STORAGE_MAP_VALUE = 3,
+	__SK_DIAG_BPF_STORAGE_MAX = 4,
+};
+
+typedef u64 (*btf_bpf_sk_storage_get)(struct bpf_map *, struct sock *, void *, u64, gfp_t);
+
+typedef u64 (*btf_bpf_sk_storage_delete)(struct bpf_map *, struct sock *);
+
+typedef u64 (*btf_bpf_sk_storage_get_tracing)(struct bpf_map *, struct sock *, void *, u64, gfp_t);
+
+typedef u64 (*btf_bpf_sk_storage_delete_tracing)(struct bpf_map *, struct sock *);
+
+struct bpf_sk_storage_diag {
+	u32 nr_maps;
+	struct bpf_map *maps[0];
+};
+
+struct bpf_iter_seq_sk_storage_map_info {
+	struct bpf_map *map;
+	unsigned int bucket_id;
+	unsigned int skip_elems;
+};
+
+struct bpf_iter__bpf_sk_storage_map {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct bpf_map *map;
+	};
+	union {
+		struct sock *sk;
+	};
+	union {
+		void *value;
+	};
+};
+
+struct datalink_proto {
+	unsigned char type[8];
+	struct llc_sap *sap;
+	short unsigned int header_length;
+	int (*rcvfunc)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
+	int (*request)(struct datalink_proto *, struct sk_buff *, const unsigned char *);
+	struct list_head node;
+};
+
+struct tc_ratespec {
+	unsigned char cell_log;
+	__u8 linklayer;
+	short unsigned int overhead;
+	short int cell_align;
+	short unsigned int mpu;
+	__u32 rate;
+};
+
+struct tc_prio_qopt {
+	int bands;
+	__u8 priomap[16];
+};
+
+struct skb_array {
+	struct ptr_ring ring;
+};
+
+struct psched_ratecfg {
+	u64 rate_bytes_ps;
+	u32 mult;
+	u16 overhead;
+	u16 mpu;
+	u8 linklayer;
+	u8 shift;
+	long: 32;
+};
+
+struct psched_pktrate {
+	u64 rate_pkts_ps;
+	u32 mult;
+	u8 shift;
+};
+
+struct mini_Qdisc_pair {
+	struct mini_Qdisc miniq1;
+	struct mini_Qdisc miniq2;
+	struct mini_Qdisc **p_miniq;
+};
+
+struct pfifo_fast_priv {
+	struct skb_array q[3];
+};
+
+struct tcamsg {
+	unsigned char tca_family;
+	unsigned char tca__pad1;
+	short unsigned int tca__pad2;
+};
+
+enum {
+	TCA_ROOT_UNSPEC = 0,
+	TCA_ROOT_TAB = 1,
+	TCA_ROOT_FLAGS = 2,
+	TCA_ROOT_COUNT = 3,
+	TCA_ROOT_TIME_DELTA = 4,
+	TCA_ROOT_EXT_WARN_MSG = 5,
+	__TCA_ROOT_MAX = 6,
+};
+
+struct tc_action_net {
+	struct tcf_idrinfo *idrinfo;
+	const struct tc_action_ops *ops;
+};
+
+struct tc_act_pernet_id {
+	struct list_head list;
+	unsigned int id;
+};
+
+struct unix_edge;
+
+struct scm_fp_list {
+	short int count;
+	short int count_unix;
+	short int max;
+	bool inflight;
+	bool dead;
+	struct list_head vertices;
+	struct unix_edge *edges;
+	struct user_struct *user;
+	struct file *fp[253];
+};
+
+struct scm_cookie {
+	struct pid *pid;
+	struct scm_fp_list *fp;
+	struct scm_creds creds;
+};
+
+struct sockaddr_nl {
+	__kernel_sa_family_t nl_family;
+	short unsigned int nl_pad;
+	__u32 nl_pid;
+	__u32 nl_groups;
+};
+
+enum nlmsgerr_attrs {
+	NLMSGERR_ATTR_UNUSED = 0,
+	NLMSGERR_ATTR_MSG = 1,
+	NLMSGERR_ATTR_OFFS = 2,
+	NLMSGERR_ATTR_COOKIE = 3,
+	NLMSGERR_ATTR_POLICY = 4,
+	NLMSGERR_ATTR_MISS_TYPE = 5,
+	NLMSGERR_ATTR_MISS_NEST = 6,
+	__NLMSGERR_ATTR_MAX = 7,
+	NLMSGERR_ATTR_MAX = 6,
+};
+
+struct nl_pktinfo {
+	__u32 group;
+};
+
+enum {
+	NETLINK_UNCONNECTED = 0,
+	NETLINK_CONNECTED = 1,
+};
+
+enum netlink_skb_flags {
+	NETLINK_SKB_DST = 8,
+};
+
+struct netlink_notify {
+	struct net *net;
+	u32 portid;
+	int protocol;
+};
+
+struct netlink_tap {
+	struct net_device *dev;
+	struct module *module;
+	struct list_head list;
+};
+
+struct trace_event_raw_netlink_extack {
+	struct trace_entry ent;
+	u32 __data_loc_msg;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_netlink_extack {
+	u32 msg;
+	const void *msg_ptr_;
+};
+
+typedef void (*btf_trace_netlink_extack)(void *, const char *);
+
+enum {
+	NETLINK_F_KERNEL_SOCKET = 0,
+	NETLINK_F_RECV_PKTINFO = 1,
+	NETLINK_F_BROADCAST_SEND_ERROR = 2,
+	NETLINK_F_RECV_NO_ENOBUFS = 3,
+	NETLINK_F_LISTEN_ALL_NSID = 4,
+	NETLINK_F_CAP_ACK = 5,
+	NETLINK_F_EXT_ACK = 6,
+	NETLINK_F_STRICT_CHK = 7,
+};
+
+struct netlink_sock {
+	struct sock sk;
+	long unsigned int flags;
+	u32 portid;
+	u32 dst_portid;
+	u32 dst_group;
+	u32 subscriptions;
+	u32 ngroups;
+	long unsigned int *groups;
+	long unsigned int state;
+	size_t max_recvmsg_len;
+	wait_queue_head_t wait;
+	bool bound;
+	bool cb_running;
+	int dump_done_errno;
+	struct netlink_callback cb;
+	struct mutex nl_cb_mutex;
+	void (*netlink_rcv)(struct sk_buff *);
+	int (*netlink_bind)(struct net *, int);
+	void (*netlink_unbind)(struct net *, int);
+	void (*netlink_release)(struct sock *, long unsigned int *);
+	struct module *module;
+	struct rhash_head node;
+	struct callback_head rcu;
+};
+
+struct listeners;
+
+struct netlink_table {
+	struct rhashtable hash;
+	struct hlist_head mc_list;
+	struct listeners *listeners;
+	unsigned int flags;
+	unsigned int groups;
+	struct mutex *cb_mutex;
+	struct module *module;
+	int (*bind)(struct net *, int);
+	void (*unbind)(struct net *, int);
+	void (*release)(struct sock *, long unsigned int *);
+	int registered;
+};
+
+struct listeners {
+	struct callback_head rcu;
+	long unsigned int masks[0];
+};
+
+struct netlink_tap_net {
+	struct list_head netlink_tap_all;
+	struct mutex netlink_tap_lock;
+};
+
+struct netlink_compare_arg {
+	possible_net_t pnet;
+	u32 portid;
+};
+
+struct netlink_broadcast_data {
+	struct sock *exclude_sk;
+	struct net *net;
+	u32 portid;
+	u32 group;
+	int failure;
+	int delivery_failure;
+	int congested;
+	int delivered;
+	gfp_t allocation;
+	struct sk_buff *skb;
+	struct sk_buff *skb2;
+	int (*tx_filter)(struct sock *, struct sk_buff *, void *);
+	void *tx_data;
+};
+
+struct netlink_set_err_data {
+	struct sock *exclude_sk;
+	u32 portid;
+	u32 group;
+	int code;
+};
+
+struct nl_seq_iter {
+	struct seq_net_private p;
+	struct rhashtable_iter hti;
+	int link;
+};
+
+struct bpf_iter__netlink {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct netlink_sock *sk;
+	};
+};
+
+struct ethtool_forced_speed_map {
+	u32 speed;
+	long unsigned int caps[4];
+	const u32 *cap_arr;
+	u32 arr_size;
+};
+
+struct link_mode_info {
+	int speed;
+	u8 lanes;
+	u8 duplex;
+};
+
+struct linkinfo_reply_data {
+	struct ethnl_reply_data base;
+	struct ethtool_link_ksettings ksettings;
+	struct ethtool_link_settings *lsettings;
+};
+
+struct debug_reply_data {
+	struct ethnl_reply_data base;
+	u32 msg_mask;
+};
+
+struct privflags_reply_data {
+	struct ethnl_reply_data base;
+	const char (*priv_flag_names)[32];
+	unsigned int n_priv_flags;
+	u32 priv_flags;
+};
+
+enum {
+	ETHTOOL_A_PAUSE_STAT_UNSPEC = 0,
+	ETHTOOL_A_PAUSE_STAT_PAD = 1,
+	ETHTOOL_A_PAUSE_STAT_TX_FRAMES = 2,
+	ETHTOOL_A_PAUSE_STAT_RX_FRAMES = 3,
+	__ETHTOOL_A_PAUSE_STAT_CNT = 4,
+	ETHTOOL_A_PAUSE_STAT_MAX = 3,
+};
+
+struct pause_req_info {
+	struct ethnl_req_info base;
+	enum ethtool_mac_stats_src src;
+};
+
+struct pause_reply_data {
+	struct ethnl_reply_data base;
+	struct ethtool_pauseparam pauseparam;
+	long: 32;
+	struct ethtool_pause_stats pausestat;
+};
+
+enum {
+	ETHTOOL_A_TUNNEL_UDP_ENTRY_UNSPEC = 0,
+	ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT = 1,
+	ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE = 2,
+	__ETHTOOL_A_TUNNEL_UDP_ENTRY_CNT = 3,
+	ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX = 2,
+};
+
+enum {
+	ETHTOOL_A_TUNNEL_UDP_TABLE_UNSPEC = 0,
+	ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE = 1,
+	ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES = 2,
+	ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY = 3,
+	__ETHTOOL_A_TUNNEL_UDP_TABLE_CNT = 4,
+	ETHTOOL_A_TUNNEL_UDP_TABLE_MAX = 3,
+};
+
+enum {
+	ETHTOOL_A_TUNNEL_UDP_UNSPEC = 0,
+	ETHTOOL_A_TUNNEL_UDP_TABLE = 1,
+	__ETHTOOL_A_TUNNEL_UDP_CNT = 2,
+	ETHTOOL_A_TUNNEL_UDP_MAX = 1,
+};
+
+enum udp_parsable_tunnel_type {
+	UDP_TUNNEL_TYPE_VXLAN = 1,
+	UDP_TUNNEL_TYPE_GENEVE = 2,
+	UDP_TUNNEL_TYPE_VXLAN_GPE = 4,
+};
+
+enum udp_tunnel_nic_info_flags {
+	UDP_TUNNEL_NIC_INFO_MAY_SLEEP = 1,
+	UDP_TUNNEL_NIC_INFO_OPEN_ONLY = 2,
+	UDP_TUNNEL_NIC_INFO_IPV4_ONLY = 4,
+	UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN = 8,
+};
+
+struct udp_tunnel_nic_ops {
+	void (*get_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
+	void (*set_port_priv)(struct net_device *, unsigned int, unsigned int, u8);
+	void (*add_port)(struct net_device *, struct udp_tunnel_info *);
+	void (*del_port)(struct net_device *, struct udp_tunnel_info *);
+	void (*reset_ntf)(struct net_device *);
+	size_t (*dump_size)(struct net_device *, unsigned int);
+	int (*dump_write)(struct net_device *, unsigned int, struct sk_buff *);
+};
+
+struct ethnl_tunnel_info_dump_ctx {
+	struct ethnl_req_info req_info;
+	long unsigned int ifindex;
+};
+
+struct ethtool_cmis_cdb {
+	u8 cmis_rev;
+	u8 read_write_len_ext;
+	u16 max_completion_time;
+};
+
+enum ethtool_cmis_cdb_cmd_id {
+	ETHTOOL_CMIS_CDB_CMD_QUERY_STATUS = 0,
+	ETHTOOL_CMIS_CDB_CMD_MODULE_FEATURES = 64,
+	ETHTOOL_CMIS_CDB_CMD_FW_MANAGMENT_FEATURES = 65,
+	ETHTOOL_CMIS_CDB_CMD_START_FW_DOWNLOAD = 257,
+	ETHTOOL_CMIS_CDB_CMD_WRITE_FW_BLOCK_LPL = 259,
+	ETHTOOL_CMIS_CDB_CMD_COMPLETE_FW_DOWNLOAD = 263,
+	ETHTOOL_CMIS_CDB_CMD_RUN_FW_IMAGE = 265,
+	ETHTOOL_CMIS_CDB_CMD_COMMIT_FW_IMAGE = 266,
+};
+
+struct ethtool_cmis_cdb_request {
+	__be16 id;
+	union {
+		struct {
+			__be16 epl_len;
+			u8 lpl_len;
+			u8 chk_code;
+			u8 resv1;
+			u8 resv2;
+			u8 payload[120];
+		};
+		struct {
+			__be16 epl_len;
+			u8 lpl_len;
+			u8 chk_code;
+			u8 resv1;
+			u8 resv2;
+			u8 payload[120];
+		} body;
+	};
+};
+
+struct ethtool_cmis_cdb_cmd_args {
+	struct ethtool_cmis_cdb_request req;
+	u16 max_duration;
+	u8 read_write_len_ext;
+	u8 msleep_pre_rpl;
+	u8 rpl_exp_len;
+	u8 flags;
+	char *err_msg;
+};
+
+struct ethtool_cmis_cdb_rpl_hdr {
+	u8 rpl_len;
+	u8 rpl_chk_code;
+};
+
+struct ethtool_cmis_cdb_rpl {
+	struct ethtool_cmis_cdb_rpl_hdr hdr;
+	u8 payload[120];
+};
+
+struct cmis_rev_rpl {
+	u8 rev;
+};
+
+struct cmis_cdb_advert_rpl {
+	u8 inst_supported;
+	u8 read_write_len_ext;
+	u8 resv1;
+	u8 resv2;
+};
+
+struct cmis_password_entry_pl {
+	__be32 password;
+};
+
+struct cmis_cdb_query_status_pl {
+	u16 response_delay;
+};
+
+struct cmis_cdb_query_status_rpl {
+	u8 length;
+	u8 status;
+};
+
+struct cmis_cdb_module_features_rpl {
+	u8 resv1[34];
+	__be16 max_completion_time;
+};
+
+struct cmis_wait_for_cond_rpl {
+	u8 state;
+};
+
+struct nf_log_buf {
+	unsigned int count;
+	char buf[1020];
+};
+
+enum nf_hook_ops_type {
+	NF_HOOK_OP_UNDEFINED = 0,
+	NF_HOOK_OP_NF_TABLES = 1,
+	NF_HOOK_OP_BPF = 2,
+};
+
+struct nf_hook_ops {
+	nf_hookfn *hook;
+	struct net_device *dev;
+	void *priv;
+	u8 pf;
+	enum nf_hook_ops_type hook_ops_type: 8;
+	unsigned int hooknum;
+	int priority;
+};
+
+struct nf_defrag_hook {
+	struct module *owner;
+	int (*enable)(struct net *);
+	void (*disable)(struct net *);
+};
+
+struct bpf_nf_ctx {
+	const struct nf_hook_state *state;
+	struct sk_buff *skb;
+};
+
+enum nf_ip_hook_priorities {
+	NF_IP_PRI_FIRST = -2147483648,
+	NF_IP_PRI_RAW_BEFORE_DEFRAG = -450,
+	NF_IP_PRI_CONNTRACK_DEFRAG = -400,
+	NF_IP_PRI_RAW = -300,
+	NF_IP_PRI_SELINUX_FIRST = -225,
+	NF_IP_PRI_CONNTRACK = -200,
+	NF_IP_PRI_MANGLE = -150,
+	NF_IP_PRI_NAT_DST = -100,
+	NF_IP_PRI_FILTER = 0,
+	NF_IP_PRI_SECURITY = 50,
+	NF_IP_PRI_NAT_SRC = 100,
+	NF_IP_PRI_SELINUX_LAST = 225,
+	NF_IP_PRI_CONNTRACK_HELPER = 300,
+	NF_IP_PRI_CONNTRACK_CONFIRM = 2147483647,
+	NF_IP_PRI_LAST = 2147483647,
+};
+
+struct bpf_nf_link {
+	struct bpf_link link;
+	struct nf_hook_ops hook_ops;
+	netns_tracker ns_tracker;
+	struct net *net;
+	u32 dead;
+	const struct nf_defrag_hook *defrag_hook;
+	long: 32;
+};
+
+enum sk_action {
+	SK_DROP = 0,
+	SK_PASS = 1,
+};
+
+struct bpf_sk_lookup_kern {
+	u16 family;
+	u16 protocol;
+	__be16 sport;
+	u16 dport;
+	struct {
+		__be32 saddr;
+		__be32 daddr;
+	} v4;
+	struct {
+		const struct in6_addr *saddr;
+		const struct in6_addr *daddr;
+	} v6;
+	struct sock *selected_sk;
+	u32 ingress_ifindex;
+	bool no_reuseport;
+};
+
+struct tcp_sack_block_wire {
+	__be32 start_seq;
+	__be32 end_seq;
+};
+
+struct static_key_false_deferred {
+	struct static_key_false key;
+};
+
+enum tcp_ca_ack_event_flags {
+	CA_ACK_SLOWPATH = 1,
+	CA_ACK_WIN_UPDATE = 2,
+	CA_ACK_ECE = 4,
+};
+
+struct tcp_sacktag_state {
+	u64 first_sackt;
+	u64 last_sackt;
+	u32 reord;
+	u32 sack_delivered;
+	int flag;
+	unsigned int mss_now;
+	struct rate_sample *rate;
+	long: 32;
+};
+
+enum tcp_metric_index {
+	TCP_METRIC_RTT = 0,
+	TCP_METRIC_RTTVAR = 1,
+	TCP_METRIC_SSTHRESH = 2,
+	TCP_METRIC_CWND = 3,
+	TCP_METRIC_REORDERING = 4,
+	TCP_METRIC_RTT_US = 5,
+	TCP_METRIC_RTTVAR_US = 6,
+	__TCP_METRIC_MAX = 7,
+};
+
+enum {
+	TCP_METRICS_ATTR_UNSPEC = 0,
+	TCP_METRICS_ATTR_ADDR_IPV4 = 1,
+	TCP_METRICS_ATTR_ADDR_IPV6 = 2,
+	TCP_METRICS_ATTR_AGE = 3,
+	TCP_METRICS_ATTR_TW_TSVAL = 4,
+	TCP_METRICS_ATTR_TW_TS_STAMP = 5,
+	TCP_METRICS_ATTR_VALS = 6,
+	TCP_METRICS_ATTR_FOPEN_MSS = 7,
+	TCP_METRICS_ATTR_FOPEN_SYN_DROPS = 8,
+	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS = 9,
+	TCP_METRICS_ATTR_FOPEN_COOKIE = 10,
+	TCP_METRICS_ATTR_SADDR_IPV4 = 11,
+	TCP_METRICS_ATTR_SADDR_IPV6 = 12,
+	TCP_METRICS_ATTR_PAD = 13,
+	__TCP_METRICS_ATTR_MAX = 14,
+};
+
+enum {
+	TCP_METRICS_CMD_UNSPEC = 0,
+	TCP_METRICS_CMD_GET = 1,
+	TCP_METRICS_CMD_DEL = 2,
+	__TCP_METRICS_CMD_MAX = 3,
+};
+
+struct tcp_fastopen_metrics {
+	u16 mss;
+	u16 syn_loss: 10;
+	u16 try_exp: 2;
+	long unsigned int last_syn_loss;
+	struct tcp_fastopen_cookie cookie;
+};
+
+struct tcp_metrics_block {
+	struct tcp_metrics_block *tcpm_next;
+	struct net *tcpm_net;
+	struct inetpeer_addr tcpm_saddr;
+	struct inetpeer_addr tcpm_daddr;
+	long unsigned int tcpm_stamp;
+	u32 tcpm_lock;
+	u32 tcpm_vals[5];
+	long: 32;
+	struct tcp_fastopen_metrics tcpm_fastopen;
+	struct callback_head callback_head;
+};
+
+struct tcpm_hash_bucket {
+	struct tcp_metrics_block *chain;
+};
+
+struct raw_iter_state {
+	struct seq_net_private p;
+	int bucket;
+};
+
+struct raw_frag_vec {
+	struct msghdr *msg;
+	union {
+		struct icmphdr icmph;
+		char c[1];
+	} hdr;
+	int hlen;
+};
+
+struct arpreq {
+	struct sockaddr arp_pa;
+	struct sockaddr arp_ha;
+	int arp_flags;
+	struct sockaddr arp_netmask;
+	char arp_dev[16];
+};
+
+enum {
+	NEIGH_ARP_TABLE = 0,
+	NEIGH_ND_TABLE = 1,
+	NEIGH_DN_TABLE = 2,
+	NEIGH_NR_TABLES = 3,
+	NEIGH_LINK_TABLE = 3,
+};
+
+struct neigh_seq_state {
+	struct seq_net_private p;
+	struct neigh_table *tbl;
+	struct neigh_hash_table *nht;
+	void * (*neigh_sub_iter)(struct neigh_seq_state *, struct neighbour *, loff_t *);
+	unsigned int bucket;
+	unsigned int flags;
+};
+
+struct neighbour_cb {
+	long unsigned int sched_next;
+	unsigned int flags;
+};
+
+typedef struct {
+	char ax25_call[7];
+} ax25_address;
+
+enum {
+	AX25_VALUES_IPDEFMODE = 0,
+	AX25_VALUES_AXDEFMODE = 1,
+	AX25_VALUES_BACKOFF = 2,
+	AX25_VALUES_CONMODE = 3,
+	AX25_VALUES_WINDOW = 4,
+	AX25_VALUES_EWINDOW = 5,
+	AX25_VALUES_T1 = 6,
+	AX25_VALUES_T2 = 7,
+	AX25_VALUES_T3 = 8,
+	AX25_VALUES_IDLE = 9,
+	AX25_VALUES_N2 = 10,
+	AX25_VALUES_PACLEN = 11,
+	AX25_VALUES_PROTOCOL = 12,
+	AX25_MAX_VALUES = 13,
+};
+
+struct rtentry {
+	long unsigned int rt_pad1;
+	struct sockaddr rt_dst;
+	struct sockaddr rt_gateway;
+	struct sockaddr rt_genmask;
+	short unsigned int rt_flags;
+	short int rt_pad2;
+	long unsigned int rt_pad3;
+	void *rt_pad4;
+	short int rt_metric;
+	char *rt_dev;
+	long unsigned int rt_mtu;
+	long unsigned int rt_window;
+	short unsigned int rt_irtt;
+};
+
+struct inet_protosw {
+	struct list_head list;
+	short unsigned int type;
+	short unsigned int protocol;
+	struct proto *prot;
+	const struct proto_ops *ops;
+	unsigned char flags;
+};
+
+struct pingv6_ops {
+	int (*ipv6_recv_error)(struct sock *, struct msghdr *, int, int *);
+	void (*ip6_datagram_recv_common_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
+	void (*ip6_datagram_recv_specific_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
+	int (*icmpv6_err_convert)(u8, u8, int *);
+	void (*ipv6_icmp_error)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
+	int (*ipv6_chk_addr)(struct net *, const struct in6_addr *, const struct net_device *, int);
+};
+
+struct fib_config {
+	u8 fc_dst_len;
+	dscp_t fc_dscp;
+	u8 fc_protocol;
+	u8 fc_scope;
+	u8 fc_type;
+	u8 fc_gw_family;
+	u32 fc_table;
+	__be32 fc_dst;
+	union {
+		__be32 fc_gw4;
+		struct in6_addr fc_gw6;
+	};
+	int fc_oif;
+	u32 fc_flags;
+	u32 fc_priority;
+	__be32 fc_prefsrc;
+	u32 fc_nh_id;
+	struct nlattr *fc_mx;
+	struct rtnexthop *fc_mp;
+	int fc_mx_len;
+	int fc_mp_len;
+	u32 fc_flow;
+	u32 fc_nlflags;
+	struct nl_info fc_nlinfo;
+	struct nlattr *fc_encap;
+	u16 fc_encap_type;
+};
+
+struct fib_result {
+	__be32 prefix;
+	unsigned char prefixlen;
+	unsigned char nh_sel;
+	unsigned char type;
+	unsigned char scope;
+	u32 tclassid;
+	dscp_t dscp;
+	struct fib_nh_common *nhc;
+	struct fib_info *fi;
+	struct fib_table *table;
+	struct hlist_head *fa_head;
+};
+
+struct fib_rt_info {
+	struct fib_info *fi;
+	u32 tb_id;
+	__be32 dst;
+	int dst_len;
+	dscp_t dscp;
+	u8 type;
+	u8 offload: 1;
+	u8 trap: 1;
+	u8 offload_failed: 1;
+	u8 unused: 5;
+};
+
+struct fib_entry_notifier_info {
+	struct fib_notifier_info info;
+	u32 dst;
+	int dst_len;
+	struct fib_info *fi;
+	dscp_t dscp;
+	u8 type;
+	u32 tb_id;
+};
+
+struct fib_alias {
+	struct hlist_node fa_list;
+	struct fib_info *fa_info;
+	dscp_t fa_dscp;
+	u8 fa_type;
+	u8 fa_state;
+	u8 fa_slen;
+	u32 tb_id;
+	s16 fa_default;
+	u8 offload;
+	u8 trap;
+	u8 offload_failed;
+	struct callback_head rcu;
+};
+
+struct fib_prop {
+	int error;
+	u8 scope;
+};
+
+typedef unsigned int t_key;
+
+struct key_vector {
+	t_key key;
+	unsigned char pos;
+	unsigned char bits;
+	unsigned char slen;
+	union {
+		struct hlist_head leaf;
+		struct {
+			struct {} __empty_tnode;
+			struct key_vector *tnode[0];
+		};
+	};
+};
+
+struct tnode {
+	struct callback_head rcu;
+	t_key empty_children;
+	t_key full_children;
+	struct key_vector *parent;
+	struct key_vector kv[1];
+};
+
+struct trie_stat {
+	unsigned int totdepth;
+	unsigned int maxdepth;
+	unsigned int tnodes;
+	unsigned int leaves;
+	unsigned int nullpointers;
+	unsigned int prefixes;
+	unsigned int nodesizes[32];
+};
+
+struct trie {
+	struct key_vector kv[1];
+};
+
+struct fib_trie_iter {
+	struct seq_net_private p;
+	struct fib_table *tb;
+	struct key_vector *tnode;
+	unsigned int index;
+	unsigned int depth;
+};
+
+struct fib_route_iter {
+	struct seq_net_private p;
+	struct fib_table *main_tb;
+	struct key_vector *tnode;
+	long: 32;
+	loff_t pos;
+	t_key key;
+	long: 32;
+};
+
+struct snmp_mib {
+	const char *name;
+	int entry;
+};
+
+enum __sk_action {
+	__SK_DROP = 0,
+	__SK_PASS = 1,
+	__SK_REDIRECT = 2,
+	__SK_NONE = 3,
+};
+
+enum sk_psock_state_bits {
+	SK_PSOCK_TX_ENABLED = 0,
+	SK_PSOCK_RX_STRP_ENABLED = 1,
+};
+
+struct tx_work {
+	struct delayed_work work;
+	struct sock *sk;
+};
+
+struct tls_rec;
+
+struct tls_sw_context_tx {
+	struct crypto_aead *aead_send;
+	struct crypto_wait async_wait;
+	struct tx_work tx_work;
+	struct tls_rec *open_rec;
+	struct list_head tx_list;
+	atomic_t encrypt_pending;
+	u8 async_capable: 1;
+	long unsigned int tx_bitmask;
+};
+
+enum {
+	TCP_BPF_IPV4 = 0,
+	TCP_BPF_IPV6 = 1,
+	TCP_BPF_NUM_PROTS = 2,
+};
+
+enum {
+	TCP_BPF_BASE = 0,
+	TCP_BPF_TX = 1,
+	TCP_BPF_RX = 2,
+	TCP_BPF_TXRX = 3,
+	TCP_BPF_NUM_CFGS = 4,
+};
+
+struct xfrm4_protocol {
+	int (*handler)(struct sk_buff *);
+	int (*input_handler)(struct sk_buff *, int, __be32, int);
+	int (*cb_handler)(struct sk_buff *, int);
+	int (*err_handler)(struct sk_buff *, u32);
+	struct xfrm4_protocol *next;
+	int priority;
+};
+
+enum xfrm_ae_ftype_t {
+	XFRM_AE_UNSPEC = 0,
+	XFRM_AE_RTHR = 1,
+	XFRM_AE_RVAL = 2,
+	XFRM_AE_LVAL = 4,
+	XFRM_AE_ETHR = 8,
+	XFRM_AE_CR = 16,
+	XFRM_AE_CE = 32,
+	XFRM_AE_CU = 64,
+	__XFRM_AE_MAX = 65,
+};
+
+enum xfrm_nlgroups {
+	XFRMNLGRP_NONE = 0,
+	XFRMNLGRP_ACQUIRE = 1,
+	XFRMNLGRP_EXPIRE = 2,
+	XFRMNLGRP_SA = 3,
+	XFRMNLGRP_POLICY = 4,
+	XFRMNLGRP_AEVENTS = 5,
+	XFRMNLGRP_REPORT = 6,
+	XFRMNLGRP_MIGRATE = 7,
+	XFRMNLGRP_MAPPING = 8,
+	__XFRMNLGRP_MAX = 9,
+};
+
+struct km_event {
+	union {
+		u32 hard;
+		u32 proto;
+		u32 byid;
+		u32 aevent;
+		u32 type;
+	} data;
+	u32 seq;
+	u32 portid;
+	u32 event;
+	struct net *net;
+};
+
+struct xfrm_kmaddress {
+	xfrm_address_t local;
+	xfrm_address_t remote;
+	u32 reserved;
+	u16 family;
+};
+
+struct xfrm_migrate {
+	xfrm_address_t old_daddr;
+	xfrm_address_t old_saddr;
+	xfrm_address_t new_daddr;
+	xfrm_address_t new_saddr;
+	u8 proto;
+	u8 mode;
+	u16 reserved;
+	u32 reqid;
+	u16 old_family;
+	u16 new_family;
+};
+
+struct xfrm_mgr {
+	struct list_head list;
+	int (*notify)(struct xfrm_state *, const struct km_event *);
+	int (*acquire)(struct xfrm_state *, struct xfrm_tmpl *, struct xfrm_policy *);
+	struct xfrm_policy * (*compile_policy)(struct sock *, int, u8 *, int, int *);
+	int (*new_mapping)(struct xfrm_state *, xfrm_address_t *, __be16);
+	int (*notify_policy)(struct xfrm_policy *, int, const struct km_event *);
+	int (*report)(struct net *, u8, struct xfrm_selector *, xfrm_address_t *);
+	int (*migrate)(const struct xfrm_selector *, u8, u8, const struct xfrm_migrate *, int, const struct xfrm_kmaddress *, const struct xfrm_encap_tmpl *);
+	bool (*is_alive)(const struct km_event *);
+};
+
+struct xfrmk_sadinfo {
+	u32 sadhcnt;
+	u32 sadhmcnt;
+	u32 sadcnt;
+};
+
+struct xfrm_translator {
+	int (*alloc_compat)(struct sk_buff *, const struct nlmsghdr *);
+	struct nlmsghdr * (*rcv_msg_compat)(const struct nlmsghdr *, int, const struct nla_policy *, struct netlink_ext_ack *);
+	int (*xlate_user_policy_sockptr)(u8 **, int);
+	struct module *owner;
+};
+
+enum sock_shutdown_cmd {
+	SHUT_RD = 0,
+	SHUT_WR = 1,
+	SHUT_RDWR = 2,
+};
+
+struct unix_edge {
+	struct unix_sock *predecessor;
+	struct unix_sock *successor;
+	struct list_head vertex_entry;
+	struct list_head stack_entry;
+};
+
+struct unix_skb_parms {
+	struct pid *pid;
+	kuid_t uid;
+	kgid_t gid;
+	struct scm_fp_list *fp;
+	u32 consumed;
+};
+
+struct unix_stream_read_state {
+	int (*recv_actor)(struct sk_buff *, int, int, struct unix_stream_read_state *);
+	struct socket *socket;
+	struct msghdr *msg;
+	struct pipe_inode_info *pipe;
+	size_t size;
+	int flags;
+	unsigned int splice_flags;
+};
+
+struct bpf_unix_iter_state {
+	struct seq_net_private p;
+	unsigned int cur_sk;
+	unsigned int end_sk;
+	unsigned int max_sk;
+	struct sock **batch;
+	bool st_bucket_done;
+};
+
+struct bpf_iter__unix {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct unix_sock *unix_sk;
+	};
+	uid_t uid;
+	long: 32;
+};
+
+enum fib6_walk_state {
+	FWS_S = 0,
+	FWS_L = 1,
+	FWS_R = 2,
+	FWS_C = 3,
+	FWS_U = 4,
+};
+
+struct fib6_walker {
+	struct list_head lh;
+	struct fib6_node *root;
+	struct fib6_node *node;
+	struct fib6_info *leaf;
+	enum fib6_walk_state state;
+	unsigned int skip;
+	unsigned int count;
+	unsigned int skip_in_node;
+	int (*func)(struct fib6_walker *);
+	void *args;
+};
+
+struct fib6_entry_notifier_info {
+	struct fib_notifier_info info;
+	struct fib6_info *rt;
+	unsigned int nsiblings;
+};
+
+struct ipv6_route_iter {
+	struct seq_net_private p;
+	struct fib6_walker w;
+	loff_t skip;
+	struct fib6_table *tbl;
+	int sernum;
+};
+
+struct bpf_iter__ipv6_route {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct fib6_info *rt;
+	};
+};
+
+struct fib6_cleaner {
+	struct fib6_walker w;
+	struct net *net;
+	int (*func)(struct fib6_info *, void *);
+	int sernum;
+	void *arg;
+	bool skip_notify;
+};
+
+enum {
+	FIB6_NO_SERNUM_CHANGE = 0,
+};
+
+struct fib6_dump_arg {
+	struct net *net;
+	struct notifier_block *nb;
+	struct netlink_ext_ack *extack;
+};
+
+struct fib6_nh_pcpu_arg {
+	struct fib6_info *from;
+	const struct fib6_table *table;
+};
+
+struct lookup_args {
+	int offset;
+	const struct in6_addr *addr;
+};
+
+struct nduseroptmsg {
+	unsigned char nduseropt_family;
+	unsigned char nduseropt_pad1;
+	short unsigned int nduseropt_opts_len;
+	int nduseropt_ifindex;
+	__u8 nduseropt_icmp_type;
+	__u8 nduseropt_icmp_code;
+	short unsigned int nduseropt_pad2;
+	unsigned int nduseropt_pad3;
+};
+
+enum {
+	NDUSEROPT_UNSPEC = 0,
+	NDUSEROPT_SRCADDR = 1,
+	__NDUSEROPT_MAX = 2,
+};
+
+struct nd_msg {
+	struct icmp6hdr icmph;
+	struct in6_addr target;
+	__u8 opt[0];
+};
+
+struct rs_msg {
+	struct icmp6hdr icmph;
+	__u8 opt[0];
+};
+
+struct ra_msg {
+	struct icmp6hdr icmph;
+	__be32 reachable_time;
+	__be32 retrans_timer;
+};
+
+struct icmp6_filter {
+	__u32 data[8];
+};
+
+struct raw6_sock {
+	struct inet_sock inet;
+	__u32 checksum;
+	__u32 offset;
+	struct icmp6_filter filter;
+	__u32 ip6mr_table;
+	struct ipv6_pinfo inet6;
+	long: 32;
+};
+
+struct raw6_frag_vec {
+	struct msghdr *msg;
+	int hlen;
+	char c[4];
+};
+
+struct ping_iter_state {
+	struct seq_net_private p;
+	int bucket;
+	sa_family_t family;
+};
+
+struct pingfakehdr {
+	struct icmphdr icmph;
+	struct msghdr *msg;
+	sa_family_t family;
+	__wsum wcheck;
+};
+
+struct in6_flowlabel_req {
+	struct in6_addr flr_dst;
+	__be32 flr_label;
+	__u8 flr_action;
+	__u8 flr_share;
+	__u16 flr_flags;
+	__u16 flr_expires;
+	__u16 flr_linger;
+	__u32 __flr_pad;
+};
+
+struct ip6fl_iter_state {
+	struct seq_net_private p;
+	struct pid_namespace *pid_ns;
+	int bucket;
+};
+
+struct sr6_tlv {
+	__u8 type;
+	__u8 len;
+	__u8 data[0];
+};
+
+enum {
+	SEG6_ATTR_UNSPEC = 0,
+	SEG6_ATTR_DST = 1,
+	SEG6_ATTR_DSTLEN = 2,
+	SEG6_ATTR_HMACKEYID = 3,
+	SEG6_ATTR_SECRET = 4,
+	SEG6_ATTR_SECRETLEN = 5,
+	SEG6_ATTR_ALGID = 6,
+	SEG6_ATTR_HMACINFO = 7,
+	__SEG6_ATTR_MAX = 8,
+};
+
+enum {
+	SEG6_CMD_UNSPEC = 0,
+	SEG6_CMD_SETHMAC = 1,
+	SEG6_CMD_DUMPHMAC = 2,
+	SEG6_CMD_SET_TUNSRC = 3,
+	SEG6_CMD_GET_TUNSRC = 4,
+	__SEG6_CMD_MAX = 5,
+};
+
+enum ip_conntrack_status {
+	IPS_EXPECTED_BIT = 0,
+	IPS_EXPECTED = 1,
+	IPS_SEEN_REPLY_BIT = 1,
+	IPS_SEEN_REPLY = 2,
+	IPS_ASSURED_BIT = 2,
+	IPS_ASSURED = 4,
+	IPS_CONFIRMED_BIT = 3,
+	IPS_CONFIRMED = 8,
+	IPS_SRC_NAT_BIT = 4,
+	IPS_SRC_NAT = 16,
+	IPS_DST_NAT_BIT = 5,
+	IPS_DST_NAT = 32,
+	IPS_NAT_MASK = 48,
+	IPS_SEQ_ADJUST_BIT = 6,
+	IPS_SEQ_ADJUST = 64,
+	IPS_SRC_NAT_DONE_BIT = 7,
+	IPS_SRC_NAT_DONE = 128,
+	IPS_DST_NAT_DONE_BIT = 8,
+	IPS_DST_NAT_DONE = 256,
+	IPS_NAT_DONE_MASK = 384,
+	IPS_DYING_BIT = 9,
+	IPS_DYING = 512,
+	IPS_FIXED_TIMEOUT_BIT = 10,
+	IPS_FIXED_TIMEOUT = 1024,
+	IPS_TEMPLATE_BIT = 11,
+	IPS_TEMPLATE = 2048,
+	IPS_UNTRACKED_BIT = 12,
+	IPS_UNTRACKED = 4096,
+	IPS_NAT_CLASH_BIT = 12,
+	IPS_NAT_CLASH = 4096,
+	IPS_HELPER_BIT = 13,
+	IPS_HELPER = 8192,
+	IPS_OFFLOAD_BIT = 14,
+	IPS_OFFLOAD = 16384,
+	IPS_HW_OFFLOAD_BIT = 15,
+	IPS_HW_OFFLOAD = 32768,
+	IPS_UNCHANGEABLE_MASK = 56313,
+	__IPS_MAX_BIT = 16,
+};
+
+struct switchdev_brport {
+	struct net_device *dev;
+	const void *ctx;
+	struct notifier_block *atomic_nb;
+	struct notifier_block *blocking_nb;
+	bool tx_fwd_offload;
+};
+
+enum switchdev_notifier_type {
+	SWITCHDEV_FDB_ADD_TO_BRIDGE = 1,
+	SWITCHDEV_FDB_DEL_TO_BRIDGE = 2,
+	SWITCHDEV_FDB_ADD_TO_DEVICE = 3,
+	SWITCHDEV_FDB_DEL_TO_DEVICE = 4,
+	SWITCHDEV_FDB_OFFLOADED = 5,
+	SWITCHDEV_FDB_FLUSH_TO_BRIDGE = 6,
+	SWITCHDEV_PORT_OBJ_ADD = 7,
+	SWITCHDEV_PORT_OBJ_DEL = 8,
+	SWITCHDEV_PORT_ATTR_SET = 9,
+	SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE = 10,
+	SWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE = 11,
+	SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE = 12,
+	SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE = 13,
+	SWITCHDEV_VXLAN_FDB_OFFLOADED = 14,
+	SWITCHDEV_BRPORT_OFFLOADED = 15,
+	SWITCHDEV_BRPORT_UNOFFLOADED = 16,
+	SWITCHDEV_BRPORT_REPLAY = 17,
+};
+
+struct switchdev_notifier_info {
+	struct net_device *dev;
+	struct netlink_ext_ack *extack;
+	const void *ctx;
+};
+
+struct switchdev_notifier_fdb_info {
+	struct switchdev_notifier_info info;
+	const unsigned char *addr;
+	u16 vid;
+	u8 added_by_user: 1;
+	u8 is_local: 1;
+	u8 locked: 1;
+	u8 offloaded: 1;
+};
+
+struct switchdev_notifier_brport_info {
+	struct switchdev_notifier_info info;
+	const struct switchdev_brport brport;
+};
+
+struct net_bridge_mdb_entry {
+	struct rhash_head rhnode;
+	struct net_bridge *br;
+	struct net_bridge_port_group *ports;
+	struct br_ip addr;
+	bool host_joined;
+	struct timer_list timer;
+	struct hlist_node mdb_node;
+	struct net_bridge_mcast_gc mcast_gc;
+	struct callback_head rcu;
+};
+
+struct br_input_skb_cb {
+	struct net_device *brdev;
+	u16 frag_max_size;
+	u8 igmp;
+	u8 mrouters_only: 1;
+	u8 proxyarp_replied: 1;
+	u8 src_port_isolated: 1;
+	u8 promisc: 1;
+	u8 vlan_filtered: 1;
+	u8 br_netfilter_broute: 1;
+	u8 tx_fwd_offload: 1;
+	int src_hwdom;
+	long unsigned int fwd_hwdoms;
+	u32 backup_nhid;
+};
+
+enum br_pkt_type {
+	BR_PKT_UNICAST = 0,
+	BR_PKT_MULTICAST = 1,
+	BR_PKT_BROADCAST = 2,
+};
+
+struct __bridge_info {
+	__u64 designated_root;
+	__u64 bridge_id;
+	__u32 root_path_cost;
+	__u32 max_age;
+	__u32 hello_time;
+	__u32 forward_delay;
+	__u32 bridge_max_age;
+	__u32 bridge_hello_time;
+	__u32 bridge_forward_delay;
+	__u8 topology_change;
+	__u8 topology_change_detected;
+	__u8 root_port;
+	__u8 stp_enabled;
+	__u32 ageing_time;
+	__u32 gc_interval;
+	__u32 hello_timer_value;
+	__u32 tcn_timer_value;
+	__u32 topology_change_timer_value;
+	__u32 gc_timer_value;
+};
+
+struct __port_info {
+	__u64 designated_root;
+	__u64 designated_bridge;
+	__u16 port_id;
+	__u16 designated_port;
+	__u32 path_cost;
+	__u32 designated_cost;
+	__u8 state;
+	__u8 top_change_ack;
+	__u8 config_pending;
+	__u8 unused0;
+	__u32 message_age_timer_value;
+	__u32 forward_delay_timer_value;
+	__u32 hold_timer_value;
+	long: 32;
+};
+
+struct brport_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct net_bridge_port *, char *);
+	int (*store)(struct net_bridge_port *, long unsigned int);
+	int (*store_raw)(struct net_bridge_port *, char *);
+};
+
+enum {
+	MDBA_UNSPEC = 0,
+	MDBA_MDB = 1,
+	MDBA_ROUTER = 2,
+	__MDBA_MAX = 3,
+};
+
+enum {
+	MDBA_MDB_UNSPEC = 0,
+	MDBA_MDB_ENTRY = 1,
+	__MDBA_MDB_MAX = 2,
+};
+
+enum {
+	MDBA_MDB_ENTRY_UNSPEC = 0,
+	MDBA_MDB_ENTRY_INFO = 1,
+	__MDBA_MDB_ENTRY_MAX = 2,
+};
+
+enum {
+	MDBA_MDB_EATTR_UNSPEC = 0,
+	MDBA_MDB_EATTR_TIMER = 1,
+	MDBA_MDB_EATTR_SRC_LIST = 2,
+	MDBA_MDB_EATTR_GROUP_MODE = 3,
+	MDBA_MDB_EATTR_SOURCE = 4,
+	MDBA_MDB_EATTR_RTPROT = 5,
+	MDBA_MDB_EATTR_DST = 6,
+	MDBA_MDB_EATTR_DST_PORT = 7,
+	MDBA_MDB_EATTR_VNI = 8,
+	MDBA_MDB_EATTR_IFINDEX = 9,
+	MDBA_MDB_EATTR_SRC_VNI = 10,
+	__MDBA_MDB_EATTR_MAX = 11,
+};
+
+enum {
+	MDBA_MDB_SRCLIST_UNSPEC = 0,
+	MDBA_MDB_SRCLIST_ENTRY = 1,
+	__MDBA_MDB_SRCLIST_MAX = 2,
+};
+
+enum {
+	MDBA_MDB_SRCATTR_UNSPEC = 0,
+	MDBA_MDB_SRCATTR_ADDRESS = 1,
+	MDBA_MDB_SRCATTR_TIMER = 2,
+	__MDBA_MDB_SRCATTR_MAX = 3,
+};
+
+enum {
+	MDBA_ROUTER_UNSPEC = 0,
+	MDBA_ROUTER_PORT = 1,
+	__MDBA_ROUTER_MAX = 2,
+};
+
+enum {
+	MDBA_ROUTER_PATTR_UNSPEC = 0,
+	MDBA_ROUTER_PATTR_TIMER = 1,
+	MDBA_ROUTER_PATTR_TYPE = 2,
+	MDBA_ROUTER_PATTR_INET_TIMER = 3,
+	MDBA_ROUTER_PATTR_INET6_TIMER = 4,
+	MDBA_ROUTER_PATTR_VID = 5,
+	__MDBA_ROUTER_PATTR_MAX = 6,
+};
+
+enum {
+	MDBE_ATTR_UNSPEC = 0,
+	MDBE_ATTR_SOURCE = 1,
+	MDBE_ATTR_SRC_LIST = 2,
+	MDBE_ATTR_GROUP_MODE = 3,
+	MDBE_ATTR_RTPROT = 4,
+	MDBE_ATTR_DST = 5,
+	MDBE_ATTR_DST_PORT = 6,
+	MDBE_ATTR_VNI = 7,
+	MDBE_ATTR_IFINDEX = 8,
+	MDBE_ATTR_SRC_VNI = 9,
+	MDBE_ATTR_STATE_MASK = 10,
+	__MDBE_ATTR_MAX = 11,
+};
+
+enum {
+	MDBE_SRC_LIST_UNSPEC = 0,
+	MDBE_SRC_LIST_ENTRY = 1,
+	__MDBE_SRC_LIST_MAX = 2,
+};
+
+enum {
+	MDBE_SRCATTR_UNSPEC = 0,
+	MDBE_SRCATTR_ADDRESS = 1,
+	__MDBE_SRCATTR_MAX = 2,
+};
+
+struct br_mdb_src_entry {
+	struct br_ip addr;
+};
+
+struct br_mdb_config {
+	struct net_bridge *br;
+	struct net_bridge_port *p;
+	struct br_mdb_entry *entry;
+	struct br_ip group;
+	bool src_entry;
+	u8 filter_mode;
+	u16 nlflags;
+	struct br_mdb_src_entry *src_entries;
+	int num_src_entries;
+	u8 rt_protocol;
+};
+
+struct br_mdb_flush_desc {
+	u32 port_ifindex;
+	u16 vid;
+	u8 rt_protocol;
+	u8 state;
+	u8 state_mask;
+};
+
+struct devlink_trap_metadata {
+	const char *trap_name;
+	const char *trap_group_name;
+	struct net_device *input_dev;
+	netdevice_tracker dev_tracker;
+	const struct flow_action_cookie *fa_cookie;
+	enum devlink_trap_type trap_type;
+};
+
+struct trace_event_raw_devlink_hwmsg {
+	struct trace_entry ent;
+	u32 __data_loc_bus_name;
+	u32 __data_loc_dev_name;
+	u32 __data_loc_driver_name;
+	bool incoming;
+	long unsigned int type;
+	u32 __data_loc_buf;
+	size_t len;
+	char __data[0];
+};
+
+struct trace_event_raw_devlink_hwerr {
+	struct trace_entry ent;
+	u32 __data_loc_bus_name;
+	u32 __data_loc_dev_name;
+	u32 __data_loc_driver_name;
+	int err;
+	u32 __data_loc_msg;
+	char __data[0];
+};
+
+struct trace_event_raw_devlink_health_report {
+	struct trace_entry ent;
+	u32 __data_loc_bus_name;
+	u32 __data_loc_dev_name;
+	u32 __data_loc_driver_name;
+	u32 __data_loc_reporter_name;
+	u32 __data_loc_msg;
+	char __data[0];
+};
+
+struct trace_event_raw_devlink_health_recover_aborted {
+	struct trace_entry ent;
+	u32 __data_loc_bus_name;
+	u32 __data_loc_dev_name;
+	u32 __data_loc_driver_name;
+	u32 __data_loc_reporter_name;
+	bool health_state;
+	long: 32;
+	u64 time_since_last_recover;
+	char __data[0];
+};
+
+struct trace_event_raw_devlink_health_reporter_state_update {
+	struct trace_entry ent;
+	u32 __data_loc_bus_name;
+	u32 __data_loc_dev_name;
+	u32 __data_loc_driver_name;
+	u32 __data_loc_reporter_name;
+	u8 new_state;
+	char __data[0];
+};
+
+struct trace_event_raw_devlink_trap_report {
+	struct trace_entry ent;
+	u32 __data_loc_bus_name;
+	u32 __data_loc_dev_name;
+	u32 __data_loc_driver_name;
+	u32 __data_loc_trap_name;
+	u32 __data_loc_trap_group_name;
+	char input_dev_name[16];
+	char __data[0];
+};
+
+struct trace_event_data_offsets_devlink_hwmsg {
+	u32 bus_name;
+	const void *bus_name_ptr_;
+	u32 dev_name;
+	const void *dev_name_ptr_;
+	u32 driver_name;
+	const void *driver_name_ptr_;
+	u32 buf;
+	const void *buf_ptr_;
+};
+
+struct trace_event_data_offsets_devlink_hwerr {
+	u32 bus_name;
+	const void *bus_name_ptr_;
+	u32 dev_name;
+	const void *dev_name_ptr_;
+	u32 driver_name;
+	const void *driver_name_ptr_;
+	u32 msg;
+	const void *msg_ptr_;
+};
+
+struct trace_event_data_offsets_devlink_health_report {
+	u32 bus_name;
+	const void *bus_name_ptr_;
+	u32 dev_name;
+	const void *dev_name_ptr_;
+	u32 driver_name;
+	const void *driver_name_ptr_;
+	u32 reporter_name;
+	const void *reporter_name_ptr_;
+	u32 msg;
+	const void *msg_ptr_;
+};
+
+struct trace_event_data_offsets_devlink_health_recover_aborted {
+	u32 bus_name;
+	const void *bus_name_ptr_;
+	u32 dev_name;
+	const void *dev_name_ptr_;
+	u32 driver_name;
+	const void *driver_name_ptr_;
+	u32 reporter_name;
+	const void *reporter_name_ptr_;
+};
+
+struct trace_event_data_offsets_devlink_health_reporter_state_update {
+	u32 bus_name;
+	const void *bus_name_ptr_;
+	u32 dev_name;
+	const void *dev_name_ptr_;
+	u32 driver_name;
+	const void *driver_name_ptr_;
+	u32 reporter_name;
+	const void *reporter_name_ptr_;
+};
+
+struct trace_event_data_offsets_devlink_trap_report {
+	u32 bus_name;
+	const void *bus_name_ptr_;
+	u32 dev_name;
+	const void *dev_name_ptr_;
+	u32 driver_name;
+	const void *driver_name_ptr_;
+	u32 trap_name;
+	const void *trap_name_ptr_;
+	u32 trap_group_name;
+	const void *trap_group_name_ptr_;
+};
+
+typedef void (*btf_trace_devlink_hwmsg)(void *, const struct devlink *, bool, long unsigned int, const u8 *, size_t);
+
+typedef void (*btf_trace_devlink_hwerr)(void *, const struct devlink *, int, const char *);
+
+typedef void (*btf_trace_devlink_health_report)(void *, const struct devlink *, const char *, const char *);
+
+typedef void (*btf_trace_devlink_health_recover_aborted)(void *, const struct devlink *, const char *, bool, u64);
+
+typedef void (*btf_trace_devlink_health_reporter_state_update)(void *, const struct devlink *, const char *, bool);
+
+typedef void (*btf_trace_devlink_trap_report)(void *, const struct devlink *, struct sk_buff *, const struct devlink_trap_metadata *);
+
+typedef void devlink_rel_notify_cb_t(struct devlink *, u32);
+
+typedef void devlink_rel_cleanup_cb_t(struct devlink *, u32, u32);
+
+struct devlink_rel {
+	u32 index;
+	refcount_t refcount;
+	u32 devlink_index;
+	struct {
+		u32 devlink_index;
+		u32 obj_index;
+		devlink_rel_notify_cb_t *notify_cb;
+		devlink_rel_cleanup_cb_t *cleanup_cb;
+		struct delayed_work notify_work;
+	} nested_in;
+};
+
+struct devlink_sb {
+	struct list_head list;
+	unsigned int index;
+	u32 size;
+	u16 ingress_pools_count;
+	u16 egress_pools_count;
+	u16 ingress_tc_count;
+	u16 egress_tc_count;
+};
+
+struct devlink_region_ops {
+	const char *name;
+	void (*destructor)(const void *);
+	int (*snapshot)(struct devlink *, const struct devlink_region_ops *, struct netlink_ext_ack *, u8 **);
+	int (*read)(struct devlink *, const struct devlink_region_ops *, struct netlink_ext_ack *, u64, u32, u8 *);
+	void *priv;
+};
+
+struct devlink_port_region_ops {
+	const char *name;
+	void (*destructor)(const void *);
+	int (*snapshot)(struct devlink_port *, const struct devlink_port_region_ops *, struct netlink_ext_ack *, u8 **);
+	int (*read)(struct devlink_port *, const struct devlink_port_region_ops *, struct netlink_ext_ack *, u64, u32, u8 *);
+	void *priv;
+};
+
+struct devlink_region {
+	struct devlink *devlink;
+	struct devlink_port *port;
+	struct list_head list;
+	union {
+		const struct devlink_region_ops *ops;
+		const struct devlink_port_region_ops *port_ops;
+	};
+	struct mutex snapshot_lock;
+	struct list_head snapshot_list;
+	u32 max_snapshots;
+	u32 cur_snapshots;
+	u64 size;
+};
+
+struct devlink_snapshot {
+	struct list_head list;
+	struct devlink_region *region;
+	u8 *data;
+	u32 id;
+};
+
+typedef int devlink_chunk_fill_t(void *, u8 *, u32, u64, struct netlink_ext_ack *);
+
+enum devlink_linecard_state {
+	DEVLINK_LINECARD_STATE_UNSPEC = 0,
+	DEVLINK_LINECARD_STATE_UNPROVISIONED = 1,
+	DEVLINK_LINECARD_STATE_UNPROVISIONING = 2,
+	DEVLINK_LINECARD_STATE_PROVISIONING = 3,
+	DEVLINK_LINECARD_STATE_PROVISIONING_FAILED = 4,
+	DEVLINK_LINECARD_STATE_PROVISIONED = 5,
+	DEVLINK_LINECARD_STATE_ACTIVE = 6,
+	__DEVLINK_LINECARD_STATE_MAX = 7,
+	DEVLINK_LINECARD_STATE_MAX = 6,
+};
+
+struct devlink_linecard_ops;
+
+struct devlink_linecard_type;
+
+struct devlink_linecard {
+	struct list_head list;
+	struct devlink *devlink;
+	unsigned int index;
+	const struct devlink_linecard_ops *ops;
+	void *priv;
+	enum devlink_linecard_state state;
+	struct mutex state_lock;
+	const char *type;
+	struct devlink_linecard_type *types;
+	unsigned int types_count;
+	u32 rel_index;
+};
+
+struct devlink_linecard_ops {
+	int (*provision)(struct devlink_linecard *, void *, const char *, const void *, struct netlink_ext_ack *);
+	int (*unprovision)(struct devlink_linecard *, void *, struct netlink_ext_ack *);
+	bool (*same_provision)(struct devlink_linecard *, void *, const char *, const void *);
+	unsigned int (*types_count)(struct devlink_linecard *, void *);
+	void (*types_get)(struct devlink_linecard *, void *, unsigned int, const char **, const void **);
+};
+
+struct devlink_linecard_type {
+	const char *type;
+	const void *priv;
+};
+
+struct dsa_tag_driver {
+	const struct dsa_device_ops *ops;
+	struct list_head list;
+	struct module *owner;
+};
+
+enum vlan_name_types {
+	VLAN_NAME_TYPE_PLUS_VID = 0,
+	VLAN_NAME_TYPE_RAW_PLUS_VID = 1,
+	VLAN_NAME_TYPE_PLUS_VID_NO_PAD = 2,
+	VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD = 3,
+	VLAN_NAME_TYPE_HIGHEST = 4,
+};
+
+struct vlan_net {
+	struct proc_dir_entry *proc_vlan_dir;
+	struct proc_dir_entry *proc_vlan_conf;
+	short unsigned int name_type;
+};
+
+struct switchdev_notifier_port_obj_info {
+	struct switchdev_notifier_info info;
+	const struct switchdev_obj *obj;
+	bool handled;
+};
+
+struct switchdev_notifier_port_attr_info {
+	struct switchdev_notifier_info info;
+	const struct switchdev_attr *attr;
+	bool handled;
+};
+
+typedef void switchdev_deferred_func_t(struct net_device *, const void *);
+
+struct switchdev_deferred_item {
+	struct list_head list;
+	struct net_device *dev;
+	netdevice_tracker dev_tracker;
+	switchdev_deferred_func_t *func;
+	long unsigned int data[0];
+};
+
+struct switchdev_nested_priv {
+	bool (*check_cb)(const struct net_device *);
+	bool (*foreign_dev_check_cb)(const struct net_device *, const struct net_device *);
+	const struct net_device *dev;
+	struct net_device *lower_dev;
+};
+
+struct scm_timestamping_internal {
+	struct timespec64 ts[3];
+};
+
+enum mptcp_event_type {
+	MPTCP_EVENT_UNSPEC = 0,
+	MPTCP_EVENT_CREATED = 1,
+	MPTCP_EVENT_ESTABLISHED = 2,
+	MPTCP_EVENT_CLOSED = 3,
+	MPTCP_EVENT_ANNOUNCED = 6,
+	MPTCP_EVENT_REMOVED = 7,
+	MPTCP_EVENT_SUB_ESTABLISHED = 10,
+	MPTCP_EVENT_SUB_CLOSED = 11,
+	MPTCP_EVENT_SUB_PRIORITY = 13,
+	MPTCP_EVENT_LISTENER_CREATED = 15,
+	MPTCP_EVENT_LISTENER_CLOSED = 16,
+};
+
+struct mptcp_skb_cb {
+	u64 map_seq;
+	u64 end_seq;
+	u32 offset;
+	u8 has_rxtstamp: 1;
+};
+
+struct trace_event_raw_mptcp_subflow_get_send {
+	struct trace_entry ent;
+	bool active;
+	bool free;
+	u32 snd_wnd;
+	u32 pace;
+	u8 backup;
+	u64 ratio;
+	char __data[0];
+};
+
+struct trace_event_raw_mptcp_dump_mpext {
+	struct trace_entry ent;
+	u64 data_ack;
+	u64 data_seq;
+	u32 subflow_seq;
+	u16 data_len;
+	u16 csum;
+	u8 use_map;
+	u8 dsn64;
+	u8 data_fin;
+	u8 use_ack;
+	u8 ack64;
+	u8 mpc_map;
+	u8 frozen;
+	u8 reset_transient;
+	u8 reset_reason;
+	u8 csum_reqd;
+	u8 infinite_map;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_ack_update_msk {
+	struct trace_entry ent;
+	u64 data_ack;
+	u64 old_snd_una;
+	u64 new_snd_una;
+	u64 new_wnd_end;
+	u64 msk_wnd_end;
+	char __data[0];
+};
+
+struct trace_event_raw_subflow_check_data_avail {
+	struct trace_entry ent;
+	u8 status;
+	const void *skb;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_mptcp_subflow_get_send {};
+
+struct trace_event_data_offsets_mptcp_dump_mpext {};
+
+struct trace_event_data_offsets_ack_update_msk {};
+
+struct trace_event_data_offsets_subflow_check_data_avail {};
+
+typedef void (*btf_trace_mptcp_subflow_get_send)(void *, struct mptcp_subflow_context *);
+
+typedef void (*btf_trace_mptcp_sendmsg_frag)(void *, struct mptcp_ext *);
+
+typedef void (*btf_trace_get_mapping_status)(void *, struct mptcp_ext *);
+
+typedef void (*btf_trace_ack_update_msk)(void *, u64, u64, u64, u64, u64);
+
+typedef void (*btf_trace_subflow_check_data_avail)(void *, __u8, struct sk_buff *);
+
+enum {
+	MPTCP_CMSG_TS = 1,
+	MPTCP_CMSG_INQ = 2,
+};
+
+struct mptcp_sendmsg_info {
+	int mss_now;
+	int size_goal;
+	u16 limit;
+	u16 sent;
+	unsigned int flags;
+	bool data_lock_held;
+};
+
+struct subflow_send_info {
+	struct sock *ssk;
+	long: 32;
+	u64 linger_time;
+};
+
+enum handshake_handler_class {
+	HANDSHAKE_HANDLER_CLASS_NONE = 0,
+	HANDSHAKE_HANDLER_CLASS_TLSHD = 1,
+	HANDSHAKE_HANDLER_CLASS_MAX = 2,
+};
+
+struct handshake_net {
+	spinlock_t hn_lock;
+	int hn_pending;
+	int hn_pending_max;
+	struct list_head hn_requests;
+	long unsigned int hn_flags;
+};
+
+enum hn_flags_bits {
+	HANDSHAKE_F_NET_DRAINING = 0,
+};
+
+enum hr_flags_bits {
+	HANDSHAKE_F_REQ_COMPLETED = 0,
+	HANDSHAKE_F_REQ_SESSION = 1,
+};
+
+enum bug_trap_type {
+	BUG_TRAP_TYPE_NONE = 0,
+	BUG_TRAP_TYPE_WARN = 1,
+	BUG_TRAP_TYPE_BUG = 2,
+};
+
+struct cpio_data {
+	void *data;
+	size_t size;
+	char name[18];
+};
+
+enum cpio_fields {
+	C_MAGIC = 0,
+	C_INO = 1,
+	C_MODE = 2,
+	C_UID = 3,
+	C_GID = 4,
+	C_NLINK = 5,
+	C_MTIME = 6,
+	C_FILESIZE = 7,
+	C_MAJ = 8,
+	C_MIN = 9,
+	C_RMAJ = 10,
+	C_RMIN = 11,
+	C_NAMESIZE = 12,
+	C_CHKSUM = 13,
+	C_NFIELDS = 14,
+};
+
+struct klist_waiter {
+	struct list_head list;
+	struct klist_node *node;
+	struct task_struct *process;
+	int woken;
+};
+
+struct maple_metadata {
+	unsigned char end;
+	unsigned char gap;
+};
+
+struct maple_pnode;
+
+struct maple_range_64 {
+	struct maple_pnode *parent;
+	long unsigned int pivot[31];
+	union {
+		void *slot[32];
+		struct {
+			void *pad[31];
+			struct maple_metadata meta;
+		};
+	};
+};
+
+struct maple_arange_64 {
+	struct maple_pnode *parent;
+	long unsigned int pivot[20];
+	void *slot[21];
+	long unsigned int gap[21];
+	struct maple_metadata meta;
+};
+
+struct maple_topiary {
+	struct maple_pnode *parent;
+	struct maple_enode *next;
+};
+
+enum maple_type {
+	maple_dense = 0,
+	maple_leaf_64 = 1,
+	maple_range_64 = 2,
+	maple_arange_64 = 3,
+};
+
+struct maple_node {
+	union {
+		struct {
+			struct maple_pnode *parent;
+			void *slot[63];
+		};
+		struct {
+			void *pad;
+			struct callback_head rcu;
+			struct maple_enode *piv_parent;
+			unsigned char parent_slot;
+			enum maple_type type;
+			unsigned char slot_len;
+			unsigned int ma_flags;
+		};
+		struct maple_range_64 mr64;
+		struct maple_arange_64 ma64;
+		struct maple_alloc alloc;
+	};
+};
+
+struct ma_topiary {
+	struct maple_enode *head;
+	struct maple_enode *tail;
+	struct maple_tree *mtree;
+};
+
+struct ma_wr_state {
+	struct ma_state *mas;
+	struct maple_node *node;
+	long unsigned int r_min;
+	long unsigned int r_max;
+	enum maple_type type;
+	unsigned char offset_end;
+	long unsigned int *pivots;
+	long unsigned int end_piv;
+	void **slots;
+	void *entry;
+	void *content;
+};
+
+struct trace_event_raw_ma_op {
+	struct trace_entry ent;
+	const char *fn;
+	long unsigned int min;
+	long unsigned int max;
+	long unsigned int index;
+	long unsigned int last;
+	void *node;
+	char __data[0];
+};
+
+struct trace_event_raw_ma_read {
+	struct trace_entry ent;
+	const char *fn;
+	long unsigned int min;
+	long unsigned int max;
+	long unsigned int index;
+	long unsigned int last;
+	void *node;
+	char __data[0];
+};
+
+struct trace_event_raw_ma_write {
+	struct trace_entry ent;
+	const char *fn;
+	long unsigned int min;
+	long unsigned int max;
+	long unsigned int index;
+	long unsigned int last;
+	long unsigned int piv;
+	void *val;
+	void *node;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_ma_op {};
+
+struct trace_event_data_offsets_ma_read {};
+
+struct trace_event_data_offsets_ma_write {};
+
+typedef void (*btf_trace_ma_op)(void *, const char *, struct ma_state *);
+
+typedef void (*btf_trace_ma_read)(void *, const char *, struct ma_state *);
+
+typedef void (*btf_trace_ma_write)(void *, const char *, struct ma_state *, long unsigned int, void *);
+
+struct maple_big_node {
+	struct maple_pnode *parent;
+	long unsigned int pivot[65];
+	union {
+		struct maple_enode *slot[66];
+		struct {
+			long unsigned int padding[43];
+			long unsigned int gap[43];
+		};
+	};
+	unsigned char b_end;
+	enum maple_type type;
+};
+
+struct maple_subtree_state {
+	struct ma_state *orig_l;
+	struct ma_state *orig_r;
+	struct ma_state *l;
+	struct ma_state *m;
+	struct ma_state *r;
+	struct ma_topiary *free;
+	struct ma_topiary *destroy;
+	struct maple_big_node *bn;
+};
+
+typedef void (*phys_reset_t)(long unsigned int, bool);
+
+struct sigaltstack {
+	void *ss_sp;
+	int ss_flags;
+	__kernel_size_t ss_size;
+};
+
+typedef struct sigaltstack stack_t;
+
+struct sigcontext {
+	long unsigned int trap_no;
+	long unsigned int error_code;
+	long unsigned int oldmask;
+	long unsigned int arm_r0;
+	long unsigned int arm_r1;
+	long unsigned int arm_r2;
+	long unsigned int arm_r3;
+	long unsigned int arm_r4;
+	long unsigned int arm_r5;
+	long unsigned int arm_r6;
+	long unsigned int arm_r7;
+	long unsigned int arm_r8;
+	long unsigned int arm_r9;
+	long unsigned int arm_r10;
+	long unsigned int arm_fp;
+	long unsigned int arm_ip;
+	long unsigned int arm_sp;
+	long unsigned int arm_lr;
+	long unsigned int arm_pc;
+	long unsigned int arm_cpsr;
+	long unsigned int fault_address;
+};
+
+struct ucontext {
+	long unsigned int uc_flags;
+	struct ucontext *uc_link;
+	stack_t uc_stack;
+	struct sigcontext uc_mcontext;
+	sigset_t uc_sigmask;
+	int __unused[30];
+	long unsigned int uc_regspace[128];
+};
+
+struct aux_sigframe {
+	long unsigned int end_magic;
+	long: 32;
+};
+
+struct sigframe {
+	struct ucontext uc;
+	long unsigned int retcode[4];
+};
+
+struct rt_sigframe {
+	struct siginfo info;
+	struct sigframe sig;
+};
+
+struct tlb_args {
+	struct vm_area_struct *ta_vma;
+	long unsigned int ta_start;
+	long unsigned int ta_end;
+};
+
+struct section_perm {
+	const char *name;
+	long unsigned int start;
+	long unsigned int end;
+	pmdval_t mask;
+	pmdval_t prot;
+	pmdval_t clear;
+};
+
+union offset_union {
+	long unsigned int un;
+	long int sn;
+};
+
+struct l2x0_event_attribute {
+	struct device_attribute attr;
+	unsigned int config;
+	bool pl310_only;
+};
+
+struct taint_flag {
+	char c_true;
+	char c_false;
+	bool module;
+	const char *desc;
+};
+
+struct warn_args {
+	const char *fmt;
+	va_list args;
+};
+
+struct waitid_info {
+	pid_t pid;
+	uid_t uid;
+	int status;
+	int cause;
+};
+
+struct wait_opts {
+	enum pid_type wo_type;
+	int wo_flags;
+	struct pid *wo_pid;
+	struct waitid_info *wo_info;
+	int wo_stat;
+	struct rusage *wo_rusage;
+	wait_queue_entry_t child_wait;
+	int notask_error;
+};
+
+typedef long unsigned int old_sigset_t;
+
+struct old_sigaction {
+	__sighandler_t sa_handler;
+	old_sigset_t sa_mask;
+	long unsigned int sa_flags;
+	__sigrestore_t sa_restorer;
+};
+
+enum {
+	TRACE_SIGNAL_DELIVERED = 0,
+	TRACE_SIGNAL_IGNORED = 1,
+	TRACE_SIGNAL_ALREADY_PENDING = 2,
+	TRACE_SIGNAL_OVERFLOW_FAIL = 3,
+	TRACE_SIGNAL_LOSE_INFO = 4,
+};
+
+struct trace_event_raw_signal_generate {
+	struct trace_entry ent;
+	int sig;
+	int errno;
+	int code;
+	char comm[16];
+	pid_t pid;
+	int group;
+	int result;
+	char __data[0];
+};
+
+struct trace_event_raw_signal_deliver {
+	struct trace_entry ent;
+	int sig;
+	int errno;
+	int code;
+	long unsigned int sa_handler;
+	long unsigned int sa_flags;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_signal_generate {};
+
+struct trace_event_data_offsets_signal_deliver {};
+
+typedef void (*btf_trace_signal_generate)(void *, int, struct kernel_siginfo *, struct task_struct *, int, int);
+
+typedef void (*btf_trace_signal_deliver)(void *, int, struct kernel_siginfo *, struct k_sigaction *);
+
+enum sig_handler {
+	HANDLER_CURRENT = 0,
+	HANDLER_SIG_DFL = 1,
+	HANDLER_EXIT = 2,
+};
+
+enum {
+	KERNEL_PARAM_OPS_FL_NOARG = 1,
+};
+
+struct param_attribute {
+	struct module_attribute mattr;
+	const struct kernel_param *param;
+};
+
+struct module_param_attrs {
+	unsigned int num;
+	struct attribute_group grp;
+	struct param_attribute attrs[0];
+};
+
+struct module_version_attribute {
+	struct module_attribute mattr;
+	const char *module_name;
+	const char *version;
+};
+
+struct kmalloced_param {
+	struct list_head list;
+	char val[0];
+};
+
+struct async_entry {
+	struct list_head domain_list;
+	struct list_head global_list;
+	struct work_struct work;
+	async_cookie_t cookie;
+	async_func_t func;
+	void *data;
+	struct async_domain *domain;
+	long: 32;
+};
+
+typedef struct {
+	void *lock;
+	long unsigned int flags;
+} class_irqsave_t;
+
+typedef struct {
+	struct rq *lock;
+	struct rq_flags rf;
+} class_rq_lock_t;
+
+typedef struct {
+	struct rq *lock;
+	struct rq *lock2;
+} class_double_rq_lock_t;
+
+struct idle_timer {
+	struct hrtimer timer;
+	int done;
+	long: 32;
+};
+
+typedef struct task_group *rt_rq_iter_t;
+
+struct rt_schedulable_data {
+	struct task_group *tg;
+	long: 32;
+	u64 rt_period;
+	u64 rt_runtime;
+};
+
+enum dl_bw_request {
+	dl_bw_req_check_overflow = 0,
+	dl_bw_req_alloc = 1,
+	dl_bw_req_free = 2,
+};
+
+typedef struct task_struct *class_find_get_task_t;
+
+enum rwsem_waiter_type {
+	RWSEM_WAITING_FOR_WRITE = 0,
+	RWSEM_WAITING_FOR_READ = 1,
+};
+
+struct rwsem_waiter {
+	struct list_head list;
+	struct task_struct *task;
+	enum rwsem_waiter_type type;
+	long unsigned int timeout;
+	bool handoff_set;
+};
+
+enum rwsem_wake_type {
+	RWSEM_WAKE_ANY = 0,
+	RWSEM_WAKE_READERS = 1,
+	RWSEM_WAKE_READ_OWNED = 2,
+};
+
+enum owner_state {
+	OWNER_NULL = 1,
+	OWNER_WRITER = 2,
+	OWNER_READER = 4,
+	OWNER_NONSPINNABLE = 8,
+};
+
+struct rt_wake_q_head {
+	struct wake_q_head head;
+	struct task_struct *rtlock_task;
+};
+
+enum rtmutex_chainwalk {
+	RT_MUTEX_MIN_CHAINWALK = 0,
+	RT_MUTEX_FULL_CHAINWALK = 1,
+};
+
+struct nbcon_state {
+	union {
+		unsigned int atom;
+		struct {
+			unsigned int prio: 2;
+			unsigned int req_prio: 2;
+			unsigned int unsafe: 1;
+			unsigned int unsafe_takeover: 1;
+			unsigned int cpu: 24;
+		};
+	};
+};
+
+enum {
+	IRQCHIP_FWNODE_REAL = 0,
+	IRQCHIP_FWNODE_NAMED = 1,
+	IRQCHIP_FWNODE_NAMED_ID = 2,
+};
+
+struct irqchip_fwid {
+	struct fwnode_handle fwnode;
+	unsigned int type;
+	char *name;
+	phys_addr_t *pa;
+};
+
+struct trace_event_raw_dma_map {
+	struct trace_entry ent;
+	u32 __data_loc_device;
+	long: 32;
+	u64 phys_addr;
+	u64 dma_addr;
+	size_t size;
+	enum dma_data_direction dir;
+	long unsigned int attrs;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_dma_unmap {
+	struct trace_entry ent;
+	u32 __data_loc_device;
+	long: 32;
+	u64 addr;
+	size_t size;
+	enum dma_data_direction dir;
+	long unsigned int attrs;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_dma_alloc {
+	struct trace_entry ent;
+	u32 __data_loc_device;
+	void *virt_addr;
+	u64 dma_addr;
+	size_t size;
+	gfp_t flags;
+	long unsigned int attrs;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_dma_free {
+	struct trace_entry ent;
+	u32 __data_loc_device;
+	void *virt_addr;
+	u64 dma_addr;
+	size_t size;
+	long unsigned int attrs;
+	char __data[0];
+};
+
+struct trace_event_raw_dma_map_sg {
+	struct trace_entry ent;
+	u32 __data_loc_device;
+	u32 __data_loc_phys_addrs;
+	u32 __data_loc_dma_addrs;
+	u32 __data_loc_lengths;
+	enum dma_data_direction dir;
+	long unsigned int attrs;
+	char __data[0];
+};
+
+struct trace_event_raw_dma_unmap_sg {
+	struct trace_entry ent;
+	u32 __data_loc_device;
+	u32 __data_loc_addrs;
+	enum dma_data_direction dir;
+	long unsigned int attrs;
+	char __data[0];
+};
+
+struct trace_event_raw_dma_sync_single {
+	struct trace_entry ent;
+	u32 __data_loc_device;
+	long: 32;
+	u64 dma_addr;
+	size_t size;
+	enum dma_data_direction dir;
+	char __data[0];
+};
+
+struct trace_event_raw_dma_sync_sg {
+	struct trace_entry ent;
+	u32 __data_loc_device;
+	u32 __data_loc_dma_addrs;
+	u32 __data_loc_lengths;
+	enum dma_data_direction dir;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_dma_map {
+	u32 device;
+	const void *device_ptr_;
+};
+
+struct trace_event_data_offsets_dma_unmap {
+	u32 device;
+	const void *device_ptr_;
+};
+
+struct trace_event_data_offsets_dma_alloc {
+	u32 device;
+	const void *device_ptr_;
+};
+
+struct trace_event_data_offsets_dma_free {
+	u32 device;
+	const void *device_ptr_;
+};
+
+struct trace_event_data_offsets_dma_map_sg {
+	u32 device;
+	const void *device_ptr_;
+	u32 phys_addrs;
+	const void *phys_addrs_ptr_;
+	u32 dma_addrs;
+	const void *dma_addrs_ptr_;
+	u32 lengths;
+	const void *lengths_ptr_;
+};
+
+struct trace_event_data_offsets_dma_unmap_sg {
+	u32 device;
+	const void *device_ptr_;
+	u32 addrs;
+	const void *addrs_ptr_;
+};
+
+struct trace_event_data_offsets_dma_sync_single {
+	u32 device;
+	const void *device_ptr_;
+};
+
+struct trace_event_data_offsets_dma_sync_sg {
+	u32 device;
+	const void *device_ptr_;
+	u32 dma_addrs;
+	const void *dma_addrs_ptr_;
+	u32 lengths;
+	const void *lengths_ptr_;
+};
+
+typedef void (*btf_trace_dma_map_page)(void *, struct device *, phys_addr_t, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
+
+typedef void (*btf_trace_dma_map_resource)(void *, struct device *, phys_addr_t, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
+
+typedef void (*btf_trace_dma_unmap_page)(void *, struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
+
+typedef void (*btf_trace_dma_unmap_resource)(void *, struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
+
+typedef void (*btf_trace_dma_alloc)(void *, struct device *, void *, dma_addr_t, size_t, gfp_t, long unsigned int);
+
+typedef void (*btf_trace_dma_free)(void *, struct device *, void *, dma_addr_t, size_t, long unsigned int);
+
+typedef void (*btf_trace_dma_map_sg)(void *, struct device *, struct scatterlist *, int, int, enum dma_data_direction, long unsigned int);
+
+typedef void (*btf_trace_dma_unmap_sg)(void *, struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
+
+typedef void (*btf_trace_dma_sync_single_for_cpu)(void *, struct device *, dma_addr_t, size_t, enum dma_data_direction);
+
+typedef void (*btf_trace_dma_sync_single_for_device)(void *, struct device *, dma_addr_t, size_t, enum dma_data_direction);
+
+typedef void (*btf_trace_dma_sync_sg_for_cpu)(void *, struct device *, struct scatterlist *, int, enum dma_data_direction);
+
+typedef void (*btf_trace_dma_sync_sg_for_device)(void *, struct device *, struct scatterlist *, int, enum dma_data_direction);
+
+struct dma_devres {
+	size_t size;
+	void *vaddr;
+	dma_addr_t dma_handle;
+	long unsigned int attrs;
+};
+
+enum kernel_read_file_id {
+	READING_UNKNOWN = 0,
+	READING_FIRMWARE = 1,
+	READING_MODULE = 2,
+	READING_KEXEC_IMAGE = 3,
+	READING_KEXEC_INITRAMFS = 4,
+	READING_POLICY = 5,
+	READING_X509_CERTIFICATE = 6,
+	READING_MAX_ID = 7,
+};
+
+enum mod_license {
+	NOT_GPL_ONLY = 0,
+	GPL_ONLY = 1,
+};
+
+struct find_symbol_arg {
+	const char *name;
+	bool gplok;
+	bool warn;
+	struct module *owner;
+	const s32 *crc;
+	const struct kernel_symbol *sym;
+	enum mod_license license;
+};
+
+enum fail_dup_mod_reason {
+	FAIL_DUP_MOD_BECOMING = 0,
+	FAIL_DUP_MOD_LOAD = 1,
+};
+
+struct mod_tree_root {
+	struct latch_tree_root root;
+	long unsigned int addr_min;
+	long unsigned int addr_max;
+};
+
+struct trace_event_raw_module_load {
+	struct trace_entry ent;
+	unsigned int taints;
+	u32 __data_loc_name;
+	char __data[0];
+};
+
+struct trace_event_raw_module_free {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	char __data[0];
+};
+
+struct trace_event_raw_module_refcnt {
+	struct trace_entry ent;
+	long unsigned int ip;
+	int refcnt;
+	u32 __data_loc_name;
+	char __data[0];
+};
+
+struct trace_event_raw_module_request {
+	struct trace_entry ent;
+	long unsigned int ip;
+	bool wait;
+	u32 __data_loc_name;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_module_load {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_module_free {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_module_refcnt {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_module_request {
+	u32 name;
+	const void *name_ptr_;
+};
+
+typedef void (*btf_trace_module_load)(void *, struct module *);
+
+typedef void (*btf_trace_module_free)(void *, struct module *);
+
+typedef void (*btf_trace_module_get)(void *, struct module *, long unsigned int);
+
+typedef void (*btf_trace_module_put)(void *, struct module *, long unsigned int);
+
+typedef void (*btf_trace_module_request)(void *, char *, bool, long unsigned int);
+
+struct symsearch {
+	const struct kernel_symbol *start;
+	const struct kernel_symbol *stop;
+	const s32 *crcs;
+	enum mod_license license;
+};
+
+struct mod_initfree {
+	struct llist_node node;
+	void *init_text;
+	void *init_data;
+	void *init_rodata;
+};
+
+struct idempotent {
+	const void *cookie;
+	struct hlist_node entry;
+	struct completion complete;
+	int ret;
+};
+
+struct __kernel_itimerspec {
+	struct __kernel_timespec it_interval;
+	struct __kernel_timespec it_value;
+};
+
+struct old_itimerspec32 {
+	struct old_timespec32 it_interval;
+	struct old_timespec32 it_value;
+};
+
+struct old_timex32 {
+	u32 modes;
+	s32 offset;
+	s32 freq;
+	s32 maxerror;
+	s32 esterror;
+	s32 status;
+	s32 constant;
+	s32 precision;
+	s32 tolerance;
+	struct old_timeval32 time;
+	s32 tick;
+	s32 ppsfreq;
+	s32 jitter;
+	s32 shift;
+	s32 stabil;
+	s32 jitcnt;
+	s32 calcnt;
+	s32 errcnt;
+	s32 stbcnt;
+	s32 tai;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct sigevent {
+	sigval_t sigev_value;
+	int sigev_signo;
+	int sigev_notify;
+	union {
+		int _pad[13];
+		int _tid;
+		struct {
+			void (*_function)(sigval_t);
+			void *_attribute;
+		} _sigev_thread;
+	} _sigev_un;
+};
+
+typedef struct sigevent sigevent_t;
+
+struct kallsym_iter {
+	loff_t pos;
+	loff_t pos_mod_end;
+	loff_t pos_ftrace_mod_end;
+	loff_t pos_bpf_end;
+	long unsigned int value;
+	unsigned int nameoff;
+	char type;
+	char name[512];
+	char module_name[60];
+	int exported;
+	int show_value;
+};
+
+struct bpf_iter__ksym {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct kallsym_iter *ksym;
+	};
+};
+
+struct cgroupstats {
+	__u64 nr_sleeping;
+	__u64 nr_running;
+	__u64 nr_stopped;
+	__u64 nr_uninterruptible;
+	__u64 nr_io_wait;
+};
+
+enum cgroup_filetype {
+	CGROUP_FILE_PROCS = 0,
+	CGROUP_FILE_TASKS = 1,
+};
+
+struct cgroup_pidlist {
+	struct {
+		enum cgroup_filetype type;
+		struct pid_namespace *ns;
+	} key;
+	pid_t *list;
+	int length;
+	struct list_head links;
+	struct cgroup *owner;
+	struct delayed_work destroy_dwork;
+};
+
+enum cgroup1_param {
+	Opt_all = 0,
+	Opt_clone_children = 1,
+	Opt_cpuset_v2_mode = 2,
+	Opt_name = 3,
+	Opt_none = 4,
+	Opt_noprefix = 5,
+	Opt_release_agent = 6,
+	Opt_xattr = 7,
+	Opt_favordynmods___2 = 8,
+	Opt_nofavordynmods = 9,
+};
+
+struct uf_node {
+	struct uf_node *parent;
+	unsigned int rank;
+};
+
+struct fmeter {
+	int cnt;
+	int val;
+	time64_t time;
+	spinlock_t lock;
+	long: 32;
+};
+
+enum prs_errcode {
+	PERR_NONE = 0,
+	PERR_INVCPUS = 1,
+	PERR_INVPARENT = 2,
+	PERR_NOTPART = 3,
+	PERR_NOTEXCL = 4,
+	PERR_NOCPUS = 5,
+	PERR_HOTPLUG = 6,
+	PERR_CPUSEMPTY = 7,
+	PERR_HKEEPING = 8,
+	PERR_ACCESS = 9,
+};
+
+typedef enum {
+	CS_ONLINE = 0,
+	CS_CPU_EXCLUSIVE = 1,
+	CS_MEM_EXCLUSIVE = 2,
+	CS_MEM_HARDWALL = 3,
+	CS_MEMORY_MIGRATE = 4,
+	CS_SCHED_LOAD_BALANCE = 5,
+	CS_SPREAD_PAGE = 6,
+	CS_SPREAD_SLAB = 7,
+} cpuset_flagbits_t;
+
+typedef enum {
+	FILE_MEMORY_MIGRATE = 0,
+	FILE_CPULIST = 1,
+	FILE_MEMLIST = 2,
+	FILE_EFFECTIVE_CPULIST = 3,
+	FILE_EFFECTIVE_MEMLIST = 4,
+	FILE_SUBPARTS_CPULIST = 5,
+	FILE_EXCLUSIVE_CPULIST = 6,
+	FILE_EFFECTIVE_XCPULIST = 7,
+	FILE_ISOLATED_CPULIST = 8,
+	FILE_CPU_EXCLUSIVE = 9,
+	FILE_MEM_EXCLUSIVE = 10,
+	FILE_MEM_HARDWALL = 11,
+	FILE_SCHED_LOAD_BALANCE = 12,
+	FILE_PARTITION_ROOT = 13,
+	FILE_SCHED_RELAX_DOMAIN_LEVEL = 14,
+	FILE_MEMORY_PRESSURE_ENABLED = 15,
+	FILE_MEMORY_PRESSURE = 16,
+	FILE_SPREAD_PAGE = 17,
+	FILE_SPREAD_SLAB = 18,
+} cpuset_filetype_t;
+
+struct cpuset {
+	struct cgroup_subsys_state css;
+	long unsigned int flags;
+	cpumask_var_t cpus_allowed;
+	nodemask_t mems_allowed;
+	cpumask_var_t effective_cpus;
+	nodemask_t effective_mems;
+	cpumask_var_t effective_xcpus;
+	cpumask_var_t exclusive_cpus;
+	nodemask_t old_mems_allowed;
+	struct fmeter fmeter;
+	int attach_in_progress;
+	int relax_domain_level;
+	int nr_subparts;
+	int partition_root_state;
+	int nr_deadline_tasks;
+	int nr_migrate_dl_tasks;
+	u64 sum_migrate_dl_bw;
+	enum prs_errcode prs_err;
+	struct cgroup_file partition_file;
+	struct list_head remote_sibling;
+	struct uf_node node;
+};
+
+struct tmpmasks {
+	cpumask_var_t addmask;
+	cpumask_var_t delmask;
+	cpumask_var_t new_cpus;
+};
+
+enum partition_cmd {
+	partcmd_enable = 0,
+	partcmd_enablei = 1,
+	partcmd_disable = 2,
+	partcmd_update = 3,
+	partcmd_invalidate = 4,
+};
+
+struct cpuset_migrate_mm_work {
+	struct work_struct work;
+	struct mm_struct *mm;
+	nodemask_t from;
+	nodemask_t to;
+};
+
+struct action_cache {
+	long unsigned int allow_native[15];
+};
+
+struct notification;
+
+struct seccomp_filter {
+	refcount_t refs;
+	refcount_t users;
+	bool log;
+	bool wait_killable_recv;
+	struct action_cache cache;
+	struct seccomp_filter *prev;
+	struct bpf_prog *prog;
+	struct notification *notif;
+	struct mutex notify_lock;
+	wait_queue_head_t wqh;
+};
+
+struct seccomp_notif_sizes {
+	__u16 seccomp_notif;
+	__u16 seccomp_notif_resp;
+	__u16 seccomp_data;
+};
+
+struct seccomp_notif {
+	__u64 id;
+	__u32 pid;
+	__u32 flags;
+	struct seccomp_data data;
+};
+
+struct seccomp_notif_resp {
+	__u64 id;
+	__s64 val;
+	__s32 error;
+	__u32 flags;
+};
+
+struct seccomp_notif_addfd {
+	__u64 id;
+	__u32 flags;
+	__u32 srcfd;
+	__u32 newfd;
+	__u32 newfd_flags;
+};
+
+typedef int (*bpf_aux_classic_check_t)(struct sock_filter *, unsigned int);
+
+enum notify_state {
+	SECCOMP_NOTIFY_INIT = 0,
+	SECCOMP_NOTIFY_SENT = 1,
+	SECCOMP_NOTIFY_REPLIED = 2,
+};
+
+struct seccomp_knotif {
+	struct task_struct *task;
+	long: 32;
+	u64 id;
+	const struct seccomp_data *data;
+	enum notify_state state;
+	int error;
+	long int val;
+	u32 flags;
+	struct completion ready;
+	struct list_head list;
+	struct list_head addfd;
+	long: 32;
+};
+
+struct seccomp_kaddfd {
+	struct file *file;
+	int fd;
+	unsigned int flags;
+	__u32 ioctl_flags;
+	union {
+		bool setfd;
+		int ret;
+	};
+	struct completion completion;
+	struct list_head list;
+};
+
+struct notification {
+	atomic_t requests;
+	u32 flags;
+	u64 next_id;
+	struct list_head notifications;
+};
+
+struct seccomp_log_name {
+	u32 log;
+	const char *name;
+};
+
+struct trace_bprintk_fmt {
+	struct list_head list;
+	const char *fmt;
+};
+
+typedef long unsigned int perf_trace_t[2048];
+
+struct kprobe_trace_entry_head {
+	struct trace_entry ent;
+	long unsigned int ip;
+};
+
+struct kretprobe_trace_entry_head {
+	struct trace_entry ent;
+	long unsigned int func;
+	long unsigned int ret_ip;
+};
+
+struct objpool_slot {
+	uint32_t head;
+	uint32_t tail;
+	uint32_t last;
+	uint32_t mask;
+	void *entries[0];
+};
+
+struct objpool_head;
+
+typedef int (*objpool_fini_cb)(struct objpool_head *, void *);
+
+struct objpool_head {
+	int obj_size;
+	int nr_objs;
+	int nr_possible_cpus;
+	int capacity;
+	gfp_t gfp;
+	refcount_t ref;
+	long unsigned int flags;
+	struct objpool_slot **cpu_slots;
+	objpool_fini_cb release;
+	void *context;
+};
+
+struct kretprobe_instance;
+
+typedef int (*kretprobe_handler_t)(struct kretprobe_instance *, struct pt_regs *);
+
+struct kretprobe_holder;
+
+struct kretprobe_instance {
+	struct callback_head rcu;
+	struct llist_node llist;
+	struct kretprobe_holder *rph;
+	kprobe_opcode_t *ret_addr;
+	void *fp;
+	char data[0];
+};
+
+struct kretprobe;
+
+struct kretprobe_holder {
+	struct kretprobe *rp;
+	struct objpool_head pool;
+};
+
+struct kretprobe {
+	struct kprobe kp;
+	kretprobe_handler_t handler;
+	kretprobe_handler_t entry_handler;
+	int maxactive;
+	int nmissed;
+	size_t data_size;
+	struct kretprobe_holder *rph;
+};
+
+struct trace_kprobe {
+	struct dyn_event devent;
+	struct kretprobe rp;
+	long unsigned int *nhit;
+	const char *symbol;
+	struct trace_probe tp;
+};
+
+struct sym_count_ctx {
+	unsigned int count;
+	const char *name;
+};
+
+enum btf_func_linkage {
+	BTF_FUNC_STATIC = 0,
+	BTF_FUNC_GLOBAL = 1,
+	BTF_FUNC_EXTERN = 2,
+};
+
+struct btf_var_secinfo {
+	__u32 type;
+	__u32 offset;
+	__u32 size;
+};
+
+struct bpf_kfunc_desc {
+	struct btf_func_model func_model;
+	u32 func_id;
+	s32 imm;
+	u16 offset;
+	long unsigned int addr;
+};
+
+struct bpf_kfunc_desc_tab {
+	struct bpf_kfunc_desc descs[256];
+	u32 nr_descs;
+};
+
+struct bpf_kfunc_btf {
+	struct btf *btf;
+	struct module *module;
+	u16 offset;
+};
+
+struct bpf_kfunc_btf_tab {
+	struct bpf_kfunc_btf descs[256];
+	u32 nr_descs;
+};
+
+enum {
+	BPF_MAX_LOOPS = 8388608,
+};
+
+typedef u32 (*bpf_convert_ctx_access_t)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);
+
+struct bpf_core_ctx {
+	struct bpf_verifier_log *log;
+	const struct btf *btf;
+};
+
+struct bpf_verifier_stack_elem {
+	struct bpf_verifier_state st;
+	int insn_idx;
+	int prev_insn_idx;
+	struct bpf_verifier_stack_elem *next;
+	u32 log_pos;
+};
+
+struct bpf_call_arg_meta {
+	struct bpf_map *map_ptr;
+	bool raw_mode;
+	bool pkt_access;
+	u8 release_regno;
+	int regno;
+	int access_size;
+	int mem_size;
+	long: 32;
+	u64 msize_max_value;
+	int ref_obj_id;
+	int dynptr_id;
+	int map_uid;
+	int func_id;
+	struct btf *btf;
+	u32 btf_id;
+	struct btf *ret_btf;
+	u32 ret_btf_id;
+	u32 subprogno;
+	struct btf_field *kptr_field;
+};
+
+struct bpf_kfunc_call_arg_meta {
+	struct btf *btf;
+	u32 func_id;
+	u32 kfunc_flags;
+	const struct btf_type *func_proto;
+	const char *func_name;
+	u32 ref_obj_id;
+	u8 release_regno;
+	bool r0_rdonly;
+	u32 ret_btf_id;
+	u64 r0_size;
+	u32 subprogno;
+	long: 32;
+	struct {
+		u64 value;
+		bool found;
+		long: 32;
+	} arg_constant;
+	struct btf *arg_btf;
+	u32 arg_btf_id;
+	bool arg_owning_ref;
+	struct {
+		struct btf_field *field;
+	} arg_list_head;
+	struct {
+		struct btf_field *field;
+	} arg_rbtree_root;
+	struct {
+		enum bpf_dynptr_type type;
+		u32 id;
+		u32 ref_obj_id;
+	} initialized_dynptr;
+	struct {
+		u8 spi;
+		u8 frameno;
+	} iter;
+	struct {
+		struct bpf_map *ptr;
+		int uid;
+	} map;
+	long: 32;
+	u64 mem_size;
+};
+
+enum reg_arg_type {
+	SRC_OP = 0,
+	DST_OP = 1,
+	DST_OP_NO_MARK = 2,
+};
+
+struct linked_reg {
+	u8 frameno;
+	union {
+		u8 spi;
+		u8 regno;
+	};
+	bool is_reg;
+};
+
+struct linked_regs {
+	int cnt;
+	struct linked_reg entries[6];
+};
+
+enum bpf_access_src {
+	ACCESS_DIRECT = 1,
+	ACCESS_HELPER = 2,
+};
+
+struct task_struct__safe_rcu {
+	const cpumask_t *cpus_ptr;
+	struct css_set *cgroups;
+	struct task_struct *real_parent;
+	struct task_struct *group_leader;
+};
+
+struct cgroup__safe_rcu {
+	struct kernfs_node *kn;
+};
+
+struct css_set__safe_rcu {
+	struct cgroup *dfl_cgrp;
+};
+
+struct mm_struct__safe_rcu_or_null {
+	struct file *exe_file;
+};
+
+struct sk_buff__safe_rcu_or_null {
+	struct sock *sk;
+};
+
+struct request_sock__safe_rcu_or_null {
+	struct sock *sk;
+};
+
+struct bpf_iter_meta__safe_trusted {
+	struct seq_file *seq;
+};
+
+struct bpf_iter__task__safe_trusted {
+	struct bpf_iter_meta *meta;
+	struct task_struct *task;
+};
+
+struct linux_binprm__safe_trusted {
+	struct file *file;
+};
+
+struct file__safe_trusted {
+	struct inode *f_inode;
+};
+
+struct dentry__safe_trusted {
+	struct inode *d_inode;
+};
+
+struct socket__safe_trusted_or_null {
+	struct sock *sk;
+};
+
+struct bpf_reg_types {
+	const enum bpf_reg_type types[10];
+	u32 *btf_id;
+};
+
+enum {
+	AT_PKT_END = -1,
+	BEYOND_PKT_END = -2,
+};
+
+typedef int (*set_callee_state_fn)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *, int);
+
+enum {
+	KF_ARG_DYNPTR_ID = 0,
+	KF_ARG_LIST_HEAD_ID = 1,
+	KF_ARG_LIST_NODE_ID = 2,
+	KF_ARG_RB_ROOT_ID = 3,
+	KF_ARG_RB_NODE_ID = 4,
+	KF_ARG_WORKQUEUE_ID = 5,
+};
+
+enum kfunc_ptr_arg_type {
+	KF_ARG_PTR_TO_CTX = 0,
+	KF_ARG_PTR_TO_ALLOC_BTF_ID = 1,
+	KF_ARG_PTR_TO_REFCOUNTED_KPTR = 2,
+	KF_ARG_PTR_TO_DYNPTR = 3,
+	KF_ARG_PTR_TO_ITER = 4,
+	KF_ARG_PTR_TO_LIST_HEAD = 5,
+	KF_ARG_PTR_TO_LIST_NODE = 6,
+	KF_ARG_PTR_TO_BTF_ID = 7,
+	KF_ARG_PTR_TO_MEM = 8,
+	KF_ARG_PTR_TO_MEM_SIZE = 9,
+	KF_ARG_PTR_TO_CALLBACK = 10,
+	KF_ARG_PTR_TO_RB_ROOT = 11,
+	KF_ARG_PTR_TO_RB_NODE = 12,
+	KF_ARG_PTR_TO_NULL = 13,
+	KF_ARG_PTR_TO_CONST_STR = 14,
+	KF_ARG_PTR_TO_MAP = 15,
+	KF_ARG_PTR_TO_WORKQUEUE = 16,
+};
+
+enum special_kfunc_type {
+	KF_bpf_obj_new_impl = 0,
+	KF_bpf_obj_drop_impl = 1,
+	KF_bpf_refcount_acquire_impl = 2,
+	KF_bpf_list_push_front_impl = 3,
+	KF_bpf_list_push_back_impl = 4,
+	KF_bpf_list_pop_front = 5,
+	KF_bpf_list_pop_back = 6,
+	KF_bpf_cast_to_kern_ctx = 7,
+	KF_bpf_rdonly_cast = 8,
+	KF_bpf_rcu_read_lock = 9,
+	KF_bpf_rcu_read_unlock = 10,
+	KF_bpf_rbtree_remove = 11,
+	KF_bpf_rbtree_add_impl = 12,
+	KF_bpf_rbtree_first = 13,
+	KF_bpf_dynptr_from_skb = 14,
+	KF_bpf_dynptr_from_xdp = 15,
+	KF_bpf_dynptr_slice = 16,
+	KF_bpf_dynptr_slice_rdwr = 17,
+	KF_bpf_dynptr_clone = 18,
+	KF_bpf_percpu_obj_new_impl = 19,
+	KF_bpf_percpu_obj_drop_impl = 20,
+	KF_bpf_throw = 21,
+	KF_bpf_wq_set_callback_impl = 22,
+	KF_bpf_preempt_disable = 23,
+	KF_bpf_preempt_enable = 24,
+	KF_bpf_iter_css_task_new = 25,
+	KF_bpf_session_cookie = 26,
+};
+
+enum {
+	REASON_BOUNDS = -1,
+	REASON_TYPE = -2,
+	REASON_PATHS = -3,
+	REASON_LIMIT = -4,
+	REASON_STACK = -5,
+};
+
+struct bpf_sanitize_info {
+	struct bpf_insn_aux_data aux;
+	bool mask_to_left;
+	long: 32;
+};
+
+enum {
+	DISCOVERED = 16,
+	EXPLORED = 32,
+	FALLTHROUGH = 1,
+	BRANCH = 2,
+};
+
+enum {
+	DONE_EXPLORING = 0,
+	KEEP_EXPLORING = 1,
+};
+
+enum exact_level {
+	NOT_EXACT = 0,
+	EXACT = 1,
+	RANGE_WITHIN = 2,
+};
+
+struct bpf_iter;
+
+struct bpf_iter_num {
+	__u64 __opaque[1];
+};
+
+struct bpf_iter_target_info {
+	struct list_head list;
+	const struct bpf_iter_reg *reg_info;
+	u32 btf_id;
+};
+
+struct bpf_iter_link {
+	struct bpf_link link;
+	struct bpf_iter_aux_info aux;
+	struct bpf_iter_target_info *tinfo;
+};
+
+struct bpf_iter_priv_data {
+	struct bpf_iter_target_info *tinfo;
+	const struct bpf_iter_seq_info *seq_info;
+	struct bpf_prog *prog;
+	long: 32;
+	u64 session_id;
+	u64 seq_num;
+	bool done_stop;
+	long: 32;
+	u8 target_private[0];
+};
+
+typedef u64 (*btf_bpf_for_each_map_elem)(struct bpf_map *, void *, void *, u64);
+
+typedef u64 (*btf_bpf_loop)(u32, void *, void *, u64);
+
+struct bpf_iter_num_kern {
+	int cur;
+	int end;
+};
+
+struct bpf_iter_seq_link_info {
+	u32 link_id;
+};
+
+struct bpf_iter__bpf_link {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct bpf_link *link;
+	};
+};
+
+struct bpf_queue_stack {
+	struct bpf_map map;
+	raw_spinlock_t lock;
+	u32 head;
+	u32 tail;
+	u32 size;
+	char elements[0];
+};
+
+typedef u64 (*btf_bpf_task_storage_get_recur)(struct bpf_map *, struct task_struct *, void *, u64, gfp_t);
+
+typedef u64 (*btf_bpf_task_storage_get)(struct bpf_map *, struct task_struct *, void *, u64, gfp_t);
+
+typedef u64 (*btf_bpf_task_storage_delete_recur)(struct bpf_map *, struct task_struct *);
+
+typedef u64 (*btf_bpf_task_storage_delete)(struct bpf_map *, struct task_struct *);
+
+typedef void (*swap_r_func_t)(void *, void *, int, const void *);
+
+typedef int (*cmp_r_func_t)(const void *, const void *, const void *);
+
+enum {
+	BTF_VAR_STATIC = 0,
+	BTF_VAR_GLOBAL_ALLOCATED = 1,
+	BTF_VAR_GLOBAL_EXTERN = 2,
+};
+
+struct btf_var {
+	__u32 linkage;
+};
+
+struct btf_decl_tag {
+	__s32 component_idx;
+};
+
+struct sk_msg_md {
+	union {
+		void *data;
+	};
+	union {
+		void *data_end;
+	};
+	__u32 family;
+	__u32 remote_ip4;
+	__u32 local_ip4;
+	__u32 remote_ip6[4];
+	__u32 local_ip6[4];
+	__u32 remote_port;
+	__u32 local_port;
+	__u32 size;
+	union {
+		struct bpf_sock *sk;
+	};
+};
+
+struct sk_reuseport_md {
+	union {
+		void *data;
+	};
+	union {
+		void *data_end;
+	};
+	__u32 len;
+	__u32 eth_protocol;
+	__u32 ip_protocol;
+	__u32 bind_inany;
+	__u32 hash;
+	long: 32;
+	union {
+		struct bpf_sock *sk;
+	};
+	union {
+		struct bpf_sock *migrating_sk;
+	};
+};
+
+struct bpf_btf_info {
+	__u64 btf;
+	__u32 btf_size;
+	__u32 id;
+	__u64 name;
+	__u32 name_len;
+	__u32 kernel_btf;
+};
+
+struct bpf_sock_addr {
+	__u32 user_family;
+	__u32 user_ip4;
+	__u32 user_ip6[4];
+	__u32 user_port;
+	__u32 family;
+	__u32 type;
+	__u32 protocol;
+	__u32 msg_src_ip4;
+	__u32 msg_src_ip6[4];
+	long: 32;
+	union {
+		struct bpf_sock *sk;
+	};
+};
+
+struct bpf_sock_ops {
+	__u32 op;
+	union {
+		__u32 args[4];
+		__u32 reply;
+		__u32 replylong[4];
+	};
+	__u32 family;
+	__u32 remote_ip4;
+	__u32 local_ip4;
+	__u32 remote_ip6[4];
+	__u32 local_ip6[4];
+	__u32 remote_port;
+	__u32 local_port;
+	__u32 is_fullsock;
+	__u32 snd_cwnd;
+	__u32 srtt_us;
+	__u32 bpf_sock_ops_cb_flags;
+	__u32 state;
+	__u32 rtt_min;
+	__u32 snd_ssthresh;
+	__u32 rcv_nxt;
+	__u32 snd_nxt;
+	__u32 snd_una;
+	__u32 mss_cache;
+	__u32 ecn_flags;
+	__u32 rate_delivered;
+	__u32 rate_interval_us;
+	__u32 packets_out;
+	__u32 retrans_out;
+	__u32 total_retrans;
+	__u32 segs_in;
+	__u32 data_segs_in;
+	__u32 segs_out;
+	__u32 data_segs_out;
+	__u32 lost_out;
+	__u32 sacked_out;
+	__u32 sk_txhash;
+	__u64 bytes_received;
+	__u64 bytes_acked;
+	union {
+		struct bpf_sock *sk;
+	};
+	union {
+		void *skb_data;
+	};
+	union {
+		void *skb_data_end;
+	};
+	__u32 skb_len;
+	__u32 skb_tcp_flags;
+	__u64 skb_hwtstamp;
+};
+
+struct bpf_sockopt {
+	union {
+		struct bpf_sock *sk;
+	};
+	union {
+		void *optval;
+	};
+	union {
+		void *optval_end;
+	};
+	__s32 level;
+	__s32 optname;
+	__s32 optlen;
+	__s32 retval;
+};
+
+struct bpf_sk_lookup {
+	union {
+		union {
+			struct bpf_sock *sk;
+		};
+		__u64 cookie;
+	};
+	__u32 family;
+	__u32 protocol;
+	__u32 remote_ip4;
+	__u32 remote_ip6[4];
+	__be16 remote_port;
+	__u32 local_ip4;
+	__u32 local_ip6[4];
+	__u32 local_port;
+	__u32 ingress_ifindex;
+	long: 32;
+};
+
+struct btf_struct_metas {
+	u32 cnt;
+	struct btf_struct_meta types[0];
+};
+
+enum {
+	BTF_FIELDS_MAX = 11,
+};
+
+struct sk_reuseport_kern {
+	struct sk_buff *skb;
+	struct sock *sk;
+	struct sock *selected_sk;
+	struct sock *migrating_sk;
+	void *data_end;
+	u32 hash;
+	u32 reuseport_id;
+	bool bind_inany;
+};
+
+enum btf_kfunc_hook {
+	BTF_KFUNC_HOOK_COMMON = 0,
+	BTF_KFUNC_HOOK_XDP = 1,
+	BTF_KFUNC_HOOK_TC = 2,
+	BTF_KFUNC_HOOK_STRUCT_OPS = 3,
+	BTF_KFUNC_HOOK_TRACING = 4,
+	BTF_KFUNC_HOOK_SYSCALL = 5,
+	BTF_KFUNC_HOOK_FMODRET = 6,
+	BTF_KFUNC_HOOK_CGROUP = 7,
+	BTF_KFUNC_HOOK_SCHED_ACT = 8,
+	BTF_KFUNC_HOOK_SK_SKB = 9,
+	BTF_KFUNC_HOOK_SOCKET_FILTER = 10,
+	BTF_KFUNC_HOOK_LWT = 11,
+	BTF_KFUNC_HOOK_NETFILTER = 12,
+	BTF_KFUNC_HOOK_KPROBE = 13,
+	BTF_KFUNC_HOOK_MAX = 14,
+};
+
+enum {
+	BTF_KFUNC_SET_MAX_CNT = 256,
+	BTF_DTOR_KFUNC_MAX_CNT = 256,
+	BTF_KFUNC_FILTER_MAX_CNT = 16,
+};
+
+struct btf_kfunc_hook_filter {
+	btf_kfunc_filter_t filters[16];
+	u32 nr_filters;
+};
+
+struct btf_kfunc_set_tab {
+	struct btf_id_set8 *sets[14];
+	struct btf_kfunc_hook_filter hook_filters[14];
+};
+
+struct btf_id_dtor_kfunc_tab {
+	u32 cnt;
+	struct btf_id_dtor_kfunc dtors[0];
+};
+
+struct btf_struct_ops_tab {
+	u32 cnt;
+	u32 capacity;
+	struct bpf_struct_ops_desc ops[0];
+};
+
+enum verifier_phase {
+	CHECK_META = 0,
+	CHECK_TYPE = 1,
+};
+
+struct resolve_vertex {
+	const struct btf_type *t;
+	u32 type_id;
+	u16 next_member;
+};
+
+enum visit_state {
+	NOT_VISITED = 0,
+	VISITED = 1,
+	RESOLVED = 2,
+};
+
+enum resolve_mode {
+	RESOLVE_TBD = 0,
+	RESOLVE_PTR = 1,
+	RESOLVE_STRUCT_OR_ARRAY = 2,
+};
+
+struct btf_sec_info {
+	u32 off;
+	u32 len;
+};
+
+struct btf_verifier_env {
+	struct btf *btf;
+	u8 *visit_states;
+	struct resolve_vertex stack[32];
+	struct bpf_verifier_log log;
+	u32 log_type_id;
+	u32 top_stack;
+	enum verifier_phase phase;
+	enum resolve_mode resolve_mode;
+};
+
+struct btf_show {
+	u64 flags;
+	void *target;
+	void (*showfn)(struct btf_show *, const char *, va_list);
+	const struct btf *btf;
+	struct {
+		u8 depth;
+		u8 depth_to_show;
+		u8 depth_check;
+		u8 array_member: 1;
+		u8 array_terminated: 1;
+		u16 array_encoding;
+		u32 type_id;
+		int status;
+		const struct btf_type *type;
+		const struct btf_member *member;
+		char name[80];
+	} state;
+	struct {
+		u32 size;
+		void *head;
+		void *data;
+		u8 safe[32];
+	} obj;
+};
+
+struct btf_kind_operations {
+	s32 (*check_meta)(struct btf_verifier_env *, const struct btf_type *, u32);
+	int (*resolve)(struct btf_verifier_env *, const struct resolve_vertex *);
+	int (*check_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
+	int (*check_kflag_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
+	void (*log_details)(struct btf_verifier_env *, const struct btf_type *);
+	void (*show)(const struct btf *, const struct btf_type *, u32, void *, u8, struct btf_show *);
+};
+
+enum {
+	BTF_FIELD_IGNORE = 0,
+	BTF_FIELD_FOUND = 1,
+};
+
+struct btf_field_info {
+	enum btf_field_type type;
+	u32 off;
+	union {
+		struct {
+			u32 type_id;
+		} kptr;
+		struct {
+			const char *node_name;
+			u32 value_btf_id;
+		} graph_root;
+	};
+};
+
+struct bpf_ctx_convert {
+	struct __sk_buff BPF_PROG_TYPE_SOCKET_FILTER_prog;
+	struct sk_buff BPF_PROG_TYPE_SOCKET_FILTER_kern;
+	struct __sk_buff BPF_PROG_TYPE_SCHED_CLS_prog;
+	struct sk_buff BPF_PROG_TYPE_SCHED_CLS_kern;
+	struct __sk_buff BPF_PROG_TYPE_SCHED_ACT_prog;
+	struct sk_buff BPF_PROG_TYPE_SCHED_ACT_kern;
+	struct xdp_md BPF_PROG_TYPE_XDP_prog;
+	struct xdp_buff BPF_PROG_TYPE_XDP_kern;
+	struct __sk_buff BPF_PROG_TYPE_CGROUP_SKB_prog;
+	struct sk_buff BPF_PROG_TYPE_CGROUP_SKB_kern;
+	struct bpf_sock BPF_PROG_TYPE_CGROUP_SOCK_prog;
+	struct sock BPF_PROG_TYPE_CGROUP_SOCK_kern;
+	struct bpf_sock_addr BPF_PROG_TYPE_CGROUP_SOCK_ADDR_prog;
+	struct bpf_sock_addr_kern BPF_PROG_TYPE_CGROUP_SOCK_ADDR_kern;
+	struct __sk_buff BPF_PROG_TYPE_LWT_IN_prog;
+	struct sk_buff BPF_PROG_TYPE_LWT_IN_kern;
+	struct __sk_buff BPF_PROG_TYPE_LWT_OUT_prog;
+	struct sk_buff BPF_PROG_TYPE_LWT_OUT_kern;
+	struct __sk_buff BPF_PROG_TYPE_LWT_XMIT_prog;
+	struct sk_buff BPF_PROG_TYPE_LWT_XMIT_kern;
+	struct __sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_prog;
+	struct sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_kern;
+	struct bpf_sock_ops BPF_PROG_TYPE_SOCK_OPS_prog;
+	struct bpf_sock_ops_kern BPF_PROG_TYPE_SOCK_OPS_kern;
+	struct __sk_buff BPF_PROG_TYPE_SK_SKB_prog;
+	struct sk_buff BPF_PROG_TYPE_SK_SKB_kern;
+	struct sk_msg_md BPF_PROG_TYPE_SK_MSG_prog;
+	struct sk_msg BPF_PROG_TYPE_SK_MSG_kern;
+	struct __sk_buff BPF_PROG_TYPE_FLOW_DISSECTOR_prog;
+	struct bpf_flow_dissector BPF_PROG_TYPE_FLOW_DISSECTOR_kern;
+	bpf_user_pt_regs_t BPF_PROG_TYPE_KPROBE_prog;
+	struct pt_regs BPF_PROG_TYPE_KPROBE_kern;
+	__u64 BPF_PROG_TYPE_TRACEPOINT_prog;
+	u64 BPF_PROG_TYPE_TRACEPOINT_kern;
+	struct bpf_perf_event_data BPF_PROG_TYPE_PERF_EVENT_prog;
+	struct bpf_perf_event_data_kern BPF_PROG_TYPE_PERF_EVENT_kern;
+	long: 32;
+	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_prog;
+	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_kern;
+	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_prog;
+	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_kern;
+	void *BPF_PROG_TYPE_TRACING_prog;
+	void *BPF_PROG_TYPE_TRACING_kern;
+	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_prog;
+	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_kern;
+	struct bpf_sysctl BPF_PROG_TYPE_CGROUP_SYSCTL_prog;
+	struct bpf_sysctl_kern BPF_PROG_TYPE_CGROUP_SYSCTL_kern;
+	struct bpf_sockopt BPF_PROG_TYPE_CGROUP_SOCKOPT_prog;
+	struct bpf_sockopt_kern BPF_PROG_TYPE_CGROUP_SOCKOPT_kern;
+	struct sk_reuseport_md BPF_PROG_TYPE_SK_REUSEPORT_prog;
+	struct sk_reuseport_kern BPF_PROG_TYPE_SK_REUSEPORT_kern;
+	struct bpf_sk_lookup BPF_PROG_TYPE_SK_LOOKUP_prog;
+	struct bpf_sk_lookup_kern BPF_PROG_TYPE_SK_LOOKUP_kern;
+	void *BPF_PROG_TYPE_STRUCT_OPS_prog;
+	void *BPF_PROG_TYPE_STRUCT_OPS_kern;
+	void *BPF_PROG_TYPE_EXT_prog;
+	void *BPF_PROG_TYPE_EXT_kern;
+	void *BPF_PROG_TYPE_SYSCALL_prog;
+	void *BPF_PROG_TYPE_SYSCALL_kern;
+	struct bpf_nf_ctx BPF_PROG_TYPE_NETFILTER_prog;
+	struct bpf_nf_ctx BPF_PROG_TYPE_NETFILTER_kern;
+	long: 32;
+};
+
+enum {
+	__ctx_convertBPF_PROG_TYPE_SOCKET_FILTER = 0,
+	__ctx_convertBPF_PROG_TYPE_SCHED_CLS = 1,
+	__ctx_convertBPF_PROG_TYPE_SCHED_ACT = 2,
+	__ctx_convertBPF_PROG_TYPE_XDP = 3,
+	__ctx_convertBPF_PROG_TYPE_CGROUP_SKB = 4,
+	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK = 5,
+	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK_ADDR = 6,
+	__ctx_convertBPF_PROG_TYPE_LWT_IN = 7,
+	__ctx_convertBPF_PROG_TYPE_LWT_OUT = 8,
+	__ctx_convertBPF_PROG_TYPE_LWT_XMIT = 9,
+	__ctx_convertBPF_PROG_TYPE_LWT_SEG6LOCAL = 10,
+	__ctx_convertBPF_PROG_TYPE_SOCK_OPS = 11,
+	__ctx_convertBPF_PROG_TYPE_SK_SKB = 12,
+	__ctx_convertBPF_PROG_TYPE_SK_MSG = 13,
+	__ctx_convertBPF_PROG_TYPE_FLOW_DISSECTOR = 14,
+	__ctx_convertBPF_PROG_TYPE_KPROBE = 15,
+	__ctx_convertBPF_PROG_TYPE_TRACEPOINT = 16,
+	__ctx_convertBPF_PROG_TYPE_PERF_EVENT = 17,
+	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT = 18,
+	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 19,
+	__ctx_convertBPF_PROG_TYPE_TRACING = 20,
+	__ctx_convertBPF_PROG_TYPE_CGROUP_DEVICE = 21,
+	__ctx_convertBPF_PROG_TYPE_CGROUP_SYSCTL = 22,
+	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCKOPT = 23,
+	__ctx_convertBPF_PROG_TYPE_SK_REUSEPORT = 24,
+	__ctx_convertBPF_PROG_TYPE_SK_LOOKUP = 25,
+	__ctx_convertBPF_PROG_TYPE_STRUCT_OPS = 26,
+	__ctx_convertBPF_PROG_TYPE_EXT = 27,
+	__ctx_convertBPF_PROG_TYPE_SYSCALL = 28,
+	__ctx_convertBPF_PROG_TYPE_NETFILTER = 29,
+	__ctx_convert_unused = 30,
+};
+
+enum bpf_struct_walk_result {
+	WALK_SCALAR = 0,
+	WALK_PTR = 1,
+	WALK_STRUCT = 2,
+};
+
+struct bpf_cand_cache {
+	const char *name;
+	u32 name_len;
+	u16 kind;
+	u16 cnt;
+	struct {
+		const struct btf *btf;
+		u32 id;
+	} cands[0];
+};
+
+enum btf_arg_tag {
+	ARG_TAG_CTX = 1,
+	ARG_TAG_NONNULL = 2,
+	ARG_TAG_TRUSTED = 4,
+	ARG_TAG_NULLABLE = 8,
+	ARG_TAG_ARENA = 16,
+};
+
+struct btf_show_snprintf {
+	struct btf_show show;
+	int len_left;
+	int len;
+};
+
+enum {
+	BTF_MODULE_F_LIVE = 1,
+};
+
+struct btf_module {
+	struct list_head list;
+	struct module *module;
+	struct btf *btf;
+	struct bin_attribute *sysfs_attr;
+	int flags;
+};
+
+typedef u64 (*btf_bpf_btf_find_by_name_kind)(char *, int, u32, int);
+
+struct bpf_netns_link {
+	struct bpf_link link;
+	enum bpf_attach_type type;
+	enum netns_bpf_attach_type netns_type;
+	struct net *net;
+	struct list_head node;
+	long: 32;
+};
+
+typedef u64 (*btf_bpf_cgrp_storage_get)(struct bpf_map *, struct cgroup *, void *, u64, gfp_t);
+
+typedef u64 (*btf_bpf_cgrp_storage_delete)(struct bpf_map *, struct cgroup *);
+
+struct bpf_cpumask {
+	cpumask_t cpumask;
+	refcount_t usage;
+};
+
+struct callchain_cpus_entries {
+	struct callback_head callback_head;
+	struct perf_callchain_entry *cpu_entries[0];
+};
+
+struct parallel_data;
+
+struct padata_priv {
+	struct list_head list;
+	struct parallel_data *pd;
+	int cb_cpu;
+	unsigned int seq_nr;
+	int info;
+	void (*parallel)(struct padata_priv *);
+	void (*serial)(struct padata_priv *);
+};
+
+struct padata_cpumask {
+	cpumask_var_t pcpu;
+	cpumask_var_t cbcpu;
+};
+
+struct padata_shell;
+
+struct padata_list;
+
+struct padata_serial_queue;
+
+struct parallel_data {
+	struct padata_shell *ps;
+	struct padata_list *reorder_list;
+	struct padata_serial_queue *squeue;
+	refcount_t refcnt;
+	unsigned int seq_nr;
+	unsigned int processed;
+	int cpu;
+	struct padata_cpumask cpumask;
+	struct work_struct reorder_work;
+	long: 32;
+	long: 32;
+	long: 32;
+	spinlock_t lock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct padata_list {
+	struct list_head list;
+	spinlock_t lock;
+};
+
+struct padata_serial_queue {
+	struct padata_list serial;
+	struct work_struct work;
+	struct parallel_data *pd;
+};
+
+struct padata_instance;
+
+struct padata_shell {
+	struct padata_instance *pinst;
+	struct parallel_data *pd;
+	struct parallel_data *opd;
+	struct list_head list;
+};
+
+struct padata_instance {
+	struct hlist_node cpu_online_node;
+	struct hlist_node cpu_dead_node;
+	struct workqueue_struct *parallel_wq;
+	struct workqueue_struct *serial_wq;
+	struct list_head pslist;
+	struct padata_cpumask cpumask;
+	struct kobject kobj;
+	struct mutex lock;
+	u8 flags;
+};
+
+struct padata_mt_job {
+	void (*thread_fn)(long unsigned int, long unsigned int, void *);
+	void *fn_arg;
+	long unsigned int start;
+	long unsigned int size;
+	long unsigned int align;
+	long unsigned int min_chunk;
+	int max_threads;
+	bool numa_aware;
+};
+
+struct padata_work {
+	struct work_struct pw_work;
+	struct list_head pw_list;
+	void *pw_data;
+};
+
+struct padata_mt_job_state {
+	spinlock_t lock;
+	struct completion completion;
+	struct padata_mt_job *job;
+	int nworks;
+	int nworks_fini;
+	long unsigned int chunk_size;
+};
+
+struct padata_sysfs_entry {
+	struct attribute attr;
+	ssize_t (*show)(struct padata_instance *, struct attribute *, char *);
+	ssize_t (*store)(struct padata_instance *, struct attribute *, const char *, size_t);
+};
+
+enum {
+	MEMREMAP_WB = 1,
+	MEMREMAP_WT = 2,
+	MEMREMAP_WC = 4,
+	MEMREMAP_ENC = 8,
+	MEMREMAP_DEC = 16,
+};
+
+struct trace_event_raw_oom_score_adj_update {
+	struct trace_entry ent;
+	pid_t pid;
+	char comm[16];
+	short int oom_score_adj;
+	char __data[0];
+};
+
+struct trace_event_raw_reclaim_retry_zone {
+	struct trace_entry ent;
+	int node;
+	int zone_idx;
+	int order;
+	long unsigned int reclaimable;
+	long unsigned int available;
+	long unsigned int min_wmark;
+	int no_progress_loops;
+	bool wmark_check;
+	char __data[0];
+};
+
+struct trace_event_raw_mark_victim {
+	struct trace_entry ent;
+	int pid;
+	u32 __data_loc_comm;
+	long unsigned int total_vm;
+	long unsigned int anon_rss;
+	long unsigned int file_rss;
+	long unsigned int shmem_rss;
+	uid_t uid;
+	long unsigned int pgtables;
+	short int oom_score_adj;
+	char __data[0];
+};
+
+struct trace_event_raw_wake_reaper {
+	struct trace_entry ent;
+	int pid;
+	char __data[0];
+};
+
+struct trace_event_raw_start_task_reaping {
+	struct trace_entry ent;
+	int pid;
+	char __data[0];
+};
+
+struct trace_event_raw_finish_task_reaping {
+	struct trace_entry ent;
+	int pid;
+	char __data[0];
+};
+
+struct trace_event_raw_skip_task_reaping {
+	struct trace_entry ent;
+	int pid;
+	char __data[0];
+};
+
+struct trace_event_raw_compact_retry {
+	struct trace_entry ent;
+	int order;
+	int priority;
+	int result;
+	int retries;
+	int max_retries;
+	bool ret;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_oom_score_adj_update {};
+
+struct trace_event_data_offsets_reclaim_retry_zone {};
+
+struct trace_event_data_offsets_mark_victim {
+	u32 comm;
+	const void *comm_ptr_;
+};
+
+struct trace_event_data_offsets_wake_reaper {};
+
+struct trace_event_data_offsets_start_task_reaping {};
+
+struct trace_event_data_offsets_finish_task_reaping {};
+
+struct trace_event_data_offsets_skip_task_reaping {};
+
+struct trace_event_data_offsets_compact_retry {};
+
+typedef void (*btf_trace_oom_score_adj_update)(void *, struct task_struct *);
+
+typedef void (*btf_trace_reclaim_retry_zone)(void *, struct zoneref *, int, long unsigned int, long unsigned int, long unsigned int, int, bool);
+
+typedef void (*btf_trace_mark_victim)(void *, struct task_struct *, uid_t);
+
+typedef void (*btf_trace_wake_reaper)(void *, int);
+
+typedef void (*btf_trace_start_task_reaping)(void *, int);
+
+typedef void (*btf_trace_finish_task_reaping)(void *, int);
+
+typedef void (*btf_trace_skip_task_reaping)(void *, int);
+
+typedef void (*btf_trace_compact_retry)(void *, int, enum compact_priority, enum compact_result, int, int, bool);
+
+struct shmem_quota_limits {
+	qsize_t usrquota_bhardlimit;
+	qsize_t usrquota_ihardlimit;
+	qsize_t grpquota_bhardlimit;
+	qsize_t grpquota_ihardlimit;
+};
+
+struct shmem_sb_info {
+	long unsigned int max_blocks;
+	long: 32;
+	struct percpu_counter used_blocks;
+	long unsigned int max_inodes;
+	long unsigned int free_ispace;
+	raw_spinlock_t stat_lock;
+	umode_t mode;
+	unsigned char huge;
+	kuid_t uid;
+	kgid_t gid;
+	bool full_inums;
+	bool noswap;
+	ino_t next_ino;
+	ino_t *ino_batch;
+	struct mempolicy *mpol;
+	spinlock_t shrinklist_lock;
+	struct list_head shrinklist;
+	long unsigned int shrinklist_len;
+	struct shmem_quota_limits qlimits;
+};
+
+enum sgp_type {
+	SGP_READ = 0,
+	SGP_NOALLOC = 1,
+	SGP_CACHE = 2,
+	SGP_WRITE = 3,
+	SGP_FALLOC = 4,
+};
+
+struct shmem_falloc {
+	wait_queue_head_t *waitq;
+	long unsigned int start;
+	long unsigned int next;
+	long unsigned int nr_falloced;
+	long unsigned int nr_unswapped;
+};
+
+struct shmem_options {
+	long long unsigned int blocks;
+	long long unsigned int inodes;
+	struct mempolicy *mpol;
+	kuid_t uid;
+	kgid_t gid;
+	umode_t mode;
+	bool full_inums;
+	int huge;
+	int seen;
+	bool noswap;
+	short unsigned int quota_types;
+	long: 32;
+	struct shmem_quota_limits qlimits;
+};
+
+enum shmem_param {
+	Opt_gid___2 = 0,
+	Opt_huge = 1,
+	Opt_mode___2 = 2,
+	Opt_mpol = 3,
+	Opt_nr_blocks = 4,
+	Opt_nr_inodes = 5,
+	Opt_size = 6,
+	Opt_uid___2 = 7,
+	Opt_inode32 = 8,
+	Opt_inode64 = 9,
+	Opt_noswap = 10,
+	Opt_quota = 11,
+	Opt_usrquota = 12,
+	Opt_grpquota = 13,
+	Opt_usrquota_block_hardlimit = 14,
+	Opt_usrquota_inode_hardlimit = 15,
+	Opt_grpquota_block_hardlimit = 16,
+	Opt_grpquota_inode_hardlimit = 17,
+};
+
+enum meminit_context {
+	MEMINIT_EARLY = 0,
+	MEMINIT_HOTPLUG = 1,
+};
+
+enum mminit_level {
+	MMINIT_WARNING = 0,
+	MMINIT_VERIFY = 1,
+	MMINIT_TRACE = 2,
+};
+
+enum {
+	FOLL_TOUCH = 65536,
+	FOLL_TRIED = 131072,
+	FOLL_REMOTE = 262144,
+	FOLL_PIN = 524288,
+	FOLL_FAST_ONLY = 1048576,
+	FOLL_UNLOCKABLE = 2097152,
+	FOLL_MADV_POPULATE = 4194304,
+};
+
+struct follow_page_context {
+	struct dev_pagemap *pgmap;
+	unsigned int page_mask;
+};
+
+struct pages_or_folios {
+	union {
+		struct page **pages;
+		struct folio **folios;
+		void **entries;
+	};
+	bool has_folios;
+	long int nr_entries;
+};
+
+typedef int fpi_t;
+
+struct swap_cgroup_ctrl {
+	struct page **map;
+	long unsigned int length;
+	spinlock_t lock;
+};
+
+struct swap_cgroup {
+	short unsigned int id;
+};
+
+struct open_how {
+	__u64 flags;
+	__u64 mode;
+	__u64 resolve;
+};
+
+struct saved {
+	struct path link;
+	struct delayed_call done;
+	const char *name;
+	unsigned int seq;
+};
+
+struct nameidata {
+	struct path path;
+	struct qstr last;
+	struct path root;
+	struct inode *inode;
+	unsigned int flags;
+	unsigned int state;
+	unsigned int seq;
+	unsigned int next_seq;
+	unsigned int m_seq;
+	unsigned int r_seq;
+	int last_type;
+	unsigned int depth;
+	int total_link_count;
+	struct saved *stack;
+	struct saved internal[2];
+	struct filename *name;
+	struct nameidata *saved;
+	unsigned int root_seq;
+	int dfd;
+	vfsuid_t dir_vfsuid;
+	umode_t dir_mode;
+	long: 32;
+};
+
+enum {
+	LAST_NORM = 0,
+	LAST_ROOT = 1,
+	LAST_DOT = 2,
+	LAST_DOTDOT = 3,
+};
+
+enum {
+	WALK_TRAILING = 1,
+	WALK_MORE = 2,
+	WALK_NOFOLLOW = 4,
+};
+
+struct word_at_a_time {
+	const long unsigned int one_bits;
+	const long unsigned int high_bits;
+};
+
+struct splice_desc {
+	size_t total_len;
+	unsigned int len;
+	unsigned int flags;
+	union {
+		void *userptr;
+		struct file *file;
+		void *data;
+	} u;
+	void (*splice_eof)(struct splice_desc *);
+	long: 32;
+	loff_t pos;
+	loff_t *opos;
+	size_t num_spliced;
+	bool need_wakeup;
+	long: 32;
+};
+
+typedef int splice_actor(struct pipe_inode_info *, struct pipe_buffer *, struct splice_desc *);
+
+typedef int splice_direct_actor(struct pipe_inode_info *, struct splice_desc *);
+
+typedef int __kernel_daddr_t;
+
+struct ustat {
+	__kernel_daddr_t f_tfree;
+	long unsigned int f_tinode;
+	char f_fname[6];
+	char f_fpack[6];
+};
+
+struct statfs {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u32 f_blocks;
+	__u32 f_bfree;
+	__u32 f_bavail;
+	__u32 f_files;
+	__u32 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_flags;
+	__u32 f_spare[4];
+};
+
+struct statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_flags;
+	__u32 f_spare[4];
+};
+
+struct mnt_idmap {
+	struct uid_gid_map uid_map;
+	struct uid_gid_map gid_map;
+	refcount_t count;
+};
+
+struct mpage_readpage_args {
+	struct bio *bio;
+	struct folio *folio;
+	unsigned int nr_pages;
+	bool is_readahead;
+	sector_t last_block_in_bio;
+	struct buffer_head map_bh;
+	long unsigned int first_logical_block;
+	get_block_t *get_block;
+};
+
+struct mpage_data {
+	struct bio *bio;
+	long: 32;
+	sector_t last_block_in_bio;
+	get_block_t *get_block;
+	long: 32;
+};
+
+struct inotify_event_info {
+	struct fsnotify_event fse;
+	u32 mask;
+	int wd;
+	u32 sync_cookie;
+	int name_len;
+	char name[0];
+};
+
+struct inotify_event {
+	__s32 wd;
+	__u32 mask;
+	__u32 cookie;
+	__u32 len;
+	char name[0];
+};
+
+struct timerfd_ctx {
+	union {
+		struct hrtimer tmr;
+		struct alarm alarm;
+	} t;
+	ktime_t tintv;
+	ktime_t moffs;
+	wait_queue_head_t wqh;
+	long: 32;
+	u64 ticks;
+	int clockid;
+	short unsigned int expired;
+	short unsigned int settime_flags;
+	struct callback_head rcu;
+	struct list_head clist;
+	spinlock_t cancel_lock;
+	bool might_cancel;
+};
+
+struct srcu_notifier_head {
+	struct mutex mutex;
+	struct srcu_usage srcuu;
+	struct srcu_struct srcu;
+	struct notifier_block *head;
+};
+
+struct trace_event_raw_locks_get_lock_context {
+	struct trace_entry ent;
+	long unsigned int i_ino;
+	dev_t s_dev;
+	unsigned char type;
+	struct file_lock_context *ctx;
+	char __data[0];
+};
+
+struct trace_event_raw_filelock_lock {
+	struct trace_entry ent;
+	struct file_lock *fl;
+	long unsigned int i_ino;
+	dev_t s_dev;
+	struct file_lock_core *blocker;
+	fl_owner_t owner;
+	unsigned int pid;
+	unsigned int flags;
+	unsigned char type;
+	loff_t fl_start;
+	loff_t fl_end;
+	int ret;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_filelock_lease {
+	struct trace_entry ent;
+	struct file_lease *fl;
+	long unsigned int i_ino;
+	dev_t s_dev;
+	struct file_lock_core *blocker;
+	fl_owner_t owner;
+	unsigned int flags;
+	unsigned char type;
+	long unsigned int break_time;
+	long unsigned int downgrade_time;
+	char __data[0];
+};
+
+struct trace_event_raw_generic_add_lease {
+	struct trace_entry ent;
+	long unsigned int i_ino;
+	int wcount;
+	int rcount;
+	int icount;
+	dev_t s_dev;
+	fl_owner_t owner;
+	unsigned int flags;
+	unsigned char type;
+	char __data[0];
+};
+
+struct trace_event_raw_leases_conflict {
+	struct trace_entry ent;
+	void *lease;
+	void *breaker;
+	unsigned int l_fl_flags;
+	unsigned int b_fl_flags;
+	unsigned char l_fl_type;
+	unsigned char b_fl_type;
+	bool conflict;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_locks_get_lock_context {};
+
+struct trace_event_data_offsets_filelock_lock {};
+
+struct trace_event_data_offsets_filelock_lease {};
+
+struct trace_event_data_offsets_generic_add_lease {};
+
+struct trace_event_data_offsets_leases_conflict {};
+
+typedef void (*btf_trace_locks_get_lock_context)(void *, struct inode *, int, struct file_lock_context *);
+
+typedef void (*btf_trace_posix_lock_inode)(void *, struct inode *, struct file_lock *, int);
+
+typedef void (*btf_trace_fcntl_setlk)(void *, struct inode *, struct file_lock *, int);
+
+typedef void (*btf_trace_locks_remove_posix)(void *, struct inode *, struct file_lock *, int);
+
+typedef void (*btf_trace_flock_lock_inode)(void *, struct inode *, struct file_lock *, int);
+
+typedef void (*btf_trace_break_lease_noblock)(void *, struct inode *, struct file_lease *);
+
+typedef void (*btf_trace_break_lease_block)(void *, struct inode *, struct file_lease *);
+
+typedef void (*btf_trace_break_lease_unblock)(void *, struct inode *, struct file_lease *);
+
+typedef void (*btf_trace_generic_delete_lease)(void *, struct inode *, struct file_lease *);
+
+typedef void (*btf_trace_time_out_leases)(void *, struct inode *, struct file_lease *);
+
+typedef void (*btf_trace_generic_add_lease)(void *, struct inode *, struct file_lease *);
+
+typedef void (*btf_trace_leases_conflict)(void *, bool, struct file_lease *, struct file_lease *);
+
+struct file_lock_list_struct {
+	spinlock_t lock;
+	struct hlist_head hlist;
+};
+
+struct locks_iterator {
+	int li_cpu;
+	long: 32;
+	loff_t li_pos;
+};
+
+enum nfs_stat {
+	NFS_OK = 0,
+	NFSERR_PERM = 1,
+	NFSERR_NOENT = 2,
+	NFSERR_IO = 5,
+	NFSERR_NXIO = 6,
+	NFSERR_EAGAIN = 11,
+	NFSERR_ACCES = 13,
+	NFSERR_EXIST = 17,
+	NFSERR_XDEV = 18,
+	NFSERR_NODEV = 19,
+	NFSERR_NOTDIR = 20,
+	NFSERR_ISDIR = 21,
+	NFSERR_INVAL = 22,
+	NFSERR_FBIG = 27,
+	NFSERR_NOSPC = 28,
+	NFSERR_ROFS = 30,
+	NFSERR_MLINK = 31,
+	NFSERR_NAMETOOLONG = 63,
+	NFSERR_NOTEMPTY = 66,
+	NFSERR_DQUOT = 69,
+	NFSERR_STALE = 70,
+	NFSERR_REMOTE = 71,
+	NFSERR_WFLUSH = 99,
+	NFSERR_BADHANDLE = 10001,
+	NFSERR_NOT_SYNC = 10002,
+	NFSERR_BAD_COOKIE = 10003,
+	NFSERR_NOTSUPP = 10004,
+	NFSERR_TOOSMALL = 10005,
+	NFSERR_SERVERFAULT = 10006,
+	NFSERR_BADTYPE = 10007,
+	NFSERR_JUKEBOX = 10008,
+	NFSERR_SAME = 10009,
+	NFSERR_DENIED = 10010,
+	NFSERR_EXPIRED = 10011,
+	NFSERR_LOCKED = 10012,
+	NFSERR_GRACE = 10013,
+	NFSERR_FHEXPIRED = 10014,
+	NFSERR_SHARE_DENIED = 10015,
+	NFSERR_WRONGSEC = 10016,
+	NFSERR_CLID_INUSE = 10017,
+	NFSERR_RESOURCE = 10018,
+	NFSERR_MOVED = 10019,
+	NFSERR_NOFILEHANDLE = 10020,
+	NFSERR_MINOR_VERS_MISMATCH = 10021,
+	NFSERR_STALE_CLIENTID = 10022,
+	NFSERR_STALE_STATEID = 10023,
+	NFSERR_OLD_STATEID = 10024,
+	NFSERR_BAD_STATEID = 10025,
+	NFSERR_BAD_SEQID = 10026,
+	NFSERR_NOT_SAME = 10027,
+	NFSERR_LOCK_RANGE = 10028,
+	NFSERR_SYMLINK = 10029,
+	NFSERR_RESTOREFH = 10030,
+	NFSERR_LEASE_MOVED = 10031,
+	NFSERR_ATTRNOTSUPP = 10032,
+	NFSERR_NO_GRACE = 10033,
+	NFSERR_RECLAIM_BAD = 10034,
+	NFSERR_RECLAIM_CONFLICT = 10035,
+	NFSERR_BAD_XDR = 10036,
+	NFSERR_LOCKS_HELD = 10037,
+	NFSERR_OPENMODE = 10038,
+	NFSERR_BADOWNER = 10039,
+	NFSERR_BADCHAR = 10040,
+	NFSERR_BADNAME = 10041,
+	NFSERR_BAD_RANGE = 10042,
+	NFSERR_LOCK_NOTSUPP = 10043,
+	NFSERR_OP_ILLEGAL = 10044,
+	NFSERR_DEADLOCK = 10045,
+	NFSERR_FILE_OPEN = 10046,
+	NFSERR_ADMIN_REVOKED = 10047,
+	NFSERR_CB_PATH_DOWN = 10048,
+};
+
+enum nfsstat4 {
+	NFS4_OK = 0,
+	NFS4ERR_PERM = 1,
+	NFS4ERR_NOENT = 2,
+	NFS4ERR_IO = 5,
+	NFS4ERR_NXIO = 6,
+	NFS4ERR_ACCESS = 13,
+	NFS4ERR_EXIST = 17,
+	NFS4ERR_XDEV = 18,
+	NFS4ERR_NOTDIR = 20,
+	NFS4ERR_ISDIR = 21,
+	NFS4ERR_INVAL = 22,
+	NFS4ERR_FBIG = 27,
+	NFS4ERR_NOSPC = 28,
+	NFS4ERR_ROFS = 30,
+	NFS4ERR_MLINK = 31,
+	NFS4ERR_NAMETOOLONG = 63,
+	NFS4ERR_NOTEMPTY = 66,
+	NFS4ERR_DQUOT = 69,
+	NFS4ERR_STALE = 70,
+	NFS4ERR_BADHANDLE = 10001,
+	NFS4ERR_BAD_COOKIE = 10003,
+	NFS4ERR_NOTSUPP = 10004,
+	NFS4ERR_TOOSMALL = 10005,
+	NFS4ERR_SERVERFAULT = 10006,
+	NFS4ERR_BADTYPE = 10007,
+	NFS4ERR_DELAY = 10008,
+	NFS4ERR_SAME = 10009,
+	NFS4ERR_DENIED = 10010,
+	NFS4ERR_EXPIRED = 10011,
+	NFS4ERR_LOCKED = 10012,
+	NFS4ERR_GRACE = 10013,
+	NFS4ERR_FHEXPIRED = 10014,
+	NFS4ERR_SHARE_DENIED = 10015,
+	NFS4ERR_WRONGSEC = 10016,
+	NFS4ERR_CLID_INUSE = 10017,
+	NFS4ERR_RESOURCE = 10018,
+	NFS4ERR_MOVED = 10019,
+	NFS4ERR_NOFILEHANDLE = 10020,
+	NFS4ERR_MINOR_VERS_MISMATCH = 10021,
+	NFS4ERR_STALE_CLIENTID = 10022,
+	NFS4ERR_STALE_STATEID = 10023,
+	NFS4ERR_OLD_STATEID = 10024,
+	NFS4ERR_BAD_STATEID = 10025,
+	NFS4ERR_BAD_SEQID = 10026,
+	NFS4ERR_NOT_SAME = 10027,
+	NFS4ERR_LOCK_RANGE = 10028,
+	NFS4ERR_SYMLINK = 10029,
+	NFS4ERR_RESTOREFH = 10030,
+	NFS4ERR_LEASE_MOVED = 10031,
+	NFS4ERR_ATTRNOTSUPP = 10032,
+	NFS4ERR_NO_GRACE = 10033,
+	NFS4ERR_RECLAIM_BAD = 10034,
+	NFS4ERR_RECLAIM_CONFLICT = 10035,
+	NFS4ERR_BADXDR = 10036,
+	NFS4ERR_LOCKS_HELD = 10037,
+	NFS4ERR_OPENMODE = 10038,
+	NFS4ERR_BADOWNER = 10039,
+	NFS4ERR_BADCHAR = 10040,
+	NFS4ERR_BADNAME = 10041,
+	NFS4ERR_BAD_RANGE = 10042,
+	NFS4ERR_LOCK_NOTSUPP = 10043,
+	NFS4ERR_OP_ILLEGAL = 10044,
+	NFS4ERR_DEADLOCK = 10045,
+	NFS4ERR_FILE_OPEN = 10046,
+	NFS4ERR_ADMIN_REVOKED = 10047,
+	NFS4ERR_CB_PATH_DOWN = 10048,
+	NFS4ERR_BADIOMODE = 10049,
+	NFS4ERR_BADLAYOUT = 10050,
+	NFS4ERR_BAD_SESSION_DIGEST = 10051,
+	NFS4ERR_BADSESSION = 10052,
+	NFS4ERR_BADSLOT = 10053,
+	NFS4ERR_COMPLETE_ALREADY = 10054,
+	NFS4ERR_CONN_NOT_BOUND_TO_SESSION = 10055,
+	NFS4ERR_DELEG_ALREADY_WANTED = 10056,
+	NFS4ERR_BACK_CHAN_BUSY = 10057,
+	NFS4ERR_LAYOUTTRYLATER = 10058,
+	NFS4ERR_LAYOUTUNAVAILABLE = 10059,
+	NFS4ERR_NOMATCHING_LAYOUT = 10060,
+	NFS4ERR_RECALLCONFLICT = 10061,
+	NFS4ERR_UNKNOWN_LAYOUTTYPE = 10062,
+	NFS4ERR_SEQ_MISORDERED = 10063,
+	NFS4ERR_SEQUENCE_POS = 10064,
+	NFS4ERR_REQ_TOO_BIG = 10065,
+	NFS4ERR_REP_TOO_BIG = 10066,
+	NFS4ERR_REP_TOO_BIG_TO_CACHE = 10067,
+	NFS4ERR_RETRY_UNCACHED_REP = 10068,
+	NFS4ERR_UNSAFE_COMPOUND = 10069,
+	NFS4ERR_TOO_MANY_OPS = 10070,
+	NFS4ERR_OP_NOT_IN_SESSION = 10071,
+	NFS4ERR_HASH_ALG_UNSUPP = 10072,
+	NFS4ERR_CLIENTID_BUSY = 10074,
+	NFS4ERR_PNFS_IO_HOLE = 10075,
+	NFS4ERR_SEQ_FALSE_RETRY = 10076,
+	NFS4ERR_BAD_HIGH_SLOT = 10077,
+	NFS4ERR_DEADSESSION = 10078,
+	NFS4ERR_ENCR_ALG_UNSUPP = 10079,
+	NFS4ERR_PNFS_NO_LAYOUT = 10080,
+	NFS4ERR_NOT_ONLY_OP = 10081,
+	NFS4ERR_WRONG_CRED = 10082,
+	NFS4ERR_WRONG_TYPE = 10083,
+	NFS4ERR_DIRDELEG_UNAVAIL = 10084,
+	NFS4ERR_REJECT_DELEG = 10085,
+	NFS4ERR_RETURNCONFLICT = 10086,
+	NFS4ERR_DELEG_REVOKED = 10087,
+	NFS4ERR_PARTNER_NOTSUPP = 10088,
+	NFS4ERR_PARTNER_NO_AUTH = 10089,
+	NFS4ERR_UNION_NOTSUPP = 10090,
+	NFS4ERR_OFFLOAD_DENIED = 10091,
+	NFS4ERR_WRONG_LFS = 10092,
+	NFS4ERR_BADLABEL = 10093,
+	NFS4ERR_OFFLOAD_NO_REQS = 10094,
+	NFS4ERR_NOXATTR = 10095,
+	NFS4ERR_XATTR2BIG = 10096,
+	NFS4ERR_FIRST_FREE = 10097,
+};
+
+struct core_name {
+	char *corename;
+	int used;
+	int size;
+};
+
+enum procmap_query_flags {
+	PROCMAP_QUERY_VMA_READABLE = 1,
+	PROCMAP_QUERY_VMA_WRITABLE = 2,
+	PROCMAP_QUERY_VMA_EXECUTABLE = 4,
+	PROCMAP_QUERY_VMA_SHARED = 8,
+	PROCMAP_QUERY_COVERING_OR_NEXT_VMA = 16,
+	PROCMAP_QUERY_FILE_BACKED_VMA = 32,
+};
+
+struct procmap_query {
+	__u64 size;
+	__u64 query_flags;
+	__u64 query_addr;
+	__u64 vma_start;
+	__u64 vma_end;
+	__u64 vma_flags;
+	__u64 vma_page_size;
+	__u64 vma_offset;
+	__u64 inode;
+	__u32 dev_major;
+	__u32 dev_minor;
+	__u32 vma_name_size;
+	__u32 build_id_size;
+	__u64 vma_name_addr;
+	__u64 build_id_addr;
+};
+
+struct proc_maps_private {
+	struct inode *inode;
+	struct task_struct *task;
+	struct mm_struct *mm;
+	struct vma_iterator iter;
+};
+
+struct ramfs_mount_opts {
+	umode_t mode;
+};
+
+struct ramfs_fs_info {
+	struct ramfs_mount_opts mount_opts;
+};
+
+enum ramfs_param {
+	Opt_mode___3 = 0,
+};
+
+struct jffs2_tmp_dnode_info {
+	struct rb_node rb;
+	struct jffs2_full_dnode *fn;
+	uint32_t version;
+	uint32_t data_crc;
+	uint32_t partial_crc;
+	uint32_t csize;
+	uint16_t overlapped;
+};
+
+struct jffs2_inodirty {
+	uint32_t ino;
+	struct jffs2_inodirty *next;
+};
+
+struct ubifs_data_node {
+	struct ubifs_ch ch;
+	__u8 key[16];
+	__le32 size;
+	__le16 compr_type;
+	__le16 compr_size;
+	__u8 data[0];
+};
+
+enum {
+	UBIFS_NO_NODE_GROUP = 0,
+	UBIFS_IN_NODE_GROUP = 1,
+	UBIFS_LAST_OF_NODE_GROUP = 2,
+};
+
+struct ubifs_pad_node {
+	struct ubifs_ch ch;
+	__le32 pad_len;
+};
+
+struct ubifs_trun_node {
+	struct ubifs_ch ch;
+	__le32 inum;
+	__u8 padding[12];
+	__le64 old_size;
+	__le64 new_size;
+};
+
+struct ubifs_auth_node {
+	struct ubifs_ch ch;
+	__u8 hmac[0];
+};
+
+struct replay_entry {
+	int lnum;
+	int offs;
+	int len;
+	u8 hash[0];
+	unsigned int deletion: 1;
+	long long unsigned int sqnum;
+	struct list_head list;
+	union ubifs_key key;
+	union {
+		struct fscrypt_name nm;
+		struct {
+			loff_t old_size;
+			loff_t new_size;
+		};
+	};
+};
+
+struct bud_entry {
+	struct list_head list;
+	struct ubifs_bud *bud;
+	long: 32;
+	long long unsigned int sqnum;
+	int free;
+	int dirty;
+};
+
+struct ubifs_orph_node {
+	struct ubifs_ch ch;
+	__le64 cmt_no;
+	__le64 inos[0];
+};
+
+typedef int (*dbg_leaf_callback)(struct ubifs_info *, struct ubifs_zbranch *, void *);
+
+typedef int (*dbg_znode_callback)(struct ubifs_info *, struct ubifs_znode *, void *);
+
+struct check_orphan {
+	struct rb_node rb;
+	ino_t inum;
+};
+
+struct check_info {
+	long unsigned int last_ino;
+	long unsigned int tot_inos;
+	long unsigned int missing;
+	long: 32;
+	long long unsigned int leaf_cnt;
+	struct ubifs_ino_node *node;
+	struct rb_root root;
+};
+
+enum {
+	OVL_REDIRECT_OFF = 0,
+	OVL_REDIRECT_FOLLOW = 1,
+	OVL_REDIRECT_NOFOLLOW = 2,
+	OVL_REDIRECT_ON = 3,
+};
+
+struct ovl_opt_set {
+	bool metacopy;
+	bool redirect;
+	bool nfs_export;
+	bool index;
+};
+
+struct ovl_fs_context_layer {
+	char *name;
+	struct path path;
+};
+
+struct ovl_fs_context {
+	struct path upper;
+	struct path work;
+	size_t capacity;
+	size_t nr;
+	size_t nr_data;
+	struct ovl_opt_set set;
+	struct ovl_fs_context_layer *lower;
+	char *lowerdir_all;
+};
+
+enum ovl_opt {
+	Opt_lowerdir = 0,
+	Opt_lowerdir_add = 1,
+	Opt_datadir_add = 2,
+	Opt_upperdir = 3,
+	Opt_workdir = 4,
+	Opt_default_permissions = 5,
+	Opt_redirect_dir = 6,
+	Opt_index = 7,
+	Opt_uuid = 8,
+	Opt_nfs_export = 9,
+	Opt_userxattr = 10,
+	Opt_xino = 11,
+	Opt_metacopy = 12,
+	Opt_verity = 13,
+	Opt_volatile = 14,
+};
+
+typedef int (*eventfs_callback)(const char *, umode_t *, void **, const struct file_operations **);
+
+typedef void (*eventfs_release)(const char *, void *);
+
+struct eventfs_entry {
+	const char *name;
+	eventfs_callback callback;
+	eventfs_release release;
+};
+
+enum {
+	TRACEFS_EVENT_INODE = 2,
+	TRACEFS_GID_PERM_SET = 4,
+	TRACEFS_UID_PERM_SET = 8,
+	TRACEFS_INSTANCE_INODE = 16,
+};
+
+struct tracefs_inode {
+	struct inode vfs_inode;
+	struct list_head list;
+	long unsigned int flags;
+	void *private;
+};
+
+struct eventfs_attr {
+	int mode;
+	kuid_t uid;
+	kgid_t gid;
+};
+
+struct eventfs_inode {
+	union {
+		struct list_head list;
+		struct callback_head rcu;
+	};
+	struct list_head children;
+	const struct eventfs_entry *entries;
+	const char *name;
+	struct eventfs_attr *entry_attrs;
+	void *data;
+	struct eventfs_attr attr;
+	struct kref kref;
+	unsigned int is_freed: 1;
+	unsigned int is_events: 1;
+	unsigned int nr_entries: 30;
+	unsigned int ino;
+};
+
+struct eventfs_root_inode {
+	struct eventfs_inode ei;
+	struct dentry *events_dir;
+};
+
+enum {
+	EVENTFS_SAVE_MODE = 65536,
+	EVENTFS_SAVE_UID = 131072,
+	EVENTFS_SAVE_GID = 262144,
+};
+
+struct sem;
+
+struct sem_queue;
+
+struct sem_undo;
+
+struct semid_ds {
+	struct ipc_perm sem_perm;
+	__kernel_old_time_t sem_otime;
+	__kernel_old_time_t sem_ctime;
+	struct sem *sem_base;
+	struct sem_queue *sem_pending;
+	struct sem_queue **sem_pending_last;
+	struct sem_undo *undo;
+	short unsigned int sem_nsems;
+};
+
+struct sem {
+	int semval;
+	struct pid *sempid;
+	spinlock_t lock;
+	struct list_head pending_alter;
+	struct list_head pending_const;
+	long: 32;
+	time64_t sem_otime;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct sembuf;
+
+struct sem_queue {
+	struct list_head list;
+	struct task_struct *sleeper;
+	struct sem_undo *undo;
+	struct pid *pid;
+	int status;
+	struct sembuf *sops;
+	struct sembuf *blocking;
+	int nsops;
+	bool alter;
+	bool dupsop;
+};
+
+struct sem_undo {
+	struct list_head list_proc;
+	struct callback_head rcu;
+	struct sem_undo_list *ulp;
+	struct list_head list_id;
+	int semid;
+	short int semadj[0];
+};
+
+struct semid64_ds {
+	struct ipc64_perm sem_perm;
+	long unsigned int sem_otime;
+	long unsigned int sem_otime_high;
+	long unsigned int sem_ctime;
+	long unsigned int sem_ctime_high;
+	long unsigned int sem_nsems;
+	long unsigned int __unused3;
+	long unsigned int __unused4;
+};
+
+struct sembuf {
+	short unsigned int sem_num;
+	short int sem_op;
+	short int sem_flg;
+};
+
+struct seminfo {
+	int semmap;
+	int semmni;
+	int semmns;
+	int semmnu;
+	int semmsl;
+	int semopm;
+	int semume;
+	int semusz;
+	int semvmx;
+	int semaem;
+};
+
+struct sem_undo_list {
+	refcount_t refcnt;
+	spinlock_t lock;
+	struct list_head list_proc;
+};
+
+struct sem_array {
+	struct kern_ipc_perm sem_perm;
+	time64_t sem_ctime;
+	struct list_head pending_alter;
+	struct list_head pending_const;
+	struct list_head list_id;
+	int sem_nsems;
+	int complex_count;
+	unsigned int use_global_lock;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct sem sems[0];
+};
+
+struct lskcipher_instance {
+	void (*free)(struct lskcipher_instance *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct {
+			char head[128];
+			struct crypto_instance base;
+		} s;
+		struct lskcipher_alg alg;
+	};
+};
+
+struct crypto_lskcipher_spawn {
+	struct crypto_spawn base;
+};
+
+struct akcipher_instance {
+	void (*free)(struct akcipher_instance *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct {
+			char head[64];
+			struct crypto_instance base;
+		} s;
+		struct akcipher_alg alg;
+	};
+};
+
+struct crypto_akcipher_spawn {
+	struct crypto_spawn base;
+};
+
+struct cryptomgr_param {
+	struct rtattr *tb[34];
+	struct {
+		struct rtattr attr;
+		struct crypto_attr_type data;
+	} type;
+	struct {
+		struct rtattr attr;
+		struct crypto_attr_alg data;
+	} attrs[32];
+	char template[128];
+	struct crypto_larval *larval;
+	u32 otype;
+	u32 omask;
+};
+
+struct crypto_test_param {
+	char driver[128];
+	char alg[128];
+	u32 type;
+};
+
+struct pcrypt_request {
+	struct padata_priv padata;
+	void *data;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	void *__ctx[0];
+};
+
+struct pcrypt_instance_ctx {
+	struct crypto_aead_spawn spawn;
+	struct padata_shell *psenc;
+	struct padata_shell *psdec;
+	atomic_t tfm_count;
+};
+
+struct pcrypt_aead_ctx {
+	struct crypto_aead *child;
+	unsigned int cb_cpu;
+};
+
+struct internal_state {
+	int dummy;
+};
+
+struct deflate_ctx {
+	struct z_stream_s comp_stream;
+	struct z_stream_s decomp_stream;
+};
+
+typedef unsigned char u8___2;
+
+struct rand_data {
+	void *hash_state;
+	long: 32;
+	__u64 prev_time;
+	__u64 last_delta;
+	__s64 last_delta2;
+	unsigned int flags;
+	unsigned int osr;
+	unsigned char *mem;
+	unsigned int memlocation;
+	unsigned int memblocks;
+	unsigned int memblocksize;
+	unsigned int memaccessloops;
+	unsigned int rct_count;
+	unsigned int apt_cutoff;
+	unsigned int apt_cutoff_permanent;
+	unsigned int apt_observations;
+	unsigned int apt_count;
+	unsigned int apt_base;
+	unsigned int health_failure;
+	unsigned int apt_base_set: 1;
+	long: 32;
+};
+
+struct crypto_rng;
+
+struct rng_alg {
+	int (*generate)(struct crypto_rng *, const u8 *, unsigned int, u8 *, unsigned int);
+	int (*seed)(struct crypto_rng *, const u8 *, unsigned int);
+	void (*set_ent)(struct crypto_rng *, const u8 *, unsigned int);
+	unsigned int seedsize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_alg base;
+};
+
+struct crypto_rng {
+	struct crypto_tfm base;
+};
+
+struct jitterentropy {
+	spinlock_t jent_lock;
+	struct rand_data *entropy_collector;
+	struct crypto_shash *tfm;
+	struct shash_desc *sdesc;
+};
+
+enum {
+	DISK_EVENT_MEDIA_CHANGE = 1,
+	DISK_EVENT_EJECT_REQUEST = 2,
+};
+
+enum {
+	DISK_EVENT_FLAG_POLL = 1,
+	DISK_EVENT_FLAG_UEVENT = 2,
+	DISK_EVENT_FLAG_BLOCK_ON_EXCL_WRITE = 4,
+};
+
+struct bdev_inode {
+	struct block_device bdev;
+	struct inode vfs_inode;
+};
+
+struct queue_sysfs_entry {
+	struct attribute attr;
+	ssize_t (*show)(struct gendisk *, char *);
+	int (*load_module)(struct gendisk *, const char *, size_t);
+	ssize_t (*store)(struct gendisk *, const char *, size_t);
+};
+
+enum blk_default_limits {
+	BLK_MAX_SEGMENTS = 128,
+	BLK_SAFE_MAX_SECTORS = 255,
+	BLK_MAX_SEGMENT_SIZE = 65536,
+	BLK_SEG_BOUNDARY_MASK = 4294967295,
+};
+
+enum blk_integrity_flags {
+	BLK_INTEGRITY_NOVERIFY = 1,
+	BLK_INTEGRITY_NOGENERATE = 2,
+	BLK_INTEGRITY_DEVICE_CAPABLE = 4,
+	BLK_INTEGRITY_REF_TAG = 8,
+	BLK_INTEGRITY_STACKED = 16,
+};
+
+enum xen_domain_type {
+	XEN_NATIVE = 0,
+	XEN_PV_DOMAIN = 1,
+	XEN_HVM_DOMAIN = 2,
+};
+
+enum bio_merge_status {
+	BIO_MERGE_OK = 0,
+	BIO_MERGE_NONE = 1,
+	BIO_MERGE_FAILED = 2,
+};
+
+struct sbq_wait {
+	struct sbitmap_queue *sbq;
+	struct wait_queue_entry wait;
+};
+
+enum {
+	BLK_TAG_ALLOC_FIFO = 0,
+	BLK_TAG_ALLOC_RR = 1,
+	BLK_TAG_ALLOC_MAX = 2,
+};
+
+struct bt_iter_data {
+	struct blk_mq_hw_ctx *hctx;
+	struct request_queue *q;
+	busy_tag_iter_fn *fn;
+	void *data;
+	bool reserved;
+};
+
+struct bt_tags_iter_data {
+	struct blk_mq_tags *tags;
+	busy_tag_iter_fn *fn;
+	void *data;
+	unsigned int flags;
+};
+
+struct blkpg_ioctl_arg {
+	int op;
+	int flags;
+	int datalen;
+	void *data;
+};
+
+struct blkpg_partition {
+	long long int start;
+	long long int length;
+	int pno;
+	char devname[64];
+	char volname[64];
+	long: 32;
+};
+
+struct pr_reservation {
+	__u64 key;
+	__u32 type;
+	__u32 flags;
+};
+
+struct pr_registration {
+	__u64 old_key;
+	__u64 new_key;
+	__u32 flags;
+	__u32 __pad;
+};
+
+struct pr_preempt {
+	__u64 old_key;
+	__u64 new_key;
+	__u32 type;
+	__u32 flags;
+};
+
+struct pr_clear {
+	__u64 key;
+	__u32 flags;
+	__u32 __pad;
+};
+
+struct pr_keys {
+	u32 generation;
+	u32 num_keys;
+	u64 keys[0];
+};
+
+struct pr_held_reservation {
+	u64 key;
+	u32 generation;
+	enum pr_type type;
+};
+
+enum {
+	IOU_F_TWQ_LAZY_WAKE = 1,
+};
+
+enum io_uring_cmd_flags {
+	IO_URING_F_COMPLETE_DEFER = 1,
+	IO_URING_F_UNLOCKED = 2,
+	IO_URING_F_MULTISHOT = 4,
+	IO_URING_F_IOWQ = 8,
+	IO_URING_F_NONBLOCK = -2147483648,
+	IO_URING_F_SQE128 = 256,
+	IO_URING_F_CQE32 = 512,
+	IO_URING_F_IOPOLL = 1024,
+	IO_URING_F_CANCEL = 2048,
+	IO_URING_F_COMPAT = 4096,
+};
+
+struct blk_iou_cmd {
+	int res;
+	bool nowait;
+};
+
+struct badblocks_context {
+	sector_t start;
+	sector_t len;
+	int ack;
+	long: 32;
+};
+
+typedef guid_t efi_guid_t;
+
+struct _gpt_header {
+	__le64 signature;
+	__le32 revision;
+	__le32 header_size;
+	__le32 header_crc32;
+	__le32 reserved1;
+	__le64 my_lba;
+	__le64 alternate_lba;
+	__le64 first_usable_lba;
+	__le64 last_usable_lba;
+	efi_guid_t disk_guid;
+	__le64 partition_entry_lba;
+	__le32 num_partition_entries;
+	__le32 sizeof_partition_entry;
+	__le32 partition_entry_array_crc32;
+};
+
+typedef struct _gpt_header gpt_header;
+
+struct _gpt_entry_attributes {
+	u64 required_to_function: 1;
+	u64 reserved: 47;
+	u64 type_guid_specific: 16;
+};
+
+typedef struct _gpt_entry_attributes gpt_entry_attributes;
+
+struct _gpt_entry {
+	efi_guid_t partition_type_guid;
+	efi_guid_t unique_partition_guid;
+	__le64 starting_lba;
+	__le64 ending_lba;
+	gpt_entry_attributes attributes;
+	__le16 partition_name[36];
+};
+
+typedef struct _gpt_entry gpt_entry;
+
+struct _gpt_mbr_record {
+	u8 boot_indicator;
+	u8 start_head;
+	u8 start_sector;
+	u8 start_track;
+	u8 os_type;
+	u8 end_head;
+	u8 end_sector;
+	u8 end_track;
+	__le32 starting_lba;
+	__le32 size_in_lba;
+};
+
+typedef struct _gpt_mbr_record gpt_mbr_record;
+
+struct _legacy_mbr {
+	u8 boot_code[440];
+	__le32 unique_mbr_signature;
+	__le16 unknown;
+	gpt_mbr_record partition_record[4];
+	__le16 signature;
+} __attribute__((packed));
+
+typedef struct _legacy_mbr legacy_mbr;
+
+struct blk_ia_range_sysfs_entry {
+	struct attribute attr;
+	ssize_t (*show)(struct blk_independent_access_range *, char *);
+};
+
+struct sg_io_v4 {
+	__s32 guard;
+	__u32 protocol;
+	__u32 subprotocol;
+	__u32 request_len;
+	__u64 request;
+	__u64 request_tag;
+	__u32 request_attr;
+	__u32 request_priority;
+	__u32 request_extra;
+	__u32 max_response_len;
+	__u64 response;
+	__u32 dout_iovec_count;
+	__u32 dout_xfer_len;
+	__u32 din_iovec_count;
+	__u32 din_xfer_len;
+	__u64 dout_xferp;
+	__u64 din_xferp;
+	__u32 timeout;
+	__u32 flags;
+	__u64 usr_ptr;
+	__u32 spare_in;
+	__u32 driver_status;
+	__u32 transport_status;
+	__u32 device_status;
+	__u32 retry_delay;
+	__u32 info;
+	__u32 duration;
+	__u32 response_len;
+	__s32 din_resid;
+	__s32 dout_resid;
+	__u64 generated_tag;
+	__u32 spare_out;
+	__u32 padding;
+};
+
+typedef int bsg_sg_io_fn(struct request_queue *, struct sg_io_v4 *, bool, unsigned int);
+
+struct rq_map_data {
+	struct page **pages;
+	long unsigned int offset;
+	short unsigned int page_order;
+	short unsigned int nr_entries;
+	bool null_mapped;
+	bool from_user;
+};
+
+struct bsg_job;
+
+typedef int bsg_job_fn(struct bsg_job *);
+
+struct bsg_buffer {
+	unsigned int payload_len;
+	int sg_cnt;
+	struct scatterlist *sg_list;
+};
+
+struct bsg_job {
+	struct device *dev;
+	struct kref kref;
+	unsigned int timeout;
+	void *request;
+	void *reply;
+	unsigned int request_len;
+	unsigned int reply_len;
+	struct bsg_buffer request_payload;
+	struct bsg_buffer reply_payload;
+	int result;
+	unsigned int reply_payload_rcv_len;
+	struct request *bidi_rq;
+	struct bio *bidi_bio;
+	void *dd_data;
+};
+
+typedef enum blk_eh_timer_return bsg_timeout_fn(struct request *);
+
+enum scsi_device_event {
+	SDEV_EVT_MEDIA_CHANGE = 1,
+	SDEV_EVT_INQUIRY_CHANGE_REPORTED = 2,
+	SDEV_EVT_CAPACITY_CHANGE_REPORTED = 3,
+	SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED = 4,
+	SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED = 5,
+	SDEV_EVT_LUN_CHANGE_REPORTED = 6,
+	SDEV_EVT_ALUA_STATE_CHANGE_REPORTED = 7,
+	SDEV_EVT_POWER_ON_RESET_OCCURRED = 8,
+	SDEV_EVT_FIRST = 1,
+	SDEV_EVT_LAST = 8,
+	SDEV_EVT_MAXBITS = 9,
+};
+
+struct bsg_device;
+
+struct bsg_set {
+	struct blk_mq_tag_set tag_set;
+	struct bsg_device *bd;
+	bsg_job_fn *job_fn;
+	bsg_timeout_fn *timeout_fn;
+};
+
+struct throtl_data {
+	struct throtl_service_queue service_queue;
+	struct request_queue *queue;
+	unsigned int nr_queued[2];
+	unsigned int throtl_slice;
+	struct work_struct dispatch_work;
+	bool track_bio_latency;
+};
+
+struct blkg_rwstat_sample {
+	u64 cnt[5];
+};
+
+enum tg_state_flags {
+	THROTL_TG_PENDING = 1,
+	THROTL_TG_WAS_EMPTY = 2,
+	THROTL_TG_CANCELING = 4,
+};
+
+struct wrapper {
+	cmp_func_t cmp;
+	swap_func_t swap;
+};
+
+struct sg_append_table {
+	struct sg_table sgt;
+	struct scatterlist *prv;
+	unsigned int total_nents;
+};
+
+typedef struct scatterlist *sg_alloc_fn(unsigned int, gfp_t);
+
+typedef void sg_free_fn(struct scatterlist *, unsigned int);
+
+struct sg_page_iter {
+	struct scatterlist *sg;
+	unsigned int sg_pgoffset;
+	unsigned int __nents;
+	int __pg_advance;
+};
+
+struct sg_dma_page_iter {
+	struct sg_page_iter base;
+};
+
+struct sg_mapping_iter {
+	struct page *page;
+	void *addr;
+	size_t length;
+	size_t consumed;
+	struct sg_page_iter piter;
+	unsigned int __offset;
+	unsigned int __remaining;
+	unsigned int __flags;
+};
+
+struct interval_tree_node {
+	struct rb_node rb;
+	long unsigned int start;
+	long unsigned int last;
+	long unsigned int __subtree_last;
+};
+
+struct gen_pool_chunk {
+	struct list_head next_chunk;
+	atomic_long_t avail;
+	phys_addr_t phys_addr;
+	void *owner;
+	long unsigned int start_addr;
+	long unsigned int end_addr;
+	long unsigned int bits[0];
+};
+
+struct genpool_data_align {
+	int align;
+};
+
+struct genpool_data_fixed {
+	long unsigned int offset;
+};
+
+typedef struct {
+	U32 litLength;
+	U32 matchLength;
+} ZSTD_sequenceLength;
+
+typedef struct {
+	size_t estLitSize;
+	size_t estBlockSize;
+} EstimatedBlockSize;
+
+typedef U64 ZSTD_VecMask;
+
+typedef enum {
+	search_hashChain = 0,
+	search_binaryTree = 1,
+	search_rowHash = 2,
+} searchMethod_e;
+
+struct phy_lookup {
+	struct list_head node;
+	const char *dev_id;
+	const char *con_id;
+	struct phy *phy;
+};
+
+struct pinfunction {
+	const char *name;
+	const char * const *groups;
+	size_t ngroups;
+};
+
+struct pcs_pdata {
+	int irq;
+	void (*rearm)();
+};
+
+struct function_desc {
+	struct pinfunction func;
+	void *data;
+};
+
+struct pcs_func_vals {
+	void *reg;
+	unsigned int val;
+	unsigned int mask;
+};
+
+struct pcs_conf_vals {
+	enum pin_config_param param;
+	unsigned int val;
+	unsigned int enable;
+	unsigned int disable;
+	unsigned int mask;
+};
+
+struct pcs_conf_type {
+	const char *name;
+	enum pin_config_param param;
+};
+
+struct pcs_function {
+	const char *name;
+	struct pcs_func_vals *vals;
+	unsigned int nvals;
+	struct pcs_conf_vals *conf;
+	int nconfs;
+	struct list_head node;
+};
+
+struct pcs_gpiofunc_range {
+	unsigned int offset;
+	unsigned int npins;
+	unsigned int gpiofunc;
+	struct list_head node;
+};
+
+struct pcs_data {
+	struct pinctrl_pin_desc *pa;
+	int cur;
+};
+
+struct pcs_soc_data {
+	unsigned int flags;
+	int irq;
+	unsigned int irq_enable_mask;
+	unsigned int irq_status_mask;
+	void (*rearm)();
+};
+
+struct pcs_device {
+	struct resource *res;
+	void *base;
+	void *saved_vals;
+	unsigned int size;
+	struct device *dev;
+	struct device_node *np;
+	struct pinctrl_dev *pctl;
+	unsigned int flags;
+	struct property *missing_nr_pinctrl_cells;
+	struct pcs_soc_data socdata;
+	raw_spinlock_t lock;
+	struct mutex mutex;
+	unsigned int width;
+	unsigned int fmask;
+	unsigned int fshift;
+	unsigned int foff;
+	unsigned int fmax;
+	bool bits_per_mux;
+	unsigned int bits_per_pin;
+	struct pcs_data pins;
+	struct list_head gpiofuncs;
+	struct list_head irqs;
+	struct irq_chip chip;
+	struct irq_domain *domain;
+	struct pinctrl_desc desc;
+	unsigned int (*read)(void *);
+	void (*write)(unsigned int, void *);
+};
+
+struct pcs_interrupt {
+	void *reg;
+	irq_hw_number_t hwirq;
+	unsigned int irq;
+	struct list_head node;
+};
+
+enum of_gpio_flags {
+	OF_GPIO_ACTIVE_LOW = 1,
+	OF_GPIO_SINGLE_ENDED = 2,
+	OF_GPIO_OPEN_DRAIN = 4,
+	OF_GPIO_TRANSITORY = 8,
+	OF_GPIO_PULL_UP = 16,
+	OF_GPIO_PULL_DOWN = 32,
+	OF_GPIO_PULL_DISABLE = 64,
+};
+
+typedef struct gpio_desc * (*of_find_gpio_quirk)(struct device_node *, const char *, unsigned int, enum of_gpio_flags *);
+
+struct of_rename_gpio {
+	const char *con_id;
+	const char *legacy_id;
+	const char *compatible;
+};
+
+struct gen_74x164_chip {
+	struct gpio_chip gpio_chip;
+	struct mutex lock;
+	struct gpio_desc *gpiod_oe;
+	u32 registers;
+	u8 buffer[0];
+};
+
+enum led_default_state {
+	LEDS_DEFSTATE_OFF = 0,
+	LEDS_DEFSTATE_ON = 1,
+	LEDS_DEFSTATE_KEEP = 2,
+};
+
+struct led_properties {
+	u32 color;
+	bool color_present;
+	const char *function;
+	u32 func_enum;
+	bool func_enum_present;
+	const char *label;
+};
+
+enum led_trigger_netdev_modes {
+	TRIGGER_NETDEV_LINK = 0,
+	TRIGGER_NETDEV_LINK_10 = 1,
+	TRIGGER_NETDEV_LINK_100 = 2,
+	TRIGGER_NETDEV_LINK_1000 = 3,
+	TRIGGER_NETDEV_LINK_2500 = 4,
+	TRIGGER_NETDEV_LINK_5000 = 5,
+	TRIGGER_NETDEV_LINK_10000 = 6,
+	TRIGGER_NETDEV_HALF_DUPLEX = 7,
+	TRIGGER_NETDEV_FULL_DUPLEX = 8,
+	TRIGGER_NETDEV_TX = 9,
+	TRIGGER_NETDEV_RX = 10,
+	TRIGGER_NETDEV_TX_ERR = 11,
+	TRIGGER_NETDEV_RX_ERR = 12,
+	__TRIGGER_NETDEV_MAX = 13,
+};
+
+struct led_netdev_data {
+	struct mutex lock;
+	struct delayed_work work;
+	struct notifier_block notifier;
+	struct led_classdev *led_cdev;
+	struct net_device *net_dev;
+	char device_name[16];
+	atomic_t interval;
+	unsigned int last_activity;
+	long unsigned int mode;
+	int link_speed;
+	long unsigned int supported_link_modes[4];
+	u8 duplex;
+	bool carrier_link_up;
+	bool hw_control;
+};
+
+struct pcim_iomap_devres {
+	void *table[6];
+};
+
+struct pcim_intx_devres {
+	int orig_intx;
+};
+
+enum pcim_addr_devres_type {
+	PCIM_ADDR_DEVRES_TYPE_INVALID = 0,
+	PCIM_ADDR_DEVRES_TYPE_REGION = 1,
+	PCIM_ADDR_DEVRES_TYPE_REGION_MAPPING = 2,
+	PCIM_ADDR_DEVRES_TYPE_MAPPING = 3,
+};
+
+struct pcim_addr_devres {
+	enum pcim_addr_devres_type type;
+	void *baseaddr;
+	long unsigned int offset;
+	long unsigned int len;
+	int bar;
+};
+
+enum iproc_pcie_reg {
+	IPROC_PCIE_CLK_CTRL = 0,
+	IPROC_PCIE_MSI_GIC_MODE = 1,
+	IPROC_PCIE_MSI_BASE_ADDR = 2,
+	IPROC_PCIE_MSI_WINDOW_SIZE = 3,
+	IPROC_PCIE_MSI_ADDR_LO = 4,
+	IPROC_PCIE_MSI_ADDR_HI = 5,
+	IPROC_PCIE_MSI_EN_CFG = 6,
+	IPROC_PCIE_CFG_IND_ADDR = 7,
+	IPROC_PCIE_CFG_IND_DATA = 8,
+	IPROC_PCIE_CFG_ADDR = 9,
+	IPROC_PCIE_CFG_DATA = 10,
+	IPROC_PCIE_INTX_EN = 11,
+	IPROC_PCIE_OARR0 = 12,
+	IPROC_PCIE_OMAP0 = 13,
+	IPROC_PCIE_OARR1 = 14,
+	IPROC_PCIE_OMAP1 = 15,
+	IPROC_PCIE_OARR2 = 16,
+	IPROC_PCIE_OMAP2 = 17,
+	IPROC_PCIE_OARR3 = 18,
+	IPROC_PCIE_OMAP3 = 19,
+	IPROC_PCIE_IARR0 = 20,
+	IPROC_PCIE_IMAP0 = 21,
+	IPROC_PCIE_IARR1 = 22,
+	IPROC_PCIE_IMAP1 = 23,
+	IPROC_PCIE_IARR2 = 24,
+	IPROC_PCIE_IMAP2 = 25,
+	IPROC_PCIE_IARR3 = 26,
+	IPROC_PCIE_IMAP3 = 27,
+	IPROC_PCIE_IARR4 = 28,
+	IPROC_PCIE_IMAP4 = 29,
+	IPROC_PCIE_CFG_RD_STATUS = 30,
+	IPROC_PCIE_LINK_STATUS = 31,
+	IPROC_PCIE_APB_ERR_EN = 32,
+	IPROC_PCIE_MAX_NUM_REG = 33,
+};
+
+struct clk_notifier {
+	struct clk *clk;
+	struct srcu_notifier_head notifier_head;
+	struct list_head node;
+};
+
+struct clk_parent_map;
+
+struct clk_core {
+	const char *name;
+	const struct clk_ops *ops;
+	struct clk_hw *hw;
+	struct module *owner;
+	struct device *dev;
+	struct hlist_node rpm_node;
+	struct device_node *of_node;
+	struct clk_core *parent;
+	struct clk_parent_map *parents;
+	u8 num_parents;
+	u8 new_parent_index;
+	long unsigned int rate;
+	long unsigned int req_rate;
+	long unsigned int new_rate;
+	struct clk_core *new_parent;
+	struct clk_core *new_child;
+	long unsigned int flags;
+	bool orphan;
+	bool rpm_enabled;
+	unsigned int enable_count;
+	unsigned int prepare_count;
+	unsigned int protect_count;
+	long unsigned int min_rate;
+	long unsigned int max_rate;
+	long unsigned int accuracy;
+	int phase;
+	struct clk_duty duty;
+	struct hlist_head children;
+	struct hlist_node child_node;
+	struct hlist_head clks;
+	unsigned int notifier_count;
+	struct dentry *dentry;
+	struct hlist_node debug_node;
+	struct kref ref;
+};
+
+struct clk_onecell_data {
+	struct clk **clks;
+	unsigned int clk_num;
+};
+
+struct clk_parent_map {
+	const struct clk_hw *hw;
+	struct clk_core *core;
+	const char *fw_name;
+	const char *name;
+	int index;
+};
+
+struct trace_event_raw_clk {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	char __data[0];
+};
+
+struct trace_event_raw_clk_rate {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	long unsigned int rate;
+	char __data[0];
+};
+
+struct trace_event_raw_clk_rate_range {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	long unsigned int min;
+	long unsigned int max;
+	char __data[0];
+};
+
+struct trace_event_raw_clk_parent {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	u32 __data_loc_pname;
+	char __data[0];
+};
+
+struct trace_event_raw_clk_phase {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	int phase;
+	char __data[0];
+};
+
+struct trace_event_raw_clk_duty_cycle {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	unsigned int num;
+	unsigned int den;
+	char __data[0];
+};
+
+struct trace_event_raw_clk_rate_request {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	u32 __data_loc_pname;
+	long unsigned int min;
+	long unsigned int max;
+	long unsigned int prate;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_clk {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_clk_rate {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_clk_rate_range {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_clk_parent {
+	u32 name;
+	const void *name_ptr_;
+	u32 pname;
+	const void *pname_ptr_;
+};
+
+struct trace_event_data_offsets_clk_phase {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_clk_duty_cycle {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_clk_rate_request {
+	u32 name;
+	const void *name_ptr_;
+	u32 pname;
+	const void *pname_ptr_;
+};
+
+typedef void (*btf_trace_clk_enable)(void *, struct clk_core *);
+
+typedef void (*btf_trace_clk_enable_complete)(void *, struct clk_core *);
+
+typedef void (*btf_trace_clk_disable)(void *, struct clk_core *);
+
+typedef void (*btf_trace_clk_disable_complete)(void *, struct clk_core *);
+
+typedef void (*btf_trace_clk_prepare)(void *, struct clk_core *);
+
+typedef void (*btf_trace_clk_prepare_complete)(void *, struct clk_core *);
+
+typedef void (*btf_trace_clk_unprepare)(void *, struct clk_core *);
+
+typedef void (*btf_trace_clk_unprepare_complete)(void *, struct clk_core *);
+
+typedef void (*btf_trace_clk_set_rate)(void *, struct clk_core *, long unsigned int);
+
+typedef void (*btf_trace_clk_set_rate_complete)(void *, struct clk_core *, long unsigned int);
+
+typedef void (*btf_trace_clk_set_min_rate)(void *, struct clk_core *, long unsigned int);
+
+typedef void (*btf_trace_clk_set_max_rate)(void *, struct clk_core *, long unsigned int);
+
+typedef void (*btf_trace_clk_set_rate_range)(void *, struct clk_core *, long unsigned int, long unsigned int);
+
+typedef void (*btf_trace_clk_set_parent)(void *, struct clk_core *, struct clk_core *);
+
+typedef void (*btf_trace_clk_set_parent_complete)(void *, struct clk_core *, struct clk_core *);
+
+typedef void (*btf_trace_clk_set_phase)(void *, struct clk_core *, int);
+
+typedef void (*btf_trace_clk_set_phase_complete)(void *, struct clk_core *, int);
+
+typedef void (*btf_trace_clk_set_duty_cycle)(void *, struct clk_core *, struct clk_duty *);
+
+typedef void (*btf_trace_clk_set_duty_cycle_complete)(void *, struct clk_core *, struct clk_duty *);
+
+typedef void (*btf_trace_clk_rate_request_start)(void *, struct clk_rate_request *);
+
+typedef void (*btf_trace_clk_rate_request_done)(void *, struct clk_rate_request *);
+
+struct clk_notifier_devres {
+	struct clk *clk;
+	struct notifier_block *nb;
+};
+
+struct of_clk_provider {
+	struct list_head link;
+	struct device_node *node;
+	struct clk * (*get)(struct of_phandle_args *, void *);
+	struct clk_hw * (*get_hw)(struct of_phandle_args *, void *);
+	void *data;
+};
+
+struct clock_provider {
+	void (*clk_init_cb)(struct device_node *);
+	struct device_node *np;
+	struct list_head node;
+};
+
+enum tty_flow_change {
+	TTY_FLOW_NO_CHANGE = 0,
+	TTY_THROTTLE_SAFE = 1,
+	TTY_UNTHROTTLE_SAFE = 2,
+};
+
+struct n_tty_data {
+	size_t read_head;
+	size_t commit_head;
+	size_t canon_head;
+	size_t echo_head;
+	size_t echo_commit;
+	size_t echo_mark;
+	long unsigned int char_map[8];
+	long unsigned int overrun_time;
+	unsigned int num_overrun;
+	bool no_room;
+	unsigned char lnext: 1;
+	unsigned char erasing: 1;
+	unsigned char raw: 1;
+	unsigned char real_raw: 1;
+	unsigned char icanon: 1;
+	unsigned char push: 1;
+	u8 read_buf[4096];
+	long unsigned int read_flags[128];
+	u8 echo_buf[4096];
+	size_t read_tail;
+	size_t line_start;
+	size_t lookahead_count;
+	unsigned int column;
+	unsigned int canon_column;
+	size_t echo_tail;
+	struct mutex atomic_read_lock;
+	struct mutex output_lock;
+};
+
+enum {
+	ERASE = 0,
+	WERASE = 1,
+	KILL = 2,
+};
+
+struct uart_match {
+	struct uart_port *port;
+	struct uart_driver *driver;
+};
+
+struct serial8250_config {
+	const char *name;
+	short unsigned int fifo_size;
+	short unsigned int tx_loadsz;
+	unsigned char fcr;
+	unsigned char rxtrig_bytes[4];
+	unsigned int flags;
+};
+
+struct memdev {
+	const char *name;
+	const struct file_operations *fops;
+	fmode_t fmode;
+	umode_t mode;
+};
+
+enum lrng_get_seed_flags {
+	LRNG_GET_SEED_NONBLOCK = 1,
+	LRNG_GET_SEED_FULLY_SEEDED = 2,
+};
+
+enum chacha_constants {
+	CHACHA_CONSTANT_EXPA = 1634760805,
+	CHACHA_CONSTANT_ND_3 = 857760878,
+	CHACHA_CONSTANT_2_BY = 2036477234,
+	CHACHA_CONSTANT_TE_K = 1797285236,
+};
+
+enum dpm_order {
+	DPM_ORDER_NONE = 0,
+	DPM_ORDER_DEV_AFTER_PARENT = 1,
+	DPM_ORDER_PARENT_BEFORE_DEV = 2,
+	DPM_ORDER_DEV_LAST = 3,
+};
+
+struct dev_ext_attribute {
+	struct device_attribute attr;
+	void *var;
+};
+
+struct fwnode_link {
+	struct fwnode_handle *supplier;
+	struct list_head s_hook;
+	struct fwnode_handle *consumer;
+	struct list_head c_hook;
+	u8 flags;
+};
+
+union device_attr_group_devres {
+	const struct attribute_group *group;
+	const struct attribute_group **groups;
+};
+
+struct class_dir {
+	struct kobject kobj;
+	const struct class *class;
+};
+
+struct root_device {
+	struct device dev;
+	struct module *owner;
+	long: 32;
+};
+
+struct software_node_ref_args {
+	const struct software_node *node;
+	unsigned int nargs;
+	u64 args[8];
+};
+
+struct swnode {
+	struct kobject kobj;
+	struct fwnode_handle fwnode;
+	const struct software_node *node;
+	int id;
+	struct ida child_ids;
+	struct list_head entry;
+	struct list_head children;
+	struct swnode *parent;
+	unsigned int allocated: 1;
+	unsigned int managed: 1;
+};
+
+struct firmware_cache {
+	spinlock_t lock;
+	struct list_head head;
+	int state;
+};
+
+struct firmware_work {
+	struct work_struct work;
+	struct module *module;
+	const char *name;
+	struct device *device;
+	void *context;
+	void (*cont)(const struct firmware *, void *);
+	u32 opt_flags;
+};
+
+struct reg_field {
+	unsigned int reg;
+	unsigned int lsb;
+	unsigned int msb;
+	unsigned int id_size;
+	unsigned int id_offset;
+};
+
+struct regmap_range_node {
+	struct rb_node node;
+	const char *name;
+	struct regmap *map;
+	unsigned int range_min;
+	unsigned int range_max;
+	unsigned int selector_reg;
+	unsigned int selector_mask;
+	int selector_shift;
+	unsigned int window_start;
+	unsigned int window_len;
+};
+
+struct regmap_field {
+	struct regmap *regmap;
+	unsigned int mask;
+	unsigned int shift;
+	unsigned int reg;
+	unsigned int id_size;
+	unsigned int id_offset;
+};
+
+struct trace_event_raw_regmap_reg {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	unsigned int reg;
+	unsigned int val;
+	char __data[0];
+};
+
+struct trace_event_raw_regmap_bulk {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	unsigned int reg;
+	u32 __data_loc_buf;
+	int val_len;
+	char __data[0];
+};
+
+struct trace_event_raw_regmap_block {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	unsigned int reg;
+	int count;
+	char __data[0];
+};
+
+struct trace_event_raw_regcache_sync {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	u32 __data_loc_status;
+	u32 __data_loc_type;
+	char __data[0];
+};
+
+struct trace_event_raw_regmap_bool {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	int flag;
+	char __data[0];
+};
+
+struct trace_event_raw_regmap_async {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	char __data[0];
+};
+
+struct trace_event_raw_regcache_drop_region {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	unsigned int from;
+	unsigned int to;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_regmap_reg {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_regmap_bulk {
+	u32 name;
+	const void *name_ptr_;
+	u32 buf;
+	const void *buf_ptr_;
+};
+
+struct trace_event_data_offsets_regmap_block {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_regcache_sync {
+	u32 name;
+	const void *name_ptr_;
+	u32 status;
+	const void *status_ptr_;
+	u32 type;
+	const void *type_ptr_;
+};
+
+struct trace_event_data_offsets_regmap_bool {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_regmap_async {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_regcache_drop_region {
+	u32 name;
+	const void *name_ptr_;
+};
+
+typedef void (*btf_trace_regmap_reg_write)(void *, struct regmap *, unsigned int, unsigned int);
+
+typedef void (*btf_trace_regmap_reg_read)(void *, struct regmap *, unsigned int, unsigned int);
+
+typedef void (*btf_trace_regmap_reg_read_cache)(void *, struct regmap *, unsigned int, unsigned int);
+
+typedef void (*btf_trace_regmap_bulk_write)(void *, struct regmap *, unsigned int, const void *, int);
+
+typedef void (*btf_trace_regmap_bulk_read)(void *, struct regmap *, unsigned int, const void *, int);
+
+typedef void (*btf_trace_regmap_hw_read_start)(void *, struct regmap *, unsigned int, int);
+
+typedef void (*btf_trace_regmap_hw_read_done)(void *, struct regmap *, unsigned int, int);
+
+typedef void (*btf_trace_regmap_hw_write_start)(void *, struct regmap *, unsigned int, int);
+
+typedef void (*btf_trace_regmap_hw_write_done)(void *, struct regmap *, unsigned int, int);
+
+typedef void (*btf_trace_regcache_sync)(void *, struct regmap *, const char *, const char *);
+
+typedef void (*btf_trace_regmap_cache_only)(void *, struct regmap *, bool);
+
+typedef void (*btf_trace_regmap_cache_bypass)(void *, struct regmap *, bool);
+
+typedef void (*btf_trace_regmap_async_write_start)(void *, struct regmap *, unsigned int, int);
+
+typedef void (*btf_trace_regmap_async_io_complete)(void *, struct regmap *);
+
+typedef void (*btf_trace_regmap_async_complete_start)(void *, struct regmap *);
+
+typedef void (*btf_trace_regmap_async_complete_done)(void *, struct regmap *);
+
+typedef void (*btf_trace_regcache_drop_region)(void *, struct regmap *, unsigned int, unsigned int);
+
+struct syscon_platform_data {
+	const char *label;
+};
+
+struct syscon {
+	struct device_node *np;
+	struct regmap *regmap;
+	struct reset_control *reset;
+	struct list_head list;
+};
+
+struct dma_fence_array;
+
+struct dma_fence_array_cb {
+	struct dma_fence_cb cb;
+	struct dma_fence_array *array;
+};
+
+struct dma_fence_array {
+	struct dma_fence base;
+	spinlock_t lock;
+	unsigned int num_fences;
+	atomic_t num_pending;
+	struct dma_fence **fences;
+	struct irq_work work;
+	struct dma_fence_array_cb callbacks[0];
+};
+
+struct dma_fence_chain {
+	struct dma_fence base;
+	struct dma_fence *prev;
+	long: 32;
+	u64 prev_seqno;
+	struct dma_fence *fence;
+	union {
+		struct dma_fence_cb cb;
+		struct irq_work work;
+	};
+	spinlock_t lock;
+};
+
+struct dma_fence_unwrap {
+	struct dma_fence *chain;
+	struct dma_fence *array;
+	unsigned int index;
+};
+
+struct squashfs_super_block___2 {
+	__le32 s_magic;
+	__le32 pad0[9];
+	__le64 bytes_used;
+};
+
+struct mtdblk_dev {
+	struct mtd_blktrans_dev mbd;
+	int count;
+	struct mutex cache_mutex;
+	unsigned char *cache_data;
+	long unsigned int cache_offset;
+	unsigned int cache_size;
+	enum {
+		STATE_EMPTY = 0,
+		STATE_CLEAN = 1,
+		STATE_DIRTY = 2,
+	} cache_state;
+};
+
+struct flchip_shared {
+	struct mutex lock;
+	struct flchip *writing;
+	struct flchip *erasing;
+};
+
+struct cfi_pri_intelext {
+	uint8_t pri[3];
+	uint8_t MajorVersion;
+	uint8_t MinorVersion;
+	uint32_t FeatureSupport;
+	uint8_t SuspendCmdSupport;
+	uint16_t BlkStatusRegMask;
+	uint8_t VccOptimal;
+	uint8_t VppOptimal;
+	uint8_t NumProtectionFields;
+	uint16_t ProtRegAddr;
+	uint8_t FactProtRegSize;
+	uint8_t UserProtRegSize;
+	uint8_t extra[0];
+} __attribute__((packed));
+
+struct cfi_intelext_otpinfo {
+	uint32_t ProtRegAddr;
+	uint16_t FactGroups;
+	uint8_t FactProtRegSize;
+	uint16_t UserGroups;
+	uint8_t UserProtRegSize;
+} __attribute__((packed));
+
+struct cfi_intelext_blockinfo {
+	uint16_t NumIdentBlocks;
+	uint16_t BlockSize;
+	uint16_t MinBlockEraseCycles;
+	uint8_t BitsPerCell;
+	uint8_t BlockCap;
+};
+
+struct cfi_intelext_regioninfo {
+	uint16_t NumIdentPartitions;
+	uint8_t NumOpAllowed;
+	uint8_t NumOpAllowedSimProgMode;
+	uint8_t NumOpAllowedSimEraMode;
+	uint8_t NumBlockTypes;
+	struct cfi_intelext_blockinfo BlockTypes[1];
+};
+
+struct cfi_intelext_programming_regioninfo {
+	uint8_t ProgRegShift;
+	uint8_t Reserved1;
+	uint8_t ControlValid;
+	uint8_t Reserved2;
+	uint8_t ControlInvalid;
+	uint8_t Reserved3;
+};
+
+struct cfi_pri_atmel {
+	uint8_t pri[3];
+	uint8_t MajorVersion;
+	uint8_t MinorVersion;
+	uint8_t Features;
+	uint8_t BottomBoot;
+	uint8_t BurstMode;
+	uint8_t PageMode;
+};
+
+enum fwh_lock_state {
+	FWH_UNLOCKED = 0,
+	FWH_DENY_WRITE = 1,
+	FWH_IMMUTABLE = 2,
+	FWH_DENY_READ = 4,
+};
+
+struct fwh_xxlock_thunk {
+	enum fwh_lock_state val;
+	flstate_t state;
+};
+
+enum nand_bbt_block_status {
+	NAND_BBT_BLOCK_STATUS_UNKNOWN = 0,
+	NAND_BBT_BLOCK_GOOD = 1,
+	NAND_BBT_BLOCK_WORN = 2,
+	NAND_BBT_BLOCK_RESERVED = 3,
+	NAND_BBT_BLOCK_FACTORY_BAD = 4,
+	NAND_BBT_BLOCK_NUM_STATUS = 5,
+};
+
+struct nand_ecc_sw_hamming_conf {
+	struct nand_ecc_req_tweak_ctx req_ctx;
+	unsigned int code_size;
+	u8 *calc_buf;
+	u8 *code_buf;
+	unsigned int sm_order;
+};
+
+struct nand_ecc_step_info {
+	int stepsize;
+	const int *strengths;
+	int nstrengths;
+};
+
+struct nand_ecc_caps {
+	const struct nand_ecc_step_info *stepinfos;
+	int nstepinfos;
+	int (*calc_ecc_bytes)(int, int);
+};
+
+struct nand_subop {
+	unsigned int cs;
+	const struct nand_op_instr *instrs;
+	unsigned int ninstrs;
+	unsigned int first_instr_start_off;
+	unsigned int last_instr_end_off;
+};
+
+struct nand_op_parser_addr_constraints {
+	unsigned int maxcycles;
+};
+
+struct nand_op_parser_data_constraints {
+	unsigned int maxlen;
+};
+
+struct nand_op_parser_pattern_elem {
+	enum nand_op_instr_type type;
+	bool optional;
+	union {
+		struct nand_op_parser_addr_constraints addr;
+		struct nand_op_parser_data_constraints data;
+	} ctx;
+};
+
+struct nand_op_parser_pattern {
+	const struct nand_op_parser_pattern_elem *elems;
+	unsigned int nelems;
+	int (*exec)(struct nand_chip *, const struct nand_subop *);
+};
+
+struct nand_op_parser {
+	const struct nand_op_parser_pattern *patterns;
+	unsigned int npatterns;
+};
+
+struct nand_op_parser_ctx {
+	const struct nand_op_instr *instrs;
+	unsigned int ninstrs;
+	struct nand_subop subop;
+};
+
+enum nand_ecc_legacy_mode {
+	NAND_ECC_INVALID = 0,
+	NAND_ECC_NONE = 1,
+	NAND_ECC_SOFT = 2,
+	NAND_ECC_SOFT_BCH = 3,
+	NAND_ECC_HW = 4,
+	NAND_ECC_HW_SYNDROME = 5,
+	NAND_ECC_ON_DIE = 6,
+};
+
+struct brcmnand_platform_data {
+	int chip_select;
+	const char * const *part_probe_types;
+	unsigned int ecc_stepsize;
+	unsigned int ecc_strength;
+};
+
+struct brcm_nand_dma_desc {
+	u32 next_desc;
+	u32 next_desc_ext;
+	u32 cmd_irq;
+	u32 dram_addr;
+	u32 dram_addr_ext;
+	u32 tfr_len;
+	u32 total_len;
+	u32 flash_addr;
+	u32 flash_addr_ext;
+	u32 cs;
+	u32 pad2[5];
+	u32 status_valid;
+};
+
+enum edu_reg {
+	EDU_CONFIG = 0,
+	EDU_DRAM_ADDR = 1,
+	EDU_EXT_ADDR = 2,
+	EDU_LENGTH = 3,
+	EDU_CMD = 4,
+	EDU_STOP = 5,
+	EDU_STATUS = 6,
+	EDU_DONE = 7,
+	EDU_ERR_STATUS = 8,
+};
+
+enum flash_dma_reg {
+	FLASH_DMA_REVISION = 0,
+	FLASH_DMA_FIRST_DESC = 1,
+	FLASH_DMA_FIRST_DESC_EXT = 2,
+	FLASH_DMA_CTRL = 3,
+	FLASH_DMA_MODE = 4,
+	FLASH_DMA_STATUS = 5,
+	FLASH_DMA_INTERRUPT_DESC = 6,
+	FLASH_DMA_INTERRUPT_DESC_EXT = 7,
+	FLASH_DMA_ERROR_STATUS = 8,
+	FLASH_DMA_CURRENT_DESC = 9,
+	FLASH_DMA_CURRENT_DESC_EXT = 10,
+};
+
+enum {
+	BRCMNAND_HAS_1K_SECTORS = 1,
+	BRCMNAND_HAS_PREFETCH = 2,
+	BRCMNAND_HAS_CACHE_MODE = 4,
+	BRCMNAND_HAS_WP = 8,
+};
+
+struct brcmnand_host;
+
+struct brcmnand_controller {
+	struct device *dev;
+	struct nand_controller controller;
+	void *nand_base;
+	void *nand_fc;
+	void *flash_dma_base;
+	int irq;
+	unsigned int dma_irq;
+	int nand_version;
+	struct brcmnand_soc *soc;
+	struct clk *clk;
+	int cmd_pending;
+	bool dma_pending;
+	bool edu_pending;
+	struct completion done;
+	struct completion dma_done;
+	struct completion edu_done;
+	struct list_head host_list;
+	const u16 *edu_offsets;
+	void *edu_base;
+	int edu_irq;
+	int edu_count;
+	long: 32;
+	u64 edu_dram_addr;
+	u32 edu_ext_addr;
+	u32 edu_cmd;
+	u32 edu_config;
+	int sas;
+	int sector_size_1k;
+	u8 *oob;
+	const u16 *flash_dma_offsets;
+	struct brcm_nand_dma_desc *dma_desc;
+	dma_addr_t dma_pa;
+	int (*dma_trans)(struct brcmnand_host *, u64, u32 *, u8 *, u32, u8);
+	u8 flash_cache[512];
+	const u16 *reg_offsets;
+	unsigned int reg_spacing;
+	const u8 *cs_offsets;
+	const u8 *cs0_offsets;
+	unsigned int max_block_size;
+	const unsigned int *block_sizes;
+	unsigned int max_page_size;
+	const unsigned int *page_sizes;
+	unsigned int page_size_shift;
+	unsigned int max_oob;
+	u32 ecc_level_shift;
+	u32 features;
+	u32 nand_cs_nand_select;
+	u32 nand_cs_nand_xor;
+	u32 corr_stat_threshold;
+	u32 flash_dma_mode;
+	u32 flash_edu_mode;
+	bool pio_poll_mode;
+};
+
+struct brcmnand_cfg {
+	u64 device_size;
+	unsigned int block_size;
+	unsigned int page_size;
+	unsigned int spare_area_size;
+	unsigned int device_width;
+	unsigned int col_adr_bytes;
+	unsigned int blk_adr_bytes;
+	unsigned int ful_adr_bytes;
+	unsigned int sector_size_1k;
+	unsigned int ecc_level;
+	u32 acc_control;
+	u32 config;
+	u32 config_ext;
+	u32 timing_1;
+	u32 timing_2;
+};
+
+struct brcmnand_host {
+	struct list_head node;
+	struct nand_chip chip;
+	struct platform_device *pdev;
+	int cs;
+	unsigned int last_cmd;
+	unsigned int last_byte;
+	u64 last_addr;
+	struct brcmnand_cfg hwcfg;
+	struct brcmnand_controller *ctrl;
+	long: 32;
+};
+
+enum brcmnand_reg {
+	BRCMNAND_CMD_START = 0,
+	BRCMNAND_CMD_EXT_ADDRESS = 1,
+	BRCMNAND_CMD_ADDRESS = 2,
+	BRCMNAND_INTFC_STATUS = 3,
+	BRCMNAND_CS_SELECT = 4,
+	BRCMNAND_CS_XOR = 5,
+	BRCMNAND_LL_OP = 6,
+	BRCMNAND_CS0_BASE = 7,
+	BRCMNAND_CS1_BASE = 8,
+	BRCMNAND_CORR_THRESHOLD = 9,
+	BRCMNAND_CORR_THRESHOLD_EXT = 10,
+	BRCMNAND_UNCORR_COUNT = 11,
+	BRCMNAND_CORR_COUNT = 12,
+	BRCMNAND_CORR_EXT_ADDR = 13,
+	BRCMNAND_CORR_ADDR = 14,
+	BRCMNAND_UNCORR_EXT_ADDR = 15,
+	BRCMNAND_UNCORR_ADDR = 16,
+	BRCMNAND_SEMAPHORE = 17,
+	BRCMNAND_ID = 18,
+	BRCMNAND_ID_EXT = 19,
+	BRCMNAND_LL_RDATA = 20,
+	BRCMNAND_OOB_READ_BASE = 21,
+	BRCMNAND_OOB_READ_10_BASE = 22,
+	BRCMNAND_OOB_WRITE_BASE = 23,
+	BRCMNAND_OOB_WRITE_10_BASE = 24,
+	BRCMNAND_FC_BASE = 25,
+};
+
+enum brcmnand_cs_reg {
+	BRCMNAND_CS_CFG_EXT = 0,
+	BRCMNAND_CS_CFG = 1,
+	BRCMNAND_CS_ACC_CONTROL = 2,
+	BRCMNAND_CS_TIMING1 = 3,
+	BRCMNAND_CS_TIMING2 = 4,
+};
+
+enum {
+	CFG_BLK_ADR_BYTES_SHIFT = 8,
+	CFG_COL_ADR_BYTES_SHIFT = 12,
+	CFG_FUL_ADR_BYTES_SHIFT = 16,
+	CFG_BUS_WIDTH_SHIFT = 23,
+	CFG_BUS_WIDTH = 8388608,
+	CFG_DEVICE_SIZE_SHIFT = 24,
+	CFG_PAGE_SIZE_SHIFT_v2_1 = 30,
+	CFG_PAGE_SIZE_SHIFT = 20,
+	CFG_BLK_SIZE_SHIFT = 28,
+	CFG_EXT_PAGE_SIZE_SHIFT = 0,
+	CFG_EXT_BLK_SIZE_SHIFT = 4,
+};
+
+enum {
+	INTFC_FLASH_STATUS = 255,
+	INTFC_ERASED = 134217728,
+	INTFC_OOB_VALID = 268435456,
+	INTFC_CACHE_VALID = 536870912,
+	INTFC_FLASH_READY = 1073741824,
+	INTFC_CTLR_READY = 2147483648,
+};
+
+enum {
+	ACC_CONTROL_CACHE_MODE = 4194304,
+	ACC_CONTROL_PREFETCH = 8388608,
+	ACC_CONTROL_PAGE_HIT = 16777216,
+	ACC_CONTROL_WR_PREEMPT = 33554432,
+	ACC_CONTROL_PARTIAL_PAGE = 67108864,
+	ACC_CONTROL_RD_ERASED = 134217728,
+	ACC_CONTROL_FAST_PGM_RDIN = 268435456,
+	ACC_CONTROL_WR_ECC = 1073741824,
+	ACC_CONTROL_RD_ECC = 2147483648,
+};
+
+enum {
+	CS_SELECT_NAND_WP = 536870912,
+	CS_SELECT_AUTO_DEVICE_ID_CFG = 1073741824,
+};
+
+enum brcmnand_llop_type {
+	LL_OP_CMD = 0,
+	LL_OP_ADDR = 1,
+	LL_OP_WR = 2,
+	LL_OP_RD = 3,
+};
+
+enum {
+	LLOP_RE = 65536,
+	LLOP_WE = 131072,
+	LLOP_ALE = 262144,
+	LLOP_CLE = 524288,
+	LLOP_RETURN_IDLE = 2147483648,
+	LLOP_DATA_MASK = 65535,
+};
+
+struct ubi_leb_change_req {
+	__s32 lnum;
+	__s32 bytes;
+	__s8 dtype;
+	__s8 padding[7];
+};
+
+struct ubi_ltree_entry {
+	struct rb_node rb;
+	int vol_id;
+	int lnum;
+	int users;
+	struct rw_semaphore mutex;
+};
+
+struct ubi_eba_leb_desc {
+	int lnum;
+	int pnum;
+};
+
+struct ubi_eba_entry;
+
+struct ubi_eba_table {
+	struct ubi_eba_entry *entries;
+};
+
+struct ubi_eba_entry {
+	int pnum;
+};
+
+struct ubiblock_param {
+	int ubi_num;
+	int vol_id;
+	char name[64];
+};
+
+struct ubiblock_pdu {
+	struct ubi_sgl usgl;
+};
+
+struct ubiblock {
+	struct ubi_volume_desc *desc;
+	int ubi_num;
+	int vol_id;
+	int refcnt;
+	int leb_size;
+	struct gendisk *gd;
+	struct request_queue *rq;
+	struct mutex dev_mutex;
+	struct list_head list;
+	struct blk_mq_tag_set tag_set;
+};
+
+struct bcm_qspi_parms {
+	u32 speed_hz;
+	u8 mode;
+	u8 bits_per_word;
+};
+
+struct bcm_xfer_mode {
+	bool flex_mode;
+	unsigned int width;
+	unsigned int addrlen;
+	unsigned int hp;
+};
+
+enum base_type {
+	MSPI = 0,
+	BSPI = 1,
+	CHIP_SELECT = 2,
+	BASEMAX = 3,
+};
+
+enum irq_source {
+	SINGLE_L2 = 0,
+	MUXED_L1 = 1,
+};
+
+struct bcm_qspi_irq {
+	const char *irq_name;
+	const irq_handler_t irq_handler;
+	int irq_source;
+	u32 mask;
+};
+
+struct bcm_qspi_dev_id {
+	const struct bcm_qspi_irq *irqp;
+	void *dev;
+};
+
+struct qspi_trans {
+	struct spi_transfer *trans;
+	int byte;
+	bool mspi_last_trans;
+};
+
+struct bcm_qspi {
+	struct platform_device *pdev;
+	struct spi_controller *host;
+	struct clk *clk;
+	u32 base_clk;
+	u32 max_speed_hz;
+	void *base[3];
+	struct bcm_qspi_soc_intc *soc_intc;
+	struct bcm_qspi_parms last_parms;
+	struct qspi_trans trans_pos;
+	int curr_cs;
+	int bspi_maj_rev;
+	int bspi_min_rev;
+	int bspi_enabled;
+	const struct spi_mem_op *bspi_rf_op;
+	u32 bspi_rf_op_idx;
+	u32 bspi_rf_op_len;
+	u32 bspi_rf_op_status;
+	struct bcm_xfer_mode xfer_mode;
+	u32 s3_strap_override_ctrl;
+	bool bspi_mode;
+	bool big_endian;
+	int num_irqs;
+	struct bcm_qspi_dev_id *dev_ids;
+	struct completion mspi_done;
+	struct completion bspi_done;
+	u8 mspi_maj_rev;
+	u8 mspi_min_rev;
+	bool mspi_spcr3_sysclk;
+};
+
+struct bcm_qspi_data {
+	bool has_mspi_rev;
+	bool has_spcr3_sysclk;
+};
+
+struct mdio_board_info {
+	const char *bus_id;
+	char modalias[32];
+	int mdio_addr;
+	const void *platform_data;
+};
+
+struct mdio_board_entry {
+	struct list_head list;
+	struct mdio_board_info board_info;
+};
+
+enum phy_state_work {
+	PHY_STATE_WORK_NONE = 0,
+	PHY_STATE_WORK_ANEG = 1,
+	PHY_STATE_WORK_SUSPEND = 2,
+};
+
+struct mdio_driver {
+	struct mdio_driver_common mdiodrv;
+	int (*probe)(struct mdio_device *);
+	void (*remove)(struct mdio_device *);
+	void (*shutdown)(struct mdio_device *);
+};
+
+struct swmii_regs {
+	u16 bmsr;
+	u16 lpa;
+	u16 lpagb;
+	u16 estat;
+};
+
+enum {
+	SWMII_SPEED_10 = 0,
+	SWMII_SPEED_100 = 1,
+	SWMII_SPEED_1000 = 2,
+	SWMII_DUPLEX_HALF = 0,
+	SWMII_DUPLEX_FULL = 1,
+};
+
+struct sfp;
+
+struct sfp_socket_ops;
+
+struct sfp_quirk;
+
+struct sfp_bus {
+	struct kref kref;
+	struct list_head node;
+	const struct fwnode_handle *fwnode;
+	const struct sfp_socket_ops *socket_ops;
+	struct device *sfp_dev;
+	struct sfp *sfp;
+	const struct sfp_quirk *sfp_quirk;
+	const struct sfp_upstream_ops *upstream_ops;
+	void *upstream;
+	struct phy_device *phydev;
+	bool registered;
+	bool started;
+};
+
+struct sfp_quirk {
+	const char *vendor;
+	const char *part;
+	void (*modes)(const struct sfp_eeprom_id *, long unsigned int *, long unsigned int *);
+	void (*fixup)(struct sfp *);
+};
+
+struct sfp_socket_ops {
+	void (*attach)(struct sfp *);
+	void (*detach)(struct sfp *);
+	void (*start)(struct sfp *);
+	void (*stop)(struct sfp *);
+	void (*set_signal_rate)(struct sfp *, unsigned int);
+	int (*module_info)(struct sfp *, struct ethtool_modinfo *);
+	int (*module_eeprom)(struct sfp *, struct ethtool_eeprom *, u8 *);
+	int (*module_eeprom_by_page)(struct sfp *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);
+};
+
+struct mdio_mux_child_bus;
+
+struct mdio_mux_parent_bus {
+	struct mii_bus *mii_bus;
+	int current_child;
+	int parent_id;
+	void *switch_data;
+	int (*switch_fn)(int, int, void *);
+	struct mdio_mux_child_bus *children;
+};
+
+struct mdio_mux_child_bus {
+	struct mii_bus *mii_bus;
+	struct mdio_mux_parent_bus *parent;
+	struct mdio_mux_child_bus *next;
+	int bus_number;
+};
+
+struct b53_srab_port_priv {
+	int irq;
+	bool irq_enabled;
+	struct b53_device *dev;
+	unsigned int num;
+	phy_interface_t mode;
+};
+
+struct b53_srab_priv {
+	void *regs;
+	void *mux_config;
+	struct b53_srab_port_priv port_intrs[9];
+};
+
+enum usb_device_speed {
+	USB_SPEED_UNKNOWN = 0,
+	USB_SPEED_LOW = 1,
+	USB_SPEED_FULL = 2,
+	USB_SPEED_HIGH = 3,
+	USB_SPEED_WIRELESS = 4,
+	USB_SPEED_SUPER = 5,
+	USB_SPEED_SUPER_PLUS = 6,
+};
+
+enum usb_charger_type {
+	UNKNOWN_TYPE = 0,
+	SDP_TYPE = 1,
+	DCP_TYPE = 2,
+	CDP_TYPE = 3,
+	ACA_TYPE = 4,
+};
+
+enum usb_charger_state {
+	USB_CHARGER_DEFAULT = 0,
+	USB_CHARGER_PRESENT = 1,
+	USB_CHARGER_ABSENT = 2,
+};
+
+enum usb_phy_events {
+	USB_EVENT_NONE = 0,
+	USB_EVENT_VBUS = 1,
+	USB_EVENT_ID = 2,
+	USB_EVENT_CHARGER = 3,
+	USB_EVENT_ENUMERATED = 4,
+};
+
+enum usb_phy_type {
+	USB_PHY_TYPE_UNDEFINED = 0,
+	USB_PHY_TYPE_USB2 = 1,
+	USB_PHY_TYPE_USB3 = 2,
+};
+
+struct usb_phy;
+
+struct usb_phy_io_ops {
+	int (*read)(struct usb_phy *, u32);
+	int (*write)(struct usb_phy *, u32, u32);
+};
+
+struct usb_otg;
+
+struct usb_charger_current {
+	unsigned int sdp_min;
+	unsigned int sdp_max;
+	unsigned int dcp_min;
+	unsigned int dcp_max;
+	unsigned int cdp_min;
+	unsigned int cdp_max;
+	unsigned int aca_min;
+	unsigned int aca_max;
+};
+
+struct usb_phy {
+	struct device *dev;
+	const char *label;
+	unsigned int flags;
+	enum usb_phy_type type;
+	enum usb_phy_events last_event;
+	struct usb_otg *otg;
+	struct device *io_dev;
+	struct usb_phy_io_ops *io_ops;
+	void *io_priv;
+	struct extcon_dev *edev;
+	struct extcon_dev *id_edev;
+	struct notifier_block vbus_nb;
+	struct notifier_block id_nb;
+	struct notifier_block type_nb;
+	enum usb_charger_type chg_type;
+	enum usb_charger_state chg_state;
+	struct usb_charger_current chg_cur;
+	struct work_struct chg_work;
+	struct atomic_notifier_head notifier;
+	u16 port_status;
+	u16 port_change;
+	struct list_head head;
+	int (*init)(struct usb_phy *);
+	void (*shutdown)(struct usb_phy *);
+	int (*set_vbus)(struct usb_phy *, int);
+	int (*set_power)(struct usb_phy *, unsigned int);
+	int (*set_suspend)(struct usb_phy *, int);
+	int (*set_wakeup)(struct usb_phy *, bool);
+	int (*notify_connect)(struct usb_phy *, enum usb_device_speed);
+	int (*notify_disconnect)(struct usb_phy *, enum usb_device_speed);
+	enum usb_charger_type (*charger_detect)(struct usb_phy *);
+};
+
+struct phy_devm {
+	struct usb_phy *phy;
+	struct notifier_block *nb;
+};
+
+enum dmi_field {
+	DMI_NONE = 0,
+	DMI_BIOS_VENDOR = 1,
+	DMI_BIOS_VERSION = 2,
+	DMI_BIOS_DATE = 3,
+	DMI_BIOS_RELEASE = 4,
+	DMI_EC_FIRMWARE_RELEASE = 5,
+	DMI_SYS_VENDOR = 6,
+	DMI_PRODUCT_NAME = 7,
+	DMI_PRODUCT_VERSION = 8,
+	DMI_PRODUCT_SERIAL = 9,
+	DMI_PRODUCT_UUID = 10,
+	DMI_PRODUCT_SKU = 11,
+	DMI_PRODUCT_FAMILY = 12,
+	DMI_BOARD_VENDOR = 13,
+	DMI_BOARD_NAME = 14,
+	DMI_BOARD_VERSION = 15,
+	DMI_BOARD_SERIAL = 16,
+	DMI_BOARD_ASSET_TAG = 17,
+	DMI_CHASSIS_VENDOR = 18,
+	DMI_CHASSIS_TYPE = 19,
+	DMI_CHASSIS_VERSION = 20,
+	DMI_CHASSIS_SERIAL = 21,
+	DMI_CHASSIS_ASSET_TAG = 22,
+	DMI_STRING_MAX = 23,
+	DMI_OEM_STRING = 24,
+};
+
+enum power_supply_notifier_events {
+	PSY_EVENT_PROP_CHANGED = 0,
+};
+
+struct power_supply_config {
+	struct device_node *of_node;
+	struct fwnode_handle *fwnode;
+	void *drv_data;
+	const struct attribute_group **attr_grp;
+	char **supplied_to;
+	size_t num_supplicants;
+};
+
+struct psy_am_i_supplied_data {
+	struct power_supply *psy;
+	unsigned int count;
+};
+
+struct psy_get_supplier_prop_data {
+	struct power_supply *psy;
+	enum power_supply_property psp;
+	union power_supply_propval *val;
+};
+
+struct trace_event_raw_thermal_temperature {
+	struct trace_entry ent;
+	u32 __data_loc_thermal_zone;
+	int id;
+	int temp_prev;
+	int temp;
+	char __data[0];
+};
+
+struct trace_event_raw_cdev_update {
+	struct trace_entry ent;
+	u32 __data_loc_type;
+	long unsigned int target;
+	char __data[0];
+};
+
+struct trace_event_raw_thermal_zone_trip {
+	struct trace_entry ent;
+	u32 __data_loc_thermal_zone;
+	int id;
+	int trip;
+	enum thermal_trip_type trip_type;
+	char __data[0];
+};
+
+struct trace_event_raw_thermal_power_cpu_get_power_simple {
+	struct trace_entry ent;
+	int cpu;
+	u32 power;
+	char __data[0];
+};
+
+struct trace_event_raw_thermal_power_cpu_limit {
+	struct trace_entry ent;
+	u32 __data_loc_cpumask;
+	unsigned int freq;
+	long unsigned int cdev_state;
+	u32 power;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_thermal_temperature {
+	u32 thermal_zone;
+	const void *thermal_zone_ptr_;
+};
+
+struct trace_event_data_offsets_cdev_update {
+	u32 type;
+	const void *type_ptr_;
+};
+
+struct trace_event_data_offsets_thermal_zone_trip {
+	u32 thermal_zone;
+	const void *thermal_zone_ptr_;
+};
+
+struct trace_event_data_offsets_thermal_power_cpu_get_power_simple {};
+
+struct trace_event_data_offsets_thermal_power_cpu_limit {
+	u32 cpumask;
+	const void *cpumask_ptr_;
+};
+
+typedef void (*btf_trace_thermal_temperature)(void *, struct thermal_zone_device *);
+
+typedef void (*btf_trace_cdev_update)(void *, struct thermal_cooling_device *, long unsigned int);
+
+typedef void (*btf_trace_thermal_zone_trip)(void *, struct thermal_zone_device *, int, enum thermal_trip_type);
+
+typedef void (*btf_trace_thermal_power_cpu_get_power_simple)(void *, int, u32);
+
+typedef void (*btf_trace_thermal_power_cpu_limit)(void *, const struct cpumask *, unsigned int, long unsigned int, u32);
+
+struct of_endpoint {
+	unsigned int port;
+	unsigned int id;
+	const struct device_node *local_node;
+};
+
+struct supplier_bindings {
+	struct device_node * (*parse_prop)(struct device_node *, const char *, int);
+	struct device_node * (*get_con_dev)(struct device_node *);
+	bool optional;
+	u8 fwlink_flags;
+};
+
+struct of_intc_desc {
+	struct list_head list;
+	of_irq_init_cb_t irq_init_cb;
+	struct device_node *dev;
+	struct device_node *interrupt_parent;
+};
+
+struct bcm47xx_wdt {
+	u32 (*timer_set)(struct bcm47xx_wdt *, u32);
+	u32 (*timer_set_ms)(struct bcm47xx_wdt *, u32);
+	u32 max_timer_ms;
+	void *driver_data;
+	struct watchdog_device wdd;
+	struct timer_list soft_timer;
+	atomic_t soft_ticks;
+};
+
+typedef int (*armpmu_init_fn)(struct arm_pmu *);
+
+struct pmu_probe_info {
+	unsigned int cpuid;
+	unsigned int mask;
+	armpmu_init_fn init;
+};
+
+struct rmem {
+	struct device *dev;
+	struct nvmem_device *nvmem;
+	struct reserved_mem *mem;
+	phys_addr_t size;
+};
+
+struct __kernel_old_timespec {
+	__kernel_old_time_t tv_sec;
+	long int tv_nsec;
+};
+
+struct user_msghdr {
+	void *msg_name;
+	int msg_namelen;
+	struct iovec *msg_iov;
+	__kernel_size_t msg_iovlen;
+	void *msg_control;
+	__kernel_size_t msg_controllen;
+	unsigned int msg_flags;
+};
+
+struct mmsghdr {
+	struct user_msghdr msg_hdr;
+	unsigned int msg_len;
+};
+
+typedef u32 compat_uint_t;
+
+struct compat_if_settings {
+	unsigned int type;
+	unsigned int size;
+	compat_uptr_t ifs_ifsu;
+};
+
+struct compat_ifreq {
+	union {
+		char ifrn_name[16];
+	} ifr_ifrn;
+	union {
+		struct sockaddr ifru_addr;
+		struct sockaddr ifru_dstaddr;
+		struct sockaddr ifru_broadaddr;
+		struct sockaddr ifru_netmask;
+		struct sockaddr ifru_hwaddr;
+		short int ifru_flags;
+		compat_int_t ifru_ivalue;
+		compat_int_t ifru_mtu;
+		struct compat_ifmap ifru_map;
+		char ifru_slave[16];
+		char ifru_newname[16];
+		compat_caddr_t ifru_data;
+		struct compat_if_settings ifru_settings;
+	} ifr_ifru;
+};
+
+struct compat_msghdr {
+	compat_uptr_t msg_name;
+	compat_int_t msg_namelen;
+	compat_uptr_t msg_iov;
+	compat_size_t msg_iovlen;
+	compat_uptr_t msg_control;
+	compat_size_t msg_controllen;
+	compat_uint_t msg_flags;
+};
+
+struct compat_mmsghdr {
+	struct compat_msghdr msg_hdr;
+	compat_uint_t msg_len;
+};
+
+struct scm_ts_pktinfo {
+	__u32 if_index;
+	__u32 pkt_length;
+	__u32 reserved[2];
+};
+
+struct used_address {
+	struct __kernel_sockaddr_storage name;
+	unsigned int name_len;
+};
+
+struct csum_state {
+	__wsum csum;
+	size_t off;
+};
+
+struct scm_timestamping {
+	struct __kernel_old_timespec ts[3];
+};
+
+struct scm_timestamping64 {
+	struct __kernel_timespec ts[3];
+};
+
+enum {
+	NETNSA_NONE = 0,
+	NETNSA_NSID = 1,
+	NETNSA_PID = 2,
+	NETNSA_FD = 3,
+	NETNSA_TARGET_NSID = 4,
+	NETNSA_CURRENT_NSID = 5,
+	__NETNSA_MAX = 6,
+};
+
+struct net_fill_args {
+	u32 portid;
+	u32 seq;
+	int flags;
+	int cmd;
+	int nsid;
+	bool add_ref;
+	int ref_nsid;
+};
+
+struct rtnl_net_dump_cb {
+	struct net *tgt_net;
+	struct net *ref_net;
+	struct sk_buff *skb;
+	struct net_fill_args fillargs;
+	int idx;
+	int s_idx;
+};
+
+struct ndt_stats {
+	__u64 ndts_allocs;
+	__u64 ndts_destroys;
+	__u64 ndts_hash_grows;
+	__u64 ndts_res_failed;
+	__u64 ndts_lookups;
+	__u64 ndts_hits;
+	__u64 ndts_rcv_probes_mcast;
+	__u64 ndts_rcv_probes_ucast;
+	__u64 ndts_periodic_gc_runs;
+	__u64 ndts_forced_gc_runs;
+	__u64 ndts_table_fulls;
+};
+
+enum {
+	NDTPA_UNSPEC = 0,
+	NDTPA_IFINDEX = 1,
+	NDTPA_REFCNT = 2,
+	NDTPA_REACHABLE_TIME = 3,
+	NDTPA_BASE_REACHABLE_TIME = 4,
+	NDTPA_RETRANS_TIME = 5,
+	NDTPA_GC_STALETIME = 6,
+	NDTPA_DELAY_PROBE_TIME = 7,
+	NDTPA_QUEUE_LEN = 8,
+	NDTPA_APP_PROBES = 9,
+	NDTPA_UCAST_PROBES = 10,
+	NDTPA_MCAST_PROBES = 11,
+	NDTPA_ANYCAST_DELAY = 12,
+	NDTPA_PROXY_DELAY = 13,
+	NDTPA_PROXY_QLEN = 14,
+	NDTPA_LOCKTIME = 15,
+	NDTPA_QUEUE_LENBYTES = 16,
+	NDTPA_MCAST_REPROBES = 17,
+	NDTPA_PAD = 18,
+	NDTPA_INTERVAL_PROBE_TIME_MS = 19,
+	__NDTPA_MAX = 20,
+};
+
+struct ndtmsg {
+	__u8 ndtm_family;
+	__u8 ndtm_pad1;
+	__u16 ndtm_pad2;
+};
+
+struct ndt_config {
+	__u16 ndtc_key_len;
+	__u16 ndtc_entry_size;
+	__u32 ndtc_entries;
+	__u32 ndtc_last_flush;
+	__u32 ndtc_last_rand;
+	__u32 ndtc_hash_rnd;
+	__u32 ndtc_hash_mask;
+	__u32 ndtc_hash_chain_gc;
+	__u32 ndtc_proxy_qlen;
+};
+
+enum {
+	NDTA_UNSPEC = 0,
+	NDTA_NAME = 1,
+	NDTA_THRESH1 = 2,
+	NDTA_THRESH2 = 3,
+	NDTA_THRESH3 = 4,
+	NDTA_CONFIG = 5,
+	NDTA_PARMS = 6,
+	NDTA_STATS = 7,
+	NDTA_GC_INTERVAL = 8,
+	NDTA_PAD = 9,
+	__NDTA_MAX = 10,
+};
+
+struct neigh_dump_filter {
+	int master_idx;
+	int dev_idx;
+};
+
+struct neigh_sysctl_table {
+	struct ctl_table_header *sysctl_header;
+	struct ctl_table neigh_vars[21];
+};
+
+enum {
+	BPF_F_RECOMPUTE_CSUM = 1,
+	BPF_F_INVALIDATE_HASH = 2,
+};
+
+enum {
+	BPF_F_HDR_FIELD_MASK = 15,
+};
+
+enum {
+	BPF_F_PSEUDO_HDR = 16,
+	BPF_F_MARK_MANGLED_0 = 32,
+	BPF_F_MARK_ENFORCE = 64,
+};
+
+enum {
+	BPF_F_TUNINFO_IPV6 = 1,
+};
+
+enum {
+	BPF_F_ZERO_CSUM_TX = 2,
+	BPF_F_DONT_FRAGMENT = 4,
+	BPF_F_SEQ_NUMBER = 8,
+	BPF_F_NO_TUNNEL_KEY = 16,
+};
+
+enum {
+	BPF_F_TUNINFO_FLAGS = 16,
+};
+
+enum {
+	BPF_CSUM_LEVEL_QUERY = 0,
+	BPF_CSUM_LEVEL_INC = 1,
+	BPF_CSUM_LEVEL_DEC = 2,
+	BPF_CSUM_LEVEL_RESET = 3,
+};
+
+enum {
+	BPF_F_ADJ_ROOM_FIXED_GSO = 1,
+	BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 = 2,
+	BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 = 4,
+	BPF_F_ADJ_ROOM_ENCAP_L4_GRE = 8,
+	BPF_F_ADJ_ROOM_ENCAP_L4_UDP = 16,
+	BPF_F_ADJ_ROOM_NO_CSUM_RESET = 32,
+	BPF_F_ADJ_ROOM_ENCAP_L2_ETH = 64,
+	BPF_F_ADJ_ROOM_DECAP_L3_IPV4 = 128,
+	BPF_F_ADJ_ROOM_DECAP_L3_IPV6 = 256,
+};
+
+enum {
+	BPF_ADJ_ROOM_ENCAP_L2_MASK = 255,
+	BPF_ADJ_ROOM_ENCAP_L2_SHIFT = 56,
+};
+
+enum {
+	BPF_SK_LOOKUP_F_REPLACE = 1,
+	BPF_SK_LOOKUP_F_NO_REUSEPORT = 2,
+};
+
+enum bpf_adj_room_mode {
+	BPF_ADJ_ROOM_NET = 0,
+	BPF_ADJ_ROOM_MAC = 1,
+};
+
+enum bpf_hdr_start_off {
+	BPF_HDR_START_MAC = 0,
+	BPF_HDR_START_NET = 1,
+};
+
+enum bpf_lwt_encap_mode {
+	BPF_LWT_ENCAP_SEG6 = 0,
+	BPF_LWT_ENCAP_SEG6_INLINE = 1,
+	BPF_LWT_ENCAP_IP = 2,
+};
+
+enum {
+	BPF_SKB_TSTAMP_UNSPEC = 0,
+	BPF_SKB_TSTAMP_DELIVERY_MONO = 1,
+	BPF_SKB_CLOCK_REALTIME = 0,
+	BPF_SKB_CLOCK_MONOTONIC = 1,
+	BPF_SKB_CLOCK_TAI = 2,
+};
+
+struct bpf_tunnel_key {
+	__u32 tunnel_id;
+	union {
+		__u32 remote_ipv4;
+		__u32 remote_ipv6[4];
+	};
+	__u8 tunnel_tos;
+	__u8 tunnel_ttl;
+	union {
+		__u16 tunnel_ext;
+		__be16 tunnel_flags;
+	};
+	__u32 tunnel_label;
+	union {
+		__u32 local_ipv4;
+		__u32 local_ipv6[4];
+	};
+};
+
+struct bpf_xfrm_state {
+	__u32 reqid;
+	__u32 spi;
+	__u16 family;
+	__u16 ext;
+	union {
+		__u32 remote_ipv4;
+		__u32 remote_ipv6[4];
+	};
+};
+
+struct bpf_tcp_sock {
+	__u32 snd_cwnd;
+	__u32 srtt_us;
+	__u32 rtt_min;
+	__u32 snd_ssthresh;
+	__u32 rcv_nxt;
+	__u32 snd_nxt;
+	__u32 snd_una;
+	__u32 mss_cache;
+	__u32 ecn_flags;
+	__u32 rate_delivered;
+	__u32 rate_interval_us;
+	__u32 packets_out;
+	__u32 retrans_out;
+	__u32 total_retrans;
+	__u32 segs_in;
+	__u32 data_segs_in;
+	__u32 segs_out;
+	__u32 data_segs_out;
+	__u32 lost_out;
+	__u32 sacked_out;
+	__u64 bytes_received;
+	__u64 bytes_acked;
+	__u32 dsack_dups;
+	__u32 delivered;
+	__u32 delivered_ce;
+	__u32 icsk_retransmits;
+};
+
+struct bpf_sock_tuple {
+	union {
+		struct {
+			__be32 saddr;
+			__be32 daddr;
+			__be16 sport;
+			__be16 dport;
+		} ipv4;
+		struct {
+			__be32 saddr[4];
+			__be32 daddr[4];
+			__be16 sport;
+			__be16 dport;
+		} ipv6;
+	};
+};
+
+struct bpf_xdp_sock {
+	__u32 queue_id;
+};
+
+enum {
+	TCP_BPF_IW = 1001,
+	TCP_BPF_SNDCWND_CLAMP = 1002,
+	TCP_BPF_DELACK_MAX = 1003,
+	TCP_BPF_RTO_MIN = 1004,
+	TCP_BPF_SYN = 1005,
+	TCP_BPF_SYN_IP = 1006,
+	TCP_BPF_SYN_MAC = 1007,
+	TCP_BPF_SOCK_OPS_CB_FLAGS = 1008,
+};
+
+enum {
+	BPF_LOAD_HDR_OPT_TCP_SYN = 1,
+};
+
+enum {
+	BPF_FIB_LOOKUP_DIRECT = 1,
+	BPF_FIB_LOOKUP_OUTPUT = 2,
+	BPF_FIB_LOOKUP_SKIP_NEIGH = 4,
+	BPF_FIB_LOOKUP_TBID = 8,
+	BPF_FIB_LOOKUP_SRC = 16,
+	BPF_FIB_LOOKUP_MARK = 32,
+};
+
+enum {
+	BPF_FIB_LKUP_RET_SUCCESS = 0,
+	BPF_FIB_LKUP_RET_BLACKHOLE = 1,
+	BPF_FIB_LKUP_RET_UNREACHABLE = 2,
+	BPF_FIB_LKUP_RET_PROHIBIT = 3,
+	BPF_FIB_LKUP_RET_NOT_FWDED = 4,
+	BPF_FIB_LKUP_RET_FWD_DISABLED = 5,
+	BPF_FIB_LKUP_RET_UNSUPP_LWT = 6,
+	BPF_FIB_LKUP_RET_NO_NEIGH = 7,
+	BPF_FIB_LKUP_RET_FRAG_NEEDED = 8,
+	BPF_FIB_LKUP_RET_NO_SRC_ADDR = 9,
+};
+
+struct bpf_fib_lookup {
+	__u8 family;
+	__u8 l4_protocol;
+	__be16 sport;
+	__be16 dport;
+	union {
+		__u16 tot_len;
+		__u16 mtu_result;
+	};
+	__u32 ifindex;
+	union {
+		__u8 tos;
+		__be32 flowinfo;
+		__u32 rt_metric;
+	};
+	union {
+		__be32 ipv4_src;
+		__u32 ipv6_src[4];
+	};
+	union {
+		__be32 ipv4_dst;
+		__u32 ipv6_dst[4];
+	};
+	union {
+		struct {
+			__be16 h_vlan_proto;
+			__be16 h_vlan_TCI;
+		};
+		__u32 tbid;
+	};
+	union {
+		struct {
+			__u32 mark;
+		};
+		struct {
+			__u8 smac[6];
+			__u8 dmac[6];
+		};
+	};
+};
+
+struct bpf_redir_neigh {
+	__u32 nh_family;
+	union {
+		__be32 ipv4_nh;
+		__u32 ipv6_nh[4];
+	};
+};
+
+enum bpf_check_mtu_flags {
+	BPF_MTU_CHK_SEGS = 1,
+};
+
+enum bpf_check_mtu_ret {
+	BPF_MTU_CHK_RET_SUCCESS = 0,
+	BPF_MTU_CHK_RET_FRAG_NEEDED = 1,
+	BPF_MTU_CHK_RET_SEGS_TOOBIG = 2,
+};
+
+struct compat_sock_fprog {
+	u16 len;
+	compat_uptr_t filter;
+};
+
+struct udp6_sock {
+	struct udp_sock udp;
+	struct ipv6_pinfo inet6;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct tcp6_sock {
+	struct tcp_sock tcp;
+	struct ipv6_pinfo inet6;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct ipv6_bpf_stub {
+	int (*inet6_bind)(struct sock *, struct sockaddr *, int, u32);
+	struct sock * (*udp6_lib_lookup)(const struct net *, const struct in6_addr *, __be16, const struct in6_addr *, __be16, int, int, struct udp_table *, struct sk_buff *);
+	int (*ipv6_setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
+	int (*ipv6_getsockopt)(struct sock *, int, int, sockptr_t, sockptr_t);
+	int (*ipv6_dev_get_saddr)(struct net *, const struct net_device *, const struct in6_addr *, unsigned int, struct in6_addr *);
+};
+
+struct bpf_tcp_req_attrs {
+	u32 rcv_tsval;
+	u32 rcv_tsecr;
+	u16 mss;
+	u8 rcv_wscale;
+	u8 snd_wscale;
+	u8 ecn_ok;
+	u8 wscale_ok;
+	u8 sack_ok;
+	u8 tstamp_ok;
+	u8 usec_ts_ok;
+	u8 reserved[3];
+};
+
+struct tls_msg {
+	u8 control;
+};
+
+struct sk_skb_cb {
+	unsigned char data[20];
+	unsigned char pad[4];
+	struct _strp_msg strp;
+	struct tls_msg tls;
+	u64 temp_reg;
+};
+
+enum {
+	SEG6_LOCAL_ACTION_UNSPEC = 0,
+	SEG6_LOCAL_ACTION_END = 1,
+	SEG6_LOCAL_ACTION_END_X = 2,
+	SEG6_LOCAL_ACTION_END_T = 3,
+	SEG6_LOCAL_ACTION_END_DX2 = 4,
+	SEG6_LOCAL_ACTION_END_DX6 = 5,
+	SEG6_LOCAL_ACTION_END_DX4 = 6,
+	SEG6_LOCAL_ACTION_END_DT6 = 7,
+	SEG6_LOCAL_ACTION_END_DT4 = 8,
+	SEG6_LOCAL_ACTION_END_B6 = 9,
+	SEG6_LOCAL_ACTION_END_B6_ENCAP = 10,
+	SEG6_LOCAL_ACTION_END_BM = 11,
+	SEG6_LOCAL_ACTION_END_S = 12,
+	SEG6_LOCAL_ACTION_END_AS = 13,
+	SEG6_LOCAL_ACTION_END_AM = 14,
+	SEG6_LOCAL_ACTION_END_BPF = 15,
+	SEG6_LOCAL_ACTION_END_DT46 = 16,
+	__SEG6_LOCAL_ACTION_MAX = 17,
+};
+
+struct seg6_bpf_srh_state {
+	local_lock_t bh_lock;
+	struct ipv6_sr_hdr *srh;
+	u16 hdrlen;
+	bool valid;
+};
+
+struct tls_strparser {
+	struct sock *sk;
+	u32 mark: 8;
+	u32 stopped: 1;
+	u32 copy_mode: 1;
+	u32 mixed_decrypted: 1;
+	bool msg_ready;
+	struct strp_msg stm;
+	struct sk_buff *anchor;
+	struct work_struct work;
+};
+
+struct tls_sw_context_rx {
+	struct crypto_aead *aead_recv;
+	struct crypto_wait async_wait;
+	struct sk_buff_head rx_list;
+	void (*saved_data_ready)(struct sock *);
+	u8 reader_present;
+	u8 async_capable: 1;
+	u8 zc_capable: 1;
+	u8 reader_contended: 1;
+	struct tls_strparser strp;
+	atomic_t decrypt_pending;
+	struct sk_buff_head async_hold;
+	struct wait_queue_head wq;
+};
+
+struct nf_conn___init {
+	struct nf_conn ct;
+};
+
+typedef u64 (*btf_bpf_skb_get_pay_offset)(struct sk_buff *);
+
+typedef u64 (*btf_bpf_skb_get_nlattr)(struct sk_buff *, u32, u32);
+
+typedef u64 (*btf_bpf_skb_get_nlattr_nest)(struct sk_buff *, u32, u32);
+
+typedef u64 (*btf_bpf_skb_load_helper_8)(const struct sk_buff *, const void *, int, int);
+
+typedef u64 (*btf_bpf_skb_load_helper_8_no_cache)(const struct sk_buff *, int);
+
+typedef u64 (*btf_bpf_skb_load_helper_16)(const struct sk_buff *, const void *, int, int);
+
+typedef u64 (*btf_bpf_skb_load_helper_16_no_cache)(const struct sk_buff *, int);
+
+typedef u64 (*btf_bpf_skb_load_helper_32)(const struct sk_buff *, const void *, int, int);
+
+typedef u64 (*btf_bpf_skb_load_helper_32_no_cache)(const struct sk_buff *, int);
+
+struct bpf_scratchpad {
+	union {
+		__be32 diff[128];
+		u8 buff[512];
+	};
+	local_lock_t bh_lock;
+};
+
+typedef u64 (*btf_bpf_skb_store_bytes)(struct sk_buff *, u32, const void *, u32, u64);
+
+typedef u64 (*btf_bpf_skb_load_bytes)(const struct sk_buff *, u32, void *, u32);
+
+typedef u64 (*btf_bpf_flow_dissector_load_bytes)(const struct bpf_flow_dissector *, u32, void *, u32);
+
+typedef u64 (*btf_bpf_skb_load_bytes_relative)(const struct sk_buff *, u32, void *, u32, u32);
+
+typedef u64 (*btf_bpf_skb_pull_data)(struct sk_buff *, u32);
+
+typedef u64 (*btf_bpf_sk_fullsock)(struct sock *);
+
+typedef u64 (*btf_sk_skb_pull_data)(struct sk_buff *, u32);
+
+typedef u64 (*btf_bpf_l3_csum_replace)(struct sk_buff *, u32, u64, u64, u64);
+
+typedef u64 (*btf_bpf_l4_csum_replace)(struct sk_buff *, u32, u64, u64, u64);
+
+typedef u64 (*btf_bpf_csum_diff)(__be32 *, u32, __be32 *, u32, __wsum);
+
+typedef u64 (*btf_bpf_csum_update)(struct sk_buff *, __wsum);
+
+typedef u64 (*btf_bpf_csum_level)(struct sk_buff *, u64);
+
+enum {
+	BPF_F_NEIGH = 65536,
+	BPF_F_PEER = 131072,
+	BPF_F_NEXTHOP = 262144,
+};
+
+typedef u64 (*btf_bpf_clone_redirect)(struct sk_buff *, u32, u64);
+
+typedef u64 (*btf_bpf_redirect)(u32, u64);
+
+typedef u64 (*btf_bpf_redirect_peer)(u32, u64);
+
+typedef u64 (*btf_bpf_redirect_neigh)(u32, struct bpf_redir_neigh *, int, u64);
+
+typedef u64 (*btf_bpf_msg_apply_bytes)(struct sk_msg *, u32);
+
+typedef u64 (*btf_bpf_msg_cork_bytes)(struct sk_msg *, u32);
+
+typedef u64 (*btf_bpf_msg_pull_data)(struct sk_msg *, u32, u32, u64);
+
+typedef u64 (*btf_bpf_msg_push_data)(struct sk_msg *, u32, u32, u64);
+
+typedef u64 (*btf_bpf_msg_pop_data)(struct sk_msg *, u32, u32, u64);
+
+typedef u64 (*btf_bpf_get_cgroup_classid_curr)();
+
+typedef u64 (*btf_bpf_skb_cgroup_classid)(const struct sk_buff *);
+
+typedef u64 (*btf_bpf_get_cgroup_classid)(const struct sk_buff *);
+
+typedef u64 (*btf_bpf_get_route_realm)(const struct sk_buff *);
+
+typedef u64 (*btf_bpf_get_hash_recalc)(struct sk_buff *);
+
+typedef u64 (*btf_bpf_set_hash_invalid)(struct sk_buff *);
+
+typedef u64 (*btf_bpf_set_hash)(struct sk_buff *, u32);
+
+typedef u64 (*btf_bpf_skb_vlan_push)(struct sk_buff *, __be16, u16);
+
+typedef u64 (*btf_bpf_skb_vlan_pop)(struct sk_buff *);
+
+typedef u64 (*btf_bpf_skb_change_proto)(struct sk_buff *, __be16, u64);
+
+typedef u64 (*btf_bpf_skb_change_type)(struct sk_buff *, u32);
+
+typedef u64 (*btf_sk_skb_adjust_room)(struct sk_buff *, s32, u32, u64);
+
+typedef u64 (*btf_bpf_skb_adjust_room)(struct sk_buff *, s32, u32, u64);
+
+typedef u64 (*btf_bpf_skb_change_tail)(struct sk_buff *, u32, u64);
+
+typedef u64 (*btf_sk_skb_change_tail)(struct sk_buff *, u32, u64);
+
+typedef u64 (*btf_bpf_skb_change_head)(struct sk_buff *, u32, u64);
+
+typedef u64 (*btf_sk_skb_change_head)(struct sk_buff *, u32, u64);
+
+typedef u64 (*btf_bpf_xdp_get_buff_len)(struct xdp_buff *);
+
+typedef u64 (*btf_bpf_xdp_adjust_head)(struct xdp_buff *, int);
+
+typedef u64 (*btf_bpf_xdp_load_bytes)(struct xdp_buff *, u32, void *, u32);
+
+typedef u64 (*btf_bpf_xdp_store_bytes)(struct xdp_buff *, u32, void *, u32);
+
+typedef u64 (*btf_bpf_xdp_adjust_tail)(struct xdp_buff *, int);
+
+typedef u64 (*btf_bpf_xdp_adjust_meta)(struct xdp_buff *, int);
+
+typedef u64 (*btf_bpf_xdp_redirect)(u32, u64);
+
+typedef u64 (*btf_bpf_xdp_redirect_map)(struct bpf_map *, u64, u64);
+
+typedef u64 (*btf_bpf_skb_event_output)(struct sk_buff *, struct bpf_map *, u64, void *, u64);
+
+typedef u64 (*btf_bpf_skb_get_tunnel_key)(struct sk_buff *, struct bpf_tunnel_key *, u32, u64);
+
+typedef u64 (*btf_bpf_skb_get_tunnel_opt)(struct sk_buff *, u8 *, u32);
+
+typedef u64 (*btf_bpf_skb_set_tunnel_key)(struct sk_buff *, const struct bpf_tunnel_key *, u32, u64);
+
+typedef u64 (*btf_bpf_skb_set_tunnel_opt)(struct sk_buff *, const u8 *, u32);
+
+typedef u64 (*btf_bpf_skb_under_cgroup)(struct sk_buff *, struct bpf_map *, u32);
+
+typedef u64 (*btf_bpf_skb_cgroup_id)(const struct sk_buff *);
+
+typedef u64 (*btf_bpf_skb_ancestor_cgroup_id)(const struct sk_buff *, int);
+
+typedef u64 (*btf_bpf_sk_cgroup_id)(struct sock *);
+
+typedef u64 (*btf_bpf_sk_ancestor_cgroup_id)(struct sock *, int);
+
+typedef u64 (*btf_bpf_xdp_event_output)(struct xdp_buff *, struct bpf_map *, u64, void *, u64);
+
+typedef u64 (*btf_bpf_get_socket_cookie)(struct sk_buff *);
+
+typedef u64 (*btf_bpf_get_socket_cookie_sock_addr)(struct bpf_sock_addr_kern *);
+
+typedef u64 (*btf_bpf_get_socket_cookie_sock)(struct sock *);
+
+typedef u64 (*btf_bpf_get_socket_ptr_cookie)(struct sock *);
+
+typedef u64 (*btf_bpf_get_socket_cookie_sock_ops)(struct bpf_sock_ops_kern *);
+
+typedef u64 (*btf_bpf_get_netns_cookie_sock)(struct sock *);
+
+typedef u64 (*btf_bpf_get_netns_cookie_sock_addr)(struct bpf_sock_addr_kern *);
+
+typedef u64 (*btf_bpf_get_netns_cookie_sock_ops)(struct bpf_sock_ops_kern *);
+
+typedef u64 (*btf_bpf_get_netns_cookie_sk_msg)(struct sk_msg *);
+
+typedef u64 (*btf_bpf_get_socket_uid)(struct sk_buff *);
+
+typedef u64 (*btf_bpf_sk_setsockopt)(struct sock *, int, int, char *, int);
+
+typedef u64 (*btf_bpf_sk_getsockopt)(struct sock *, int, int, char *, int);
+
+typedef u64 (*btf_bpf_unlocked_sk_setsockopt)(struct sock *, int, int, char *, int);
+
+typedef u64 (*btf_bpf_unlocked_sk_getsockopt)(struct sock *, int, int, char *, int);
+
+typedef u64 (*btf_bpf_sock_addr_setsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);
+
+typedef u64 (*btf_bpf_sock_addr_getsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);
+
+typedef u64 (*btf_bpf_sock_ops_setsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);
+
+typedef u64 (*btf_bpf_sock_ops_getsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);
+
+typedef u64 (*btf_bpf_sock_ops_cb_flags_set)(struct bpf_sock_ops_kern *, int);
+
+typedef u64 (*btf_bpf_bind)(struct bpf_sock_addr_kern *, struct sockaddr *, int);
+
+typedef u64 (*btf_bpf_skb_get_xfrm_state)(struct sk_buff *, u32, struct bpf_xfrm_state *, u32, u64);
+
+typedef u64 (*btf_bpf_xdp_fib_lookup)(struct xdp_buff *, struct bpf_fib_lookup *, int, u32);
+
+typedef u64 (*btf_bpf_skb_fib_lookup)(struct sk_buff *, struct bpf_fib_lookup *, int, u32);
+
+typedef u64 (*btf_bpf_skb_check_mtu)(struct sk_buff *, u32, u32 *, s32, u64);
+
+typedef u64 (*btf_bpf_xdp_check_mtu)(struct xdp_buff *, u32, u32 *, s32, u64);
+
+typedef u64 (*btf_bpf_lwt_in_push_encap)(struct sk_buff *, u32, void *, u32);
+
+typedef u64 (*btf_bpf_lwt_xmit_push_encap)(struct sk_buff *, u32, void *, u32);
+
+typedef u64 (*btf_bpf_lwt_seg6_store_bytes)(struct sk_buff *, u32, const void *, u32);
+
+typedef u64 (*btf_bpf_lwt_seg6_action)(struct sk_buff *, u32, void *, u32);
+
+typedef u64 (*btf_bpf_lwt_seg6_adjust_srh)(struct sk_buff *, u32, s32);
+
+typedef u64 (*btf_bpf_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);
+
+typedef u64 (*btf_bpf_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);
+
+typedef u64 (*btf_bpf_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);
+
+typedef u64 (*btf_bpf_tc_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);
+
+typedef u64 (*btf_bpf_tc_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);
+
+typedef u64 (*btf_bpf_tc_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);
+
+typedef u64 (*btf_bpf_sk_release)(struct sock *);
+
+typedef u64 (*btf_bpf_xdp_sk_lookup_udp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);
+
+typedef u64 (*btf_bpf_xdp_skc_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);
+
+typedef u64 (*btf_bpf_xdp_sk_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);
+
+typedef u64 (*btf_bpf_sock_addr_skc_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);
+
+typedef u64 (*btf_bpf_sock_addr_sk_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);
+
+typedef u64 (*btf_bpf_sock_addr_sk_lookup_udp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);
+
+typedef u64 (*btf_bpf_tcp_sock)(struct sock *);
+
+typedef u64 (*btf_bpf_get_listener_sock)(struct sock *);
+
+typedef u64 (*btf_bpf_skb_ecn_set_ce)(struct sk_buff *);
+
+typedef u64 (*btf_bpf_tcp_check_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);
+
+typedef u64 (*btf_bpf_tcp_gen_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);
+
+typedef u64 (*btf_bpf_sk_assign)(struct sk_buff *, struct sock *, u64);
+
+typedef u64 (*btf_bpf_sock_ops_load_hdr_opt)(struct bpf_sock_ops_kern *, void *, u32, u64);
+
+typedef u64 (*btf_bpf_sock_ops_store_hdr_opt)(struct bpf_sock_ops_kern *, const void *, u32, u64);
+
+typedef u64 (*btf_bpf_sock_ops_reserve_hdr_opt)(struct bpf_sock_ops_kern *, u32, u64);
+
+typedef u64 (*btf_bpf_skb_set_tstamp)(struct sk_buff *, u64, u32);
+
+typedef u64 (*btf_bpf_tcp_raw_gen_syncookie_ipv4)(struct iphdr *, struct tcphdr *, u32);
+
+typedef u64 (*btf_bpf_tcp_raw_gen_syncookie_ipv6)(struct ipv6hdr *, struct tcphdr *, u32);
+
+typedef u64 (*btf_bpf_tcp_raw_check_syncookie_ipv4)(struct iphdr *, struct tcphdr *);
+
+typedef u64 (*btf_bpf_tcp_raw_check_syncookie_ipv6)(struct ipv6hdr *, struct tcphdr *);
+
+typedef u64 (*btf_sk_select_reuseport)(struct sk_reuseport_kern *, struct bpf_map *, void *, u32);
+
+typedef u64 (*btf_sk_reuseport_load_bytes)(const struct sk_reuseport_kern *, u32, void *, u32);
+
+typedef u64 (*btf_sk_reuseport_load_bytes_relative)(const struct sk_reuseport_kern *, u32, void *, u32, u32);
+
+typedef u64 (*btf_bpf_sk_lookup_assign)(struct bpf_sk_lookup_kern *, struct sock *, u64);
+
+typedef u64 (*btf_bpf_skc_to_tcp6_sock)(struct sock *);
+
+typedef u64 (*btf_bpf_skc_to_tcp_sock)(struct sock *);
+
+typedef u64 (*btf_bpf_skc_to_tcp_timewait_sock)(struct sock *);
+
+typedef u64 (*btf_bpf_skc_to_tcp_request_sock)(struct sock *);
+
+typedef u64 (*btf_bpf_skc_to_udp6_sock)(struct sock *);
+
+typedef u64 (*btf_bpf_skc_to_unix_sock)(struct sock *);
+
+typedef u64 (*btf_bpf_skc_to_mptcp_sock)(struct sock *);
+
+typedef u64 (*btf_bpf_sock_from_file)(struct file *);
+
+enum netdev_xdp_act {
+	NETDEV_XDP_ACT_BASIC = 1,
+	NETDEV_XDP_ACT_REDIRECT = 2,
+	NETDEV_XDP_ACT_NDO_XMIT = 4,
+	NETDEV_XDP_ACT_XSK_ZEROCOPY = 8,
+	NETDEV_XDP_ACT_HW_OFFLOAD = 16,
+	NETDEV_XDP_ACT_RX_SG = 32,
+	NETDEV_XDP_ACT_NDO_XMIT_SG = 64,
+	NETDEV_XDP_ACT_MASK = 127,
+};
+
+enum netdev_xdp_rx_metadata {
+	NETDEV_XDP_RX_METADATA_TIMESTAMP = 1,
+	NETDEV_XDP_RX_METADATA_HASH = 2,
+	NETDEV_XDP_RX_METADATA_VLAN_TAG = 4,
+};
+
+enum netdev_xsk_flags {
+	NETDEV_XSK_FLAGS_TX_TIMESTAMP = 1,
+	NETDEV_XSK_FLAGS_TX_CHECKSUM = 2,
+};
+
+enum netdev_qstats_scope {
+	NETDEV_QSTATS_SCOPE_QUEUE = 1,
+};
+
+enum {
+	NETDEV_A_DEV_IFINDEX = 1,
+	NETDEV_A_DEV_PAD = 2,
+	NETDEV_A_DEV_XDP_FEATURES = 3,
+	NETDEV_A_DEV_XDP_ZC_MAX_SEGS = 4,
+	NETDEV_A_DEV_XDP_RX_METADATA_FEATURES = 5,
+	NETDEV_A_DEV_XSK_FEATURES = 6,
+	__NETDEV_A_DEV_MAX = 7,
+	NETDEV_A_DEV_MAX = 6,
+};
+
+enum {
+	NETDEV_A_PAGE_POOL_ID = 1,
+	NETDEV_A_PAGE_POOL_IFINDEX = 2,
+	NETDEV_A_PAGE_POOL_NAPI_ID = 3,
+	NETDEV_A_PAGE_POOL_INFLIGHT = 4,
+	NETDEV_A_PAGE_POOL_INFLIGHT_MEM = 5,
+	NETDEV_A_PAGE_POOL_DETACH_TIME = 6,
+	NETDEV_A_PAGE_POOL_DMABUF = 7,
+	__NETDEV_A_PAGE_POOL_MAX = 8,
+	NETDEV_A_PAGE_POOL_MAX = 7,
+};
+
+enum {
+	NETDEV_A_NAPI_IFINDEX = 1,
+	NETDEV_A_NAPI_ID = 2,
+	NETDEV_A_NAPI_IRQ = 3,
+	NETDEV_A_NAPI_PID = 4,
+	__NETDEV_A_NAPI_MAX = 5,
+	NETDEV_A_NAPI_MAX = 4,
+};
+
+enum {
+	NETDEV_A_QUEUE_ID = 1,
+	NETDEV_A_QUEUE_IFINDEX = 2,
+	NETDEV_A_QUEUE_TYPE = 3,
+	NETDEV_A_QUEUE_NAPI_ID = 4,
+	NETDEV_A_QUEUE_DMABUF = 5,
+	__NETDEV_A_QUEUE_MAX = 6,
+	NETDEV_A_QUEUE_MAX = 5,
+};
+
+enum {
+	NETDEV_A_QSTATS_IFINDEX = 1,
+	NETDEV_A_QSTATS_QUEUE_TYPE = 2,
+	NETDEV_A_QSTATS_QUEUE_ID = 3,
+	NETDEV_A_QSTATS_SCOPE = 4,
+	NETDEV_A_QSTATS_RX_PACKETS = 8,
+	NETDEV_A_QSTATS_RX_BYTES = 9,
+	NETDEV_A_QSTATS_TX_PACKETS = 10,
+	NETDEV_A_QSTATS_TX_BYTES = 11,
+	NETDEV_A_QSTATS_RX_ALLOC_FAIL = 12,
+	NETDEV_A_QSTATS_RX_HW_DROPS = 13,
+	NETDEV_A_QSTATS_RX_HW_DROP_OVERRUNS = 14,
+	NETDEV_A_QSTATS_RX_CSUM_COMPLETE = 15,
+	NETDEV_A_QSTATS_RX_CSUM_UNNECESSARY = 16,
+	NETDEV_A_QSTATS_RX_CSUM_NONE = 17,
+	NETDEV_A_QSTATS_RX_CSUM_BAD = 18,
+	NETDEV_A_QSTATS_RX_HW_GRO_PACKETS = 19,
+	NETDEV_A_QSTATS_RX_HW_GRO_BYTES = 20,
+	NETDEV_A_QSTATS_RX_HW_GRO_WIRE_PACKETS = 21,
+	NETDEV_A_QSTATS_RX_HW_GRO_WIRE_BYTES = 22,
+	NETDEV_A_QSTATS_RX_HW_DROP_RATELIMITS = 23,
+	NETDEV_A_QSTATS_TX_HW_DROPS = 24,
+	NETDEV_A_QSTATS_TX_HW_DROP_ERRORS = 25,
+	NETDEV_A_QSTATS_TX_CSUM_NONE = 26,
+	NETDEV_A_QSTATS_TX_NEEDS_CSUM = 27,
+	NETDEV_A_QSTATS_TX_HW_GSO_PACKETS = 28,
+	NETDEV_A_QSTATS_TX_HW_GSO_BYTES = 29,
+	NETDEV_A_QSTATS_TX_HW_GSO_WIRE_PACKETS = 30,
+	NETDEV_A_QSTATS_TX_HW_GSO_WIRE_BYTES = 31,
+	NETDEV_A_QSTATS_TX_HW_DROP_RATELIMITS = 32,
+	NETDEV_A_QSTATS_TX_STOP = 33,
+	NETDEV_A_QSTATS_TX_WAKE = 34,
+	__NETDEV_A_QSTATS_MAX = 35,
+	NETDEV_A_QSTATS_MAX = 34,
+};
+
+enum {
+	NETDEV_A_DMABUF_IFINDEX = 1,
+	NETDEV_A_DMABUF_QUEUES = 2,
+	NETDEV_A_DMABUF_FD = 3,
+	NETDEV_A_DMABUF_ID = 4,
+	__NETDEV_A_DMABUF_MAX = 5,
+	NETDEV_A_DMABUF_MAX = 4,
+};
+
+enum {
+	NETDEV_CMD_DEV_GET = 1,
+	NETDEV_CMD_DEV_ADD_NTF = 2,
+	NETDEV_CMD_DEV_DEL_NTF = 3,
+	NETDEV_CMD_DEV_CHANGE_NTF = 4,
+	NETDEV_CMD_PAGE_POOL_GET = 5,
+	NETDEV_CMD_PAGE_POOL_ADD_NTF = 6,
+	NETDEV_CMD_PAGE_POOL_DEL_NTF = 7,
+	NETDEV_CMD_PAGE_POOL_CHANGE_NTF = 8,
+	NETDEV_CMD_PAGE_POOL_STATS_GET = 9,
+	NETDEV_CMD_QUEUE_GET = 10,
+	NETDEV_CMD_NAPI_GET = 11,
+	NETDEV_CMD_QSTATS_GET = 12,
+	NETDEV_CMD_BIND_RX = 13,
+	__NETDEV_CMD_MAX = 14,
+	NETDEV_CMD_MAX = 13,
+};
+
+struct netdev_queue_stats_rx {
+	u64 bytes;
+	u64 packets;
+	u64 alloc_fail;
+	u64 hw_drops;
+	u64 hw_drop_overruns;
+	u64 csum_unnecessary;
+	u64 csum_none;
+	u64 csum_bad;
+	u64 hw_gro_packets;
+	u64 hw_gro_bytes;
+	u64 hw_gro_wire_packets;
+	u64 hw_gro_wire_bytes;
+	u64 hw_drop_ratelimits;
+};
+
+struct netdev_queue_stats_tx {
+	u64 bytes;
+	u64 packets;
+	u64 hw_drops;
+	u64 hw_drop_errors;
+	u64 csum_none;
+	u64 needs_csum;
+	u64 hw_gso_packets;
+	u64 hw_gso_bytes;
+	u64 hw_gso_wire_packets;
+	u64 hw_gso_wire_bytes;
+	u64 hw_drop_ratelimits;
+	u64 stop;
+	u64 wake;
+};
+
+struct net_devmem_dmabuf_binding {
+	struct dma_buf *dmabuf;
+	struct dma_buf_attachment *attachment;
+	struct sg_table *sgt;
+	struct net_device *dev;
+	struct gen_pool *chunk_pool;
+	refcount_t ref;
+	struct list_head list;
+	struct xarray bound_rxqs;
+	u32 id;
+};
+
+enum {
+	NETDEV_NLGRP_MGMT = 0,
+	NETDEV_NLGRP_PAGE_POOL = 1,
+};
+
+struct netdev_nl_dump_ctx {
+	long unsigned int ifindex;
+	unsigned int rxq_idx;
+	unsigned int txq_idx;
+	unsigned int napi_id;
+};
+
+enum {
+	NETDEV_A_PAGE_POOL_STATS_INFO = 1,
+	NETDEV_A_PAGE_POOL_STATS_ALLOC_FAST = 8,
+	NETDEV_A_PAGE_POOL_STATS_ALLOC_SLOW = 9,
+	NETDEV_A_PAGE_POOL_STATS_ALLOC_SLOW_HIGH_ORDER = 10,
+	NETDEV_A_PAGE_POOL_STATS_ALLOC_EMPTY = 11,
+	NETDEV_A_PAGE_POOL_STATS_ALLOC_REFILL = 12,
+	NETDEV_A_PAGE_POOL_STATS_ALLOC_WAIVE = 13,
+	NETDEV_A_PAGE_POOL_STATS_RECYCLE_CACHED = 14,
+	NETDEV_A_PAGE_POOL_STATS_RECYCLE_CACHE_FULL = 15,
+	NETDEV_A_PAGE_POOL_STATS_RECYCLE_RING = 16,
+	NETDEV_A_PAGE_POOL_STATS_RECYCLE_RING_FULL = 17,
+	NETDEV_A_PAGE_POOL_STATS_RECYCLE_RELEASED_REFCNT = 18,
+	__NETDEV_A_PAGE_POOL_STATS_MAX = 19,
+	NETDEV_A_PAGE_POOL_STATS_MAX = 18,
+};
+
+typedef int (*pp_nl_fill_cb)(struct sk_buff *, const struct page_pool *, const struct genl_info *);
+
+struct page_pool_dump_cb {
+	long unsigned int ifindex;
+	u32 pp_id;
+};
+
+enum ethtool_test_flags {
+	ETH_TEST_FL_OFFLINE = 1,
+	ETH_TEST_FL_FAILED = 2,
+	ETH_TEST_FL_EXTERNAL_LB = 4,
+	ETH_TEST_FL_EXTERNAL_LB_DONE = 8,
+};
+
+struct net_packet_attrs {
+	const unsigned char *src;
+	const unsigned char *dst;
+	u32 ip_src;
+	u32 ip_dst;
+	bool tcp;
+	u16 sport;
+	u16 dport;
+	int timeout;
+	int size;
+	int max_size;
+	u8 id;
+	u16 queue_mapping;
+};
+
+struct net_test_priv {
+	struct net_packet_attrs *packet;
+	struct packet_type pt;
+	struct completion comp;
+	int double_vlan;
+	int vlan_id;
+	int ok;
+};
+
+struct netsfhdr {
+	__be32 version;
+	__be64 magic;
+	u8 id;
+} __attribute__((packed));
+
+struct net_test {
+	char name[32];
+	int (*fn)(struct net_device *);
+};
+
+struct sk_psock_link {
+	struct list_head list;
+	struct bpf_map *map;
+	void *link_raw;
+};
+
+struct dmabuf_genpool_chunk_owner {
+	long unsigned int base_virtual;
+	dma_addr_t base_dma_addr;
+	struct net_iov *niovs;
+	size_t num_niovs;
+	struct net_devmem_dmabuf_binding *binding;
+};
+
+enum tc_link_layer {
+	TC_LINKLAYER_UNAWARE = 0,
+	TC_LINKLAYER_ETHERNET = 1,
+	TC_LINKLAYER_ATM = 2,
+};
+
+enum {
+	TCA_STAB_UNSPEC = 0,
+	TCA_STAB_BASE = 1,
+	TCA_STAB_DATA = 2,
+	__TCA_STAB_MAX = 3,
+};
+
+struct qdisc_rate_table {
+	struct tc_ratespec rate;
+	u32 data[256];
+	struct qdisc_rate_table *next;
+	int refcnt;
+};
+
+struct Qdisc_class_common {
+	u32 classid;
+	unsigned int filter_cnt;
+	struct hlist_node hnode;
+};
+
+struct Qdisc_class_hash {
+	struct hlist_head *hash;
+	unsigned int hashsize;
+	unsigned int hashmask;
+	unsigned int hashelems;
+};
+
+struct qdisc_watchdog {
+	struct hrtimer timer;
+	struct Qdisc *qdisc;
+	long: 32;
+};
+
+struct tc_query_caps_base {
+	enum tc_setup_type type;
+	void *caps;
+};
+
+enum tc_root_command {
+	TC_ROOT_GRAFT = 0,
+};
+
+struct tc_root_qopt_offload {
+	enum tc_root_command command;
+	u32 handle;
+	bool ingress;
+};
+
+struct check_loop_arg {
+	struct qdisc_walker w;
+	struct Qdisc *p;
+	int depth;
+};
+
+struct tcf_bind_args {
+	struct tcf_walker w;
+	long unsigned int base;
+	long unsigned int cl;
+	u32 classid;
+};
+
+struct tc_bind_class_args {
+	struct qdisc_walker w;
+	long unsigned int new_cl;
+	u32 portid;
+	u32 clid;
+};
+
+struct qdisc_dump_args {
+	struct qdisc_walker w;
+	struct sk_buff *skb;
+	struct netlink_callback *cb;
+};
+
+struct tc_fifo_qopt {
+	__u32 limit;
+};
+
+struct tc_qopt_offload_stats {
+	struct gnet_stats_basic_sync *bstats;
+	struct gnet_stats_queue *qstats;
+};
+
+enum tc_fifo_command {
+	TC_FIFO_REPLACE = 0,
+	TC_FIFO_DESTROY = 1,
+	TC_FIFO_STATS = 2,
+};
+
+struct tc_fifo_qopt_offload {
+	enum tc_fifo_command command;
+	u32 handle;
+	u32 parent;
+	union {
+		struct tc_qopt_offload_stats stats;
+	};
+};
+
+struct tcf_ematch_tree_hdr {
+	__u16 nmatches;
+	__u16 progid;
+};
+
+enum {
+	TCA_EMATCH_TREE_UNSPEC = 0,
+	TCA_EMATCH_TREE_HDR = 1,
+	TCA_EMATCH_TREE_LIST = 2,
+	__TCA_EMATCH_TREE_MAX = 3,
+};
+
+struct tcf_ematch_hdr {
+	__u16 matchid;
+	__u16 kind;
+	__u16 flags;
+	__u16 pad;
+};
+
+struct tcf_pkt_info {
+	unsigned char *ptr;
+	int nexthdr;
+};
+
+struct tcf_ematch_ops;
+
+struct tcf_ematch {
+	struct tcf_ematch_ops *ops;
+	long unsigned int data;
+	unsigned int datalen;
+	u16 matchid;
+	u16 flags;
+	struct net *net;
+};
+
+struct tcf_ematch_ops {
+	int kind;
+	int datalen;
+	int (*change)(struct net *, void *, int, struct tcf_ematch *);
+	int (*match)(struct sk_buff *, struct tcf_ematch *, struct tcf_pkt_info *);
+	void (*destroy)(struct tcf_ematch *);
+	int (*dump)(struct sk_buff *, struct tcf_ematch *);
+	struct module *owner;
+	struct list_head link;
+};
+
+struct tcf_ematch_tree {
+	struct tcf_ematch_tree_hdr hdr;
+	struct tcf_ematch *matches;
+};
+
+struct bpf_dummy_ops_state {
+	int val;
+};
+
+struct bpf_dummy_ops {
+	int (*test_1)(struct bpf_dummy_ops_state *);
+	int (*test_2)(struct bpf_dummy_ops_state *, int, short unsigned int, char, long unsigned int);
+	int (*test_sleepable)(struct bpf_dummy_ops_state *);
+};
+
+typedef int (*dummy_ops_test_ret_fn)(struct bpf_dummy_ops_state *, ...);
+
+struct bpf_dummy_ops_test_args {
+	u64 args[12];
+	struct bpf_dummy_ops_state state;
+	long: 32;
+};
+
+struct bpf_struct_ops_bpf_dummy_ops {
+	struct bpf_struct_ops_common_value common;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct bpf_dummy_ops data;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+enum {
+	ETHTOOL_A_BITSET_BIT_UNSPEC = 0,
+	ETHTOOL_A_BITSET_BIT_INDEX = 1,
+	ETHTOOL_A_BITSET_BIT_NAME = 2,
+	ETHTOOL_A_BITSET_BIT_VALUE = 3,
+	__ETHTOOL_A_BITSET_BIT_CNT = 4,
+	ETHTOOL_A_BITSET_BIT_MAX = 3,
+};
+
+enum {
+	ETHTOOL_A_BITSET_BITS_UNSPEC = 0,
+	ETHTOOL_A_BITSET_BITS_BIT = 1,
+	__ETHTOOL_A_BITSET_BITS_CNT = 2,
+	ETHTOOL_A_BITSET_BITS_MAX = 1,
+};
+
+enum {
+	ETHTOOL_A_BITSET_UNSPEC = 0,
+	ETHTOOL_A_BITSET_NOMASK = 1,
+	ETHTOOL_A_BITSET_SIZE = 2,
+	ETHTOOL_A_BITSET_BITS = 3,
+	ETHTOOL_A_BITSET_VALUE = 4,
+	ETHTOOL_A_BITSET_MASK = 5,
+	__ETHTOOL_A_BITSET_CNT = 6,
+	ETHTOOL_A_BITSET_MAX = 5,
+};
+
+struct linkmodes_reply_data {
+	struct ethnl_reply_data base;
+	struct ethtool_link_ksettings ksettings;
+	struct ethtool_link_settings *lsettings;
+	bool peer_empty;
+};
+
+struct wol_reply_data {
+	struct ethnl_reply_data base;
+	struct ethtool_wolinfo wol;
+	bool show_sopass;
+};
+
+struct channels_reply_data {
+	struct ethnl_reply_data base;
+	struct ethtool_channels channels;
+};
+
+enum {
+	ETHTOOL_A_CABLE_PAIR_A = 0,
+	ETHTOOL_A_CABLE_PAIR_B = 1,
+	ETHTOOL_A_CABLE_PAIR_C = 2,
+	ETHTOOL_A_CABLE_PAIR_D = 3,
+};
+
+enum {
+	ETHTOOL_A_CABLE_INF_SRC_UNSPEC = 0,
+	ETHTOOL_A_CABLE_INF_SRC_TDR = 1,
+	ETHTOOL_A_CABLE_INF_SRC_ALCD = 2,
+};
+
+enum {
+	ETHTOOL_A_CABLE_RESULT_UNSPEC = 0,
+	ETHTOOL_A_CABLE_RESULT_PAIR = 1,
+	ETHTOOL_A_CABLE_RESULT_CODE = 2,
+	ETHTOOL_A_CABLE_RESULT_SRC = 3,
+	__ETHTOOL_A_CABLE_RESULT_CNT = 4,
+	ETHTOOL_A_CABLE_RESULT_MAX = 3,
+};
+
+enum {
+	ETHTOOL_A_CABLE_FAULT_LENGTH_UNSPEC = 0,
+	ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR = 1,
+	ETHTOOL_A_CABLE_FAULT_LENGTH_CM = 2,
+	ETHTOOL_A_CABLE_FAULT_LENGTH_SRC = 3,
+	__ETHTOOL_A_CABLE_FAULT_LENGTH_CNT = 4,
+	ETHTOOL_A_CABLE_FAULT_LENGTH_MAX = 3,
+};
+
+enum {
+	ETHTOOL_A_CABLE_TEST_NTF_STATUS_UNSPEC = 0,
+	ETHTOOL_A_CABLE_TEST_NTF_STATUS_STARTED = 1,
+	ETHTOOL_A_CABLE_TEST_NTF_STATUS_COMPLETED = 2,
+};
+
+enum {
+	ETHTOOL_A_CABLE_NEST_UNSPEC = 0,
+	ETHTOOL_A_CABLE_NEST_RESULT = 1,
+	ETHTOOL_A_CABLE_NEST_FAULT_LENGTH = 2,
+	__ETHTOOL_A_CABLE_NEST_CNT = 3,
+	ETHTOOL_A_CABLE_NEST_MAX = 2,
+};
+
+enum {
+	ETHTOOL_A_CABLE_TEST_NTF_UNSPEC = 0,
+	ETHTOOL_A_CABLE_TEST_NTF_HEADER = 1,
+	ETHTOOL_A_CABLE_TEST_NTF_STATUS = 2,
+	ETHTOOL_A_CABLE_TEST_NTF_NEST = 3,
+	__ETHTOOL_A_CABLE_TEST_NTF_CNT = 4,
+	ETHTOOL_A_CABLE_TEST_NTF_MAX = 3,
+};
+
+enum {
+	ETHTOOL_A_CABLE_TEST_TDR_CFG_UNSPEC = 0,
+	ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST = 1,
+	ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST = 2,
+	ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP = 3,
+	ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR = 4,
+	__ETHTOOL_A_CABLE_TEST_TDR_CFG_CNT = 5,
+	ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX = 4,
+};
+
+enum {
+	ETHTOOL_A_CABLE_AMPLITUDE_UNSPEC = 0,
+	ETHTOOL_A_CABLE_AMPLITUDE_PAIR = 1,
+	ETHTOOL_A_CABLE_AMPLITUDE_mV = 2,
+	__ETHTOOL_A_CABLE_AMPLITUDE_CNT = 3,
+	ETHTOOL_A_CABLE_AMPLITUDE_MAX = 2,
+};
+
+enum {
+	ETHTOOL_A_CABLE_PULSE_UNSPEC = 0,
+	ETHTOOL_A_CABLE_PULSE_mV = 1,
+	__ETHTOOL_A_CABLE_PULSE_CNT = 2,
+	ETHTOOL_A_CABLE_PULSE_MAX = 1,
+};
+
+enum {
+	ETHTOOL_A_CABLE_STEP_UNSPEC = 0,
+	ETHTOOL_A_CABLE_STEP_FIRST_DISTANCE = 1,
+	ETHTOOL_A_CABLE_STEP_LAST_DISTANCE = 2,
+	ETHTOOL_A_CABLE_STEP_STEP_DISTANCE = 3,
+	__ETHTOOL_A_CABLE_STEP_CNT = 4,
+	ETHTOOL_A_CABLE_STEP_MAX = 3,
+};
+
+enum {
+	ETHTOOL_A_CABLE_TDR_NEST_UNSPEC = 0,
+	ETHTOOL_A_CABLE_TDR_NEST_STEP = 1,
+	ETHTOOL_A_CABLE_TDR_NEST_AMPLITUDE = 2,
+	ETHTOOL_A_CABLE_TDR_NEST_PULSE = 3,
+	__ETHTOOL_A_CABLE_TDR_NEST_CNT = 4,
+	ETHTOOL_A_CABLE_TDR_NEST_MAX = 3,
+};
+
+struct phc_vclocks_reply_data {
+	struct ethnl_reply_data base;
+	int num;
+	int *index;
+};
+
+enum ethtool_c33_pse_ext_state {
+	ETHTOOL_C33_PSE_EXT_STATE_ERROR_CONDITION = 1,
+	ETHTOOL_C33_PSE_EXT_STATE_MR_MPS_VALID = 2,
+	ETHTOOL_C33_PSE_EXT_STATE_MR_PSE_ENABLE = 3,
+	ETHTOOL_C33_PSE_EXT_STATE_OPTION_DETECT_TED = 4,
+	ETHTOOL_C33_PSE_EXT_STATE_OPTION_VPORT_LIM = 5,
+	ETHTOOL_C33_PSE_EXT_STATE_OVLD_DETECTED = 6,
+	ETHTOOL_C33_PSE_EXT_STATE_PD_DLL_POWER_TYPE = 7,
+	ETHTOOL_C33_PSE_EXT_STATE_POWER_NOT_AVAILABLE = 8,
+	ETHTOOL_C33_PSE_EXT_STATE_SHORT_DETECTED = 9,
+};
+
+enum ethtool_c33_pse_ext_substate_error_condition {
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_NON_EXISTING_PORT = 1,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_UNDEFINED_PORT = 2,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_INTERNAL_HW_FAULT = 3,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_COMM_ERROR_AFTER_FORCE_ON = 4,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_UNKNOWN_PORT_STATUS = 5,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_HOST_CRASH_TURN_OFF = 6,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_HOST_CRASH_FORCE_SHUTDOWN = 7,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_CONFIG_CHANGE = 8,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_DETECTED_OVER_TEMP = 9,
+};
+
+enum ethtool_c33_pse_ext_substate_mr_pse_enable {
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_MR_PSE_ENABLE_DISABLE_PIN_ACTIVE = 1,
+};
+
+enum ethtool_c33_pse_ext_substate_option_detect_ted {
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_DETECT_TED_DET_IN_PROCESS = 1,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_DETECT_TED_CONNECTION_CHECK_ERROR = 2,
+};
+
+enum ethtool_c33_pse_ext_substate_option_vport_lim {
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_VPORT_LIM_HIGH_VOLTAGE = 1,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_VPORT_LIM_LOW_VOLTAGE = 2,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_VPORT_LIM_VOLTAGE_INJECTION = 3,
+};
+
+enum ethtool_c33_pse_ext_substate_ovld_detected {
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_OVLD_DETECTED_OVERLOAD = 1,
+};
+
+enum ethtool_c33_pse_ext_substate_power_not_available {
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_BUDGET_EXCEEDED = 1,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_PORT_PW_LIMIT_EXCEEDS_CONTROLLER_BUDGET = 2,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_PD_REQUEST_EXCEEDS_PORT_LIMIT = 3,
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_HW_PW_LIMIT = 4,
+};
+
+enum ethtool_c33_pse_ext_substate_short_detected {
+	ETHTOOL_C33_PSE_EXT_SUBSTATE_SHORT_DETECTED_SHORT_CONDITION = 1,
+};
+
+enum ethtool_c33_pse_admin_state {
+	ETHTOOL_C33_PSE_ADMIN_STATE_UNKNOWN = 1,
+	ETHTOOL_C33_PSE_ADMIN_STATE_DISABLED = 2,
+	ETHTOOL_C33_PSE_ADMIN_STATE_ENABLED = 3,
+};
+
+enum ethtool_c33_pse_pw_d_status {
+	ETHTOOL_C33_PSE_PW_D_STATUS_UNKNOWN = 1,
+	ETHTOOL_C33_PSE_PW_D_STATUS_DISABLED = 2,
+	ETHTOOL_C33_PSE_PW_D_STATUS_SEARCHING = 3,
+	ETHTOOL_C33_PSE_PW_D_STATUS_DELIVERING = 4,
+	ETHTOOL_C33_PSE_PW_D_STATUS_TEST = 5,
+	ETHTOOL_C33_PSE_PW_D_STATUS_FAULT = 6,
+	ETHTOOL_C33_PSE_PW_D_STATUS_OTHERFAULT = 7,
+};
+
+enum ethtool_podl_pse_admin_state {
+	ETHTOOL_PODL_PSE_ADMIN_STATE_UNKNOWN = 1,
+	ETHTOOL_PODL_PSE_ADMIN_STATE_DISABLED = 2,
+	ETHTOOL_PODL_PSE_ADMIN_STATE_ENABLED = 3,
+};
+
+enum ethtool_podl_pse_pw_d_status {
+	ETHTOOL_PODL_PSE_PW_D_STATUS_UNKNOWN = 1,
+	ETHTOOL_PODL_PSE_PW_D_STATUS_DISABLED = 2,
+	ETHTOOL_PODL_PSE_PW_D_STATUS_SEARCHING = 3,
+	ETHTOOL_PODL_PSE_PW_D_STATUS_DELIVERING = 4,
+	ETHTOOL_PODL_PSE_PW_D_STATUS_SLEEP = 5,
+	ETHTOOL_PODL_PSE_PW_D_STATUS_IDLE = 6,
+	ETHTOOL_PODL_PSE_PW_D_STATUS_ERROR = 7,
+};
+
+struct ethtool_c33_pse_ext_state_info {
+	enum ethtool_c33_pse_ext_state c33_pse_ext_state;
+	union {
+		enum ethtool_c33_pse_ext_substate_error_condition error_condition;
+		enum ethtool_c33_pse_ext_substate_mr_pse_enable mr_pse_enable;
+		enum ethtool_c33_pse_ext_substate_option_detect_ted option_detect_ted;
+		enum ethtool_c33_pse_ext_substate_option_vport_lim option_vport_lim;
+		enum ethtool_c33_pse_ext_substate_ovld_detected ovld_detected;
+		enum ethtool_c33_pse_ext_substate_power_not_available power_not_available;
+		enum ethtool_c33_pse_ext_substate_short_detected short_detected;
+		u32 __c33_pse_ext_substate;
+	};
+};
+
+struct ethtool_c33_pse_pw_limit_range {
+	u32 min;
+	u32 max;
+};
+
+struct pse_control_config {
+	enum ethtool_podl_pse_admin_state podl_admin_control;
+	enum ethtool_c33_pse_admin_state c33_admin_control;
+};
+
+struct pse_control_status {
+	enum ethtool_podl_pse_admin_state podl_admin_state;
+	enum ethtool_podl_pse_pw_d_status podl_pw_status;
+	enum ethtool_c33_pse_admin_state c33_admin_state;
+	enum ethtool_c33_pse_pw_d_status c33_pw_status;
+	u32 c33_pw_class;
+	u32 c33_actual_pw;
+	struct ethtool_c33_pse_ext_state_info c33_ext_state_info;
+	u32 c33_avail_pw_limit;
+	struct ethtool_c33_pse_pw_limit_range *c33_pw_limit_ranges;
+	u32 c33_pw_limit_nb_ranges;
+};
+
+enum {
+	ETHTOOL_A_C33_PSE_PW_LIMIT_UNSPEC = 0,
+	ETHTOOL_A_C33_PSE_PW_LIMIT_MIN = 1,
+	ETHTOOL_A_C33_PSE_PW_LIMIT_MAX = 2,
+};
+
+struct pse_reply_data {
+	struct ethnl_reply_data base;
+	struct pse_control_status status;
+};
+
+struct nf_sockopt_ops {
+	struct list_head list;
+	u_int8_t pf;
+	int set_optmin;
+	int set_optmax;
+	int (*set)(struct sock *, int, sockptr_t, unsigned int);
+	int get_optmin;
+	int get_optmax;
+	int (*get)(struct sock *, int, void *, int *);
+	struct module *owner;
+};
+
+enum {
+	INET_FRAG_FIRST_IN = 1,
+	INET_FRAG_LAST_IN = 2,
+	INET_FRAG_COMPLETE = 4,
+	INET_FRAG_HASH_DEAD = 8,
+	INET_FRAG_DROP = 16,
+};
+
+struct ipq {
+	struct inet_frag_queue q;
+	u8 ecn;
+	u16 max_df_size;
+	int iif;
+	unsigned int rid;
+	struct inet_peer *peer;
+};
+
+struct group_req {
+	__u32 gr_interface;
+	struct __kernel_sockaddr_storage gr_group;
+};
+
+struct in_pktinfo {
+	int ipi_ifindex;
+	struct in_addr ipi_spec_dst;
+	struct in_addr ipi_addr;
+};
+
+struct compat_group_req {
+	__u32 gr_interface;
+	struct __kernel_sockaddr_storage gr_group;
+};
+
+struct compat_group_source_req {
+	__u32 gsr_interface;
+	struct __kernel_sockaddr_storage gsr_group;
+	struct __kernel_sockaddr_storage gsr_source;
+};
+
+struct compat_group_filter {
+	union {
+		struct {
+			__u32 gf_interface_aux;
+			struct __kernel_sockaddr_storage gf_group_aux;
+			__u32 gf_fmode_aux;
+			__u32 gf_numsrc_aux;
+			struct __kernel_sockaddr_storage gf_slist[1];
+		};
+		struct {
+			__u32 gf_interface;
+			struct __kernel_sockaddr_storage gf_group;
+			__u32 gf_fmode;
+			__u32 gf_numsrc;
+			struct __kernel_sockaddr_storage gf_slist_flex[0];
+		};
+	};
+};
+
+struct tcp_plb_state {
+	u8 consec_cong_rounds: 5;
+	u8 unused: 3;
+	u32 pause_until;
+} __attribute__((packed));
+
+enum {
+	XFRM_LOOKUP_ICMP = 1,
+	XFRM_LOOKUP_QUEUE = 2,
+	XFRM_LOOKUP_KEEP_DST_REF = 4,
+};
+
+struct icmp_ext_hdr {
+	__u8 reserved1: 4;
+	__u8 version: 4;
+	__u8 reserved2;
+	__sum16 checksum;
+};
+
+struct icmp_extobj_hdr {
+	__be16 length;
+	__u8 class_num;
+	__u8 class_type;
+};
+
+struct icmp_ext_echo_ctype3_hdr {
+	__be16 afi;
+	__u8 addrlen;
+	__u8 reserved;
+};
+
+struct icmp_ext_echo_iio {
+	struct icmp_extobj_hdr extobj_hdr;
+	union {
+		char name[16];
+		__be32 ifindex;
+		struct {
+			struct icmp_ext_echo_ctype3_hdr ctype3_hdr;
+			union {
+				__be32 ipv4_addr;
+				struct in6_addr ipv6_addr;
+			} ip_addr;
+		} addr;
+	} ident;
+};
+
+struct trace_event_raw_icmp_send {
+	struct trace_entry ent;
+	const void *skbaddr;
+	int type;
+	int code;
+	__u8 saddr[4];
+	__u8 daddr[4];
+	__u16 sport;
+	__u16 dport;
+	short unsigned int ulen;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_icmp_send {};
+
+typedef void (*btf_trace_icmp_send)(void *, const struct sk_buff *, int, int);
+
+struct icmp_bxm {
+	struct sk_buff *skb;
+	int offset;
+	int data_len;
+	struct {
+		struct icmphdr icmph;
+		__be32 times[3];
+	} data;
+	int head_len;
+	struct ip_options_data replyopts;
+};
+
+struct icmp_control {
+	enum skb_drop_reason (*handler)(struct sk_buff *);
+	short int error;
+};
+
+struct rtvia {
+	__kernel_sa_family_t rtvia_family;
+	__u8 rtvia_addr[0];
+};
+
+struct fib_result_nl {
+	__be32 fl_addr;
+	u32 fl_mark;
+	unsigned char fl_tos;
+	unsigned char fl_scope;
+	unsigned char tb_id_in;
+	unsigned char tb_id;
+	unsigned char prefixlen;
+	unsigned char nh_sel;
+	unsigned char type;
+	unsigned char scope;
+	int err;
+};
+
+struct ipfrag_skb_cb {
+	union {
+		struct inet_skb_parm h4;
+		struct inet6_skb_parm h6;
+	};
+	struct sk_buff *next_frag;
+	int frag_run_len;
+	int ip_defrag_offset;
+};
+
+struct nhmsg {
+	unsigned char nh_family;
+	unsigned char nh_scope;
+	unsigned char nh_protocol;
+	unsigned char resvd;
+	unsigned int nh_flags;
+};
+
+struct nexthop_grp {
+	__u32 id;
+	__u8 weight;
+	__u8 weight_high;
+	__u16 resvd2;
+};
+
+enum {
+	NEXTHOP_GRP_TYPE_MPATH = 0,
+	NEXTHOP_GRP_TYPE_RES = 1,
+	__NEXTHOP_GRP_TYPE_MAX = 2,
+};
+
+enum {
+	NHA_UNSPEC = 0,
+	NHA_ID = 1,
+	NHA_GROUP = 2,
+	NHA_GROUP_TYPE = 3,
+	NHA_BLACKHOLE = 4,
+	NHA_OIF = 5,
+	NHA_GATEWAY = 6,
+	NHA_ENCAP_TYPE = 7,
+	NHA_ENCAP = 8,
+	NHA_GROUPS = 9,
+	NHA_MASTER = 10,
+	NHA_FDB = 11,
+	NHA_RES_GROUP = 12,
+	NHA_RES_BUCKET = 13,
+	NHA_OP_FLAGS = 14,
+	NHA_GROUP_STATS = 15,
+	NHA_HW_STATS_ENABLE = 16,
+	NHA_HW_STATS_USED = 17,
+	__NHA_MAX = 18,
+};
+
+enum {
+	NHA_RES_GROUP_UNSPEC = 0,
+	NHA_RES_GROUP_PAD = 0,
+	NHA_RES_GROUP_BUCKETS = 1,
+	NHA_RES_GROUP_IDLE_TIMER = 2,
+	NHA_RES_GROUP_UNBALANCED_TIMER = 3,
+	NHA_RES_GROUP_UNBALANCED_TIME = 4,
+	__NHA_RES_GROUP_MAX = 5,
+};
+
+enum {
+	NHA_RES_BUCKET_UNSPEC = 0,
+	NHA_RES_BUCKET_PAD = 0,
+	NHA_RES_BUCKET_INDEX = 1,
+	NHA_RES_BUCKET_IDLE_TIME = 2,
+	NHA_RES_BUCKET_NH_ID = 3,
+	__NHA_RES_BUCKET_MAX = 4,
+};
+
+enum {
+	NHA_GROUP_STATS_UNSPEC = 0,
+	NHA_GROUP_STATS_ENTRY = 1,
+	__NHA_GROUP_STATS_MAX = 2,
+};
+
+enum {
+	NHA_GROUP_STATS_ENTRY_UNSPEC = 0,
+	NHA_GROUP_STATS_ENTRY_ID = 1,
+	NHA_GROUP_STATS_ENTRY_PACKETS = 2,
+	NHA_GROUP_STATS_ENTRY_PACKETS_HW = 3,
+	__NHA_GROUP_STATS_ENTRY_MAX = 4,
+};
+
+struct nh_config {
+	u32 nh_id;
+	u8 nh_family;
+	u8 nh_protocol;
+	u8 nh_blackhole;
+	u8 nh_fdb;
+	u32 nh_flags;
+	int nh_ifindex;
+	struct net_device *dev;
+	union {
+		__be32 ipv4;
+		struct in6_addr ipv6;
+	} gw;
+	struct nlattr *nh_grp;
+	u16 nh_grp_type;
+	u16 nh_grp_res_num_buckets;
+	long unsigned int nh_grp_res_idle_timer;
+	long unsigned int nh_grp_res_unbalanced_timer;
+	bool nh_grp_res_has_num_buckets;
+	bool nh_grp_res_has_idle_timer;
+	bool nh_grp_res_has_unbalanced_timer;
+	bool nh_hw_stats;
+	struct nlattr *nh_encap;
+	u16 nh_encap_type;
+	u32 nlflags;
+	struct nl_info nlinfo;
+};
+
+enum nexthop_event_type {
+	NEXTHOP_EVENT_DEL = 0,
+	NEXTHOP_EVENT_REPLACE = 1,
+	NEXTHOP_EVENT_RES_TABLE_PRE_REPLACE = 2,
+	NEXTHOP_EVENT_BUCKET_REPLACE = 3,
+	NEXTHOP_EVENT_HW_STATS_REPORT_DELTA = 4,
+};
+
+enum nh_notifier_info_type {
+	NH_NOTIFIER_INFO_TYPE_SINGLE = 0,
+	NH_NOTIFIER_INFO_TYPE_GRP = 1,
+	NH_NOTIFIER_INFO_TYPE_RES_TABLE = 2,
+	NH_NOTIFIER_INFO_TYPE_RES_BUCKET = 3,
+	NH_NOTIFIER_INFO_TYPE_GRP_HW_STATS = 4,
+};
+
+struct nh_notifier_single_info {
+	struct net_device *dev;
+	u8 gw_family;
+	union {
+		__be32 ipv4;
+		struct in6_addr ipv6;
+	};
+	u32 id;
+	u8 is_reject: 1;
+	u8 is_fdb: 1;
+	u8 has_encap: 1;
+};
+
+struct nh_notifier_grp_entry_info {
+	u16 weight;
+	struct nh_notifier_single_info nh;
+};
+
+struct nh_notifier_grp_info {
+	u16 num_nh;
+	bool is_fdb;
+	bool hw_stats;
+	struct nh_notifier_grp_entry_info nh_entries[0];
+};
+
+struct nh_notifier_res_bucket_info {
+	u16 bucket_index;
+	unsigned int idle_timer_ms;
+	bool force;
+	struct nh_notifier_single_info old_nh;
+	struct nh_notifier_single_info new_nh;
+};
+
+struct nh_notifier_res_table_info {
+	u16 num_nh_buckets;
+	bool hw_stats;
+	struct nh_notifier_single_info nhs[0];
+};
+
+struct nh_notifier_grp_hw_stats_entry_info {
+	u32 id;
+	long: 32;
+	u64 packets;
+};
+
+struct nh_notifier_grp_hw_stats_info {
+	u16 num_nh;
+	bool hw_stats_used;
+	long: 32;
+	struct nh_notifier_grp_hw_stats_entry_info stats[0];
+};
+
+struct nh_notifier_info {
+	struct net *net;
+	struct netlink_ext_ack *extack;
+	u32 id;
+	enum nh_notifier_info_type type;
+	union {
+		struct nh_notifier_single_info *nh;
+		struct nh_notifier_grp_info *nh_grp;
+		struct nh_notifier_res_table_info *nh_res_table;
+		struct nh_notifier_res_bucket_info *nh_res_bucket;
+		struct nh_notifier_grp_hw_stats_info *nh_grp_hw_stats;
+	};
+};
+
+struct nh_dump_filter {
+	u32 nh_id;
+	int dev_idx;
+	int master_idx;
+	bool group_filter;
+	bool fdb_filter;
+	u32 res_bucket_nh_id;
+	u32 op_flags;
+};
+
+struct rtm_dump_nh_ctx {
+	u32 idx;
+};
+
+struct rtm_dump_res_bucket_ctx {
+	struct rtm_dump_nh_ctx nh;
+	u16 bucket_index;
+};
+
+struct rtm_dump_nexthop_bucket_data {
+	struct rtm_dump_res_bucket_ctx *ctx;
+	struct nh_dump_filter filter;
+};
+
+struct rta_mfc_stats {
+	__u64 mfcs_packets;
+	__u64 mfcs_bytes;
+	__u64 mfcs_wrong_if;
+};
+
+struct bictcp {
+	u32 cnt;
+	u32 last_max_cwnd;
+	u32 last_cwnd;
+	u32 last_time;
+	u32 bic_origin_point;
+	u32 bic_K;
+	u32 delay_min;
+	u32 epoch_start;
+	u32 ack_cnt;
+	u32 tcp_cwnd;
+	u16 unused;
+	u8 sample_cnt;
+	u8 found;
+	u32 round_start;
+	u32 end_seq;
+	u32 last_ack;
+	u32 curr_rtt;
+};
+
+typedef u64 (*btf_bpf_tcp_send_ack)(struct tcp_sock *, u32);
+
+struct bpf_struct_ops_tcp_congestion_ops {
+	struct bpf_struct_ops_common_value common;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct tcp_congestion_ops data;
+};
+
+struct nat_keepalive {
+	struct net *net;
+	u16 family;
+	xfrm_address_t saddr;
+	xfrm_address_t daddr;
+	__be16 encap_sport;
+	__be16 encap_dport;
+	__u32 smark;
+};
+
+struct nat_keepalive_work_ctx {
+	time64_t next_run;
+	time64_t now;
+};
+
+struct ac6_iter_state {
+	struct seq_net_private p;
+	struct net_device *dev;
+};
+
+enum {
+	IFLA_INET6_UNSPEC = 0,
+	IFLA_INET6_FLAGS = 1,
+	IFLA_INET6_CONF = 2,
+	IFLA_INET6_STATS = 3,
+	IFLA_INET6_MCAST = 4,
+	IFLA_INET6_CACHEINFO = 5,
+	IFLA_INET6_ICMP6STATS = 6,
+	IFLA_INET6_TOKEN = 7,
+	IFLA_INET6_ADDR_GEN_MODE = 8,
+	IFLA_INET6_RA_MTU = 9,
+	__IFLA_INET6_MAX = 10,
+};
+
+enum in6_addr_gen_mode {
+	IN6_ADDR_GEN_MODE_EUI64 = 0,
+	IN6_ADDR_GEN_MODE_NONE = 1,
+	IN6_ADDR_GEN_MODE_STABLE_PRIVACY = 2,
+	IN6_ADDR_GEN_MODE_RANDOM = 3,
+};
+
+struct ifla_cacheinfo {
+	__u32 max_reasm_len;
+	__u32 tstamp;
+	__u32 reachable_time;
+	__u32 retrans_time;
+};
+
+struct wpan_phy;
+
+struct wpan_dev_header_ops;
+
+struct ieee802154_pan_device;
+
+struct wpan_dev {
+	struct wpan_phy *wpan_phy;
+	int iftype;
+	struct list_head list;
+	struct net_device *netdev;
+	const struct wpan_dev_header_ops *header_ops;
+	struct net_device *lowpan_dev;
+	u32 identifier;
+	__le16 pan_id;
+	__le16 short_addr;
+	long: 32;
+	__le64 extended_addr;
+	atomic_t bsn;
+	atomic_t dsn;
+	u8 min_be;
+	u8 max_be;
+	u8 csma_retries;
+	s8 frame_retries;
+	bool lbt;
+	bool ackreq;
+	struct mutex association_lock;
+	struct ieee802154_pan_device *parent;
+	struct list_head children;
+	unsigned int max_associations;
+	unsigned int nchildren;
+};
+
+struct ifaddrmsg {
+	__u8 ifa_family;
+	__u8 ifa_prefixlen;
+	__u8 ifa_flags;
+	__u8 ifa_scope;
+	__u32 ifa_index;
+};
+
+enum {
+	IFA_UNSPEC = 0,
+	IFA_ADDRESS = 1,
+	IFA_LOCAL = 2,
+	IFA_LABEL = 3,
+	IFA_BROADCAST = 4,
+	IFA_ANYCAST = 5,
+	IFA_CACHEINFO = 6,
+	IFA_MULTICAST = 7,
+	IFA_FLAGS = 8,
+	IFA_RT_PRIORITY = 9,
+	IFA_TARGET_NETNSID = 10,
+	IFA_PROTO = 11,
+	__IFA_MAX = 12,
+};
+
+struct ifa_cacheinfo {
+	__u32 ifa_prefered;
+	__u32 ifa_valid;
+	__u32 cstamp;
+	__u32 tstamp;
+};
+
+struct prefixmsg {
+	unsigned char prefix_family;
+	unsigned char prefix_pad1;
+	short unsigned int prefix_pad2;
+	int prefix_ifindex;
+	unsigned char prefix_type;
+	unsigned char prefix_len;
+	unsigned char prefix_flags;
+	unsigned char prefix_pad3;
+};
+
+enum {
+	PREFIX_UNSPEC = 0,
+	PREFIX_ADDRESS = 1,
+	PREFIX_CACHEINFO = 2,
+	__PREFIX_MAX = 3,
+};
+
+struct prefix_cacheinfo {
+	__u32 preferred_time;
+	__u32 valid_time;
+};
+
+struct in6_ifreq {
+	struct in6_addr ifr6_addr;
+	__u32 ifr6_prefixlen;
+	int ifr6_ifindex;
+};
+
+enum {
+	DEVCONF_FORWARDING = 0,
+	DEVCONF_HOPLIMIT = 1,
+	DEVCONF_MTU6 = 2,
+	DEVCONF_ACCEPT_RA = 3,
+	DEVCONF_ACCEPT_REDIRECTS = 4,
+	DEVCONF_AUTOCONF = 5,
+	DEVCONF_DAD_TRANSMITS = 6,
+	DEVCONF_RTR_SOLICITS = 7,
+	DEVCONF_RTR_SOLICIT_INTERVAL = 8,
+	DEVCONF_RTR_SOLICIT_DELAY = 9,
+	DEVCONF_USE_TEMPADDR = 10,
+	DEVCONF_TEMP_VALID_LFT = 11,
+	DEVCONF_TEMP_PREFERED_LFT = 12,
+	DEVCONF_REGEN_MAX_RETRY = 13,
+	DEVCONF_MAX_DESYNC_FACTOR = 14,
+	DEVCONF_MAX_ADDRESSES = 15,
+	DEVCONF_FORCE_MLD_VERSION = 16,
+	DEVCONF_ACCEPT_RA_DEFRTR = 17,
+	DEVCONF_ACCEPT_RA_PINFO = 18,
+	DEVCONF_ACCEPT_RA_RTR_PREF = 19,
+	DEVCONF_RTR_PROBE_INTERVAL = 20,
+	DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN = 21,
+	DEVCONF_PROXY_NDP = 22,
+	DEVCONF_OPTIMISTIC_DAD = 23,
+	DEVCONF_ACCEPT_SOURCE_ROUTE = 24,
+	DEVCONF_MC_FORWARDING = 25,
+	DEVCONF_DISABLE_IPV6 = 26,
+	DEVCONF_ACCEPT_DAD = 27,
+	DEVCONF_FORCE_TLLAO = 28,
+	DEVCONF_NDISC_NOTIFY = 29,
+	DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL = 30,
+	DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL = 31,
+	DEVCONF_SUPPRESS_FRAG_NDISC = 32,
+	DEVCONF_ACCEPT_RA_FROM_LOCAL = 33,
+	DEVCONF_USE_OPTIMISTIC = 34,
+	DEVCONF_ACCEPT_RA_MTU = 35,
+	DEVCONF_STABLE_SECRET = 36,
+	DEVCONF_USE_OIF_ADDRS_ONLY = 37,
+	DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT = 38,
+	DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 39,
+	DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 40,
+	DEVCONF_DROP_UNSOLICITED_NA = 41,
+	DEVCONF_KEEP_ADDR_ON_DOWN = 42,
+	DEVCONF_RTR_SOLICIT_MAX_INTERVAL = 43,
+	DEVCONF_SEG6_ENABLED = 44,
+	DEVCONF_SEG6_REQUIRE_HMAC = 45,
+	DEVCONF_ENHANCED_DAD = 46,
+	DEVCONF_ADDR_GEN_MODE = 47,
+	DEVCONF_DISABLE_POLICY = 48,
+	DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN = 49,
+	DEVCONF_NDISC_TCLASS = 50,
+	DEVCONF_RPL_SEG_ENABLED = 51,
+	DEVCONF_RA_DEFRTR_METRIC = 52,
+	DEVCONF_IOAM6_ENABLED = 53,
+	DEVCONF_IOAM6_ID = 54,
+	DEVCONF_IOAM6_ID_WIDE = 55,
+	DEVCONF_NDISC_EVICT_NOCARRIER = 56,
+	DEVCONF_ACCEPT_UNTRACKED_NA = 57,
+	DEVCONF_ACCEPT_RA_MIN_LFT = 58,
+	DEVCONF_MAX = 59,
+};
+
+struct ipv6_params {
+	__s32 disable_ipv6;
+	__s32 autoconf;
+};
+
+enum {
+	INET6_IFADDR_STATE_PREDAD = 0,
+	INET6_IFADDR_STATE_DAD = 1,
+	INET6_IFADDR_STATE_POSTDAD = 2,
+	INET6_IFADDR_STATE_ERRDAD = 3,
+	INET6_IFADDR_STATE_DEAD = 4,
+};
+
+struct in6_validator_info {
+	struct in6_addr i6vi_addr;
+	struct inet6_dev *i6vi_dev;
+	struct netlink_ext_ack *extack;
+};
+
+struct ifa6_config {
+	const struct in6_addr *pfx;
+	unsigned int plen;
+	u8 ifa_proto;
+	const struct in6_addr *peer_pfx;
+	u32 rt_priority;
+	u32 ifa_flags;
+	u32 preferred_lft;
+	u32 valid_lft;
+	u16 scope;
+};
+
+enum ieee802154_filtering_level {
+	IEEE802154_FILTERING_NONE = 0,
+	IEEE802154_FILTERING_1_FCS = 1,
+	IEEE802154_FILTERING_2_PROMISCUOUS = 2,
+	IEEE802154_FILTERING_3_SCAN = 3,
+	IEEE802154_FILTERING_4_FRAME_FIELDS = 4,
+};
+
+enum nl802154_cca_modes {
+	__NL802154_CCA_INVALID = 0,
+	NL802154_CCA_ENERGY = 1,
+	NL802154_CCA_CARRIER = 2,
+	NL802154_CCA_ENERGY_CARRIER = 3,
+	NL802154_CCA_ALOHA = 4,
+	NL802154_CCA_UWB_SHR = 5,
+	NL802154_CCA_UWB_MULTIPLEXED = 6,
+	__NL802154_CCA_ATTR_AFTER_LAST = 7,
+	NL802154_CCA_ATTR_MAX = 6,
+};
+
+enum nl802154_cca_opts {
+	NL802154_CCA_OPT_ENERGY_CARRIER_AND = 0,
+	NL802154_CCA_OPT_ENERGY_CARRIER_OR = 1,
+	__NL802154_CCA_OPT_ATTR_AFTER_LAST = 2,
+	NL802154_CCA_OPT_ATTR_MAX = 1,
+};
+
+enum nl802154_supported_bool_states {
+	NL802154_SUPPORTED_BOOL_FALSE = 0,
+	NL802154_SUPPORTED_BOOL_TRUE = 1,
+	__NL802154_SUPPORTED_BOOL_INVALD = 2,
+	NL802154_SUPPORTED_BOOL_BOTH = 3,
+	__NL802154_SUPPORTED_BOOL_AFTER_LAST = 4,
+	NL802154_SUPPORTED_BOOL_MAX = 3,
+};
+
+struct wpan_phy_supported {
+	u32 channels[32];
+	u32 cca_modes;
+	u32 cca_opts;
+	u32 iftypes;
+	enum nl802154_supported_bool_states lbt;
+	u8 min_minbe;
+	u8 max_minbe;
+	u8 min_maxbe;
+	u8 max_maxbe;
+	u8 min_csma_backoffs;
+	u8 max_csma_backoffs;
+	s8 min_frame_retries;
+	s8 max_frame_retries;
+	size_t tx_powers_size;
+	size_t cca_ed_levels_size;
+	const s32 *tx_powers;
+	const s32 *cca_ed_levels;
+};
+
+struct wpan_phy_cca {
+	enum nl802154_cca_modes mode;
+	enum nl802154_cca_opts opt;
+};
+
+struct wpan_phy {
+	const void *privid;
+	long unsigned int flags;
+	u8 current_channel;
+	u8 current_page;
+	struct wpan_phy_supported supported;
+	s32 transmit_power;
+	struct wpan_phy_cca cca;
+	__le64 perm_extended_addr;
+	s32 cca_ed_level;
+	u32 symbol_duration;
+	u16 lifs_period;
+	u16 sifs_period;
+	long: 32;
+	struct device dev;
+	possible_net_t _net;
+	spinlock_t queue_lock;
+	atomic_t ongoing_txs;
+	atomic_t hold_txs;
+	wait_queue_head_t sync_txq;
+	enum ieee802154_filtering_level filtering;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	char priv[0];
+};
+
+struct ieee802154_addr {
+	u8 mode;
+	__le16 pan_id;
+	long: 32;
+	union {
+		__le16 short_addr;
+		__le64 extended_addr;
+	};
+};
+
+struct ieee802154_pan_device {
+	__le16 pan_id;
+	u8 mode;
+	__le16 short_addr;
+	__le64 extended_addr;
+	struct list_head node;
+};
+
+struct wpan_dev_header_ops {
+	int (*create)(struct sk_buff *, struct net_device *, const struct ieee802154_addr *, const struct ieee802154_addr *, unsigned int);
+};
+
+union fwnet_hwaddr {
+	u8 u[16];
+	struct {
+		__be64 uniq_id;
+		u8 max_rec;
+		u8 sspd;
+		u8 fifo[6];
+	} uc;
+};
+
+struct netconfmsg {
+	__u8 ncm_family;
+};
+
+enum cleanup_prefix_rt_t {
+	CLEANUP_PREFIX_RT_NOP = 0,
+	CLEANUP_PREFIX_RT_DEL = 1,
+	CLEANUP_PREFIX_RT_EXPIRE = 2,
+};
+
+enum {
+	IPV6_SADDR_RULE_INIT = 0,
+	IPV6_SADDR_RULE_LOCAL = 1,
+	IPV6_SADDR_RULE_SCOPE = 2,
+	IPV6_SADDR_RULE_PREFERRED = 3,
+	IPV6_SADDR_RULE_OIF = 4,
+	IPV6_SADDR_RULE_LABEL = 5,
+	IPV6_SADDR_RULE_PRIVACY = 6,
+	IPV6_SADDR_RULE_ORCHID = 7,
+	IPV6_SADDR_RULE_PREFIX = 8,
+	IPV6_SADDR_RULE_MAX = 9,
+};
+
+struct ipv6_saddr_score {
+	int rule;
+	int addr_type;
+	struct inet6_ifaddr *ifa;
+	long unsigned int scorebits[1];
+	int scopedist;
+	int matchlen;
+};
+
+struct ipv6_saddr_dst {
+	const struct in6_addr *addr;
+	int ifindex;
+	int scope;
+	int label;
+	unsigned int prefs;
+};
+
+struct if6_iter_state {
+	struct seq_net_private p;
+	int bucket;
+	int offset;
+};
+
+enum addr_type_t {
+	UNICAST_ADDR = 0,
+	MULTICAST_ADDR = 1,
+	ANYCAST_ADDR = 2,
+};
+
+struct inet6_fill_args {
+	u32 portid;
+	u32 seq;
+	int event;
+	unsigned int flags;
+	int netnsid;
+	int ifindex;
+	enum addr_type_t type;
+};
+
+enum {
+	DAD_PROCESS = 0,
+	DAD_BEGIN = 1,
+	DAD_ABORT = 2,
+};
+
+typedef u32 inet6_ehashfn_t(const struct net *, const struct in6_addr *, const u16, const struct in6_addr *, const __be16);
+
+enum ip6_defrag_users {
+	IP6_DEFRAG_LOCAL_DELIVER = 0,
+	IP6_DEFRAG_CONNTRACK_IN = 1,
+	__IP6_DEFRAG_CONNTRACK_IN = 65536,
+	IP6_DEFRAG_CONNTRACK_OUT = 65537,
+	__IP6_DEFRAG_CONNTRACK_OUT = 131072,
+	IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 131073,
+	__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 196608,
+};
+
+struct frag_queue {
+	struct inet_frag_queue q;
+	int iif;
+	__u16 nhoffset;
+	u8 ecn;
+};
+
+struct ip6_mtuinfo {
+	struct sockaddr_in6 ip6m_addr;
+	__u32 ip6m_mtu;
+};
+
+typedef __u32 if_mask;
+
+struct if_set {
+	if_mask ifs_bits[8];
+};
+
+struct mif6ctl {
+	mifi_t mif6c_mifi;
+	unsigned char mif6c_flags;
+	unsigned char vifc_threshold;
+	__u16 mif6c_pifi;
+	unsigned int vifc_rate_limit;
+};
+
+struct mf6cctl {
+	struct sockaddr_in6 mf6cc_origin;
+	struct sockaddr_in6 mf6cc_mcastgrp;
+	mifi_t mf6cc_parent;
+	struct if_set mf6cc_ifset;
+};
+
+struct mrt6msg {
+	__u8 im6_mbz;
+	__u8 im6_msgtype;
+	__u16 im6_mif;
+	__u32 im6_pad;
+	struct in6_addr im6_src;
+	struct in6_addr im6_dst;
+};
+
+enum {
+	IP6MRA_CREPORT_UNSPEC = 0,
+	IP6MRA_CREPORT_MSGTYPE = 1,
+	IP6MRA_CREPORT_MIF_ID = 2,
+	IP6MRA_CREPORT_SRC_ADDR = 3,
+	IP6MRA_CREPORT_DST_ADDR = 4,
+	IP6MRA_CREPORT_PKT = 5,
+	__IP6MRA_CREPORT_MAX = 6,
+};
+
+struct mfc6_cache_cmp_arg {
+	struct in6_addr mf6c_mcastgrp;
+	struct in6_addr mf6c_origin;
+};
+
+struct mfc6_cache {
+	struct mr_mfc _c;
+	union {
+		struct {
+			struct in6_addr mf6c_mcastgrp;
+			struct in6_addr mf6c_origin;
+		};
+		struct mfc6_cache_cmp_arg cmparg;
+	};
+};
+
+struct ip6mr_result {
+	struct mr_table *mrt;
+};
+
+struct nf_ipv6_ops {
+	void (*route_input)(struct sk_buff *);
+	int (*fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
+	int (*reroute)(struct sk_buff *, const struct nf_queue_entry *);
+};
+
+struct nf_bridge_frag_data;
+
+enum l3mdev_type {
+	L3MDEV_TYPE_UNSPEC = 0,
+	L3MDEV_TYPE_VRF = 1,
+	__L3MDEV_TYPE_MAX = 2,
+};
+
+enum {
+	IP6_FH_F_FRAG = 1,
+	IP6_FH_F_AUTH = 2,
+	IP6_FH_F_SKIP_RH = 4,
+};
+
+enum {
+	SEG6_LOCAL_UNSPEC = 0,
+	SEG6_LOCAL_ACTION = 1,
+	SEG6_LOCAL_SRH = 2,
+	SEG6_LOCAL_TABLE = 3,
+	SEG6_LOCAL_NH4 = 4,
+	SEG6_LOCAL_NH6 = 5,
+	SEG6_LOCAL_IIF = 6,
+	SEG6_LOCAL_OIF = 7,
+	SEG6_LOCAL_BPF = 8,
+	SEG6_LOCAL_VRFTABLE = 9,
+	SEG6_LOCAL_COUNTERS = 10,
+	SEG6_LOCAL_FLAVORS = 11,
+	__SEG6_LOCAL_MAX = 12,
+};
+
+enum {
+	SEG6_LOCAL_BPF_PROG_UNSPEC = 0,
+	SEG6_LOCAL_BPF_PROG = 1,
+	SEG6_LOCAL_BPF_PROG_NAME = 2,
+	__SEG6_LOCAL_BPF_PROG_MAX = 3,
+};
+
+enum {
+	SEG6_LOCAL_CNT_UNSPEC = 0,
+	SEG6_LOCAL_CNT_PAD = 1,
+	SEG6_LOCAL_CNT_PACKETS = 2,
+	SEG6_LOCAL_CNT_BYTES = 3,
+	SEG6_LOCAL_CNT_ERRORS = 4,
+	__SEG6_LOCAL_CNT_MAX = 5,
+};
+
+enum {
+	SEG6_LOCAL_FLV_UNSPEC = 0,
+	SEG6_LOCAL_FLV_OPERATION = 1,
+	SEG6_LOCAL_FLV_LCBLOCK_BITS = 2,
+	SEG6_LOCAL_FLV_LCNODE_FN_BITS = 3,
+	__SEG6_LOCAL_FLV_MAX = 4,
+};
+
+enum {
+	SEG6_LOCAL_FLV_OP_UNSPEC = 0,
+	SEG6_LOCAL_FLV_OP_PSP = 1,
+	SEG6_LOCAL_FLV_OP_USP = 2,
+	SEG6_LOCAL_FLV_OP_USD = 3,
+	SEG6_LOCAL_FLV_OP_NEXT_CSID = 4,
+	__SEG6_LOCAL_FLV_OP_MAX = 5,
+};
+
+struct seg6_local_lwt;
+
+struct seg6_local_lwtunnel_ops {
+	int (*build_state)(struct seg6_local_lwt *, const void *, struct netlink_ext_ack *);
+	void (*destroy_state)(struct seg6_local_lwt *);
+};
+
+struct bpf_lwt_prog {
+	struct bpf_prog *prog;
+	char *name;
+};
+
+enum seg6_end_dt_mode {
+	DT_INVALID_MODE = -22,
+	DT_LEGACY_MODE = 0,
+	DT_VRF_MODE = 1,
+};
+
+struct seg6_end_dt_info {
+	enum seg6_end_dt_mode mode;
+	struct net *net;
+	int vrf_ifindex;
+	int vrf_table;
+	u16 family;
+};
+
+struct seg6_flavors_info {
+	__u32 flv_ops;
+	__u8 lcblock_bits;
+	__u8 lcnode_func_bits;
+};
+
+struct pcpu_seg6_local_counters;
+
+struct seg6_action_desc;
+
+struct seg6_local_lwt {
+	int action;
+	struct ipv6_sr_hdr *srh;
+	int table;
+	struct in_addr nh4;
+	struct in6_addr nh6;
+	int iif;
+	int oif;
+	struct bpf_lwt_prog bpf;
+	struct seg6_end_dt_info dt_info;
+	struct seg6_flavors_info flv_info;
+	struct pcpu_seg6_local_counters *pcpu_counters;
+	int headroom;
+	struct seg6_action_desc *desc;
+	long unsigned int parsed_optattrs;
+};
+
+struct seg6_action_desc {
+	int action;
+	long unsigned int attrs;
+	long unsigned int optattrs;
+	int (*input)(struct sk_buff *, struct seg6_local_lwt *);
+	int static_headroom;
+	struct seg6_local_lwtunnel_ops slwt_ops;
+};
+
+struct pcpu_seg6_local_counters {
+	u64_stats_t packets;
+	u64_stats_t bytes;
+	u64_stats_t errors;
+	struct u64_stats_sync syncp;
+	long: 32;
+};
+
+struct seg6_local_counters {
+	__u64 packets;
+	__u64 bytes;
+	__u64 errors;
+};
+
+enum seg6_local_pktinfo {
+	SEG6_LOCAL_PKTINFO_NOHDR = 0,
+	SEG6_LOCAL_PKTINFO_SL_ZERO = 1,
+	SEG6_LOCAL_PKTINFO_SL_ONE = 2,
+	SEG6_LOCAL_PKTINFO_SL_MORE = 3,
+	__SEG6_LOCAL_PKTINFO_MAX = 4,
+};
+
+enum seg6_local_flv_action {
+	SEG6_LOCAL_FLV_ACT_UNSPEC = 0,
+	SEG6_LOCAL_FLV_ACT_END = 1,
+	SEG6_LOCAL_FLV_ACT_PSP = 2,
+	SEG6_LOCAL_FLV_ACT_USP = 3,
+	SEG6_LOCAL_FLV_ACT_USD = 4,
+	__SEG6_LOCAL_FLV_ACT_MAX = 5,
+};
+
+struct seg6_action_param {
+	int (*parse)(struct nlattr **, struct seg6_local_lwt *, struct netlink_ext_ack *);
+	int (*put)(struct sk_buff *, struct seg6_local_lwt *);
+	int (*cmp)(struct seg6_local_lwt *, struct seg6_local_lwt *);
+	void (*destroy)(struct seg6_local_lwt *);
+};
+
+struct sockaddr_pkt {
+	short unsigned int spkt_family;
+	unsigned char spkt_device[14];
+	__be16 spkt_protocol;
+};
+
+struct sockaddr_ll {
+	short unsigned int sll_family;
+	__be16 sll_protocol;
+	int sll_ifindex;
+	short unsigned int sll_hatype;
+	unsigned char sll_pkttype;
+	unsigned char sll_halen;
+	unsigned char sll_addr[8];
+};
+
+struct tpacket_stats {
+	unsigned int tp_packets;
+	unsigned int tp_drops;
+};
+
+struct tpacket_stats_v3 {
+	unsigned int tp_packets;
+	unsigned int tp_drops;
+	unsigned int tp_freeze_q_cnt;
+};
+
+struct tpacket_rollover_stats {
+	__u64 tp_all;
+	__u64 tp_huge;
+	__u64 tp_failed;
+};
+
+union tpacket_stats_u {
+	struct tpacket_stats stats1;
+	struct tpacket_stats_v3 stats3;
+};
+
+struct tpacket_auxdata {
+	__u32 tp_status;
+	__u32 tp_len;
+	__u32 tp_snaplen;
+	__u16 tp_mac;
+	__u16 tp_net;
+	__u16 tp_vlan_tci;
+	__u16 tp_vlan_tpid;
+};
+
+struct tpacket_hdr {
+	long unsigned int tp_status;
+	unsigned int tp_len;
+	unsigned int tp_snaplen;
+	short unsigned int tp_mac;
+	short unsigned int tp_net;
+	unsigned int tp_sec;
+	unsigned int tp_usec;
+};
+
+struct tpacket2_hdr {
+	__u32 tp_status;
+	__u32 tp_len;
+	__u32 tp_snaplen;
+	__u16 tp_mac;
+	__u16 tp_net;
+	__u32 tp_sec;
+	__u32 tp_nsec;
+	__u16 tp_vlan_tci;
+	__u16 tp_vlan_tpid;
+	__u8 tp_padding[4];
+};
+
+struct tpacket_hdr_variant1 {
+	__u32 tp_rxhash;
+	__u32 tp_vlan_tci;
+	__u16 tp_vlan_tpid;
+	__u16 tp_padding;
+};
+
+struct tpacket3_hdr {
+	__u32 tp_next_offset;
+	__u32 tp_sec;
+	__u32 tp_nsec;
+	__u32 tp_snaplen;
+	__u32 tp_len;
+	__u32 tp_status;
+	__u16 tp_mac;
+	__u16 tp_net;
+	union {
+		struct tpacket_hdr_variant1 hv1;
+	};
+	__u8 tp_padding[8];
+};
+
+struct tpacket_bd_ts {
+	unsigned int ts_sec;
+	union {
+		unsigned int ts_usec;
+		unsigned int ts_nsec;
+	};
+};
+
+struct tpacket_hdr_v1 {
+	__u32 block_status;
+	__u32 num_pkts;
+	__u32 offset_to_first_pkt;
+	__u32 blk_len;
+	__u64 seq_num;
+	struct tpacket_bd_ts ts_first_pkt;
+	struct tpacket_bd_ts ts_last_pkt;
+};
+
+union tpacket_bd_header_u {
+	struct tpacket_hdr_v1 bh1;
+};
+
+struct tpacket_block_desc {
+	__u32 version;
+	__u32 offset_to_priv;
+	union tpacket_bd_header_u hdr;
+};
+
+enum tpacket_versions {
+	TPACKET_V1 = 0,
+	TPACKET_V2 = 1,
+	TPACKET_V3 = 2,
+};
+
+struct tpacket_req {
+	unsigned int tp_block_size;
+	unsigned int tp_block_nr;
+	unsigned int tp_frame_size;
+	unsigned int tp_frame_nr;
+};
+
+struct tpacket_req3 {
+	unsigned int tp_block_size;
+	unsigned int tp_block_nr;
+	unsigned int tp_frame_size;
+	unsigned int tp_frame_nr;
+	unsigned int tp_retire_blk_tov;
+	unsigned int tp_sizeof_priv;
+	unsigned int tp_feature_req_word;
+};
+
+union tpacket_req_u {
+	struct tpacket_req req;
+	struct tpacket_req3 req3;
+};
+
+struct fanout_args {
+	__u16 id;
+	__u16 type_flags;
+	__u32 max_num_members;
+};
+
+typedef __u16 __virtio16;
+
+struct virtio_net_hdr {
+	__u8 flags;
+	__u8 gso_type;
+	__virtio16 hdr_len;
+	__virtio16 gso_size;
+	__virtio16 csum_start;
+	__virtio16 csum_offset;
+};
+
+struct virtio_net_hdr_mrg_rxbuf {
+	struct virtio_net_hdr hdr;
+	__virtio16 num_buffers;
+};
+
+struct packet_mclist {
+	struct packet_mclist *next;
+	int ifindex;
+	int count;
+	short unsigned int type;
+	short unsigned int alen;
+	unsigned char addr[32];
+};
+
+struct pgv;
+
+struct tpacket_kbdq_core {
+	struct pgv *pkbdq;
+	unsigned int feature_req_word;
+	unsigned int hdrlen;
+	unsigned char reset_pending_on_curr_blk;
+	unsigned char delete_blk_timer;
+	short unsigned int kactive_blk_num;
+	short unsigned int blk_sizeof_priv;
+	short unsigned int last_kactive_blk_num;
+	char *pkblk_start;
+	char *pkblk_end;
+	int kblk_size;
+	unsigned int max_frame_len;
+	unsigned int knum_blocks;
+	uint64_t knxt_seq_num;
+	char *prev;
+	char *nxt_offset;
+	struct sk_buff *skb;
+	rwlock_t blk_fill_in_prog_lock;
+	short unsigned int retire_blk_tov;
+	short unsigned int version;
+	long unsigned int tov_in_jiffies;
+	struct timer_list retire_blk_timer;
+	long: 32;
+};
+
+struct pgv {
+	char *buffer;
+};
+
+struct packet_ring_buffer {
+	struct pgv *pg_vec;
+	unsigned int head;
+	unsigned int frames_per_block;
+	unsigned int frame_size;
+	unsigned int frame_max;
+	unsigned int pg_vec_order;
+	unsigned int pg_vec_pages;
+	unsigned int pg_vec_len;
+	unsigned int *pending_refcnt;
+	long: 32;
+	union {
+		long unsigned int *rx_owner_map;
+		struct tpacket_kbdq_core prb_bdqc;
+	};
+};
+
+struct packet_fanout {
+	possible_net_t net;
+	unsigned int num_members;
+	u32 max_num_members;
+	u16 id;
+	u8 type;
+	u8 flags;
+	union {
+		atomic_t rr_cur;
+		struct bpf_prog *bpf_prog;
+	};
+	struct list_head list;
+	spinlock_t lock;
+	refcount_t sk_ref;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct packet_type prot_hook;
+	struct sock *arr[0];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct packet_rollover {
+	int sock;
+	atomic_long_t num;
+	atomic_long_t num_huge;
+	atomic_long_t num_failed;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	u32 history[16];
+};
+
+struct packet_sock {
+	struct sock sk;
+	struct packet_fanout *fanout;
+	union tpacket_stats_u stats;
+	struct packet_ring_buffer rx_ring;
+	struct packet_ring_buffer tx_ring;
+	int copy_thresh;
+	spinlock_t bind_lock;
+	struct mutex pg_vec_lock;
+	long unsigned int flags;
+	int ifindex;
+	u8 vnet_hdr_sz;
+	__be16 num;
+	struct packet_rollover *rollover;
+	struct packet_mclist *mclist;
+	atomic_long_t mapped;
+	enum tpacket_versions tp_version;
+	unsigned int tp_hdrlen;
+	unsigned int tp_reserve;
+	unsigned int tp_tstamp;
+	struct completion skb_completion;
+	struct net_device *cached_dev;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct packet_type prot_hook;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	atomic_t tp_drops;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+enum packet_sock_flags {
+	PACKET_SOCK_ORIGDEV = 0,
+	PACKET_SOCK_AUXDATA = 1,
+	PACKET_SOCK_TX_HAS_OFF = 2,
+	PACKET_SOCK_TP_LOSS = 3,
+	PACKET_SOCK_RUNNING = 4,
+	PACKET_SOCK_PRESSURE = 5,
+	PACKET_SOCK_QDISC_BYPASS = 6,
+};
+
+struct packet_mreq_max {
+	int mr_ifindex;
+	short unsigned int mr_type;
+	short unsigned int mr_alen;
+	unsigned char mr_address[32];
+};
+
+union tpacket_uhdr {
+	struct tpacket_hdr *h1;
+	struct tpacket2_hdr *h2;
+	struct tpacket3_hdr *h3;
+	void *raw;
+};
+
+struct packet_skb_cb {
+	union {
+		struct sockaddr_pkt pkt;
+		union {
+			unsigned int origlen;
+			struct sockaddr_ll ll;
+		};
+	} sa;
+};
+
+enum {
+	IFLA_BRIDGE_VLAN_TUNNEL_UNSPEC = 0,
+	IFLA_BRIDGE_VLAN_TUNNEL_ID = 1,
+	IFLA_BRIDGE_VLAN_TUNNEL_VID = 2,
+	IFLA_BRIDGE_VLAN_TUNNEL_FLAGS = 3,
+	__IFLA_BRIDGE_VLAN_TUNNEL_MAX = 4,
+};
+
+enum {
+	BRIDGE_VLANDB_DUMP_UNSPEC = 0,
+	BRIDGE_VLANDB_DUMP_FLAGS = 1,
+	__BRIDGE_VLANDB_DUMP_MAX = 2,
+};
+
+enum {
+	BRIDGE_VLANDB_STATS_UNSPEC = 0,
+	BRIDGE_VLANDB_STATS_RX_BYTES = 1,
+	BRIDGE_VLANDB_STATS_RX_PACKETS = 2,
+	BRIDGE_VLANDB_STATS_TX_BYTES = 3,
+	BRIDGE_VLANDB_STATS_TX_PACKETS = 4,
+	BRIDGE_VLANDB_STATS_PAD = 5,
+	__BRIDGE_VLANDB_STATS_MAX = 6,
+};
+
+struct br_vlan_bind_walk_data {
+	u16 vid;
+	struct net_device *result;
+};
+
+struct br_vlan_link_state_walk_data {
+	struct net_bridge *br;
+};
+
+struct br_switchdev_mdb_complete_info {
+	struct net_bridge_port *port;
+	struct br_ip ip;
+};
+
+enum devlink_attr_selftest_result {
+	DEVLINK_ATTR_SELFTEST_RESULT_UNSPEC = 0,
+	DEVLINK_ATTR_SELFTEST_RESULT = 1,
+	DEVLINK_ATTR_SELFTEST_RESULT_ID = 2,
+	DEVLINK_ATTR_SELFTEST_RESULT_STATUS = 3,
+	__DEVLINK_ATTR_SELFTEST_RESULT_MAX = 4,
+	DEVLINK_ATTR_SELFTEST_RESULT_MAX = 3,
+};
+
+struct devlink_flash_notify {
+	const char *status_msg;
+	const char *component;
+	long unsigned int done;
+	long unsigned int total;
+	long unsigned int timeout;
+};
+
+enum devlink_info_version_type {
+	DEVLINK_INFO_VERSION_TYPE_NONE = 0,
+	DEVLINK_INFO_VERSION_TYPE_COMPONENT = 1,
+};
+
+struct devlink_info_req {
+	struct sk_buff *msg;
+	void (*version_cb)(const char *, enum devlink_info_version_type, void *);
+	void *version_cb_priv;
+};
+
+struct devlink_reload_combination {
+	enum devlink_reload_action action;
+	enum devlink_reload_limit limit;
+};
+
+struct devlink_flash_component_lookup_ctx {
+	const char *lookup_name;
+	bool lookup_name_found;
+};
+
+struct devlink_resource {
+	const char *name;
+	long: 32;
+	u64 id;
+	u64 size;
+	u64 size_new;
+	bool size_valid;
+	struct devlink_resource *parent;
+	struct devlink_resource_size_params size_params;
+	struct list_head list;
+	struct list_head resource_list;
+	devlink_resource_occ_get_t *occ_get;
+	void *occ_get_priv;
+};
+
+enum {
+	DEVLINK_ATTR_STATS_RX_PACKETS = 0,
+	DEVLINK_ATTR_STATS_RX_BYTES = 1,
+	DEVLINK_ATTR_STATS_RX_DROPPED = 2,
+	__DEVLINK_ATTR_STATS_MAX = 3,
+	DEVLINK_ATTR_STATS_MAX = 2,
+};
+
+enum {
+	DEVLINK_ATTR_TRAP_METADATA_TYPE_IN_PORT = 0,
+	DEVLINK_ATTR_TRAP_METADATA_TYPE_FA_COOKIE = 1,
+};
+
+enum devlink_trap_generic_id {
+	DEVLINK_TRAP_GENERIC_ID_SMAC_MC = 0,
+	DEVLINK_TRAP_GENERIC_ID_VLAN_TAG_MISMATCH = 1,
+	DEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER = 2,
+	DEVLINK_TRAP_GENERIC_ID_INGRESS_STP_FILTER = 3,
+	DEVLINK_TRAP_GENERIC_ID_EMPTY_TX_LIST = 4,
+	DEVLINK_TRAP_GENERIC_ID_PORT_LOOPBACK_FILTER = 5,
+	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_ROUTE = 6,
+	DEVLINK_TRAP_GENERIC_ID_TTL_ERROR = 7,
+	DEVLINK_TRAP_GENERIC_ID_TAIL_DROP = 8,
+	DEVLINK_TRAP_GENERIC_ID_NON_IP_PACKET = 9,
+	DEVLINK_TRAP_GENERIC_ID_UC_DIP_MC_DMAC = 10,
+	DEVLINK_TRAP_GENERIC_ID_DIP_LB = 11,
+	DEVLINK_TRAP_GENERIC_ID_SIP_MC = 12,
+	DEVLINK_TRAP_GENERIC_ID_SIP_LB = 13,
+	DEVLINK_TRAP_GENERIC_ID_CORRUPTED_IP_HDR = 14,
+	DEVLINK_TRAP_GENERIC_ID_IPV4_SIP_BC = 15,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_RESERVED_SCOPE = 16,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_INTERFACE_LOCAL_SCOPE = 17,
+	DEVLINK_TRAP_GENERIC_ID_MTU_ERROR = 18,
+	DEVLINK_TRAP_GENERIC_ID_UNRESOLVED_NEIGH = 19,
+	DEVLINK_TRAP_GENERIC_ID_RPF = 20,
+	DEVLINK_TRAP_GENERIC_ID_REJECT_ROUTE = 21,
+	DEVLINK_TRAP_GENERIC_ID_IPV4_LPM_UNICAST_MISS = 22,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_LPM_UNICAST_MISS = 23,
+	DEVLINK_TRAP_GENERIC_ID_NON_ROUTABLE = 24,
+	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR = 25,
+	DEVLINK_TRAP_GENERIC_ID_OVERLAY_SMAC_MC = 26,
+	DEVLINK_TRAP_GENERIC_ID_INGRESS_FLOW_ACTION_DROP = 27,
+	DEVLINK_TRAP_GENERIC_ID_EGRESS_FLOW_ACTION_DROP = 28,
+	DEVLINK_TRAP_GENERIC_ID_STP = 29,
+	DEVLINK_TRAP_GENERIC_ID_LACP = 30,
+	DEVLINK_TRAP_GENERIC_ID_LLDP = 31,
+	DEVLINK_TRAP_GENERIC_ID_IGMP_QUERY = 32,
+	DEVLINK_TRAP_GENERIC_ID_IGMP_V1_REPORT = 33,
+	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_REPORT = 34,
+	DEVLINK_TRAP_GENERIC_ID_IGMP_V3_REPORT = 35,
+	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_LEAVE = 36,
+	DEVLINK_TRAP_GENERIC_ID_MLD_QUERY = 37,
+	DEVLINK_TRAP_GENERIC_ID_MLD_V1_REPORT = 38,
+	DEVLINK_TRAP_GENERIC_ID_MLD_V2_REPORT = 39,
+	DEVLINK_TRAP_GENERIC_ID_MLD_V1_DONE = 40,
+	DEVLINK_TRAP_GENERIC_ID_IPV4_DHCP = 41,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_DHCP = 42,
+	DEVLINK_TRAP_GENERIC_ID_ARP_REQUEST = 43,
+	DEVLINK_TRAP_GENERIC_ID_ARP_RESPONSE = 44,
+	DEVLINK_TRAP_GENERIC_ID_ARP_OVERLAY = 45,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_SOLICIT = 46,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_ADVERT = 47,
+	DEVLINK_TRAP_GENERIC_ID_IPV4_BFD = 48,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_BFD = 49,
+	DEVLINK_TRAP_GENERIC_ID_IPV4_OSPF = 50,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_OSPF = 51,
+	DEVLINK_TRAP_GENERIC_ID_IPV4_BGP = 52,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_BGP = 53,
+	DEVLINK_TRAP_GENERIC_ID_IPV4_VRRP = 54,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_VRRP = 55,
+	DEVLINK_TRAP_GENERIC_ID_IPV4_PIM = 56,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_PIM = 57,
+	DEVLINK_TRAP_GENERIC_ID_UC_LB = 58,
+	DEVLINK_TRAP_GENERIC_ID_LOCAL_ROUTE = 59,
+	DEVLINK_TRAP_GENERIC_ID_EXTERNAL_ROUTE = 60,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_UC_DIP_LINK_LOCAL_SCOPE = 61,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_NODES = 62,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_ROUTERS = 63,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_SOLICIT = 64,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ADVERT = 65,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_REDIRECT = 66,
+	DEVLINK_TRAP_GENERIC_ID_IPV4_ROUTER_ALERT = 67,
+	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ALERT = 68,
+	DEVLINK_TRAP_GENERIC_ID_PTP_EVENT = 69,
+	DEVLINK_TRAP_GENERIC_ID_PTP_GENERAL = 70,
+	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_SAMPLE = 71,
+	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_TRAP = 72,
+	DEVLINK_TRAP_GENERIC_ID_EARLY_DROP = 73,
+	DEVLINK_TRAP_GENERIC_ID_VXLAN_PARSING = 74,
+	DEVLINK_TRAP_GENERIC_ID_LLC_SNAP_PARSING = 75,
+	DEVLINK_TRAP_GENERIC_ID_VLAN_PARSING = 76,
+	DEVLINK_TRAP_GENERIC_ID_PPPOE_PPP_PARSING = 77,
+	DEVLINK_TRAP_GENERIC_ID_MPLS_PARSING = 78,
+	DEVLINK_TRAP_GENERIC_ID_ARP_PARSING = 79,
+	DEVLINK_TRAP_GENERIC_ID_IP_1_PARSING = 80,
+	DEVLINK_TRAP_GENERIC_ID_IP_N_PARSING = 81,
+	DEVLINK_TRAP_GENERIC_ID_GRE_PARSING = 82,
+	DEVLINK_TRAP_GENERIC_ID_UDP_PARSING = 83,
+	DEVLINK_TRAP_GENERIC_ID_TCP_PARSING = 84,
+	DEVLINK_TRAP_GENERIC_ID_IPSEC_PARSING = 85,
+	DEVLINK_TRAP_GENERIC_ID_SCTP_PARSING = 86,
+	DEVLINK_TRAP_GENERIC_ID_DCCP_PARSING = 87,
+	DEVLINK_TRAP_GENERIC_ID_GTP_PARSING = 88,
+	DEVLINK_TRAP_GENERIC_ID_ESP_PARSING = 89,
+	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_NEXTHOP = 90,
+	DEVLINK_TRAP_GENERIC_ID_DMAC_FILTER = 91,
+	DEVLINK_TRAP_GENERIC_ID_EAPOL = 92,
+	DEVLINK_TRAP_GENERIC_ID_LOCKED_PORT = 93,
+	__DEVLINK_TRAP_GENERIC_ID_MAX = 94,
+	DEVLINK_TRAP_GENERIC_ID_MAX = 93,
+};
+
+enum devlink_trap_group_generic_id {
+	DEVLINK_TRAP_GROUP_GENERIC_ID_L2_DROPS = 0,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_DROPS = 1,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_EXCEPTIONS = 2,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_BUFFER_DROPS = 3,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_TUNNEL_DROPS = 4,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_DROPS = 5,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_STP = 6,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_LACP = 7,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_LLDP = 8,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_MC_SNOOPING = 9,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_DHCP = 10,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_NEIGH_DISCOVERY = 11,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_BFD = 12,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_OSPF = 13,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_BGP = 14,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_VRRP = 15,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_PIM = 16,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_UC_LB = 17,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_LOCAL_DELIVERY = 18,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_EXTERNAL_DELIVERY = 19,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_IPV6 = 20,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_EVENT = 21,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_GENERAL = 22,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_SAMPLE = 23,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_TRAP = 24,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_PARSER_ERROR_DROPS = 25,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_EAPOL = 26,
+	__DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 27,
+	DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 26,
+};
+
+struct devlink_stats {
+	u64_stats_t rx_bytes;
+	u64_stats_t rx_packets;
+	struct u64_stats_sync syncp;
+	long: 32;
+};
+
+struct devlink_trap_policer_item {
+	const struct devlink_trap_policer *policer;
+	long: 32;
+	u64 rate;
+	u64 burst;
+	struct list_head list;
+};
+
+struct devlink_trap_group_item {
+	const struct devlink_trap_group *group;
+	struct devlink_trap_policer_item *policer_item;
+	struct list_head list;
+	struct devlink_stats *stats;
+};
+
+struct devlink_trap_item {
+	const struct devlink_trap *trap;
+	struct devlink_trap_group_item *group_item;
+	struct list_head list;
+	enum devlink_trap_action action;
+	struct devlink_stats *stats;
+	void *priv;
+};
+
+enum {
+	IFLA_DSA_UNSPEC = 0,
+	IFLA_DSA_CONDUIT = 1,
+	IFLA_DSA_MASTER = 1,
+	__IFLA_DSA_MAX = 2,
+};
+
+struct netdev_lag_lower_state_info {
+	u8 link_up: 1;
+	u8 tx_enabled: 1;
+};
+
+enum tc_matchall_command {
+	TC_CLSMATCHALL_REPLACE = 0,
+	TC_CLSMATCHALL_DESTROY = 1,
+	TC_CLSMATCHALL_STATS = 2,
+};
+
+struct tc_cls_matchall_offload {
+	struct flow_cls_common_offload common;
+	enum tc_matchall_command command;
+	struct flow_rule *rule;
+	struct flow_stats stats;
+	bool use_act_stats;
+	long unsigned int cookie;
+};
+
+enum dsa_port_mall_action_type {
+	DSA_PORT_MALL_MIRROR = 0,
+	DSA_PORT_MALL_POLICER = 1,
+};
+
+struct dsa_mall_tc_entry {
+	struct list_head list;
+	long unsigned int cookie;
+	enum dsa_port_mall_action_type type;
+	union {
+		struct dsa_mall_mirror_tc_entry mirror;
+		struct dsa_mall_policer_tc_entry policer;
+	};
+};
+
+struct dsa_switchdev_event_work {
+	struct net_device *dev;
+	struct net_device *orig_dev;
+	struct work_struct work;
+	long unsigned int event;
+	unsigned char addr[6];
+	u16 vid;
+	bool host_addr;
+};
+
+enum dsa_standalone_event {
+	DSA_UC_ADD = 0,
+	DSA_UC_DEL = 1,
+	DSA_MC_ADD = 2,
+	DSA_MC_DEL = 3,
+};
+
+struct dsa_standalone_event_work {
+	struct work_struct work;
+	struct net_device *dev;
+	enum dsa_standalone_event event;
+	unsigned char addr[6];
+	u16 vid;
+};
+
+struct dsa_host_vlan_rx_filtering_ctx {
+	struct net_device *dev;
+	const unsigned char *addr;
+	enum dsa_standalone_event event;
+};
+
+struct dsa_user_dump_ctx {
+	struct net_device *dev;
+	struct sk_buff *skb;
+	struct netlink_callback *cb;
+	int idx;
+};
+
+struct dsa_hw_port {
+	struct list_head list;
+	struct net_device *dev;
+	int old_mtu;
+};
+
+enum vlan_ioctl_cmds {
+	ADD_VLAN_CMD = 0,
+	DEL_VLAN_CMD = 1,
+	SET_VLAN_INGRESS_PRIORITY_CMD = 2,
+	SET_VLAN_EGRESS_PRIORITY_CMD = 3,
+	GET_VLAN_INGRESS_PRIORITY_CMD = 4,
+	GET_VLAN_EGRESS_PRIORITY_CMD = 5,
+	SET_VLAN_NAME_TYPE_CMD = 6,
+	SET_VLAN_FLAG_CMD = 7,
+	GET_VLAN_REALDEV_NAME_CMD = 8,
+	GET_VLAN_VID_CMD = 9,
+};
+
+struct vlan_ioctl_args {
+	int cmd;
+	char device1[24];
+	union {
+		char device2[24];
+		int VID;
+		unsigned int skb_priority;
+		unsigned int name_type;
+		unsigned int bind_type;
+		unsigned int flag;
+	} u;
+	short int vlan_qos;
+};
+
+enum mptcp_addr_signal_status {
+	MPTCP_ADD_ADDR_SIGNAL = 0,
+	MPTCP_ADD_ADDR_ECHO = 1,
+	MPTCP_RM_ADDR_SIGNAL = 2,
+};
+
+struct csum_pseudo_header {
+	__be64 data_seq;
+	__be32 subflow_seq;
+	__be16 data_len;
+	__sum16 csum;
+};
+
+struct mptcp_pernet {
+	struct ctl_table_header *ctl_table_hdr;
+	unsigned int add_addr_timeout;
+	unsigned int blackhole_timeout;
+	unsigned int close_timeout;
+	unsigned int stale_loss_cnt;
+	atomic_t active_disable_times;
+	long unsigned int active_disable_stamp;
+	u8 mptcp_enabled;
+	u8 checksum_enabled;
+	u8 allow_join_initial_addr_port;
+	u8 pm_type;
+	char scheduler[16];
+};
+
+enum mptcp_event_attr {
+	MPTCP_ATTR_UNSPEC = 0,
+	MPTCP_ATTR_TOKEN = 1,
+	MPTCP_ATTR_FAMILY = 2,
+	MPTCP_ATTR_LOC_ID = 3,
+	MPTCP_ATTR_REM_ID = 4,
+	MPTCP_ATTR_SADDR4 = 5,
+	MPTCP_ATTR_SADDR6 = 6,
+	MPTCP_ATTR_DADDR4 = 7,
+	MPTCP_ATTR_DADDR6 = 8,
+	MPTCP_ATTR_SPORT = 9,
+	MPTCP_ATTR_DPORT = 10,
+	MPTCP_ATTR_BACKUP = 11,
+	MPTCP_ATTR_ERROR = 12,
+	MPTCP_ATTR_FLAGS = 13,
+	MPTCP_ATTR_TIMEOUT = 14,
+	MPTCP_ATTR_IF_IDX = 15,
+	MPTCP_ATTR_RESET_REASON = 16,
+	MPTCP_ATTR_RESET_FLAGS = 17,
+	MPTCP_ATTR_SERVER_SIDE = 18,
+	__MPTCP_ATTR_MAX = 19,
+};
+
+enum mptcp_pm_status {
+	MPTCP_PM_ADD_ADDR_RECEIVED = 0,
+	MPTCP_PM_ADD_ADDR_SEND_ACK = 1,
+	MPTCP_PM_RM_ADDR_RECEIVED = 2,
+	MPTCP_PM_ESTABLISHED = 3,
+	MPTCP_PM_SUBFLOW_ESTABLISHED = 4,
+	MPTCP_PM_ALREADY_ESTABLISHED = 5,
+	MPTCP_PM_MPC_ENDPOINT_ACCOUNTED = 6,
+};
+
+struct mptcp_pm_addr_entry {
+	struct list_head list;
+	struct mptcp_addr_info addr;
+	u8 flags;
+	int ifindex;
+	struct socket *lsk;
+};
+
+struct mptcp_pm_add_entry {
+	struct list_head list;
+	struct mptcp_addr_info addr;
+	u8 retrans_times;
+	struct timer_list add_timer;
+	struct mptcp_sock *sock;
+};
+
+struct pm_nl_pernet {
+	spinlock_t lock;
+	struct list_head local_addr_list;
+	unsigned int addrs;
+	unsigned int stale_loss_cnt;
+	unsigned int add_addr_signal_max;
+	unsigned int add_addr_accept_max;
+	unsigned int local_addr_max;
+	unsigned int subflows_max;
+	unsigned int next_id;
+	long unsigned int id_bitmap[8];
+};
+
+struct join_entry {
+	u32 token;
+	u32 remote_nonce;
+	u32 local_nonce;
+	u8 join_id;
+	u8 local_id;
+	u8 backup;
+	u8 valid;
+};
+
+enum {
+	HANDSHAKE_A_ACCEPT_SOCKFD = 1,
+	HANDSHAKE_A_ACCEPT_HANDLER_CLASS = 2,
+	HANDSHAKE_A_ACCEPT_MESSAGE_TYPE = 3,
+	HANDSHAKE_A_ACCEPT_TIMEOUT = 4,
+	HANDSHAKE_A_ACCEPT_AUTH_MODE = 5,
+	HANDSHAKE_A_ACCEPT_PEER_IDENTITY = 6,
+	HANDSHAKE_A_ACCEPT_CERTIFICATE = 7,
+	HANDSHAKE_A_ACCEPT_PEERNAME = 8,
+	__HANDSHAKE_A_ACCEPT_MAX = 9,
+	HANDSHAKE_A_ACCEPT_MAX = 8,
+};
+
+enum {
+	HANDSHAKE_A_DONE_STATUS = 1,
+	HANDSHAKE_A_DONE_SOCKFD = 2,
+	HANDSHAKE_A_DONE_REMOTE_AUTH = 3,
+	__HANDSHAKE_A_DONE_MAX = 4,
+	HANDSHAKE_A_DONE_MAX = 3,
+};
+
+enum {
+	HANDSHAKE_CMD_READY = 1,
+	HANDSHAKE_CMD_ACCEPT = 2,
+	HANDSHAKE_CMD_DONE = 3,
+	__HANDSHAKE_CMD_MAX = 4,
+	HANDSHAKE_CMD_MAX = 3,
+};
+
+enum hp_flags_bits {
+	HANDSHAKE_F_PROTO_NOTIFY = 0,
+};
+
+typedef __u64 Elf64_Addr;
+
+typedef __u16 Elf64_Half;
+
+typedef __u64 Elf64_Off;
+
+typedef __u32 Elf64_Word;
+
+typedef __u64 Elf64_Xword;
+
+struct elf64_hdr {
+	unsigned char e_ident[16];
+	Elf64_Half e_type;
+	Elf64_Half e_machine;
+	Elf64_Word e_version;
+	Elf64_Addr e_entry;
+	Elf64_Off e_phoff;
+	Elf64_Off e_shoff;
+	Elf64_Word e_flags;
+	Elf64_Half e_ehsize;
+	Elf64_Half e_phentsize;
+	Elf64_Half e_phnum;
+	Elf64_Half e_shentsize;
+	Elf64_Half e_shnum;
+	Elf64_Half e_shstrndx;
+};
+
+typedef struct elf64_hdr Elf64_Ehdr;
+
+struct elf32_phdr {
+	Elf32_Word p_type;
+	Elf32_Off p_offset;
+	Elf32_Addr p_vaddr;
+	Elf32_Addr p_paddr;
+	Elf32_Word p_filesz;
+	Elf32_Word p_memsz;
+	Elf32_Word p_flags;
+	Elf32_Word p_align;
+};
+
+typedef struct elf32_phdr Elf32_Phdr;
+
+struct elf64_phdr {
+	Elf64_Word p_type;
+	Elf64_Word p_flags;
+	Elf64_Off p_offset;
+	Elf64_Addr p_vaddr;
+	Elf64_Addr p_paddr;
+	Elf64_Xword p_filesz;
+	Elf64_Xword p_memsz;
+	Elf64_Xword p_align;
+};
+
+typedef struct elf64_phdr Elf64_Phdr;
+
+struct elf32_note {
+	Elf32_Word n_namesz;
+	Elf32_Word n_descsz;
+	Elf32_Word n_type;
+};
+
+typedef struct elf32_note Elf32_Nhdr;
+
+struct freader {
+	void *buf;
+	u32 buf_sz;
+	int err;
+	long: 32;
+	union {
+		struct {
+			struct file *file;
+			struct folio *folio;
+			void *addr;
+			long: 32;
+			loff_t folio_off;
+			bool may_fault;
+			long: 32;
+		};
+		struct {
+			const char *data;
+			long: 32;
+			u64 data_sz;
+		};
+	};
+};
+
+struct ida_bitmap {
+	long unsigned int bitmap[32];
+};
+
+struct uevent_sock {
+	struct list_head list;
+	struct sock *sk;
+};
+
+struct cpuinfo_arm {
+	u32 cpuid;
+	unsigned int loops_per_jiffy;
+};
+
+struct mpidr_hash {
+	u32 mask;
+	u32 shift_aff[3];
+	u32 bits;
+};
+
+struct proc_info_list {
+	unsigned int cpu_val;
+	unsigned int cpu_mask;
+	long unsigned int __cpu_mm_mmu_flags;
+	long unsigned int __cpu_io_mmu_flags;
+	long unsigned int __cpu_flush;
+	const char *arch_name;
+	const char *elf_name;
+	unsigned int elf_hwcap;
+	const char *cpu_name;
+	struct processor *proc;
+	struct cpu_tlb_fns *tlb;
+	struct cpu_user_fns *user;
+	struct cpu_cache_fns *cache;
+};
+
+struct stack {
+	u32 irq[4];
+	u32 abt[4];
+	u32 und[4];
+	u32 fiq[4];
+};
+
+struct mpu_rgn {
+	union {
+		u32 drbar;
+		u32 prbar;
+	};
+	union {
+		u32 drsr;
+		u32 prlar;
+	};
+	union {
+		u32 dracr;
+		u32 unused;
+	};
+};
+
+struct mpu_rgn_info {
+	unsigned int used;
+	struct mpu_rgn rgns[16];
+};
+
+struct secondary_data {
+	union {
+		struct mpu_rgn_info *mpu_rgn_info;
+		u64 pgdir;
+	};
+	long unsigned int swapper_pg_dir;
+	void *stack;
+	struct task_struct *task;
+	long: 32;
+};
+
+typedef struct {
+	unsigned int __softirq_pending;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+} irq_cpustat_t;
+
+enum ipi_msg_type {
+	IPI_WAKEUP = 0,
+	IPI_TIMER = 1,
+	IPI_RESCHEDULE = 2,
+	IPI_CALL_FUNC = 3,
+	IPI_CPU_STOP = 4,
+	IPI_IRQ_WORK = 5,
+	IPI_COMPLETION = 6,
+	NR_IPI = 7,
+	IPI_CPU_BACKTRACE = 7,
+	MAX_IPI = 8,
+};
+
+enum unwind_reason_code {
+	URC_OK = 0,
+	URC_CONTINUE_UNWIND = 8,
+	URC_FAILURE = 9,
+};
+
+struct unwind_ctrl_block {
+	long unsigned int vrs[16];
+	const long unsigned int *insn;
+	long unsigned int sp_high;
+	long unsigned int *lr_addr;
+	int check_each_pop;
+	int entries;
+	int byte;
+};
+
+enum regs {
+	FP = 11,
+	SP = 13,
+	LR = 14,
+	PC = 15,
+};
+
+struct cpu_efficiency {
+	const char *compatible;
+	long unsigned int efficiency;
+};
+
+typedef void (*harden_branch_predictor_fn_t)();
+
+struct fsr_info {
+	int (*fn)(long unsigned int, unsigned int, struct pt_regs *);
+	int sig;
+	int code;
+	const char *name;
+};
+
+struct cachepolicy {
+	const char policy[16];
+	unsigned int cr_mask;
+	pmdval_t pmd;
+	pteval_t pte;
+};
+
+enum decode_type {
+	DECODE_TYPE_END = 0,
+	DECODE_TYPE_TABLE = 1,
+	DECODE_TYPE_CUSTOM = 2,
+	DECODE_TYPE_SIMULATE = 3,
+	DECODE_TYPE_EMULATE = 4,
+	DECODE_TYPE_OR = 5,
+	DECODE_TYPE_REJECT = 6,
+	NUM_DECODE_TYPES = 7,
+};
+
+enum decode_reg_type {
+	REG_TYPE_NONE = 0,
+	REG_TYPE_ANY = 1,
+	REG_TYPE_SAMEAS16 = 2,
+	REG_TYPE_SP = 3,
+	REG_TYPE_PC = 4,
+	REG_TYPE_NOSP = 5,
+	REG_TYPE_NOSPPC = 6,
+	REG_TYPE_NOPC = 7,
+	REG_TYPE_NOPCWB = 8,
+	REG_TYPE_NOPCX = 9,
+	REG_TYPE_NOSPPCX = 10,
+	REG_TYPE_0 = 0,
+};
+
+struct decode_table {
+	struct decode_header header;
+	union decode_item table;
+};
+
+struct decode_custom {
+	struct decode_header header;
+	union decode_item decoder;
+};
+
+struct decode_simulate {
+	struct decode_header header;
+	union decode_item handler;
+};
+
+struct decode_emulate {
+	struct decode_header header;
+	union decode_item handler;
+};
+
+typedef enum probes_insn kprobe_decode_insn_t(probes_opcode_t, struct arch_probes_insn *, bool, const union decode_action *, const struct decode_checker **);
+
+enum {
+	STACK_USE_NONE = 0,
+	STACK_USE_UNKNOWN = 1,
+	STACK_USE_FIXED_X0X = 2,
+	STACK_USE_FIXED_XXX = 3,
+	STACK_USE_STMDX = 4,
+	NUM_STACK_USE_TYPES = 5,
+};
+
+enum {
+	BPF_R2_HI = 0,
+	BPF_R2_LO = 1,
+	BPF_R3_HI = 2,
+	BPF_R3_LO = 3,
+	BPF_R4_HI = 4,
+	BPF_R4_LO = 5,
+	BPF_R5_HI = 6,
+	BPF_R5_LO = 7,
+	BPF_R7_HI = 8,
+	BPF_R7_LO = 9,
+	BPF_R8_HI = 10,
+	BPF_R8_LO = 11,
+	BPF_R9_HI = 12,
+	BPF_R9_LO = 13,
+	BPF_FP_HI = 14,
+	BPF_FP_LO = 15,
+	BPF_TC_HI = 16,
+	BPF_TC_LO = 17,
+	BPF_AX_HI = 18,
+	BPF_AX_LO = 19,
+	BPF_JIT_SCRATCH_REGS = 20,
+};
+
+struct jit_ctx {
+	const struct bpf_prog *prog;
+	unsigned int idx;
+	unsigned int prologue_bytes;
+	unsigned int epilogue_offset;
+	unsigned int cpu_architecture;
+	u32 flags;
+	u32 *offsets;
+	u32 *target;
+	u32 stack_size;
+};
+
+struct softirq_action {
+	void (*action)();
+};
+
+struct trace_event_raw_irq_handler_entry {
+	struct trace_entry ent;
+	int irq;
+	u32 __data_loc_name;
+	char __data[0];
+};
+
+struct trace_event_raw_irq_handler_exit {
+	struct trace_entry ent;
+	int irq;
+	int ret;
+	char __data[0];
+};
+
+struct trace_event_raw_softirq {
+	struct trace_entry ent;
+	unsigned int vec;
+	char __data[0];
+};
+
+struct trace_event_raw_tasklet {
+	struct trace_entry ent;
+	void *tasklet;
+	void *func;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_irq_handler_entry {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_irq_handler_exit {};
+
+struct trace_event_data_offsets_softirq {};
+
+struct trace_event_data_offsets_tasklet {};
+
+typedef void (*btf_trace_irq_handler_entry)(void *, int, struct irqaction *);
+
+typedef void (*btf_trace_irq_handler_exit)(void *, int, struct irqaction *, int);
+
+typedef void (*btf_trace_softirq_entry)(void *, unsigned int);
+
+typedef void (*btf_trace_softirq_exit)(void *, unsigned int);
+
+typedef void (*btf_trace_softirq_raise)(void *, unsigned int);
+
+typedef void (*btf_trace_tasklet_entry)(void *, struct tasklet_struct *, void *);
+
+typedef void (*btf_trace_tasklet_exit)(void *, struct tasklet_struct *, void *);
+
+struct tasklet_head {
+	struct tasklet_struct *head;
+	struct tasklet_struct **tail;
+};
+
+struct __user_cap_header_struct {
+	__u32 version;
+	int pid;
+};
+
+typedef struct __user_cap_header_struct *cap_user_header_t;
+
+struct __user_cap_data_struct {
+	__u32 effective;
+	__u32 permitted;
+	__u32 inheritable;
+};
+
+typedef struct __user_cap_data_struct *cap_user_data_t;
+
+struct rlimit64 {
+	__u64 rlim_cur;
+	__u64 rlim_max;
+};
+
+struct prctl_mm_map {
+	__u64 start_code;
+	__u64 end_code;
+	__u64 start_data;
+	__u64 end_data;
+	__u64 start_brk;
+	__u64 brk;
+	__u64 start_stack;
+	__u64 arg_start;
+	__u64 arg_end;
+	__u64 env_start;
+	__u64 env_end;
+	__u64 *auxv;
+	__u32 auxv_size;
+	__u32 exe_fd;
+	long: 32;
+};
+
+struct tms {
+	__kernel_clock_t tms_utime;
+	__kernel_clock_t tms_stime;
+	__kernel_clock_t tms_cutime;
+	__kernel_clock_t tms_cstime;
+};
+
+struct getcpu_cache {
+	long unsigned int blob[32];
+};
+
+struct die_args {
+	struct pt_regs *regs;
+	const char *str;
+	long int err;
+	int trapnr;
+	int signr;
+};
+
+struct trace_event_raw_notifier_info {
+	struct trace_entry ent;
+	void *cb;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_notifier_info {};
+
+typedef void (*btf_trace_notifier_register)(void *, void *);
+
+typedef void (*btf_trace_notifier_unregister)(void *, void *);
+
+typedef void (*btf_trace_notifier_run)(void *, void *);
+
+struct smpboot_thread_data {
+	unsigned int cpu;
+	unsigned int status;
+	struct smp_hotplug_thread *ht;
+};
+
+enum {
+	HP_THREAD_NONE = 0,
+	HP_THREAD_ACTIVE = 1,
+	HP_THREAD_PARKED = 2,
+};
+
+typedef const struct cpumask * (*sched_domain_mask_f)(int);
+
+typedef int (*sched_domain_flags_f)();
+
+struct sd_data {
+	struct sched_domain **sd;
+	struct sched_domain_shared **sds;
+	struct sched_group **sg;
+	struct sched_group_capacity **sgc;
+};
+
+struct sched_domain_topology_level {
+	sched_domain_mask_f mask;
+	sched_domain_flags_f sd_flags;
+	int flags;
+	int numa_level;
+	struct sd_data data;
+};
+
+enum {
+	MEMBARRIER_FLAG_SYNC_CORE = 1,
+	MEMBARRIER_FLAG_RSEQ = 2,
+};
+
+enum membarrier_cmd {
+	MEMBARRIER_CMD_QUERY = 0,
+	MEMBARRIER_CMD_GLOBAL = 1,
+	MEMBARRIER_CMD_GLOBAL_EXPEDITED = 2,
+	MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED = 4,
+	MEMBARRIER_CMD_PRIVATE_EXPEDITED = 8,
+	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED = 16,
+	MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE = 32,
+	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE = 64,
+	MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ = 128,
+	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ = 256,
+	MEMBARRIER_CMD_GET_REGISTRATIONS = 512,
+	MEMBARRIER_CMD_SHARED = 1,
+};
+
+enum membarrier_cmd_flag {
+	MEMBARRIER_CMD_FLAG_CPU = 1,
+};
+
+enum cpuacct_stat_index {
+	CPUACCT_STAT_USER = 0,
+	CPUACCT_STAT_SYSTEM = 1,
+	CPUACCT_STAT_NSTATS = 2,
+};
+
+struct cpuacct {
+	struct cgroup_subsys_state css;
+	u64 *cpuusage;
+	struct kernel_cpustat *cpustat;
+};
+
+struct s_data {
+	struct sched_domain **sd;
+	struct root_domain *rd;
+};
+
+enum s_alloc {
+	sa_rootdomain = 0,
+	sa_sd = 1,
+	sa_sd_storage = 2,
+	sa_none = 3,
+};
+
+struct semaphore_waiter {
+	struct list_head list;
+	struct task_struct *task;
+	bool up;
+};
+
+enum pm_qos_req_action {
+	PM_QOS_ADD_REQ = 0,
+	PM_QOS_UPDATE_REQ = 1,
+	PM_QOS_REMOVE_REQ = 2,
+};
+
+enum {
+	IRQ_SET_MASK_OK = 0,
+	IRQ_SET_MASK_OK_NOCOPY = 1,
+	IRQ_SET_MASK_OK_DONE = 2,
+};
+
+enum {
+	IRQC_IS_HARDIRQ = 0,
+	IRQC_IS_NESTED = 1,
+};
+
+struct irq_affinity {
+	unsigned int pre_vectors;
+	unsigned int post_vectors;
+	unsigned int nr_sets;
+	unsigned int set_size[4];
+	void (*calc_sets)(struct irq_affinity *, unsigned int);
+	void *priv;
+};
+
+struct trace_event_raw_rcu_utilization {
+	struct trace_entry ent;
+	const char *s;
+	char __data[0];
+};
+
+struct trace_event_raw_rcu_stall_warning {
+	struct trace_entry ent;
+	const char *rcuname;
+	const char *msg;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_rcu_utilization {};
+
+struct trace_event_data_offsets_rcu_stall_warning {};
+
+typedef void (*btf_trace_rcu_utilization)(void *, const char *);
+
+typedef void (*btf_trace_rcu_stall_warning)(void *, const char *, const char *);
+
+struct rcu_tasks;
+
+typedef void (*rcu_tasks_gp_func_t)(struct rcu_tasks *);
+
+typedef void (*pregp_func_t)(struct list_head *);
+
+typedef void (*pertask_func_t)(struct task_struct *, struct list_head *);
+
+typedef void (*postscan_func_t)(struct list_head *);
+
+typedef void (*holdouts_func_t)(struct list_head *, bool, bool *);
+
+typedef void (*postgp_func_t)(struct rcu_tasks *);
+
+struct rcu_tasks_percpu;
+
+struct rcu_tasks {
+	struct rcuwait cbs_wait;
+	raw_spinlock_t cbs_gbl_lock;
+	struct mutex tasks_gp_mutex;
+	int gp_state;
+	int gp_sleep;
+	int init_fract;
+	long unsigned int gp_jiffies;
+	long unsigned int gp_start;
+	long unsigned int tasks_gp_seq;
+	long unsigned int n_ipis;
+	long unsigned int n_ipis_fails;
+	struct task_struct *kthread_ptr;
+	long unsigned int lazy_jiffies;
+	rcu_tasks_gp_func_t gp_func;
+	pregp_func_t pregp_func;
+	pertask_func_t pertask_func;
+	postscan_func_t postscan_func;
+	holdouts_func_t holdouts_func;
+	postgp_func_t postgp_func;
+	call_rcu_func_t call_func;
+	unsigned int wait_state;
+	struct rcu_tasks_percpu *rtpcpu;
+	struct rcu_tasks_percpu **rtpcp_array;
+	int percpu_enqueue_shift;
+	int percpu_enqueue_lim;
+	int percpu_dequeue_lim;
+	long unsigned int percpu_dequeue_gpseq;
+	struct mutex barrier_q_mutex;
+	atomic_t barrier_q_count;
+	struct completion barrier_q_completion;
+	long unsigned int barrier_q_seq;
+	long unsigned int barrier_q_start;
+	char *name;
+	char *kname;
+};
+
+struct rcu_tasks_percpu {
+	struct rcu_segcblist cblist;
+	raw_spinlock_t lock;
+	long unsigned int rtp_jiffies;
+	long unsigned int rtp_n_lock_retries;
+	struct timer_list lazy_timer;
+	unsigned int urgent_gp;
+	struct work_struct rtp_work;
+	struct irq_work rtp_irq_work;
+	struct callback_head barrier_q_head;
+	struct list_head rtp_blkd_tasks;
+	struct list_head rtp_exit_list;
+	int cpu;
+	int index;
+	struct rcu_tasks *rtpp;
+};
+
+struct trc_stall_chk_rdr {
+	int nesting;
+	int ipi_to_cpu;
+	u8 needqs;
+};
+
+struct dma_coherent_mem {
+	void *virt_base;
+	dma_addr_t device_base;
+	long unsigned int pfn_base;
+	int size;
+	long unsigned int *bitmap;
+	spinlock_t spinlock;
+	bool use_dev_dma_pfn_offset;
+};
+
+typedef __kernel_long_t __kernel_suseconds_t;
+
+typedef __kernel_suseconds_t suseconds_t;
+
+struct trace_event_raw_timer_class {
+	struct trace_entry ent;
+	void *timer;
+	char __data[0];
+};
+
+struct trace_event_raw_timer_start {
+	struct trace_entry ent;
+	void *timer;
+	void *function;
+	long unsigned int expires;
+	long unsigned int bucket_expiry;
+	long unsigned int now;
+	unsigned int flags;
+	char __data[0];
+};
+
+struct trace_event_raw_timer_expire_entry {
+	struct trace_entry ent;
+	void *timer;
+	long unsigned int now;
+	void *function;
+	long unsigned int baseclk;
+	char __data[0];
+};
+
+struct trace_event_raw_timer_base_idle {
+	struct trace_entry ent;
+	bool is_idle;
+	unsigned int cpu;
+	char __data[0];
+};
+
+struct trace_event_raw_hrtimer_init {
+	struct trace_entry ent;
+	void *hrtimer;
+	clockid_t clockid;
+	enum hrtimer_mode mode;
+	char __data[0];
+};
+
+struct trace_event_raw_hrtimer_start {
+	struct trace_entry ent;
+	void *hrtimer;
+	void *function;
+	s64 expires;
+	s64 softexpires;
+	enum hrtimer_mode mode;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_hrtimer_expire_entry {
+	struct trace_entry ent;
+	void *hrtimer;
+	long: 32;
+	s64 now;
+	void *function;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_hrtimer_class {
+	struct trace_entry ent;
+	void *hrtimer;
+	char __data[0];
+};
+
+struct trace_event_raw_itimer_state {
+	struct trace_entry ent;
+	int which;
+	long: 32;
+	long long unsigned int expires;
+	long int value_sec;
+	long int value_nsec;
+	long int interval_sec;
+	long int interval_nsec;
+	char __data[0];
+};
+
+struct trace_event_raw_itimer_expire {
+	struct trace_entry ent;
+	int which;
+	pid_t pid;
+	long long unsigned int now;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_timer_class {};
+
+struct trace_event_data_offsets_timer_start {};
+
+struct trace_event_data_offsets_timer_expire_entry {};
+
+struct trace_event_data_offsets_timer_base_idle {};
+
+struct trace_event_data_offsets_hrtimer_init {};
+
+struct trace_event_data_offsets_hrtimer_start {};
+
+struct trace_event_data_offsets_hrtimer_expire_entry {};
+
+struct trace_event_data_offsets_hrtimer_class {};
+
+struct trace_event_data_offsets_itimer_state {};
+
+struct trace_event_data_offsets_itimer_expire {};
+
+typedef void (*btf_trace_timer_init)(void *, struct timer_list *);
+
+typedef void (*btf_trace_timer_start)(void *, struct timer_list *, long unsigned int);
+
+typedef void (*btf_trace_timer_expire_entry)(void *, struct timer_list *, long unsigned int);
+
+typedef void (*btf_trace_timer_expire_exit)(void *, struct timer_list *);
+
+typedef void (*btf_trace_timer_cancel)(void *, struct timer_list *);
+
+typedef void (*btf_trace_timer_base_idle)(void *, bool, unsigned int);
+
+typedef void (*btf_trace_hrtimer_init)(void *, struct hrtimer *, clockid_t, enum hrtimer_mode);
+
+typedef void (*btf_trace_hrtimer_start)(void *, struct hrtimer *, enum hrtimer_mode);
+
+typedef void (*btf_trace_hrtimer_expire_entry)(void *, struct hrtimer *, ktime_t *);
+
+typedef void (*btf_trace_hrtimer_expire_exit)(void *, struct hrtimer *);
+
+typedef void (*btf_trace_hrtimer_cancel)(void *, struct hrtimer *);
+
+typedef void (*btf_trace_itimer_state)(void *, int, const struct itimerspec64 * const, long long unsigned int);
+
+typedef void (*btf_trace_itimer_expire)(void *, int, struct pid *, long long unsigned int);
+
+struct timer_base {
+	raw_spinlock_t lock;
+	struct timer_list *running_timer;
+	long unsigned int clk;
+	long unsigned int next_expiry;
+	unsigned int cpu;
+	bool next_expiry_recalc;
+	bool is_idle;
+	bool timers_pending;
+	long unsigned int pending_map[16];
+	struct hlist_head vectors[512];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct process_timer {
+	struct timer_list timer;
+	struct task_struct *task;
+};
+
+struct __kernel_old_itimerval {
+	struct __kernel_old_timeval it_interval;
+	struct __kernel_old_timeval it_value;
+};
+
+struct trace_event_raw_csd_queue_cpu {
+	struct trace_entry ent;
+	unsigned int cpu;
+	void *callsite;
+	void *func;
+	void *csd;
+	char __data[0];
+};
+
+struct trace_event_raw_csd_function {
+	struct trace_entry ent;
+	void *func;
+	void *csd;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_csd_queue_cpu {};
+
+struct trace_event_data_offsets_csd_function {};
+
+typedef void (*btf_trace_csd_queue_cpu)(void *, const unsigned int, long unsigned int, smp_call_func_t, call_single_data_t *);
+
+typedef void (*btf_trace_csd_function_entry)(void *, smp_call_func_t, call_single_data_t *);
+
+typedef void (*btf_trace_csd_function_exit)(void *, smp_call_func_t, call_single_data_t *);
+
+struct call_function_data {
+	call_single_data_t *csd;
+	cpumask_var_t cpumask;
+	cpumask_var_t cpumask_ipi;
+};
+
+struct smp_call_on_cpu_struct {
+	struct work_struct work;
+	struct completion done;
+	int (*func)(void *);
+	void *data;
+	int ret;
+	int cpu;
+};
+
+struct cpuset_remove_tasks_struct {
+	struct work_struct work;
+	struct cpuset *cs;
+};
+
+struct cpu_stop_done {
+	atomic_t nr_todo;
+	int ret;
+	struct completion completion;
+};
+
+struct cpu_stopper {
+	struct task_struct *thread;
+	raw_spinlock_t lock;
+	bool enabled;
+	struct list_head works;
+	struct cpu_stop_work stop_work;
+	long unsigned int caller;
+	cpu_stop_fn_t fn;
+};
+
+enum multi_stop_state {
+	MULTI_STOP_NONE = 0,
+	MULTI_STOP_PREPARE = 1,
+	MULTI_STOP_DISABLE_IRQ = 2,
+	MULTI_STOP_RUN = 3,
+	MULTI_STOP_EXIT = 4,
+};
+
+struct multi_stop_data {
+	cpu_stop_fn_t fn;
+	void *data;
+	unsigned int num_threads;
+	const struct cpumask *active_cpus;
+	enum multi_stop_state state;
+	atomic_t thread_ack;
+};
+
+typedef int (*objpool_init_obj_cb)(void *, void *);
+
+struct kprobe_blacklist_entry {
+	struct list_head list;
+	long unsigned int start_addr;
+	long unsigned int end_addr;
+};
+
+struct kprobe_insn_page {
+	struct list_head list;
+	kprobe_opcode_t *insns;
+	struct kprobe_insn_cache *cache;
+	int nused;
+	int ngarbage;
+	char slot_used[0];
+};
+
+enum kprobe_slot_state {
+	SLOT_CLEAN = 0,
+	SLOT_DIRTY = 1,
+	SLOT_USED = 2,
+};
+
+struct trace_print_flags_u64 {
+	long long unsigned int mask;
+	const char *name;
+	long: 32;
+};
+
+struct ctx_switch_entry {
+	struct trace_entry ent;
+	unsigned int prev_pid;
+	unsigned int next_pid;
+	unsigned int next_cpu;
+	unsigned char prev_prio;
+	unsigned char prev_state;
+	unsigned char next_prio;
+	unsigned char next_state;
+};
+
+struct userstack_entry {
+	struct trace_entry ent;
+	unsigned int tgid;
+	long unsigned int caller[8];
+};
+
+struct hwlat_entry {
+	struct trace_entry ent;
+	u64 duration;
+	u64 outer_duration;
+	u64 nmi_total_ts;
+	struct timespec64 timestamp;
+	unsigned int nmi_count;
+	unsigned int seqnum;
+	unsigned int count;
+	long: 32;
+};
+
+struct osnoise_entry {
+	struct trace_entry ent;
+	u64 noise;
+	u64 runtime;
+	u64 max_sample;
+	unsigned int hw_count;
+	unsigned int nmi_count;
+	unsigned int irq_count;
+	unsigned int softirq_count;
+	unsigned int thread_count;
+	long: 32;
+};
+
+struct timerlat_entry {
+	struct trace_entry ent;
+	unsigned int seqnum;
+	int context;
+	u64 timer_latency;
+};
+
+struct trace_mark {
+	long long unsigned int val;
+	char sym;
+	long: 32;
+};
+
+enum {
+	TRACE_PIDS = 1,
+	TRACE_NO_PIDS = 2,
+};
+
+struct module_string {
+	struct list_head next;
+	struct module *module;
+	char *str;
+};
+
+enum {
+	FORMAT_HEADER = 1,
+	FORMAT_FIELD_SEPERATOR = 2,
+	FORMAT_PRINTFMT = 3,
+};
+
+struct boot_triggers {
+	const char *event;
+	char *trigger;
+};
+
+struct enable_trigger_data {
+	struct trace_event_file *file;
+	bool enable;
+	bool hist;
+};
+
+enum cpufreq_table_sorting {
+	CPUFREQ_TABLE_UNSORTED = 0,
+	CPUFREQ_TABLE_SORTED_ASCENDING = 1,
+	CPUFREQ_TABLE_SORTED_DESCENDING = 2,
+};
+
+struct cpufreq_cpuinfo {
+	unsigned int max_freq;
+	unsigned int min_freq;
+	unsigned int transition_latency;
+};
+
+struct cpufreq_stats;
+
+struct cpufreq_governor;
+
+struct cpufreq_frequency_table;
+
+struct cpufreq_policy {
+	cpumask_var_t cpus;
+	cpumask_var_t related_cpus;
+	cpumask_var_t real_cpus;
+	unsigned int shared_type;
+	unsigned int cpu;
+	struct clk *clk;
+	struct cpufreq_cpuinfo cpuinfo;
+	unsigned int min;
+	unsigned int max;
+	unsigned int cur;
+	unsigned int suspend_freq;
+	unsigned int policy;
+	unsigned int last_policy;
+	struct cpufreq_governor *governor;
+	void *governor_data;
+	char last_governor[16];
+	struct work_struct update;
+	struct freq_constraints constraints;
+	struct freq_qos_request *min_freq_req;
+	struct freq_qos_request *max_freq_req;
+	struct cpufreq_frequency_table *freq_table;
+	enum cpufreq_table_sorting freq_table_sorted;
+	struct list_head policy_list;
+	struct kobject kobj;
+	struct completion kobj_unregister;
+	struct rw_semaphore rwsem;
+	bool fast_switch_possible;
+	bool fast_switch_enabled;
+	bool strict_target;
+	bool efficiencies_available;
+	unsigned int transition_delay_us;
+	bool dvfs_possible_from_any_cpu;
+	bool boost_enabled;
+	unsigned int cached_target_freq;
+	unsigned int cached_resolved_idx;
+	bool transition_ongoing;
+	spinlock_t transition_lock;
+	wait_queue_head_t transition_wait;
+	struct task_struct *transition_task;
+	struct cpufreq_stats *stats;
+	void *driver_data;
+	struct thermal_cooling_device *cdev;
+	struct notifier_block nb_min;
+	struct notifier_block nb_max;
+};
+
+struct cpufreq_governor {
+	char name[16];
+	int (*init)(struct cpufreq_policy *);
+	void (*exit)(struct cpufreq_policy *);
+	int (*start)(struct cpufreq_policy *);
+	void (*stop)(struct cpufreq_policy *);
+	void (*limits)(struct cpufreq_policy *);
+	ssize_t (*show_setspeed)(struct cpufreq_policy *, char *);
+	int (*store_setspeed)(struct cpufreq_policy *, unsigned int);
+	struct list_head governor_list;
+	struct module *owner;
+	u8 flags;
+};
+
+struct cpufreq_frequency_table {
+	unsigned int flags;
+	unsigned int driver_data;
+	unsigned int frequency;
+};
+
+struct trace_event_raw_cpu {
+	struct trace_entry ent;
+	u32 state;
+	u32 cpu_id;
+	char __data[0];
+};
+
+struct trace_event_raw_cpu_idle_miss {
+	struct trace_entry ent;
+	u32 cpu_id;
+	u32 state;
+	bool below;
+	char __data[0];
+};
+
+struct trace_event_raw_powernv_throttle {
+	struct trace_entry ent;
+	int chip_id;
+	u32 __data_loc_reason;
+	int pmax;
+	char __data[0];
+};
+
+struct trace_event_raw_pstate_sample {
+	struct trace_entry ent;
+	u32 core_busy;
+	u32 scaled_busy;
+	u32 from;
+	u32 to;
+	u64 mperf;
+	u64 aperf;
+	u64 tsc;
+	u32 freq;
+	u32 io_boost;
+	char __data[0];
+};
+
+struct trace_event_raw_cpu_frequency_limits {
+	struct trace_entry ent;
+	u32 min_freq;
+	u32 max_freq;
+	u32 cpu_id;
+	char __data[0];
+};
+
+struct trace_event_raw_device_pm_callback_start {
+	struct trace_entry ent;
+	u32 __data_loc_device;
+	u32 __data_loc_driver;
+	u32 __data_loc_parent;
+	u32 __data_loc_pm_ops;
+	int event;
+	char __data[0];
+};
+
+struct trace_event_raw_device_pm_callback_end {
+	struct trace_entry ent;
+	u32 __data_loc_device;
+	u32 __data_loc_driver;
+	int error;
+	char __data[0];
+};
+
+struct trace_event_raw_suspend_resume {
+	struct trace_entry ent;
+	const char *action;
+	int val;
+	bool start;
+	char __data[0];
+};
+
+struct trace_event_raw_wakeup_source {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	long: 32;
+	u64 state;
+	char __data[0];
+};
+
+struct trace_event_raw_clock {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	long: 32;
+	u64 state;
+	u64 cpu_id;
+	char __data[0];
+};
+
+struct trace_event_raw_power_domain {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	long: 32;
+	u64 state;
+	u64 cpu_id;
+	char __data[0];
+};
+
+struct trace_event_raw_cpu_latency_qos_request {
+	struct trace_entry ent;
+	s32 value;
+	char __data[0];
+};
+
+struct trace_event_raw_pm_qos_update {
+	struct trace_entry ent;
+	enum pm_qos_req_action action;
+	int prev_value;
+	int curr_value;
+	char __data[0];
+};
+
+struct trace_event_raw_dev_pm_qos_request {
+	struct trace_entry ent;
+	u32 __data_loc_name;
+	enum dev_pm_qos_req_type type;
+	s32 new_value;
+	char __data[0];
+};
+
+struct trace_event_raw_guest_halt_poll_ns {
+	struct trace_entry ent;
+	bool grow;
+	unsigned int new;
+	unsigned int old;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_cpu {};
+
+struct trace_event_data_offsets_cpu_idle_miss {};
+
+struct trace_event_data_offsets_powernv_throttle {
+	u32 reason;
+	const void *reason_ptr_;
+};
+
+struct trace_event_data_offsets_pstate_sample {};
+
+struct trace_event_data_offsets_cpu_frequency_limits {};
+
+struct trace_event_data_offsets_device_pm_callback_start {
+	u32 device;
+	const void *device_ptr_;
+	u32 driver;
+	const void *driver_ptr_;
+	u32 parent;
+	const void *parent_ptr_;
+	u32 pm_ops;
+	const void *pm_ops_ptr_;
+};
+
+struct trace_event_data_offsets_device_pm_callback_end {
+	u32 device;
+	const void *device_ptr_;
+	u32 driver;
+	const void *driver_ptr_;
+};
+
+struct trace_event_data_offsets_suspend_resume {};
+
+struct trace_event_data_offsets_wakeup_source {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_clock {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_power_domain {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_cpu_latency_qos_request {};
+
+struct trace_event_data_offsets_pm_qos_update {};
+
+struct trace_event_data_offsets_dev_pm_qos_request {
+	u32 name;
+	const void *name_ptr_;
+};
+
+struct trace_event_data_offsets_guest_halt_poll_ns {};
+
+typedef void (*btf_trace_cpu_idle)(void *, unsigned int, unsigned int);
+
+typedef void (*btf_trace_cpu_idle_miss)(void *, unsigned int, unsigned int, bool);
+
+typedef void (*btf_trace_powernv_throttle)(void *, int, const char *, int);
+
+typedef void (*btf_trace_pstate_sample)(void *, u32, u32, u32, u32, u64, u64, u64, u32, u32);
+
+typedef void (*btf_trace_cpu_frequency)(void *, unsigned int, unsigned int);
+
+typedef void (*btf_trace_cpu_frequency_limits)(void *, struct cpufreq_policy *);
+
+typedef void (*btf_trace_device_pm_callback_start)(void *, struct device *, const char *, int);
+
+typedef void (*btf_trace_device_pm_callback_end)(void *, struct device *, int);
+
+typedef void (*btf_trace_suspend_resume)(void *, const char *, int, bool);
+
+typedef void (*btf_trace_wakeup_source_activate)(void *, const char *, unsigned int);
+
+typedef void (*btf_trace_wakeup_source_deactivate)(void *, const char *, unsigned int);
+
+typedef void (*btf_trace_clock_enable)(void *, const char *, unsigned int, unsigned int);
+
+typedef void (*btf_trace_clock_disable)(void *, const char *, unsigned int, unsigned int);
+
+typedef void (*btf_trace_clock_set_rate)(void *, const char *, unsigned int, unsigned int);
+
+typedef void (*btf_trace_power_domain_target)(void *, const char *, unsigned int, unsigned int);
+
+typedef void (*btf_trace_pm_qos_add_request)(void *, s32);
+
+typedef void (*btf_trace_pm_qos_update_request)(void *, s32);
+
+typedef void (*btf_trace_pm_qos_remove_request)(void *, s32);
+
+typedef void (*btf_trace_pm_qos_update_target)(void *, enum pm_qos_req_action, int, int);
+
+typedef void (*btf_trace_pm_qos_update_flags)(void *, enum pm_qos_req_action, int, int);
+
+typedef void (*btf_trace_dev_pm_qos_add_request)(void *, const char *, enum dev_pm_qos_req_type, s32);
+
+typedef void (*btf_trace_dev_pm_qos_update_request)(void *, const char *, enum dev_pm_qos_req_type, s32);
+
+typedef void (*btf_trace_dev_pm_qos_remove_request)(void *, const char *, enum dev_pm_qos_req_type, s32);
+
+typedef void (*btf_trace_guest_halt_poll_ns)(void *, bool, unsigned int, unsigned int);
+
+enum bpf_perf_event_type {
+	BPF_PERF_EVENT_UNSPEC = 0,
+	BPF_PERF_EVENT_UPROBE = 1,
+	BPF_PERF_EVENT_URETPROBE = 2,
+	BPF_PERF_EVENT_KPROBE = 3,
+	BPF_PERF_EVENT_KRETPROBE = 4,
+	BPF_PERF_EVENT_TRACEPOINT = 5,
+	BPF_PERF_EVENT_EVENT = 6,
+};
+
+enum bpf_stats_type {
+	BPF_STATS_RUN_TIME = 0,
+};
+
+struct bpf_tracing_link {
+	struct bpf_tramp_link link;
+	enum bpf_attach_type attach_type;
+	struct bpf_trampoline *trampoline;
+	struct bpf_prog *tgt_prog;
+	long: 32;
+};
+
+enum bpf_audit {
+	BPF_AUDIT_LOAD = 0,
+	BPF_AUDIT_UNLOAD = 1,
+	BPF_AUDIT_MAX = 2,
+};
+
+struct bpf_prog_kstats {
+	u64 nsecs;
+	u64 cnt;
+	u64 misses;
+};
+
+struct bpf_perf_link {
+	struct bpf_link link;
+	struct file *perf_file;
+	long: 32;
+};
+
+typedef u64 (*btf_bpf_sys_bpf)(int, union bpf_attr *, u32);
+
+typedef u64 (*btf_bpf_sys_close)(u32);
+
+typedef u64 (*btf_bpf_kallsyms_lookup_name)(const char *, int, int, u64 *);
+
+struct audit_buffer;
+
+struct bpf_iter_seq_map_info {
+	u32 map_id;
+};
+
+struct bpf_iter__bpf_map {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct bpf_map *map;
+	};
+};
+
+struct bucket {
+	struct hlist_nulls_head head;
+	raw_spinlock_t raw_lock;
+};
+
+struct htab_elem;
+
+struct bpf_htab {
+	struct bpf_map map;
+	struct bpf_mem_alloc ma;
+	struct bpf_mem_alloc pcpu_ma;
+	struct bucket *buckets;
+	void *elems;
+	union {
+		struct pcpu_freelist freelist;
+		struct bpf_lru lru;
+	};
+	struct htab_elem **extra_elems;
+	long: 32;
+	struct percpu_counter pcount;
+	atomic_t count;
+	bool use_percpu_counter;
+	u32 n_buckets;
+	u32 elem_size;
+	u32 hashrnd;
+	struct lock_class_key lockdep_key;
+	int *map_locked[8];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct htab_elem {
+	union {
+		struct hlist_nulls_node hash_node;
+		struct {
+			void *padding;
+			union {
+				struct pcpu_freelist_node fnode;
+				struct htab_elem *batch_flink;
+			};
+		};
+	};
+	union {
+		void *ptr_to_pptr;
+		struct bpf_lru_node lru_node;
+	};
+	u32 hash;
+	char key[0];
+};
+
+struct bpf_iter_seq_hash_map_info {
+	struct bpf_map *map;
+	struct bpf_htab *htab;
+	void *percpu_value_buf;
+	u32 bucket_id;
+	u32 skip_elems;
+};
+
+struct bpf_bloom_filter {
+	struct bpf_map map;
+	u32 bitset_mask;
+	u32 hash_seed;
+	u32 nr_hash_funcs;
+	long unsigned int bitset[0];
+	long: 32;
+};
+
+struct bpf_mem_cache {
+	struct llist_head free_llist;
+	local_t active;
+	struct llist_head free_llist_extra;
+	struct irq_work refill_work;
+	struct obj_cgroup *objcg;
+	int unit_size;
+	int free_cnt;
+	int low_watermark;
+	int high_watermark;
+	int batch;
+	int percpu_size;
+	bool draining;
+	struct bpf_mem_cache *tgt;
+	struct llist_head free_by_rcu;
+	struct llist_node *free_by_rcu_tail;
+	struct llist_head waiting_for_gp;
+	struct llist_node *waiting_for_gp_tail;
+	struct callback_head rcu;
+	atomic_t call_rcu_in_progress;
+	struct llist_head free_llist_extra_rcu;
+	struct llist_head free_by_rcu_ttrace;
+	struct llist_head waiting_for_gp_ttrace;
+	struct callback_head rcu_ttrace;
+	atomic_t call_rcu_ttrace_in_progress;
+};
+
+struct bpf_mem_caches {
+	struct bpf_mem_cache cache[11];
+};
+
+struct bpf_devmap_val {
+	__u32 ifindex;
+	union {
+		int fd;
+		__u32 id;
+	} bpf_prog;
+};
+
+struct xdp_dev_bulk_queue {
+	struct xdp_frame *q[16];
+	struct list_head flush_node;
+	struct net_device *dev;
+	struct net_device *dev_rx;
+	struct bpf_prog *xdp_prog;
+	unsigned int count;
+};
+
+struct bpf_dtab_netdev {
+	struct net_device *dev;
+	struct hlist_node index_hlist;
+	struct bpf_prog *xdp_prog;
+	struct callback_head rcu;
+	unsigned int idx;
+	struct bpf_devmap_val val;
+};
+
+struct bpf_dtab {
+	struct bpf_map map;
+	struct bpf_dtab_netdev **netdev_map;
+	struct list_head list;
+	struct hlist_head *dev_index_head;
+	spinlock_t index_lock;
+	unsigned int items;
+	u32 n_buckets;
+	long: 32;
+};
+
+struct tcx_link {
+	struct bpf_link link;
+	struct net_device *dev;
+	u32 location;
+};
+
+struct reuseport_array {
+	struct bpf_map map;
+	struct sock *ptrs[0];
+};
+
+struct bpf_crypto_type_list {
+	const struct bpf_crypto_type *type;
+	struct list_head list;
+};
+
+struct bpf_crypto_params {
+	char type[14];
+	u8 reserved[2];
+	char algo[128];
+	u8 key[256];
+	u32 key_len;
+	u32 authsize;
+};
+
+struct bpf_crypto_ctx {
+	const struct bpf_crypto_type *type;
+	void *tfm;
+	u32 siv_len;
+	struct callback_head rcu;
+	refcount_t usage;
+};
+
+struct bp_slots_histogram {
+	atomic_t *count;
+};
+
+struct bp_cpuinfo {
+	unsigned int cpu_pinned;
+	struct bp_slots_histogram tsk_pinned;
+};
+
+enum {
+	XA_CHECK_SCHED = 4096,
+};
+
+struct wb_lock_cookie {
+	bool locked;
+	long unsigned int flags;
+};
+
+struct dirty_throttle_control {
+	struct wb_domain *dom;
+	struct dirty_throttle_control *gdtc;
+	struct bdi_writeback *wb;
+	struct fprop_local_percpu *wb_completions;
+	long unsigned int avail;
+	long unsigned int dirty;
+	long unsigned int thresh;
+	long unsigned int bg_thresh;
+	long unsigned int wb_dirty;
+	long unsigned int wb_thresh;
+	long unsigned int wb_bg_thresh;
+	long unsigned int pos_ratio;
+	bool freerun;
+	bool dirty_exceeded;
+};
+
+struct contig_page_info {
+	long unsigned int free_pages;
+	long unsigned int free_blocks_total;
+	long unsigned int free_blocks_suitable;
+};
+
+struct pcpu_group_info {
+	int nr_units;
+	long unsigned int base_offset;
+	unsigned int *cpu_map;
+};
+
+struct pcpu_alloc_info {
+	size_t static_size;
+	size_t reserved_size;
+	size_t dyn_size;
+	size_t unit_size;
+	size_t atom_size;
+	size_t alloc_size;
+	size_t __ai_size;
+	int nr_groups;
+	struct pcpu_group_info groups[0];
+};
+
+typedef int pcpu_fc_cpu_to_node_fn_t(int);
+
+typedef int pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);
+
+struct trace_event_raw_percpu_alloc_percpu {
+	struct trace_entry ent;
+	long unsigned int call_site;
+	bool reserved;
+	bool is_atomic;
+	size_t size;
+	size_t align;
+	void *base_addr;
+	int off;
+	void *ptr;
+	size_t bytes_alloc;
+	long unsigned int gfp_flags;
+	char __data[0];
+};
+
+struct trace_event_raw_percpu_free_percpu {
+	struct trace_entry ent;
+	void *base_addr;
+	int off;
+	void *ptr;
+	char __data[0];
+};
+
+struct trace_event_raw_percpu_alloc_percpu_fail {
+	struct trace_entry ent;
+	bool reserved;
+	bool is_atomic;
+	size_t size;
+	size_t align;
+	char __data[0];
+};
+
+struct trace_event_raw_percpu_create_chunk {
+	struct trace_entry ent;
+	void *base_addr;
+	char __data[0];
+};
+
+struct trace_event_raw_percpu_destroy_chunk {
+	struct trace_entry ent;
+	void *base_addr;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_percpu_alloc_percpu {};
+
+struct trace_event_data_offsets_percpu_free_percpu {};
+
+struct trace_event_data_offsets_percpu_alloc_percpu_fail {};
+
+struct trace_event_data_offsets_percpu_create_chunk {};
+
+struct trace_event_data_offsets_percpu_destroy_chunk {};
+
+typedef void (*btf_trace_percpu_alloc_percpu)(void *, long unsigned int, bool, bool, size_t, size_t, void *, int, void *, size_t, gfp_t);
+
+typedef void (*btf_trace_percpu_free_percpu)(void *, void *, int, void *);
+
+typedef void (*btf_trace_percpu_alloc_percpu_fail)(void *, bool, bool, size_t, size_t);
+
+typedef void (*btf_trace_percpu_create_chunk)(void *, void *);
+
+typedef void (*btf_trace_percpu_destroy_chunk)(void *, void *);
+
+struct pcpu_block_md {
+	int scan_hint;
+	int scan_hint_start;
+	int contig_hint;
+	int contig_hint_start;
+	int left_free;
+	int right_free;
+	int first_free;
+	int nr_bits;
+};
+
+struct pcpuobj_ext {
+	struct obj_cgroup *cgroup;
+};
+
+struct pcpu_chunk {
+	struct list_head list;
+	int free_bytes;
+	struct pcpu_block_md chunk_md;
+	long unsigned int *bound_map;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	void *base_addr;
+	long unsigned int *alloc_map;
+	struct pcpu_block_md *md_blocks;
+	void *data;
+	bool immutable;
+	bool isolated;
+	int start_offset;
+	int end_offset;
+	struct pcpuobj_ext *obj_exts;
+	int nr_pages;
+	int nr_populated;
+	int nr_empty_pop_pages;
+	long unsigned int populated[0];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct trace_event_raw_mmap_lock {
+	struct trace_entry ent;
+	struct mm_struct *mm;
+	u32 __data_loc_memcg_path;
+	bool write;
+	char __data[0];
+};
+
+struct trace_event_raw_mmap_lock_acquire_returned {
+	struct trace_entry ent;
+	struct mm_struct *mm;
+	u32 __data_loc_memcg_path;
+	bool write;
+	bool success;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_mmap_lock {
+	u32 memcg_path;
+	const void *memcg_path_ptr_;
+};
+
+struct trace_event_data_offsets_mmap_lock_acquire_returned {
+	u32 memcg_path;
+	const void *memcg_path_ptr_;
+};
+
+typedef void (*btf_trace_mmap_lock_start_locking)(void *, struct mm_struct *, const char *, bool);
+
+typedef void (*btf_trace_mmap_lock_released)(void *, struct mm_struct *, const char *, bool);
+
+typedef void (*btf_trace_mmap_lock_acquire_returned)(void *, struct mm_struct *, const char *, bool, bool);
+
+struct mlock_fbatch {
+	local_lock_t lock;
+	struct folio_batch fbatch;
+};
+
+struct vma_prepare {
+	struct vm_area_struct *vma;
+	struct vm_area_struct *adj_next;
+	struct file *file;
+	struct address_space *mapping;
+	struct anon_vma *anon_vma;
+	struct vm_area_struct *insert;
+	struct vm_area_struct *remove;
+	struct vm_area_struct *remove2;
+};
+
+typedef u64 freelist_full_t;
+
+typedef union {
+	struct {
+		void *freelist;
+		long unsigned int counter;
+	};
+	freelist_full_t full;
+} freelist_aba_t;
+
+struct kmem_cache_cpu {
+	union {
+		struct {
+			void **freelist;
+			long unsigned int tid;
+		};
+		freelist_aba_t freelist_tid;
+	};
+	struct slab *slab;
+	struct slab *partial;
+	local_lock_t lock;
+};
+
+struct kmem_cache_node {
+	spinlock_t list_lock;
+	long unsigned int nr_partial;
+	struct list_head partial;
+};
+
+typedef u32 depot_stack_handle_t;
+
+struct memory_notify {
+	long unsigned int altmap_start_pfn;
+	long unsigned int altmap_nr_pages;
+	long unsigned int start_pfn;
+	long unsigned int nr_pages;
+	int status_change_nid_normal;
+	int status_change_nid;
+};
+
+struct partial_context {
+	gfp_t flags;
+	unsigned int orig_size;
+	void *object;
+};
+
+struct track {
+	long unsigned int addr;
+	int cpu;
+	int pid;
+	long unsigned int when;
+};
+
+enum track_item {
+	TRACK_ALLOC = 0,
+	TRACK_FREE = 1,
+};
+
+enum stat_item {
+	ALLOC_FASTPATH = 0,
+	ALLOC_SLOWPATH = 1,
+	FREE_FASTPATH = 2,
+	FREE_SLOWPATH = 3,
+	FREE_FROZEN = 4,
+	FREE_ADD_PARTIAL = 5,
+	FREE_REMOVE_PARTIAL = 6,
+	ALLOC_FROM_PARTIAL = 7,
+	ALLOC_SLAB = 8,
+	ALLOC_REFILL = 9,
+	ALLOC_NODE_MISMATCH = 10,
+	FREE_SLAB = 11,
+	CPUSLAB_FLUSH = 12,
+	DEACTIVATE_FULL = 13,
+	DEACTIVATE_EMPTY = 14,
+	DEACTIVATE_TO_HEAD = 15,
+	DEACTIVATE_TO_TAIL = 16,
+	DEACTIVATE_REMOTE_FREES = 17,
+	DEACTIVATE_BYPASS = 18,
+	ORDER_FALLBACK = 19,
+	CMPXCHG_DOUBLE_CPU_FAIL = 20,
+	CMPXCHG_DOUBLE_FAIL = 21,
+	CPU_PARTIAL_ALLOC = 22,
+	CPU_PARTIAL_FREE = 23,
+	CPU_PARTIAL_NODE = 24,
+	CPU_PARTIAL_DRAIN = 25,
+	NR_SLUB_STAT_ITEMS = 26,
+};
+
+struct slub_flush_work {
+	struct work_struct work;
+	struct kmem_cache *s;
+	bool skip;
+};
+
+struct detached_freelist {
+	struct slab *slab;
+	void *tail;
+	void *freelist;
+	int cnt;
+	struct kmem_cache *s;
+};
+
+enum slab_stat_type {
+	SL_ALL = 0,
+	SL_PARTIAL = 1,
+	SL_CPU = 2,
+	SL_OBJECTS = 3,
+	SL_TOTAL = 4,
+};
+
+struct slab_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct kmem_cache *, char *);
+	ssize_t (*store)(struct kmem_cache *, const char *, size_t);
+};
+
+struct saved_alias {
+	struct kmem_cache *s;
+	const char *name;
+	struct saved_alias *next;
+};
+
+struct swap_iocb {
+	struct kiocb iocb;
+	struct bio_vec bvec[32];
+	int pages;
+	int len;
+};
+
+struct dma_block {
+	struct dma_block *next_block;
+	dma_addr_t dma;
+};
+
+struct dma_pool {
+	struct list_head page_list;
+	spinlock_t lock;
+	struct dma_block *next_block;
+	size_t nr_blocks;
+	size_t nr_active;
+	size_t nr_pages;
+	struct device *dev;
+	unsigned int size;
+	unsigned int allocation;
+	unsigned int boundary;
+	char name[32];
+	struct list_head pools;
+};
+
+struct dma_page {
+	struct list_head page_list;
+	void *vaddr;
+	dma_addr_t dma;
+};
+
+enum rmp_flags {
+	RMP_LOCKED = 1,
+	RMP_USE_SHARED_ZEROPAGE = 2,
+};
+
+struct rmap_walk_arg {
+	struct folio *folio;
+	bool map_unused_to_zeropage;
+};
+
+enum {
+	PAGE_WAS_MAPPED = 1,
+	PAGE_WAS_MLOCKED = 2,
+	PAGE_OLD_STATES = 3,
+};
+
+struct migrate_pages_stats {
+	int nr_succeeded;
+	int nr_failed_pages;
+	int nr_thp_succeeded;
+	int nr_thp_failed;
+	int nr_thp_split;
+	int nr_split;
+};
+
+struct hugepage_subpool;
+
+struct stat {
+	long unsigned int st_dev;
+	long unsigned int st_ino;
+	short unsigned int st_mode;
+	short unsigned int st_nlink;
+	short unsigned int st_uid;
+	short unsigned int st_gid;
+	long unsigned int st_rdev;
+	long unsigned int st_size;
+	long unsigned int st_blksize;
+	long unsigned int st_blocks;
+	long unsigned int st_atime;
+	long unsigned int st_atime_nsec;
+	long unsigned int st_mtime;
+	long unsigned int st_mtime_nsec;
+	long unsigned int st_ctime;
+	long unsigned int st_ctime_nsec;
+	long unsigned int __unused4;
+	long unsigned int __unused5;
+};
+
+struct stat64 {
+	long long unsigned int st_dev;
+	unsigned char __pad0[4];
+	long unsigned int __st_ino;
+	unsigned int st_mode;
+	unsigned int st_nlink;
+	long unsigned int st_uid;
+	long unsigned int st_gid;
+	long long unsigned int st_rdev;
+	unsigned char __pad3[4];
+	long: 32;
+	long long int st_size;
+	long unsigned int st_blksize;
+	long: 32;
+	long long unsigned int st_blocks;
+	long unsigned int st_atime;
+	long unsigned int st_atime_nsec;
+	long unsigned int st_mtime;
+	long unsigned int st_mtime_nsec;
+	long unsigned int st_ctime;
+	long unsigned int st_ctime_nsec;
+	long long unsigned int st_ino;
+};
+
+struct statx_timestamp {
+	__s64 tv_sec;
+	__u32 tv_nsec;
+	__s32 __reserved;
+};
+
+struct statx {
+	__u32 stx_mask;
+	__u32 stx_blksize;
+	__u64 stx_attributes;
+	__u32 stx_nlink;
+	__u32 stx_uid;
+	__u32 stx_gid;
+	__u16 stx_mode;
+	__u16 __spare0[1];
+	__u64 stx_ino;
+	__u64 stx_size;
+	__u64 stx_blocks;
+	__u64 stx_attributes_mask;
+	struct statx_timestamp stx_atime;
+	struct statx_timestamp stx_btime;
+	struct statx_timestamp stx_ctime;
+	struct statx_timestamp stx_mtime;
+	__u32 stx_rdev_major;
+	__u32 stx_rdev_minor;
+	__u32 stx_dev_major;
+	__u32 stx_dev_minor;
+	__u64 stx_mnt_id;
+	__u32 stx_dio_mem_align;
+	__u32 stx_dio_offset_align;
+	__u64 stx_subvol;
+	__u32 stx_atomic_write_unit_min;
+	__u32 stx_atomic_write_unit_max;
+	__u32 stx_atomic_write_segments_max;
+	__u32 __spare1[1];
+	__u64 __spare3[9];
+};
+
+struct linux_dirent64 {
+	u64 d_ino;
+	s64 d_off;
+	short unsigned int d_reclen;
+	unsigned char d_type;
+	char d_name[0];
+	long: 32;
+};
+
+struct linux_dirent {
+	long unsigned int d_ino;
+	long unsigned int d_off;
+	short unsigned int d_reclen;
+	char d_name[0];
+};
+
+struct getdents_callback___2 {
+	struct dir_context ctx;
+	struct linux_dirent *current_dir;
+	int prev_reclen;
+	int count;
+	int error;
+};
+
+struct getdents_callback64 {
+	struct dir_context ctx;
+	struct linux_dirent64 *current_dir;
+	int prev_reclen;
+	int count;
+	int error;
+};
+
+struct inodes_stat_t {
+	long int nr_inodes;
+	long int nr_unused;
+	long int dummy[5];
+};
+
+typedef struct {
+	rwlock_t *lock;
+} class_read_lock_t;
+
+typedef struct {
+	rwlock_t *lock;
+} class_write_lock_t;
+
+typedef struct rw_semaphore *class_rwsem_read_t;
+
+struct mount_attr {
+	__u64 attr_set;
+	__u64 attr_clr;
+	__u64 propagation;
+	__u64 userns_fd;
+};
+
+struct statmount {
+	__u32 size;
+	__u32 mnt_opts;
+	__u64 mask;
+	__u32 sb_dev_major;
+	__u32 sb_dev_minor;
+	__u64 sb_magic;
+	__u32 sb_flags;
+	__u32 fs_type;
+	__u64 mnt_id;
+	__u64 mnt_parent_id;
+	__u32 mnt_id_old;
+	__u32 mnt_parent_id_old;
+	__u64 mnt_attr;
+	__u64 mnt_propagation;
+	__u64 mnt_peer_group;
+	__u64 mnt_master;
+	__u64 propagate_from;
+	__u32 mnt_root;
+	__u32 mnt_point;
+	__u64 mnt_ns_id;
+	__u64 __spare2[49];
+	char str[0];
+};
+
+struct mnt_id_req {
+	__u32 size;
+	__u32 spare;
+	__u64 mnt_id;
+	__u64 param;
+	__u64 mnt_ns_id;
+};
+
+struct mount_kattr {
+	unsigned int attr_set;
+	unsigned int attr_clr;
+	unsigned int propagation;
+	unsigned int lookup_flags;
+	bool recurse;
+	struct user_namespace *mnt_userns;
+	struct mnt_idmap *mnt_idmap;
+};
+
+enum umount_tree_flags {
+	UMOUNT_SYNC = 1,
+	UMOUNT_PROPAGATE = 2,
+	UMOUNT_CONNECTED = 4,
+};
+
+enum mnt_tree_flags_t {
+	MNT_TREE_MOVE = 1,
+	MNT_TREE_BENEATH = 2,
+};
+
+struct kstatmount {
+	struct statmount *buf;
+	size_t bufsize;
+	struct vfsmount *mnt;
+	long: 32;
+	u64 mask;
+	struct path root;
+	struct statmount sm;
+	struct seq_file seq;
+};
+
+struct wb_writeback_work {
+	long int nr_pages;
+	struct super_block *sb;
+	enum writeback_sync_modes sync_mode;
+	unsigned int tagged_writepages: 1;
+	unsigned int for_kupdate: 1;
+	unsigned int range_cyclic: 1;
+	unsigned int for_background: 1;
+	unsigned int for_sync: 1;
+	unsigned int auto_free: 1;
+	enum wb_reason reason;
+	struct list_head list;
+	struct wb_completion *done;
+};
+
+struct trace_event_raw_writeback_folio_template {
+	struct trace_entry ent;
+	char name[32];
+	ino_t ino;
+	long unsigned int index;
+	char __data[0];
+};
+
+struct trace_event_raw_writeback_dirty_inode_template {
+	struct trace_entry ent;
+	char name[32];
+	ino_t ino;
+	long unsigned int state;
+	long unsigned int flags;
+	char __data[0];
+};
+
+struct trace_event_raw_inode_foreign_history {
+	struct trace_entry ent;
+	char name[32];
+	ino_t ino;
+	ino_t cgroup_ino;
+	unsigned int history;
+	char __data[0];
+};
+
+struct trace_event_raw_inode_switch_wbs {
+	struct trace_entry ent;
+	char name[32];
+	ino_t ino;
+	ino_t old_cgroup_ino;
+	ino_t new_cgroup_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_track_foreign_dirty {
+	struct trace_entry ent;
+	char name[32];
+	u64 bdi_id;
+	ino_t ino;
+	unsigned int memcg_id;
+	ino_t cgroup_ino;
+	ino_t page_cgroup_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_flush_foreign {
+	struct trace_entry ent;
+	char name[32];
+	ino_t cgroup_ino;
+	unsigned int frn_bdi_id;
+	unsigned int frn_memcg_id;
+	char __data[0];
+};
+
+struct trace_event_raw_writeback_write_inode_template {
+	struct trace_entry ent;
+	char name[32];
+	ino_t ino;
+	int sync_mode;
+	ino_t cgroup_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_writeback_work_class {
+	struct trace_entry ent;
+	char name[32];
+	long int nr_pages;
+	dev_t sb_dev;
+	int sync_mode;
+	int for_kupdate;
+	int range_cyclic;
+	int for_background;
+	int reason;
+	ino_t cgroup_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_writeback_pages_written {
+	struct trace_entry ent;
+	long int pages;
+	char __data[0];
+};
+
+struct trace_event_raw_writeback_class {
+	struct trace_entry ent;
+	char name[32];
+	ino_t cgroup_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_writeback_bdi_register {
+	struct trace_entry ent;
+	char name[32];
+	char __data[0];
+};
+
+struct trace_event_raw_wbc_class {
+	struct trace_entry ent;
+	char name[32];
+	long int nr_to_write;
+	long int pages_skipped;
+	int sync_mode;
+	int for_kupdate;
+	int for_background;
+	int for_reclaim;
+	int range_cyclic;
+	long int range_start;
+	long int range_end;
+	ino_t cgroup_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_writeback_queue_io {
+	struct trace_entry ent;
+	char name[32];
+	long unsigned int older;
+	long int age;
+	int moved;
+	int reason;
+	ino_t cgroup_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_global_dirty_state {
+	struct trace_entry ent;
+	long unsigned int nr_dirty;
+	long unsigned int nr_writeback;
+	long unsigned int background_thresh;
+	long unsigned int dirty_thresh;
+	long unsigned int dirty_limit;
+	long unsigned int nr_dirtied;
+	long unsigned int nr_written;
+	char __data[0];
+};
+
+struct trace_event_raw_bdi_dirty_ratelimit {
+	struct trace_entry ent;
+	char bdi[32];
+	long unsigned int write_bw;
+	long unsigned int avg_write_bw;
+	long unsigned int dirty_rate;
+	long unsigned int dirty_ratelimit;
+	long unsigned int task_ratelimit;
+	long unsigned int balanced_dirty_ratelimit;
+	ino_t cgroup_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_balance_dirty_pages {
+	struct trace_entry ent;
+	char bdi[32];
+	long unsigned int limit;
+	long unsigned int setpoint;
+	long unsigned int dirty;
+	long unsigned int bdi_setpoint;
+	long unsigned int bdi_dirty;
+	long unsigned int dirty_ratelimit;
+	long unsigned int task_ratelimit;
+	unsigned int dirtied;
+	unsigned int dirtied_pause;
+	long unsigned int paused;
+	long int pause;
+	long unsigned int period;
+	long int think;
+	ino_t cgroup_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_writeback_sb_inodes_requeue {
+	struct trace_entry ent;
+	char name[32];
+	ino_t ino;
+	long unsigned int state;
+	long unsigned int dirtied_when;
+	ino_t cgroup_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_writeback_single_inode_template {
+	struct trace_entry ent;
+	char name[32];
+	ino_t ino;
+	long unsigned int state;
+	long unsigned int dirtied_when;
+	long unsigned int writeback_index;
+	long int nr_to_write;
+	long unsigned int wrote;
+	ino_t cgroup_ino;
+	char __data[0];
+};
+
+struct trace_event_raw_writeback_inode_template {
+	struct trace_entry ent;
+	dev_t dev;
+	ino_t ino;
+	long unsigned int state;
+	__u16 mode;
+	long unsigned int dirtied_when;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_writeback_folio_template {};
+
+struct trace_event_data_offsets_writeback_dirty_inode_template {};
+
+struct trace_event_data_offsets_inode_foreign_history {};
+
+struct trace_event_data_offsets_inode_switch_wbs {};
+
+struct trace_event_data_offsets_track_foreign_dirty {};
+
+struct trace_event_data_offsets_flush_foreign {};
+
+struct trace_event_data_offsets_writeback_write_inode_template {};
+
+struct trace_event_data_offsets_writeback_work_class {};
+
+struct trace_event_data_offsets_writeback_pages_written {};
+
+struct trace_event_data_offsets_writeback_class {};
+
+struct trace_event_data_offsets_writeback_bdi_register {};
+
+struct trace_event_data_offsets_wbc_class {};
+
+struct trace_event_data_offsets_writeback_queue_io {};
+
+struct trace_event_data_offsets_global_dirty_state {};
+
+struct trace_event_data_offsets_bdi_dirty_ratelimit {};
+
+struct trace_event_data_offsets_balance_dirty_pages {};
+
+struct trace_event_data_offsets_writeback_sb_inodes_requeue {};
+
+struct trace_event_data_offsets_writeback_single_inode_template {};
+
+struct trace_event_data_offsets_writeback_inode_template {};
+
+typedef void (*btf_trace_writeback_dirty_folio)(void *, struct folio *, struct address_space *);
+
+typedef void (*btf_trace_folio_wait_writeback)(void *, struct folio *, struct address_space *);
+
+typedef void (*btf_trace_writeback_mark_inode_dirty)(void *, struct inode *, int);
+
+typedef void (*btf_trace_writeback_dirty_inode_start)(void *, struct inode *, int);
+
+typedef void (*btf_trace_writeback_dirty_inode)(void *, struct inode *, int);
+
+typedef void (*btf_trace_inode_foreign_history)(void *, struct inode *, struct writeback_control *, unsigned int);
+
+typedef void (*btf_trace_inode_switch_wbs)(void *, struct inode *, struct bdi_writeback *, struct bdi_writeback *);
+
+typedef void (*btf_trace_track_foreign_dirty)(void *, struct folio *, struct bdi_writeback *);
+
+typedef void (*btf_trace_flush_foreign)(void *, struct bdi_writeback *, unsigned int, unsigned int);
+
+typedef void (*btf_trace_writeback_write_inode_start)(void *, struct inode *, struct writeback_control *);
+
+typedef void (*btf_trace_writeback_write_inode)(void *, struct inode *, struct writeback_control *);
+
+typedef void (*btf_trace_writeback_queue)(void *, struct bdi_writeback *, struct wb_writeback_work *);
+
+typedef void (*btf_trace_writeback_exec)(void *, struct bdi_writeback *, struct wb_writeback_work *);
+
+typedef void (*btf_trace_writeback_start)(void *, struct bdi_writeback *, struct wb_writeback_work *);
+
+typedef void (*btf_trace_writeback_written)(void *, struct bdi_writeback *, struct wb_writeback_work *);
+
+typedef void (*btf_trace_writeback_wait)(void *, struct bdi_writeback *, struct wb_writeback_work *);
+
+typedef void (*btf_trace_writeback_pages_written)(void *, long int);
+
+typedef void (*btf_trace_writeback_wake_background)(void *, struct bdi_writeback *);
+
+typedef void (*btf_trace_writeback_bdi_register)(void *, struct backing_dev_info *);
+
+typedef void (*btf_trace_wbc_writepage)(void *, struct writeback_control *, struct backing_dev_info *);
+
+typedef void (*btf_trace_writeback_queue_io)(void *, struct bdi_writeback *, struct wb_writeback_work *, long unsigned int, int);
+
+typedef void (*btf_trace_global_dirty_state)(void *, long unsigned int, long unsigned int);
+
+typedef void (*btf_trace_bdi_dirty_ratelimit)(void *, struct bdi_writeback *, long unsigned int, long unsigned int);
+
+typedef void (*btf_trace_balance_dirty_pages)(void *, struct bdi_writeback *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long int, long unsigned int);
+
+typedef void (*btf_trace_writeback_sb_inodes_requeue)(void *, struct inode *);
+
+typedef void (*btf_trace_writeback_single_inode_start)(void *, struct inode *, struct writeback_control *, long unsigned int);
+
+typedef void (*btf_trace_writeback_single_inode)(void *, struct inode *, struct writeback_control *, long unsigned int);
+
+typedef void (*btf_trace_writeback_lazytime)(void *, struct inode *);
+
+typedef void (*btf_trace_writeback_lazytime_iput)(void *, struct inode *);
+
+typedef void (*btf_trace_writeback_dirty_inode_enqueue)(void *, struct inode *);
+
+typedef void (*btf_trace_sb_mark_inode_writeback)(void *, struct inode *);
+
+typedef void (*btf_trace_sb_clear_inode_writeback)(void *, struct inode *);
+
+struct inode_switch_wbs_context {
+	struct rcu_work work;
+	struct bdi_writeback *new_wb;
+	struct inode *inodes[0];
+};
+
+struct prepend_buffer {
+	char *buf;
+	int len;
+};
+
+typedef int class_get_unused_fd_t;
+
+struct mnt_ns_info {
+	__u32 size;
+	__u32 nr_mounts;
+	__u64 mnt_ns_id;
+};
+
+struct ns_get_path_task_args {
+	const struct proc_ns_operations *ns_ops;
+	struct task_struct *task;
+};
+
+enum fsconfig_command {
+	FSCONFIG_SET_FLAG = 0,
+	FSCONFIG_SET_STRING = 1,
+	FSCONFIG_SET_BINARY = 2,
+	FSCONFIG_SET_PATH = 3,
+	FSCONFIG_SET_PATH_EMPTY = 4,
+	FSCONFIG_SET_FD = 5,
+	FSCONFIG_CMD_CREATE = 6,
+	FSCONFIG_CMD_RECONFIGURE = 7,
+	FSCONFIG_CMD_CREATE_EXCL = 8,
+};
+
+struct postprocess_bh_ctx {
+	struct work_struct work;
+	struct buffer_head *bh;
+};
+
+struct bh_lru {
+	struct buffer_head *bhs[16];
+};
+
+struct bh_accounting {
+	int nr;
+	int ratelimit;
+};
+
+struct epoll_event {
+	__poll_t events;
+	long: 32;
+	__u64 data;
+};
+
+struct epoll_params {
+	__u32 busy_poll_usecs;
+	__u16 busy_poll_budget;
+	__u8 prefer_busy_poll;
+	__u8 __pad;
+};
+
+struct wake_irq;
+
+struct wakeup_source {
+	const char *name;
+	int id;
+	struct list_head entry;
+	spinlock_t lock;
+	struct wake_irq *wakeirq;
+	struct timer_list timer;
+	long unsigned int timer_expires;
+	ktime_t total_time;
+	ktime_t max_time;
+	ktime_t last_time;
+	ktime_t start_prevent_time;
+	ktime_t prevent_sleep_time;
+	long unsigned int event_count;
+	long unsigned int active_count;
+	long unsigned int relax_count;
+	long unsigned int expire_count;
+	long unsigned int wakeup_count;
+	struct device *dev;
+	bool active: 1;
+	bool autosleep_enabled: 1;
+	long: 32;
+};
+
+struct epoll_filefd {
+	struct file *file;
+	int fd;
+};
+
+struct epitem;
+
+struct eppoll_entry {
+	struct eppoll_entry *next;
+	struct epitem *base;
+	wait_queue_entry_t wait;
+	wait_queue_head_t *whead;
+};
+
+struct eventpoll;
+
+struct epitem {
+	union {
+		struct rb_node rbn;
+		struct callback_head rcu;
+	};
+	struct list_head rdllink;
+	struct epitem *next;
+	struct epoll_filefd ffd;
+	bool dying;
+	struct eppoll_entry *pwqlist;
+	struct eventpoll *ep;
+	struct hlist_node fllink;
+	struct wakeup_source *ws;
+	struct epoll_event event;
+};
+
+struct eventpoll {
+	struct mutex mtx;
+	wait_queue_head_t wq;
+	wait_queue_head_t poll_wait;
+	struct list_head rdllist;
+	rwlock_t lock;
+	struct rb_root_cached rbr;
+	struct epitem *ovflist;
+	struct wakeup_source *ws;
+	struct user_struct *user;
+	struct file *file;
+	u64 gen;
+	struct hlist_head refs;
+	refcount_t refcount;
+	unsigned int napi_id;
+	u32 busy_poll_usecs;
+	u16 busy_poll_budget;
+	bool prefer_busy_poll;
+	long: 32;
+};
+
+struct ep_pqueue {
+	poll_table pt;
+	struct epitem *epi;
+};
+
+struct epitems_head {
+	struct hlist_head epitems;
+	struct epitems_head *next;
+};
+
+typedef long unsigned int elf_greg_t;
+
+typedef elf_greg_t elf_gregset_t[18];
+
+struct elf_siginfo {
+	int si_signo;
+	int si_code;
+	int si_errno;
+};
+
+struct elf_prstatus_common {
+	struct elf_siginfo pr_info;
+	short int pr_cursig;
+	long unsigned int pr_sigpend;
+	long unsigned int pr_sighold;
+	pid_t pr_pid;
+	pid_t pr_ppid;
+	pid_t pr_pgrp;
+	pid_t pr_sid;
+	struct __kernel_old_timeval pr_utime;
+	struct __kernel_old_timeval pr_stime;
+	struct __kernel_old_timeval pr_cutime;
+	struct __kernel_old_timeval pr_cstime;
+};
+
+struct elf_prstatus {
+	struct elf_prstatus_common common;
+	elf_gregset_t pr_reg;
+	int pr_fpvalid;
+};
+
+struct elf_prpsinfo {
+	char pr_state;
+	char pr_sname;
+	char pr_zomb;
+	char pr_nice;
+	long unsigned int pr_flag;
+	__kernel_uid_t pr_uid;
+	__kernel_gid_t pr_gid;
+	pid_t pr_pid;
+	pid_t pr_ppid;
+	pid_t pr_pgrp;
+	pid_t pr_sid;
+	char pr_fname[16];
+	char pr_psargs[80];
+};
+
+struct arch_elf_state {};
+
+struct memelfnote {
+	const char *name;
+	int type;
+	unsigned int datasz;
+	void *data;
+};
+
+struct elf_thread_core_info {
+	struct elf_thread_core_info *next;
+	struct task_struct *task;
+	struct elf_prstatus prstatus;
+	struct memelfnote notes[0];
+};
+
+struct elf_note_info {
+	struct elf_thread_core_info *thread;
+	struct memelfnote psinfo;
+	struct memelfnote signote;
+	struct memelfnote auxv;
+	struct memelfnote files;
+	siginfo_t csigdata;
+	size_t size;
+	int thread_notes;
+};
+
+struct trace_event_raw_iomap_readpage_class {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	u64 ino;
+	int nr_pages;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_iomap_range_class {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	u64 ino;
+	loff_t size;
+	loff_t offset;
+	u64 length;
+	char __data[0];
+};
+
+struct trace_event_raw_iomap_class {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	u64 ino;
+	u64 addr;
+	loff_t offset;
+	u64 length;
+	u16 type;
+	u16 flags;
+	dev_t bdev;
+	char __data[0];
+};
+
+struct trace_event_raw_iomap_writepage_map {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	u64 ino;
+	u64 pos;
+	u64 dirty_len;
+	u64 addr;
+	loff_t offset;
+	u64 length;
+	u16 type;
+	u16 flags;
+	dev_t bdev;
+	char __data[0];
+};
+
+struct trace_event_raw_iomap_iter {
+	struct trace_entry ent;
+	dev_t dev;
+	long: 32;
+	u64 ino;
+	loff_t pos;
+	u64 length;
+	s64 processed;
+	unsigned int flags;
+	const void *ops;
+	long unsigned int caller;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_iomap_dio_rw_begin {
+	struct trace_entry ent;
+	dev_t dev;
+	ino_t ino;
+	loff_t isize;
+	loff_t pos;
+	size_t count;
+	size_t done_before;
+	int ki_flags;
+	unsigned int dio_flags;
+	bool aio;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_raw_iomap_dio_complete {
+	struct trace_entry ent;
+	dev_t dev;
+	ino_t ino;
+	loff_t isize;
+	loff_t pos;
+	int ki_flags;
+	bool aio;
+	int error;
+	ssize_t ret;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_iomap_readpage_class {};
+
+struct trace_event_data_offsets_iomap_range_class {};
+
+struct trace_event_data_offsets_iomap_class {};
+
+struct trace_event_data_offsets_iomap_writepage_map {};
+
+struct trace_event_data_offsets_iomap_iter {};
+
+struct trace_event_data_offsets_iomap_dio_rw_begin {};
+
+struct trace_event_data_offsets_iomap_dio_complete {};
+
+typedef void (*btf_trace_iomap_readpage)(void *, struct inode *, int);
+
+typedef void (*btf_trace_iomap_readahead)(void *, struct inode *, int);
+
+typedef void (*btf_trace_iomap_writepage)(void *, struct inode *, loff_t, u64);
+
+typedef void (*btf_trace_iomap_release_folio)(void *, struct inode *, loff_t, u64);
+
+typedef void (*btf_trace_iomap_invalidate_folio)(void *, struct inode *, loff_t, u64);
+
+typedef void (*btf_trace_iomap_dio_invalidate_fail)(void *, struct inode *, loff_t, u64);
+
+typedef void (*btf_trace_iomap_dio_rw_queued)(void *, struct inode *, loff_t, u64);
+
+typedef void (*btf_trace_iomap_iter_dstmap)(void *, struct inode *, struct iomap *);
+
+typedef void (*btf_trace_iomap_iter_srcmap)(void *, struct inode *, struct iomap *);
+
+typedef void (*btf_trace_iomap_writepage_map)(void *, struct inode *, u64, unsigned int, struct iomap *);
+
+typedef void (*btf_trace_iomap_iter)(void *, struct iomap_iter *, const void *, long unsigned int);
+
+typedef void (*btf_trace_iomap_dio_rw_begin)(void *, struct kiocb *, struct iov_iter *, unsigned int, size_t);
+
+typedef void (*btf_trace_iomap_dio_complete)(void *, struct kiocb *, int, ssize_t);
+
+struct proc_fs_context {
+	struct pid_namespace *pid_ns;
+	unsigned int mask;
+	enum proc_hidepid hidepid;
+	int gid;
+	enum proc_pidonly pidonly;
+};
+
+enum proc_param {
+	Opt_gid___3 = 0,
+	Opt_hidepid = 1,
+	Opt_subset = 2,
+};
+
+struct fd_data {
+	fmode_t mode;
+	unsigned int fd;
+};
+
+struct kernfs_global_locks {
+	struct mutex open_file_mutex[4];
+};
+
+struct kernfs_open_node {
+	struct callback_head callback_head;
+	atomic_t event;
+	wait_queue_head_t poll;
+	struct list_head files;
+	unsigned int nr_mmapped;
+	unsigned int nr_to_release;
+};
+
+struct pts_mount_opts {
+	int setuid;
+	int setgid;
+	kuid_t uid;
+	kgid_t gid;
+	umode_t mode;
+	umode_t ptmxmode;
+	int reserve;
+	int max;
+};
+
+enum {
+	Opt_uid___3 = 0,
+	Opt_gid___4 = 1,
+	Opt_mode___4 = 2,
+	Opt_ptmxmode = 3,
+	Opt_newinstance = 4,
+	Opt_max = 5,
+	Opt_err___2 = 6,
+};
+
+struct pts_fs_info {
+	struct ida allocated_ptys;
+	struct pts_mount_opts mount_opts;
+	struct super_block *sb;
+	struct dentry *ptmx_dentry;
+};
+
+struct squashfs_base_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+};
+
+struct squashfs_ipc_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+};
+
+struct squashfs_lipc_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 xattr;
+};
+
+struct squashfs_dev_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 rdev;
+};
+
+struct squashfs_ldev_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 rdev;
+	__le32 xattr;
+};
+
+struct squashfs_symlink_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 symlink_size;
+	char symlink[0];
+};
+
+struct squashfs_reg_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 start_block;
+	__le32 fragment;
+	__le32 offset;
+	__le32 file_size;
+	__le16 block_list[0];
+};
+
+struct squashfs_lreg_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le64 start_block;
+	__le64 file_size;
+	__le64 sparse;
+	__le32 nlink;
+	__le32 fragment;
+	__le32 offset;
+	__le32 xattr;
+	__le16 block_list[0];
+};
+
+struct squashfs_dir_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 start_block;
+	__le32 nlink;
+	__le16 file_size;
+	__le16 offset;
+	__le32 parent_inode;
+};
+
+struct squashfs_ldir_inode {
+	__le16 inode_type;
+	__le16 mode;
+	__le16 uid;
+	__le16 guid;
+	__le32 mtime;
+	__le32 inode_number;
+	__le32 nlink;
+	__le32 file_size;
+	__le32 start_block;
+	__le32 parent_inode;
+	__le16 i_count;
+	__le16 offset;
+	__le32 xattr;
+	struct squashfs_dir_index index[0];
+};
+
+union squashfs_inode {
+	struct squashfs_base_inode base;
+	struct squashfs_dev_inode dev;
+	struct squashfs_ldev_inode ldev;
+	struct squashfs_symlink_inode symlink;
+	struct squashfs_reg_inode reg;
+	struct squashfs_lreg_inode lreg;
+	struct squashfs_dir_inode dir;
+	struct squashfs_ldir_inode ldir;
+	struct squashfs_ipc_inode ipc;
+	struct squashfs_lipc_inode lipc;
+};
+
+struct squashfs_xz {
+	struct xz_dec *state;
+	struct xz_buf buf;
+};
+
+struct disk_comp_opts {
+	__le32 dictionary_size;
+	__le32 flags;
+};
+
+struct comp_opts {
+	int dict_size;
+};
+
+struct jffs2_readinode_info {
+	struct rb_root tn_root;
+	struct jffs2_tmp_dnode_info *mdata_tn;
+	uint32_t highest_version;
+	uint32_t latest_mctime;
+	uint32_t mctime_ver;
+	struct jffs2_full_dirent *fds;
+	struct jffs2_raw_node_ref *latest_ref;
+};
+
+struct jffs2_acl_entry {
+	jint16_t e_tag;
+	jint16_t e_perm;
+	jint32_t e_id;
+};
+
+struct jffs2_acl_header {
+	jint32_t a_version;
+	struct jffs2_acl_entry a_entries[0];
+};
+
+enum {
+	UBIFS_KEY_HASH_R5 = 0,
+	UBIFS_KEY_HASH_TEST = 1,
+};
+
+enum {
+	UBIFS_FLG_BIGLPT = 2,
+	UBIFS_FLG_SPACE_FIXUP = 4,
+	UBIFS_FLG_DOUBLE_HASH = 8,
+	UBIFS_FLG_ENCRYPTION = 16,
+	UBIFS_FLG_AUTHENTICATION = 32,
+};
+
+enum {
+	SCANNED_GARBAGE = 0,
+	SCANNED_EMPTY_SPACE = -1,
+	SCANNED_A_NODE = -2,
+	SCANNED_A_CORRUPT_NODE = -3,
+	SCANNED_A_BAD_PAD_NODE = -4,
+};
+
+enum {
+	LEB_FREED = 0,
+	LEB_FREED_IDX = 1,
+	LEB_RETAINED = 2,
+};
+
+struct ubifs_gced_idx_leb {
+	struct list_head list;
+	int lnum;
+	int unmap;
+};
+
+struct size_entry {
+	struct rb_node rb;
+	ino_t inum;
+	loff_t i_size;
+	loff_t d_size;
+	int exists;
+	struct inode *inode;
+};
+
+struct fsck_inode {
+	struct rb_node rb;
+	ino_t inum;
+	umode_t mode;
+	unsigned int nlink;
+	unsigned int xattr_cnt;
+	int references;
+	int calc_cnt;
+	long: 32;
+	long long int size;
+	unsigned int xattr_sz;
+	long: 32;
+	long long int calc_sz;
+	long long int calc_xcnt;
+	long long int calc_xsz;
+	unsigned int xattr_nms;
+	long: 32;
+	long long int calc_xnms;
+};
+
+struct fsck_data {
+	struct rb_root inodes;
+};
+
+struct ovl_lookup_data {
+	struct super_block *sb;
+	const struct ovl_layer *layer;
+	struct qstr name;
+	bool is_dir;
+	bool opaque;
+	bool xwhiteouts;
+	bool stop;
+	bool last;
+	char *redirect;
+	int metacopy;
+	bool absolute_redirect;
+	long: 32;
+};
+
+enum ovl_copyop {
+	OVL_COPY = 0,
+	OVL_CLONE = 1,
+	OVL_DEDUPE = 2,
+};
+
+struct tracefs_dir_ops {
+	int (*mkdir)(const char *);
+	int (*rmdir)(const char *);
+};
+
+struct tracefs_fs_info {
+	kuid_t uid;
+	kgid_t gid;
+	umode_t mode;
+	unsigned int opts;
+};
+
+enum {
+	Opt_uid___4 = 0,
+	Opt_gid___5 = 1,
+	Opt_mode___5 = 2,
+};
+
+struct msg_msgseg {
+	struct msg_msgseg *next;
+};
+
+typedef int __kernel_mqd_t;
+
+typedef __kernel_mqd_t mqd_t;
+
+struct mq_attr {
+	__kernel_long_t mq_flags;
+	__kernel_long_t mq_maxmsg;
+	__kernel_long_t mq_msgsize;
+	__kernel_long_t mq_curmsgs;
+	__kernel_long_t __reserved[4];
+};
+
+struct mqueue_fs_context {
+	struct ipc_namespace *ipc_ns;
+	bool newns;
+};
+
+struct posix_msg_tree_node {
+	struct rb_node rb_node;
+	struct list_head msg_list;
+	int priority;
+};
+
+struct ext_wait_queue {
+	struct task_struct *task;
+	struct list_head list;
+	struct msg_msg *msg;
+	int state;
+};
+
+struct mqueue_inode_info {
+	spinlock_t lock;
+	long: 32;
+	struct inode vfs_inode;
+	wait_queue_head_t wait_q;
+	struct rb_root msg_tree;
+	struct rb_node *msg_tree_rightmost;
+	struct posix_msg_tree_node *node_cache;
+	struct mq_attr attr;
+	struct sigevent notify;
+	struct pid *notify_owner;
+	u32 notify_self_exec_id;
+	struct user_namespace *notify_user_ns;
+	struct ucounts *ucounts;
+	struct sock *notify_sock;
+	struct sk_buff *notify_cookie;
+	struct ext_wait_queue e_wait_q[2];
+	long unsigned int qsize;
+	long: 32;
+};
+
+struct vfs_cap_data {
+	__le32 magic_etc;
+	struct {
+		__le32 permitted;
+		__le32 inheritable;
+	} data[2];
+};
+
+struct vfs_ns_cap_data {
+	__le32 magic_etc;
+	struct {
+		__le32 permitted;
+		__le32 inheritable;
+	} data[2];
+	__le32 rootid;
+};
+
+struct cpu_vfs_cap_data {
+	__u32 magic_etc;
+	kuid_t rootid;
+	kernel_cap_t permitted;
+	kernel_cap_t inheritable;
+};
+
+struct crypto_report_aead {
+	char type[64];
+	char geniv[64];
+	unsigned int blocksize;
+	unsigned int maxauthsize;
+	unsigned int ivsize;
+};
+
+struct ahash_alg {
+	int (*init)(struct ahash_request *);
+	int (*update)(struct ahash_request *);
+	int (*final)(struct ahash_request *);
+	int (*finup)(struct ahash_request *);
+	int (*digest)(struct ahash_request *);
+	int (*export)(struct ahash_request *, void *);
+	int (*import)(struct ahash_request *, const void *);
+	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
+	int (*init_tfm)(struct crypto_ahash *);
+	void (*exit_tfm)(struct crypto_ahash *);
+	int (*clone_tfm)(struct crypto_ahash *, struct crypto_ahash *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct hash_alg_common halg;
+};
+
+struct crypto_hash_walk {
+	char *data;
+	unsigned int offset;
+	unsigned int flags;
+	struct page *pg;
+	unsigned int entrylen;
+	unsigned int total;
+	struct scatterlist *sg;
+};
+
+struct ahash_instance {
+	void (*free)(struct ahash_instance *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct {
+			char head[128];
+			struct crypto_instance base;
+		} s;
+		struct ahash_alg alg;
+	};
+};
+
+struct kpp_request {
+	struct crypto_async_request base;
+	struct scatterlist *src;
+	struct scatterlist *dst;
+	unsigned int src_len;
+	unsigned int dst_len;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	void *__ctx[0];
+};
+
+struct crypto_kpp {
+	unsigned int reqsize;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_tfm base;
+};
+
+struct kpp_alg {
+	int (*set_secret)(struct crypto_kpp *, const void *, unsigned int);
+	int (*generate_public_key)(struct kpp_request *);
+	int (*compute_shared_secret)(struct kpp_request *);
+	unsigned int (*max_size)(struct crypto_kpp *);
+	int (*init)(struct crypto_kpp *);
+	void (*exit)(struct crypto_kpp *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct crypto_alg base;
+};
+
+struct kpp_instance {
+	void (*free)(struct kpp_instance *);
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct {
+			char head[64];
+			struct crypto_instance base;
+		} s;
+		struct kpp_alg alg;
+	};
+};
+
+struct crypto_kpp_spawn {
+	struct crypto_spawn base;
+};
+
+struct crypto_report_kpp {
+	char type[64];
+};
+
+struct sha3_state {
+	u64 st[25];
+	unsigned int rsiz;
+	unsigned int rsizw;
+	unsigned int partial;
+	u8 buf[144];
+	long: 32;
+};
+
+struct ccm_instance_ctx {
+	struct crypto_skcipher_spawn ctr;
+	struct crypto_ahash_spawn mac;
+};
+
+struct crypto_ccm_ctx {
+	struct crypto_ahash *mac;
+	struct crypto_skcipher *ctr;
+};
+
+struct crypto_rfc4309_ctx {
+	struct crypto_aead *child;
+	u8 nonce[3];
+};
+
+struct crypto_rfc4309_req_ctx {
+	struct scatterlist src[3];
+	struct scatterlist dst[3];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct aead_request subreq;
+};
+
+struct crypto_ccm_req_priv_ctx {
+	u8 odata[16];
+	u8 idata[16];
+	u8 auth_tag[16];
+	u32 flags;
+	struct scatterlist src[3];
+	struct scatterlist dst[3];
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	union {
+		struct ahash_request ahreq;
+		struct skcipher_request skreq;
+	};
+};
+
+struct cbcmac_tfm_ctx {
+	struct crypto_cipher *child;
+};
+
+struct cbcmac_desc_ctx {
+	unsigned int len;
+	u8 dg[0];
+};
+
+struct crypto_report_rng {
+	char type[64];
+	unsigned int seedsize;
+};
+
+struct bio_alloc_cache {
+	struct bio *free_list;
+	struct bio *free_list_irq;
+	unsigned int nr;
+	unsigned int nr_irq;
+};
+
+struct biovec_slab {
+	int nr_vecs;
+	char *name;
+	struct kmem_cache *slab;
+};
+
+struct bio_slab {
+	struct kmem_cache *slab;
+	unsigned int slab_ref;
+	unsigned int slab_size;
+	char name[8];
+};
+
+enum {
+	REQ_FSEQ_PREFLUSH = 1,
+	REQ_FSEQ_DATA = 2,
+	REQ_FSEQ_POSTFLUSH = 4,
+	REQ_FSEQ_DONE = 8,
+	REQ_FSEQ_ACTIONS = 7,
+	FLUSH_PENDING_TIMEOUT = 500,
+};
+
+struct bio_map_data {
+	bool is_our_pages: 1;
+	bool is_null_mapped: 1;
+	long: 32;
+	struct iov_iter iter;
+	struct iovec iov[0];
+};
+
+struct blk_rq_stat {
+	u64 mean;
+	u64 min;
+	u64 max;
+	u32 nr_samples;
+	long: 32;
+	u64 batch;
+};
+
+struct blk_queue_stats {
+	struct list_head callbacks;
+	spinlock_t lock;
+	int accounting;
+};
+
+struct blk_stat_callback {
+	struct list_head list;
+	struct timer_list timer;
+	struct blk_rq_stat *cpu_stat;
+	int (*bucket_fn)(const struct request *);
+	unsigned int buckets;
+	struct blk_rq_stat *stat;
+	void (*timer_fn)(struct blk_stat_callback *);
+	void *data;
+	struct callback_head rcu;
+};
+
+struct blk_mq_hw_ctx_sysfs_entry {
+	struct attribute attr;
+	ssize_t (*show)(struct blk_mq_hw_ctx *, char *);
+};
+
+enum {
+	IOPRIO_WHO_PROCESS = 1,
+	IOPRIO_WHO_PGRP = 2,
+	IOPRIO_WHO_USER = 3,
+};
+
+struct fat_boot_sector {
+	__u8 ignored[3];
+	__u8 system_id[8];
+	__u8 sector_size[2];
+	__u8 sec_per_clus;
+	__le16 reserved;
+	__u8 fats;
+	__u8 dir_entries[2];
+	__u8 sectors[2];
+	__u8 media;
+	__le16 fat_length;
+	__le16 secs_track;
+	__le16 heads;
+	__le32 hidden;
+	__le32 total_sect;
+	union {
+		struct {
+			__u8 drive_number;
+			__u8 state;
+			__u8 signature;
+			__u8 vol_id[4];
+			__u8 vol_label[11];
+			__u8 fs_type[8];
+		} fat16;
+		struct {
+			__le32 length;
+			__le16 flags;
+			__u8 version[2];
+			__le32 root_cluster;
+			__le16 info_sector;
+			__le16 backup_boot;
+			__le16 reserved2[6];
+			__u8 drive_number;
+			__u8 state;
+			__u8 signature;
+			__u8 vol_id[4];
+			__u8 vol_label[11];
+			__u8 fs_type[8];
+		} fat32;
+	};
+};
+
+struct msdos_partition {
+	u8 boot_ind;
+	u8 head;
+	u8 sector;
+	u8 cyl;
+	u8 sys_ind;
+	u8 end_head;
+	u8 end_sector;
+	u8 end_cyl;
+	__le32 start_sect;
+	__le32 nr_sects;
+};
+
+enum msdos_sys_ind {
+	DOS_EXTENDED_PARTITION = 5,
+	LINUX_EXTENDED_PARTITION = 133,
+	WIN98_EXTENDED_PARTITION = 15,
+	LINUX_DATA_PARTITION = 131,
+	LINUX_LVM_PARTITION = 142,
+	LINUX_RAID_PARTITION = 253,
+	FIT_PARTITION = 46,
+	SOLARIS_X86_PARTITION = 130,
+	NEW_SOLARIS_X86_PARTITION = 191,
+	DM6_AUX1PARTITION = 81,
+	DM6_AUX3PARTITION = 83,
+	DM6_PARTITION = 84,
+	EZD_PARTITION = 85,
+	FREEBSD_PARTITION = 165,
+	OPENBSD_PARTITION = 166,
+	NETBSD_PARTITION = 169,
+	BSDI_PARTITION = 183,
+	MINIX_PARTITION = 129,
+	UNIXWARE_PARTITION = 99,
+};
+
+struct disk_events {
+	struct list_head node;
+	struct gendisk *disk;
+	spinlock_t lock;
+	struct mutex block_mutex;
+	int block;
+	unsigned int pending;
+	unsigned int clearing;
+	long int poll_msecs;
+	struct delayed_work dwork;
+};
+
+struct bsg_device {
+	struct request_queue *queue;
+	long: 32;
+	struct device device;
+	struct cdev cdev;
+	int max_queue;
+	unsigned int timeout;
+	unsigned int reserved_size;
+	bsg_sg_io_fn *sg_io_fn;
+	long: 32;
+};
+
+struct region {
+	unsigned int start;
+	unsigned int off;
+	unsigned int group_len;
+	unsigned int end;
+	unsigned int nbits;
+};
+
+enum blake2s_lengths {
+	BLAKE2S_BLOCK_SIZE = 64,
+	BLAKE2S_HASH_SIZE = 32,
+	BLAKE2S_KEY_SIZE = 32,
+	BLAKE2S_128_HASH_SIZE = 16,
+	BLAKE2S_160_HASH_SIZE = 20,
+	BLAKE2S_224_HASH_SIZE = 28,
+	BLAKE2S_256_HASH_SIZE = 32,
+};
+
+struct blake2s_state {
+	u32 h[8];
+	u32 t[2];
+	u32 f[2];
+	u8 buf[64];
+	unsigned int buflen;
+	unsigned int outlen;
+};
+
+enum devm_ioremap_type {
+	DEVM_IOREMAP = 0,
+	DEVM_IOREMAP_UC = 1,
+	DEVM_IOREMAP_WC = 2,
+	DEVM_IOREMAP_NP = 3,
+};
+
+struct arch_io_reserve_memtype_wc_devres {
+	resource_size_t start;
+	resource_size_t size;
+};
+
+typedef struct {
+	size_t bitContainer;
+	unsigned int bitPos;
+	char *startPtr;
+	char *ptr;
+	char *endPtr;
+} BIT_CStream_t;
+
+typedef struct {
+	ptrdiff_t value;
+	const void *stateTable;
+	const void *symbolTT;
+	unsigned int stateLog;
+} FSE_CState_t;
+
+typedef struct {
+	int deltaFindState;
+	U32 deltaNbBits;
+} FSE_symbolCompressionTransform;
+
+typedef size_t (*huf_compress_f)(void *, size_t, const void *, size_t, unsigned int, unsigned int, void *, size_t, HUF_CElt *, HUF_repeat *, int);
+
+typedef struct {
+	S16 norm[53];
+	U32 wksp[285];
+} ZSTD_BuildCTableWksp;
+
+typedef enum {
+	base_0possible = 0,
+	base_1guaranteed = 1,
+} base_directive_e;
+
+typedef U32 (*ZSTD_getAllMatchesFn)(ZSTD_match_t *, ZSTD_matchState_t *, U32 *, const BYTE *, const BYTE *, const U32 *, const U32, const U32);
+
+typedef struct {
+	rawSeqStore_t seqStore;
+	U32 startPosInBlock;
+	U32 endPosInBlock;
+	U32 offset;
+} ZSTD_optLdm_t;
+
+struct sg_pool {
+	size_t size;
+	char *name;
+	struct kmem_cache *slab;
+	mempool_t *pool;
+};
+
+struct node_groups {
+	unsigned int id;
+	union {
+		unsigned int ngroups;
+		unsigned int ncpus;
+	};
+};
+
+typedef int (*of_init_fn_2)(struct device_node *, struct device_node *);
+
+enum gic_type {
+	GIC_V2 = 0,
+	GIC_V3 = 1,
+};
+
+struct gic_kvm_info {
+	enum gic_type type;
+	struct resource vcpu;
+	unsigned int maint_irq;
+	bool no_maint_irq_mask;
+	struct resource vctrl;
+	bool has_v4;
+	bool has_v4_1;
+	bool no_hw_deactivation;
+};
+
+union gic_base {
+	void *common_base;
+	void **percpu_base;
+};
+
+struct gic_chip_data {
+	union gic_base dist_base;
+	union gic_base cpu_base;
+	void *raw_dist_base;
+	void *raw_cpu_base;
+	u32 percpu_offset;
+	struct irq_domain *domain;
+	unsigned int gic_irqs;
+};
+
+enum {
+	REG_INPUT_DATA = 0,
+	REG_PORT_CONFIG = 1,
+	REG_PORT_ENABLE = 2,
+	REG_SIO_CONFIG = 3,
+	REG_SIO_CLOCK = 4,
+	REG_INT_POLARITY = 5,
+	REG_INT_TRIGGER = 6,
+	REG_INT_ACK = 7,
+	REG_INT_ENABLE = 8,
+	REG_INT_IDENT = 9,
+	MAXREG = 10,
+};
+
+enum {
+	SGPIO_ARCH_LUTON = 0,
+	SGPIO_ARCH_OCELOT = 1,
+	SGPIO_ARCH_SPARX5 = 2,
+};
+
+enum {
+	SGPIO_FLAGS_HAS_IRQ = 1,
+};
+
+struct sgpio_properties {
+	int arch;
+	int flags;
+	u8 regoff[10];
+};
+
+struct sgpio_priv;
+
+struct sgpio_bank {
+	struct sgpio_priv *priv;
+	bool is_input;
+	struct gpio_chip gpio;
+	struct pinctrl_desc pctl_desc;
+};
+
+struct sgpio_priv {
+	struct device *dev;
+	struct sgpio_bank in;
+	struct sgpio_bank out;
+	u32 bitcount;
+	u32 ports;
+	u32 clock;
+	struct regmap *regs;
+	const struct sgpio_properties *properties;
+	spinlock_t lock;
+	struct mutex poll_lock;
+};
+
+struct sgpio_port_addr {
+	u8 port;
+	u8 bit;
+};
+
+struct gpiochip_info {
+	char name[32];
+	char label[32];
+	__u32 lines;
+};
+
+enum gpio_v2_line_flag {
+	GPIO_V2_LINE_FLAG_USED = 1,
+	GPIO_V2_LINE_FLAG_ACTIVE_LOW = 2,
+	GPIO_V2_LINE_FLAG_INPUT = 4,
+	GPIO_V2_LINE_FLAG_OUTPUT = 8,
+	GPIO_V2_LINE_FLAG_EDGE_RISING = 16,
+	GPIO_V2_LINE_FLAG_EDGE_FALLING = 32,
+	GPIO_V2_LINE_FLAG_OPEN_DRAIN = 64,
+	GPIO_V2_LINE_FLAG_OPEN_SOURCE = 128,
+	GPIO_V2_LINE_FLAG_BIAS_PULL_UP = 256,
+	GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN = 512,
+	GPIO_V2_LINE_FLAG_BIAS_DISABLED = 1024,
+	GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME = 2048,
+	GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE = 4096,
+};
+
+struct gpio_v2_line_values {
+	__u64 bits;
+	__u64 mask;
+};
+
+enum gpio_v2_line_attr_id {
+	GPIO_V2_LINE_ATTR_ID_FLAGS = 1,
+	GPIO_V2_LINE_ATTR_ID_OUTPUT_VALUES = 2,
+	GPIO_V2_LINE_ATTR_ID_DEBOUNCE = 3,
+};
+
+struct gpio_v2_line_attribute {
+	__u32 id;
+	__u32 padding;
+	union {
+		__u64 flags;
+		__u64 values;
+		__u32 debounce_period_us;
+	};
+};
+
+struct gpio_v2_line_config_attribute {
+	struct gpio_v2_line_attribute attr;
+	__u64 mask;
+};
+
+struct gpio_v2_line_config {
+	__u64 flags;
+	__u32 num_attrs;
+	__u32 padding[5];
+	struct gpio_v2_line_config_attribute attrs[10];
+};
+
+struct gpio_v2_line_request {
+	__u32 offsets[64];
+	char consumer[32];
+	struct gpio_v2_line_config config;
+	__u32 num_lines;
+	__u32 event_buffer_size;
+	__u32 padding[5];
+	__s32 fd;
+};
+
+struct gpio_v2_line_info {
+	char name[32];
+	char consumer[32];
+	__u32 offset;
+	__u32 num_attrs;
+	__u64 flags;
+	struct gpio_v2_line_attribute attrs[10];
+	__u32 padding[4];
+};
+
+enum gpio_v2_line_changed_type {
+	GPIO_V2_LINE_CHANGED_REQUESTED = 1,
+	GPIO_V2_LINE_CHANGED_RELEASED = 2,
+	GPIO_V2_LINE_CHANGED_CONFIG = 3,
+};
+
+struct gpio_v2_line_info_changed {
+	struct gpio_v2_line_info info;
+	__u64 timestamp_ns;
+	__u32 event_type;
+	__u32 padding[5];
+};
+
+enum gpio_v2_line_event_id {
+	GPIO_V2_LINE_EVENT_RISING_EDGE = 1,
+	GPIO_V2_LINE_EVENT_FALLING_EDGE = 2,
+};
+
+struct gpio_v2_line_event {
+	__u64 timestamp_ns;
+	__u32 id;
+	__u32 offset;
+	__u32 seqno;
+	__u32 line_seqno;
+	__u32 padding[6];
+};
+
+struct linereq;
+
+struct line {
+	struct rb_node node;
+	struct gpio_desc *desc;
+	struct linereq *req;
+	unsigned int irq;
+	u64 edflags;
+	u64 timestamp_ns;
+	u32 req_seqno;
+	u32 line_seqno;
+	struct delayed_work work;
+	unsigned int debounce_period_us;
+	unsigned int sw_debounced;
+	unsigned int level;
+};
+
+struct linereq {
+	struct gpio_device *gdev;
+	const char *label;
+	u32 num_lines;
+	wait_queue_head_t wait;
+	struct notifier_block device_unregistered_nb;
+	u32 event_buffer_size;
+	struct {
+		union {
+			struct __kfifo kfifo;
+			struct gpio_v2_line_event *type;
+			const struct gpio_v2_line_event *const_type;
+			char (*rectype)[0];
+			struct gpio_v2_line_event *ptr;
+			const struct gpio_v2_line_event *ptr_const;
+		};
+		long: 32;
+		struct gpio_v2_line_event buf[0];
+	} events;
+	atomic_t seqno;
+	struct mutex config_mutex;
+	struct line lines[0];
+};
+
+struct gpio_chardev_data {
+	struct gpio_device *gdev;
+	wait_queue_head_t wait;
+	struct {
+		union {
+			struct __kfifo kfifo;
+			struct gpio_v2_line_info_changed *type;
+			const struct gpio_v2_line_info_changed *const_type;
+			char (*rectype)[0];
+			struct gpio_v2_line_info_changed *ptr;
+			const struct gpio_v2_line_info_changed *ptr_const;
+		};
+		long: 32;
+		struct gpio_v2_line_info_changed buf[32];
+	} events;
+	struct notifier_block lineinfo_changed_nb;
+	struct notifier_block device_unregistered_nb;
+	long unsigned int *watched_lines;
+	long: 32;
+};
+
+enum {
+	PWMF_REQUESTED = 0,
+	PWMF_EXPORTED = 1,
+};
+
+struct pwm_lookup {
+	struct list_head list;
+	const char *provider;
+	unsigned int index;
+	const char *dev_id;
+	const char *con_id;
+	unsigned int period;
+	enum pwm_polarity polarity;
+	const char *module;
+};
+
+struct trace_event_raw_pwm {
+	struct trace_entry ent;
+	unsigned int chipid;
+	unsigned int hwpwm;
+	u64 period;
+	u64 duty_cycle;
+	enum pwm_polarity polarity;
+	bool enabled;
+	int err;
+	char __data[0];
+	long: 32;
+};
+
+struct trace_event_data_offsets_pwm {};
+
+typedef void (*btf_trace_pwm_apply)(void *, struct pwm_device *, const struct pwm_state *, int);
+
+typedef void (*btf_trace_pwm_get)(void *, struct pwm_device *, const struct pwm_state *, int);
+
+struct pwm_export {
+	struct device pwm_dev;
+	struct pwm_device *pwm;
+	struct mutex lock;
+	struct pwm_state suspend;
+};
+
+struct pci_bus_resource {
+	struct list_head list;
+	struct resource *res;
+	unsigned int flags;
+};
+
+struct pci_slot_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct pci_slot *, char *);
+	ssize_t (*store)(struct pci_slot *, const char *, size_t);
+};
+
+enum {
+	NVME_REG_CAP = 0,
+	NVME_REG_VS = 8,
+	NVME_REG_INTMS = 12,
+	NVME_REG_INTMC = 16,
+	NVME_REG_CC = 20,
+	NVME_REG_CSTS = 28,
+	NVME_REG_NSSR = 32,
+	NVME_REG_AQA = 36,
+	NVME_REG_ASQ = 40,
+	NVME_REG_ACQ = 48,
+	NVME_REG_CMBLOC = 56,
+	NVME_REG_CMBSZ = 60,
+	NVME_REG_BPINFO = 64,
+	NVME_REG_BPRSEL = 68,
+	NVME_REG_BPMBL = 72,
+	NVME_REG_CMBMSC = 80,
+	NVME_REG_CRTO = 104,
+	NVME_REG_PMRCAP = 3584,
+	NVME_REG_PMRCTL = 3588,
+	NVME_REG_PMRSTS = 3592,
+	NVME_REG_PMREBS = 3596,
+	NVME_REG_PMRSWTP = 3600,
+	NVME_REG_DBS = 4096,
+};
+
+enum {
+	NVME_CC_ENABLE = 1,
+	NVME_CC_EN_SHIFT = 0,
+	NVME_CC_CSS_SHIFT = 4,
+	NVME_CC_MPS_SHIFT = 7,
+	NVME_CC_AMS_SHIFT = 11,
+	NVME_CC_SHN_SHIFT = 14,
+	NVME_CC_IOSQES_SHIFT = 16,
+	NVME_CC_IOCQES_SHIFT = 20,
+	NVME_CC_CSS_NVM = 0,
+	NVME_CC_CSS_CSI = 96,
+	NVME_CC_CSS_MASK = 112,
+	NVME_CC_AMS_RR = 0,
+	NVME_CC_AMS_WRRU = 2048,
+	NVME_CC_AMS_VS = 14336,
+	NVME_CC_SHN_NONE = 0,
+	NVME_CC_SHN_NORMAL = 16384,
+	NVME_CC_SHN_ABRUPT = 32768,
+	NVME_CC_SHN_MASK = 49152,
+	NVME_CC_IOSQES = 393216,
+	NVME_CC_IOCQES = 4194304,
+	NVME_CC_CRIME = 16777216,
+};
+
+enum {
+	NVME_CSTS_RDY = 1,
+	NVME_CSTS_CFS = 2,
+	NVME_CSTS_NSSRO = 16,
+	NVME_CSTS_PP = 32,
+	NVME_CSTS_SHST_NORMAL = 0,
+	NVME_CSTS_SHST_OCCUR = 4,
+	NVME_CSTS_SHST_CMPLT = 8,
+	NVME_CSTS_SHST_MASK = 12,
+};
+
+enum {
+	SWITCHTEC_GAS_MRPC_OFFSET = 0,
+	SWITCHTEC_GAS_TOP_CFG_OFFSET = 4096,
+	SWITCHTEC_GAS_SW_EVENT_OFFSET = 6144,
+	SWITCHTEC_GAS_SYS_INFO_OFFSET = 8192,
+	SWITCHTEC_GAS_FLASH_INFO_OFFSET = 8704,
+	SWITCHTEC_GAS_PART_CFG_OFFSET = 16384,
+	SWITCHTEC_GAS_NTB_OFFSET = 65536,
+	SWITCHTEC_GAS_PFF_CSR_OFFSET = 1261568,
+};
+
+enum {
+	SWITCHTEC_NTB_REG_INFO_OFFSET = 0,
+	SWITCHTEC_NTB_REG_CTRL_OFFSET = 16384,
+	SWITCHTEC_NTB_REG_DBMSG_OFFSET = 409600,
+};
+
+struct nt_partition_info {
+	u32 xlink_enabled;
+	u32 target_part_low;
+	u32 target_part_high;
+	u32 reserved;
+};
+
+struct ntb_info_regs {
+	u8 partition_count;
+	u8 partition_id;
+	u16 reserved1;
+	u64 ep_map;
+	u16 requester_id;
+	u16 reserved2;
+	u32 reserved3[4];
+	struct nt_partition_info ntp_info[48];
+};
+
+struct ntb_ctrl_regs {
+	u32 partition_status;
+	u32 partition_op;
+	u32 partition_ctrl;
+	u32 bar_setup;
+	u32 bar_error;
+	u16 lut_table_entries;
+	u16 lut_table_offset;
+	u32 lut_error;
+	u16 req_id_table_size;
+	u16 req_id_table_offset;
+	u32 req_id_error;
+	u32 reserved1[7];
+	struct {
+		u32 ctl;
+		u32 win_size;
+		u64 xlate_addr;
+	} bar_entry[6];
+	struct {
+		u32 win_size;
+		u32 reserved[3];
+	} bar_ext_entry[6];
+	u32 reserved2[192];
+	u32 req_id_table[512];
+	u32 reserved3[256];
+	u64 lut_entry[512];
+};
+
+struct pci_dev_reset_methods {
+	u16 vendor;
+	u16 device;
+	int (*reset)(struct pci_dev *, bool);
+};
+
+struct pci_dev_acs_enabled {
+	u16 vendor;
+	u16 device;
+	int (*acs_enabled)(struct pci_dev *, u16);
+};
+
+struct pci_dev_acs_ops {
+	u16 vendor;
+	u16 device;
+	int (*enable_acs)(struct pci_dev *);
+	int (*disable_acs_redir)(struct pci_dev *);
+};
+
+struct devm_clk_state {
+	struct clk *clk;
+	void (*exit)(struct clk *);
+};
+
+struct clk_bulk_devres {
+	struct clk_bulk_data *clks;
+	int num_clks;
+};
+
+struct clk_lookup {
+	struct list_head node;
+	const char *dev_id;
+	const char *con_id;
+	struct clk *clk;
+	struct clk_hw *clk_hw;
+};
+
+struct clk_lookup_alloc {
+	struct clk_lookup cl;
+	char dev_id[24];
+	char con_id[16];
+};
+
+struct clk_fixed_factor {
+	struct clk_hw hw;
+	unsigned int mult;
+	unsigned int div;
+	long unsigned int acc;
+	unsigned int flags;
+};
+
+struct clk_multiplier {
+	struct clk_hw hw;
+	void *reg;
+	u8 shift;
+	u8 width;
+	u8 flags;
+	spinlock_t *lock;
+};
+
+struct u32_fract {
+	__u32 numerator;
+	__u32 denominator;
+};
+
+struct clk_fractional_divider {
+	struct clk_hw hw;
+	void *reg;
+	u8 mshift;
+	u8 mwidth;
+	u8 nshift;
+	u8 nwidth;
+	u8 flags;
+	void (*approximation)(struct clk_hw *, long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *);
+	spinlock_t *lock;
+};
+
+enum iproc_arm_pll_fid {
+	ARM_PLL_FID_CRYSTAL_CLK = 0,
+	ARM_PLL_FID_SYS_CLK = 2,
+	ARM_PLL_FID_CH0_SLOW_CLK = 6,
+	ARM_PLL_FID_CH1_FAST_CLK = 7,
+};
+
+struct iproc_arm_pll {
+	struct clk_hw hw;
+	void *base;
+	long unsigned int rate;
+};
+
+struct bcm53573_ilp {
+	struct clk_hw hw;
+	struct regmap *regmap;
+};
+
+struct termios {
+	tcflag_t c_iflag;
+	tcflag_t c_oflag;
+	tcflag_t c_cflag;
+	tcflag_t c_lflag;
+	cc_t c_line;
+	cc_t c_cc[19];
+};
+
+struct termios2 {
+	tcflag_t c_iflag;
+	tcflag_t c_oflag;
+	tcflag_t c_cflag;
+	tcflag_t c_lflag;
+	cc_t c_line;
+	cc_t c_cc[19];
+	speed_t c_ispeed;
+	speed_t c_ospeed;
+};
+
+struct termio {
+	short unsigned int c_iflag;
+	short unsigned int c_oflag;
+	short unsigned int c_cflag;
+	short unsigned int c_lflag;
+	unsigned char c_line;
+	unsigned char c_cc[8];
+};
+
+enum input_clock_type {
+	INPUT_CLK_REAL = 0,
+	INPUT_CLK_MONO = 1,
+	INPUT_CLK_BOOT = 2,
+	INPUT_CLK_MAX = 3,
+};
+
+struct irq_info {
+	struct hlist_node node;
+	int irq;
+	spinlock_t lock;
+	struct list_head *head;
+};
+
+enum mctrl_gpio_idx {
+	UART_GPIO_CTS = 0,
+	UART_GPIO_DSR = 1,
+	UART_GPIO_DCD = 2,
+	UART_GPIO_RNG = 3,
+	UART_GPIO_RI = 3,
+	UART_GPIO_RTS = 4,
+	UART_GPIO_DTR = 5,
+	UART_GPIO_MAX = 6,
+};
+
+struct mctrl_gpios {
+	struct uart_port *port;
+	struct gpio_desc *gpio[6];
+	int irq[6];
+	unsigned int mctrl_prev;
+	bool mctrl_on;
+};
+
+struct jent_entropy_es {
+	uint8_t e[32];
+	uint32_t e_bits;
+};
+
+enum lrng_jent_async_state {
+	buffer_empty = 0,
+	buffer_filling = 1,
+	buffer_filled = 2,
+	buffer_reading = 3,
+};
+
+struct batched_entropy {
+	union {
+		u64 entropy_u64[8];
+		u32 entropy_u32[16];
+		u16 entropy_u16[32];
+		u8 entropy_u8[64];
+	};
+	unsigned int position;
+	spinlock_t batch_lock;
+};
+
+struct iommu_group {
+	struct kobject kobj;
+	struct kobject *devices_kobj;
+	struct list_head devices;
+	struct xarray pasid_array;
+	struct mutex mutex;
+	void *iommu_data;
+	void (*iommu_data_release)(void *);
+	char *name;
+	int id;
+	struct iommu_domain *default_domain;
+	struct iommu_domain *blocking_domain;
+	struct iommu_domain *domain;
+	struct list_head entry;
+	unsigned int owner_cnt;
+	void *owner;
+};
+
+enum iommu_resv_type {
+	IOMMU_RESV_DIRECT = 0,
+	IOMMU_RESV_DIRECT_RELAXABLE = 1,
+	IOMMU_RESV_RESERVED = 2,
+	IOMMU_RESV_MSI = 3,
+	IOMMU_RESV_SW_MSI = 4,
+};
+
+struct iommu_resv_region {
+	struct list_head list;
+	phys_addr_t start;
+	size_t length;
+	int prot;
+	enum iommu_resv_type type;
+	void (*free)(struct device *, struct iommu_resv_region *);
+};
+
+struct fsl_mc_obj_desc {
+	char type[16];
+	int id;
+	u16 vendor;
+	u16 ver_major;
+	u16 ver_minor;
+	u8 irq_count;
+	u8 region_count;
+	u32 state;
+	char label[16];
+	u16 flags;
+};
+
+struct fsl_mc_io;
+
+struct fsl_mc_device_irq;
+
+struct fsl_mc_resource;
+
+struct fsl_mc_device {
+	struct device dev;
+	u64 dma_mask;
+	u16 flags;
+	u32 icid;
+	u16 mc_handle;
+	struct fsl_mc_io *mc_io;
+	struct fsl_mc_obj_desc obj_desc;
+	struct resource *regions;
+	struct fsl_mc_device_irq **irqs;
+	struct fsl_mc_resource *resource;
+	struct device_link *consumer_link;
+	const char *driver_override;
+};
+
+enum fsl_mc_pool_type {
+	FSL_MC_POOL_DPMCP = 0,
+	FSL_MC_POOL_DPBP = 1,
+	FSL_MC_POOL_DPCON = 2,
+	FSL_MC_POOL_IRQ = 3,
+	FSL_MC_NUM_POOL_TYPES = 4,
+};
+
+struct fsl_mc_resource_pool;
+
+struct fsl_mc_resource {
+	enum fsl_mc_pool_type type;
+	s32 id;
+	void *data;
+	struct fsl_mc_resource_pool *parent_pool;
+	struct list_head node;
+};
+
+struct fsl_mc_device_irq {
+	unsigned int virq;
+	struct fsl_mc_device *mc_dev;
+	u8 dev_irq_index;
+	struct fsl_mc_resource resource;
+};
+
+struct fsl_mc_io {
+	struct device *dev;
+	u16 flags;
+	u32 portal_size;
+	phys_addr_t portal_phys_addr;
+	void *portal_virt_addr;
+	struct fsl_mc_device *dpmcp_dev;
+	union {
+		struct mutex mutex;
+		raw_spinlock_t spinlock;
+	};
+};
+
+enum cc_attr {
+	CC_ATTR_MEM_ENCRYPT = 0,
+	CC_ATTR_HOST_MEM_ENCRYPT = 1,
+	CC_ATTR_GUEST_MEM_ENCRYPT = 2,
+	CC_ATTR_GUEST_STATE_ENCRYPT = 3,
+	CC_ATTR_GUEST_UNROLL_STRING_IO = 4,
+	CC_ATTR_GUEST_SEV_SNP = 5,
+	CC_ATTR_HOST_SEV_SNP = 6,
+};
+
+struct group_device {
+	struct list_head list;
+	struct device *dev;
+	char *name;
+};
+
+struct iommu_group_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct iommu_group *, char *);
+	ssize_t (*store)(struct iommu_group *, const char *, size_t);
+};
+
+enum {
+	IOMMU_SET_DOMAIN_MUST_SUCCEED = 1,
+};
+
+struct group_for_pci_data {
+	struct pci_dev *pdev;
+	struct iommu_group *group;
+};
+
+struct device_attach_data {
+	struct device *dev;
+	bool check_async;
+	bool want_async;
+	bool have_async;
+};
+
+typedef void *acpi_handle;
+
+struct irq_affinity_devres {
+	unsigned int count;
+	unsigned int irq[0];
+};
+
+struct platform_object {
+	struct platform_device pdev;
+	char name[0];
+};
+
+struct probe {
+	struct probe *next;
+	dev_t dev;
+	long unsigned int range;
+	struct module *owner;
+	kobj_probe_t *get;
+	int (*lock)(dev_t, void *);
+	void *data;
+};
+
+struct kobj_map {
+	struct probe *probes[255];
+	struct mutex *lock;
+};
+
+struct transport_container;
+
+struct transport_class {
+	struct class class;
+	int (*setup)(struct transport_container *, struct device *, struct device *);
+	int (*configure)(struct transport_container *, struct device *, struct device *);
+	int (*remove)(struct transport_container *, struct device *, struct device *);
+};
+
+struct transport_container {
+	struct attribute_container ac;
+	const struct attribute_group *statistics;
+};
+
+struct anon_transport_class {
+	struct transport_class tclass;
+	struct attribute_container container;
+};
+
+typedef void * (*devcon_match_fn_t)(const struct fwnode_handle *, const char *, void *);
+
+struct pm_clk_notifier_block {
+	struct notifier_block nb;
+	struct dev_pm_domain *pm_domain;
+	char *con_ids[0];
+};
+
+struct regmap_debugfs_off_cache {
+	struct list_head list;
+	off_t min;
+	off_t max;
+	unsigned int base_reg;
+	unsigned int max_reg;
+};
+
+struct regmap_debugfs_node {
+	struct regmap *map;
+	struct list_head link;
+};
+
+enum scale_freq_source {
+	SCALE_FREQ_SOURCE_CPUFREQ = 0,
+	SCALE_FREQ_SOURCE_ARCH = 1,
+	SCALE_FREQ_SOURCE_CPPC = 2,
+};
+
+struct scale_freq_data {
+	enum scale_freq_source source;
+	void (*set_freq_scale)();
+};
+
+struct trace_event_raw_hw_pressure_update {
+	struct trace_entry ent;
+	long unsigned int hw_pressure;
+	int cpu;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_hw_pressure_update {};
+
+typedef void (*btf_trace_hw_pressure_update)(void *, int, long unsigned int);
+
+struct ww_class {
+	atomic_long_t stamp;
+	struct lock_class_key acquire_key;
+	struct lock_class_key mutex_key;
+	const char *acquire_name;
+	const char *mutex_name;
+	unsigned int is_wait_die;
+};
+
+struct dma_resv_list {
+	struct callback_head rcu;
+	u32 num_fences;
+	u32 max_fences;
+	struct dma_fence *table[0];
+};
+
+struct mtd_partitions {
+	const struct mtd_partition *parts;
+	int nr_parts;
+	const struct mtd_part_parser *parser;
+};
+
+struct erase_info_user {
+	__u32 start;
+	__u32 length;
+};
+
+struct erase_info_user64 {
+	__u64 start;
+	__u64 length;
+};
+
+struct mtd_oob_buf {
+	__u32 start;
+	__u32 length;
+	unsigned char *ptr;
+};
+
+struct mtd_oob_buf64 {
+	__u64 start;
+	__u32 pad;
+	__u32 length;
+	__u64 usr_ptr;
+};
+
+struct mtd_write_req {
+	__u64 start;
+	__u64 len;
+	__u64 ooblen;
+	__u64 usr_data;
+	__u64 usr_oob;
+	__u8 mode;
+	__u8 padding[7];
+};
+
+struct mtd_read_req_ecc_stats {
+	__u32 uncorrectable_errors;
+	__u32 corrected_bitflips;
+	__u32 max_bitflips;
+};
+
+struct mtd_read_req {
+	__u64 start;
+	__u64 len;
+	__u64 ooblen;
+	__u64 usr_data;
+	__u64 usr_oob;
+	__u8 mode;
+	__u8 padding[7];
+	struct mtd_read_req_ecc_stats ecc_stats;
+	long: 32;
+};
+
+struct mtd_info_user {
+	__u8 type;
+	__u32 flags;
+	__u32 size;
+	__u32 erasesize;
+	__u32 writesize;
+	__u32 oobsize;
+	__u64 padding;
+};
+
+struct region_info_user {
+	__u32 offset;
+	__u32 erasesize;
+	__u32 numblocks;
+	__u32 regionindex;
+};
+
+struct nand_oobinfo {
+	__u32 useecc;
+	__u32 eccbytes;
+	__u32 oobfree[16];
+	__u32 eccpos[32];
+};
+
+struct nand_oobfree {
+	__u32 offset;
+	__u32 length;
+};
+
+struct nand_ecclayout_user {
+	__u32 eccbytes;
+	__u32 eccpos[64];
+	__u32 oobavail;
+	struct nand_oobfree oobfree[8];
+};
+
+enum mtd_file_modes {
+	MTD_FILE_MODE_NORMAL = 0,
+	MTD_FILE_MODE_OTP_FACTORY = 1,
+	MTD_FILE_MODE_OTP_USER = 2,
+	MTD_FILE_MODE_RAW = 3,
+};
+
+struct mtd_file_info {
+	struct mtd_info *mtd;
+	enum mtd_file_modes mode;
+};
+
+struct cfi_early_fixup {
+	uint16_t mfr;
+	uint16_t id;
+	void (*fixup)(struct cfi_private *);
+};
+
+struct cfi_pri_amdstd {
+	uint8_t pri[3];
+	uint8_t MajorVersion;
+	uint8_t MinorVersion;
+	uint8_t SiliconRevision;
+	uint8_t EraseSuspend;
+	uint8_t BlkProt;
+	uint8_t TmpBlkUnprotect;
+	uint8_t BlkProtUnprot;
+	uint8_t SimultaneousOps;
+	uint8_t BurstMode;
+	uint8_t PageMode;
+	uint8_t VppMin;
+	uint8_t VppMax;
+	uint8_t TopBottom;
+	uint8_t ProgramSuspend;
+	uint8_t UnlockBypass;
+	uint8_t SecureSiliconSector;
+	uint8_t SoftwareFeatures;
+};
+
+enum cfi_quirks {
+	CFI_QUIRK_DQ_TRUE_DATA = 1,
+};
+
+typedef int (*otp_op_t)(struct map_info *, struct flchip *, loff_t, size_t, u_char *, size_t);
+
+struct ppb_lock {
+	struct flchip *chip;
+	long unsigned int adr;
+	int locked;
+};
+
+typedef s8 int8_t;
+
+struct jedec_ecc_info {
+	u8 ecc_bits;
+	u8 codeword_size;
+	__le16 bb_per_lun;
+	__le16 block_endurance;
+	u8 reserved[2];
+};
+
+struct nand_jedec_params {
+	u8 sig[4];
+	__le16 revision;
+	__le16 features;
+	u8 opt_cmd[3];
+	__le16 sec_cmd;
+	u8 num_of_param_pages;
+	u8 reserved0[18];
+	char manufacturer[12];
+	char model[20];
+	u8 jedec_id[6];
+	u8 reserved1[10];
+	__le32 byte_per_page;
+	__le16 spare_bytes_per_page;
+	u8 reserved2[6];
+	__le32 pages_per_block;
+	__le32 blocks_per_lun;
+	u8 lun_count;
+	u8 addr_cycles;
+	u8 bits_per_cell;
+	u8 programs_per_page;
+	u8 multi_plane_addr;
+	u8 multi_plane_op_attr;
+	u8 reserved3[38];
+	__le16 async_sdr_speed_grade;
+	__le16 toggle_ddr_speed_grade;
+	__le16 sync_ddr_speed_grade;
+	u8 async_sdr_features;
+	u8 toggle_ddr_features;
+	u8 sync_ddr_features;
+	__le16 t_prog;
+	__le16 t_bers;
+	__le16 t_r;
+	__le16 t_r_multi_plane;
+	__le16 t_ccs;
+	__le16 io_pin_capacitance_typ;
+	__le16 input_pin_capacitance_typ;
+	__le16 clk_pin_capacitance_typ;
+	u8 driver_strength_support;
+	__le16 t_adl;
+	u8 reserved4[36];
+	u8 guaranteed_good_blocks;
+	__le16 guaranteed_block_endurance;
+	struct jedec_ecc_info ecc_info[4];
+	u8 reserved5[29];
+	u8 reserved6[148];
+	__le16 vendor_rev_num;
+	u8 reserved7[88];
+	__le16 crc;
+} __attribute__((packed));
+
+struct nand_onfi_vendor_macronix {
+	u8 reserved;
+	u8 reliability_func;
+};
+
+enum {
+	UBI_VOL_PROP_DIRECT_WRITE = 1,
+};
+
+struct ubi_attach_req {
+	__s32 ubi_num;
+	__s32 mtd_num;
+	__s32 vid_hdr_offset;
+	__s16 max_beb_per1024;
+	__s8 disable_fm;
+	__s8 need_resv_pool;
+	__s8 padding[8];
+};
+
+struct ubi_rsvol_req {
+	__s64 bytes;
+	__s32 vol_id;
+};
+
+struct ubi_rnvol_req {
+	__s32 count;
+	__s8 padding1[12];
+	struct {
+		__s32 vol_id;
+		__s16 name_len;
+		__s8 padding2[2];
+		char name[128];
+	} ents[32];
+};
+
+struct ubi_map_req {
+	__s32 lnum;
+	__s8 dtype;
+	__s8 padding[3];
+};
+
+struct ubi_set_vol_prop_req {
+	__u8 property;
+	__u8 padding[7];
+	__u64 value;
+};
+
+typedef unsigned int (*spi_bb_txrx_bufs_fn)(struct spi_device *, spi_bb_txrx_word_fn, unsigned int, struct spi_transfer *, unsigned int);
+
+struct spi_bitbang_cs {
+	unsigned int nsecs;
+	spi_bb_txrx_word_fn txrx_word;
+	spi_bb_txrx_bufs_fn txrx_bufs;
+};
+
+struct trace_event_raw_mdio_access {
+	struct trace_entry ent;
+	char busid[61];
+	char read;
+	u8 addr;
+	u16 val;
+	unsigned int regnum;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_mdio_access {};
+
+typedef void (*btf_trace_mdio_access)(void *, struct mii_bus *, char, u8, unsigned int, u16, int);
+
+struct mdio_bus_stat_attr {
+	int addr;
+	unsigned int field_offset;
+};
+
+struct power_supply_led_trigger {
+	struct led_trigger trig;
+	struct power_supply *psy;
+};
+
+struct sr_thermal;
+
+struct sr_tmon {
+	unsigned int crit_temp;
+	unsigned int tmon_id;
+	struct sr_thermal *priv;
+};
+
+struct sr_thermal {
+	void *regs;
+	unsigned int max_crit_temp;
+	struct sr_tmon tmon[6];
+};
+
+struct nvram_header {
+	u32 magic;
+	u32 len;
+	u32 crc_ver_init;
+	u32 config_refresh;
+	u32 config_ncdl;
+};
+
+struct of_timer_irq {
+	int irq;
+	int index;
+	const char *name;
+	long unsigned int flags;
+	irq_handler_t handler;
+};
+
+struct of_timer_base {
+	void *base;
+	const char *name;
+	int index;
+};
+
+struct of_timer_clk {
+	struct clk *clk;
+	const char *name;
+	int index;
+	long unsigned int rate;
+	long unsigned int period;
+};
+
+struct timer_of {
+	unsigned int flags;
+	struct device_node *np;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct clock_event_device clkevt;
+	struct of_timer_base of_base;
+	struct of_timer_irq of_irq;
+	struct of_timer_clk of_clk;
+	void *private_data;
+	long: 32;
+	long: 32;
+};
+
+struct of_bus___2 {
+	void (*count_cells)(const void *, int, int *, int *);
+	u64 (*map)(__be32 *, const __be32 *, int, int, int);
+	int (*translate)(__be32 *, u64, int);
+};
+
+struct of_bus {
+	const char *name;
+	const char *addresses;
+	int (*match)(struct device_node *);
+	void (*count_cells)(struct device_node *, int *, int *);
+	u64 (*map)(__be32 *, const __be32 *, int, int, int, int);
+	int (*translate)(__be32 *, u64, int);
+	int flag_cells;
+	unsigned int (*get_flags)(const __be32 *);
+};
+
+struct bcma_device_id_name {
+	u16 id;
+	const char *name;
+};
+
+struct bcma_soc {
+	struct bcma_bus bus;
+	struct device *dev;
+};
+
+struct net_device_devres {
+	struct net_device *ndev;
+};
+
+enum {
+	IF_LINK_MODE_DEFAULT = 0,
+	IF_LINK_MODE_DORMANT = 1,
+	IF_LINK_MODE_TESTING = 2,
+};
+
+enum lw_bits {
+	LW_URGENT = 0,
+};
+
+struct tso_t {
+	int next_frag_idx;
+	int size;
+	void *data;
+	u16 ip_id;
+	u8 tlen;
+	bool ipv6;
+	u32 tcp_seq;
+};
+
+struct xdp_frame_bulk {
+	int count;
+	void *xa;
+	void *q[16];
+};
+
+struct xdp_attachment_info {
+	struct bpf_prog *prog;
+	u32 flags;
+};
+
+struct rx_queue_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct netdev_rx_queue *, char *);
+	ssize_t (*store)(struct netdev_rx_queue *, const char *, size_t);
+};
+
+struct netdev_queue_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct netdev_queue *, char *);
+	ssize_t (*store)(struct netdev_queue *, const char *, size_t);
+};
+
+struct dst_cache_pcpu {
+	long unsigned int refresh_ts;
+	struct dst_entry *dst;
+	u32 cookie;
+	union {
+		struct in_addr in_saddr;
+		struct in6_addr in6_saddr;
+	};
+};
+
+struct bpf_stab {
+	struct bpf_map map;
+	struct sock **sks;
+	struct sk_psock_progs progs;
+	spinlock_t lock;
+};
+
+typedef u64 (*btf_bpf_sock_map_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);
+
+typedef u64 (*btf_bpf_sk_redirect_map)(struct sk_buff *, struct bpf_map *, u32, u64);
+
+typedef u64 (*btf_bpf_msg_redirect_map)(struct sk_msg *, struct bpf_map *, u32, u64);
+
+struct sock_map_seq_info {
+	struct bpf_map *map;
+	struct sock *sk;
+	u32 index;
+};
+
+struct bpf_iter__sockmap {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct bpf_map *map;
+	};
+	union {
+		void *key;
+	};
+	union {
+		struct sock *sk;
+	};
+};
+
+struct bpf_shtab_elem {
+	struct callback_head rcu;
+	u32 hash;
+	struct sock *sk;
+	struct hlist_node node;
+	u8 key[0];
+};
+
+struct bpf_shtab_bucket {
+	struct hlist_head head;
+	spinlock_t lock;
+};
+
+struct bpf_shtab {
+	struct bpf_map map;
+	struct bpf_shtab_bucket *buckets;
+	u32 buckets_num;
+	u32 elem_size;
+	struct sk_psock_progs progs;
+	atomic_t count;
+};
+
+typedef u64 (*btf_bpf_sock_hash_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);
+
+typedef u64 (*btf_bpf_sk_redirect_hash)(struct sk_buff *, struct bpf_map *, void *, u64);
+
+typedef u64 (*btf_bpf_msg_redirect_hash)(struct sk_msg *, struct bpf_map *, void *, u64);
+
+struct sock_hash_seq_info {
+	struct bpf_map *map;
+	struct bpf_shtab *htab;
+	u32 bucket_id;
+};
+
+struct sockmap_link {
+	struct bpf_link link;
+	struct bpf_map *map;
+	enum bpf_attach_type attach_type;
+};
+
+struct llc_pdu_sn {
+	u8 dsap;
+	u8 ssap;
+	u8 ctrl_1;
+	u8 ctrl_2;
+};
+
+enum tc_mq_command {
+	TC_MQ_CREATE = 0,
+	TC_MQ_DESTROY = 1,
+	TC_MQ_STATS = 2,
+	TC_MQ_GRAFT = 3,
+};
+
+struct tc_mq_opt_offload_graft_params {
+	long unsigned int queue;
+	u32 child_handle;
+};
+
+struct tc_mq_qopt_offload {
+	enum tc_mq_command command;
+	u32 handle;
+	union {
+		struct tc_qopt_offload_stats stats;
+		struct tc_mq_opt_offload_graft_params graft_params;
+	};
+};
+
+struct mq_sched {
+	struct Qdisc **qdiscs;
+};
+
+enum {
+	TCA_FQ_CODEL_UNSPEC = 0,
+	TCA_FQ_CODEL_TARGET = 1,
+	TCA_FQ_CODEL_LIMIT = 2,
+	TCA_FQ_CODEL_INTERVAL = 3,
+	TCA_FQ_CODEL_ECN = 4,
+	TCA_FQ_CODEL_FLOWS = 5,
+	TCA_FQ_CODEL_QUANTUM = 6,
+	TCA_FQ_CODEL_CE_THRESHOLD = 7,
+	TCA_FQ_CODEL_DROP_BATCH_SIZE = 8,
+	TCA_FQ_CODEL_MEMORY_LIMIT = 9,
+	TCA_FQ_CODEL_CE_THRESHOLD_SELECTOR = 10,
+	TCA_FQ_CODEL_CE_THRESHOLD_MASK = 11,
+	__TCA_FQ_CODEL_MAX = 12,
+};
+
+enum {
+	TCA_FQ_CODEL_XSTATS_QDISC = 0,
+	TCA_FQ_CODEL_XSTATS_CLASS = 1,
+};
+
+struct tc_fq_codel_qd_stats {
+	__u32 maxpacket;
+	__u32 drop_overlimit;
+	__u32 ecn_mark;
+	__u32 new_flow_count;
+	__u32 new_flows_len;
+	__u32 old_flows_len;
+	__u32 ce_mark;
+	__u32 memory_usage;
+	__u32 drop_overmemory;
+};
+
+struct tc_fq_codel_cl_stats {
+	__s32 deficit;
+	__u32 ldelay;
+	__u32 count;
+	__u32 lastcount;
+	__u32 dropping;
+	__s32 drop_next;
+};
+
+struct tc_fq_codel_xstats {
+	__u32 type;
+	union {
+		struct tc_fq_codel_qd_stats qdisc_stats;
+		struct tc_fq_codel_cl_stats class_stats;
+	};
+};
+
+typedef u32 codel_time_t;
+
+typedef s32 codel_tdiff_t;
+
+struct codel_params {
+	codel_time_t target;
+	codel_time_t ce_threshold;
+	codel_time_t interval;
+	u32 mtu;
+	bool ecn;
+	u8 ce_threshold_selector;
+	u8 ce_threshold_mask;
+};
+
+struct codel_vars {
+	u32 count;
+	u32 lastcount;
+	bool dropping;
+	u16 rec_inv_sqrt;
+	codel_time_t first_above_time;
+	codel_time_t drop_next;
+	codel_time_t ldelay;
+};
+
+struct codel_stats {
+	u32 maxpacket;
+	u32 drop_count;
+	u32 drop_len;
+	u32 ecn_mark;
+	u32 ce_mark;
+};
+
+typedef u32 (*codel_skb_len_t)(const struct sk_buff *);
+
+typedef codel_time_t (*codel_skb_time_t)(const struct sk_buff *);
+
+typedef void (*codel_skb_drop_t)(struct sk_buff *, void *);
+
+typedef struct sk_buff * (*codel_skb_dequeue_t)(struct codel_vars *, void *);
+
+struct codel_skb_cb {
+	codel_time_t enqueue_time;
+	unsigned int mem_usage;
+};
+
+struct fq_codel_flow {
+	struct sk_buff *head;
+	struct sk_buff *tail;
+	struct list_head flowchain;
+	int deficit;
+	struct codel_vars cvars;
+};
+
+struct fq_codel_sched_data {
+	struct tcf_proto *filter_list;
+	struct tcf_block *block;
+	struct fq_codel_flow *flows;
+	u32 *backlogs;
+	u32 flows_cnt;
+	u32 quantum;
+	u32 drop_batch_size;
+	u32 memory_limit;
+	struct codel_params cparams;
+	struct codel_stats cstats;
+	u32 memory_usage;
+	u32 drop_overmemory;
+	u32 drop_overlimit;
+	u32 new_flow_count;
+	struct list_head new_flows;
+	struct list_head old_flows;
+};
+
+enum netlink_attribute_type {
+	NL_ATTR_TYPE_INVALID = 0,
+	NL_ATTR_TYPE_FLAG = 1,
+	NL_ATTR_TYPE_U8 = 2,
+	NL_ATTR_TYPE_U16 = 3,
+	NL_ATTR_TYPE_U32 = 4,
+	NL_ATTR_TYPE_U64 = 5,
+	NL_ATTR_TYPE_S8 = 6,
+	NL_ATTR_TYPE_S16 = 7,
+	NL_ATTR_TYPE_S32 = 8,
+	NL_ATTR_TYPE_S64 = 9,
+	NL_ATTR_TYPE_BINARY = 10,
+	NL_ATTR_TYPE_STRING = 11,
+	NL_ATTR_TYPE_NUL_STRING = 12,
+	NL_ATTR_TYPE_NESTED = 13,
+	NL_ATTR_TYPE_NESTED_ARRAY = 14,
+	NL_ATTR_TYPE_BITFIELD32 = 15,
+	NL_ATTR_TYPE_SINT = 16,
+	NL_ATTR_TYPE_UINT = 17,
+};
+
+enum netlink_policy_type_attr {
+	NL_POLICY_TYPE_ATTR_UNSPEC = 0,
+	NL_POLICY_TYPE_ATTR_TYPE = 1,
+	NL_POLICY_TYPE_ATTR_MIN_VALUE_S = 2,
+	NL_POLICY_TYPE_ATTR_MAX_VALUE_S = 3,
+	NL_POLICY_TYPE_ATTR_MIN_VALUE_U = 4,
+	NL_POLICY_TYPE_ATTR_MAX_VALUE_U = 5,
+	NL_POLICY_TYPE_ATTR_MIN_LENGTH = 6,
+	NL_POLICY_TYPE_ATTR_MAX_LENGTH = 7,
+	NL_POLICY_TYPE_ATTR_POLICY_IDX = 8,
+	NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE = 9,
+	NL_POLICY_TYPE_ATTR_BITFIELD32_MASK = 10,
+	NL_POLICY_TYPE_ATTR_PAD = 11,
+	NL_POLICY_TYPE_ATTR_MASK = 12,
+	__NL_POLICY_TYPE_ATTR_MAX = 13,
+	NL_POLICY_TYPE_ATTR_MAX = 12,
+};
+
+struct netlink_policy_dump_state {
+	unsigned int policy_idx;
+	unsigned int attr_idx;
+	unsigned int n_alloc;
+	struct {
+		const struct nla_policy *policy;
+		unsigned int maxtype;
+	} policies[0];
+};
+
+struct trace_event_raw_bpf_trigger_tp {
+	struct trace_entry ent;
+	int nonce;
+	char __data[0];
+};
+
+struct trace_event_raw_bpf_test_finish {
+	struct trace_entry ent;
+	int err;
+	char __data[0];
+};
+
+struct trace_event_data_offsets_bpf_trigger_tp {};
+
+struct trace_event_data_offsets_bpf_test_finish {};
+
+typedef void (*btf_trace_bpf_trigger_tp)(void *, int);
+
+typedef void (*btf_trace_bpf_test_finish)(void *, int *);
+
+struct bpf_test_timer {
+	enum {
+		NO_PREEMPT = 0,
+		NO_MIGRATE = 1,
+	} mode;
+	u32 i;
+	u64 time_start;
+	u64 time_spent;
+};
+
+struct xdp_page_head {
+	struct xdp_buff orig_ctx;
+	struct xdp_buff ctx;
+	union {
+		struct {
+			struct {} __empty_frame;
+			struct xdp_frame frame[0];
+		};
+		struct {
+			struct {} __empty_data;
+			u8 data[0];
+		};
+	};
+};
+
+struct xdp_test_data {
+	struct xdp_buff *orig_ctx;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	struct xdp_rxq_info rxq;
+	struct net_device *dev;
+	struct page_pool *pp;
+	struct xdp_frame **frames;
+	struct sk_buff **skbs;
+	struct xdp_mem_info mem;
+	u32 batch_size;
+	u32 frame_cnt;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+	long: 32;
+};
+
+struct bpf_fentry_test_t {
+	struct bpf_fentry_test_t *a;
+};
+
+struct prog_test_member1 {
+	int a;
+};
+
+struct prog_test_member {
+	struct prog_test_member1 m;
+	int c;
+};
+
+struct prog_test_ref_kfunc {
+	int a;
+	int b;
+	struct prog_test_member memb;
+	struct prog_test_ref_kfunc *next;
+	refcount_t cnt;
+};
+
+struct bpf_raw_tp_test_run_info {
+	struct bpf_prog *prog;
+	void *ctx;
+	u32 retval;
+};
+
+enum ethtool_multicast_groups {
+	ETHNL_MCGRP_MONITOR = 0,
+};
+
+struct ethnl_dump_ctx {
+	const struct ethnl_request_ops *ops;
+	struct ethnl_req_info *req_info;
+	struct ethnl_reply_data *reply_data;
+	long unsigned int pos_ifindex;
+};
+
+typedef void (*ethnl_notify_handler_t)(struct net_device *, unsigned int, const void *);
+
+struct rss_req_info {
+	struct ethnl_req_info base;
+	u32 rss_context;
+};
+
+struct rss_reply_data {
+	struct ethnl_reply_data base;
+	bool no_key_fields;
+	u32 indir_size;
+	u32 hkey_size;
+	u32 hfunc;
+	u32 input_xfrm;
+	u32 *indir_table;
+	u8 *hkey;
+};
+
+struct rss_nl_dump_ctx {
+	long unsigned int ifindex;
+	long unsigned int ctx_idx;
+	unsigned int match_ifindex;
+	unsigned int start_ctx;
+};
+
+struct features_reply_data {
+	struct ethnl_reply_data base;
+	u32 hw[2];
+	u32 wanted[2];
+	u32 active[2];
+	u32 nochange[2];
+	u32 all[2];
+};
+
+enum {
+	ETHTOOL_A_PROFILE_UNSPEC = 0,
+	ETHTOOL_A_PROFILE_IRQ_MODERATION = 1,
+	__ETHTOOL_A_PROFILE_CNT = 2,
+	ETHTOOL_A_PROFILE_MAX = 1,
+};
+
+enum {
+	ETHTOOL_A_IRQ_MODERATION_UNSPEC = 0,
+	ETHTOOL_A_IRQ_MODERATION_USEC = 1,
+	ETHTOOL_A_IRQ_MODERATION_PKTS = 2,
+	ETHTOOL_A_IRQ_MODERATION_COMPS = 3,
+	__ETHTOOL_A_IRQ_MODERATION_CNT = 4,
+	ETHTOOL_A_IRQ_MODERATION_MAX = 3,
+};
+
+struct coalesce_reply_data {
+	struct ethnl_reply_data base;
+	struct ethtool_coalesce coalesce;
+	struct kernel_ethtool_coalesce kernel_coalesce;
+	u32 supported_params;
+};
+
+enum {
+	ETHTOOL_A_TS_STAT_UNSPEC = 0,
+	ETHTOOL_A_TS_STAT_TX_PKTS = 1,
+	ETHTOOL_A_TS_STAT_TX_LOST = 2,
+	ETHTOOL_A_TS_STAT_TX_ERR = 3,
+	__ETHTOOL_A_TS_STAT_CNT = 4,
+	ETHTOOL_A_TS_STAT_MAX = 3,
+};
+
+struct tsinfo_reply_data {
+	struct ethnl_reply_data base;
+	struct kernel_ethtool_ts_info ts_info;
+	struct ethtool_ts_stats stats;
+};
+
+struct eeprom_req_info {
+	struct ethnl_req_info base;
+	u32 offset;
+	u32 length;
+	u8 page;
+	u8 bank;
+	u8 i2c_address;
+};
+
+struct eeprom_reply_data {
+	struct ethnl_reply_data base;
+	u32 length;
+	u8 *data;
+};
+
+enum {
+	ETHTOOL_A_MM_STAT_UNSPEC = 0,
+	ETHTOOL_A_MM_STAT_PAD = 1,
+	ETHTOOL_A_MM_STAT_REASSEMBLY_ERRORS = 2,
+	ETHTOOL_A_MM_STAT_SMD_ERRORS = 3,
+	ETHTOOL_A_MM_STAT_REASSEMBLY_OK = 4,
+	ETHTOOL_A_MM_STAT_RX_FRAG_COUNT = 5,
+	ETHTOOL_A_MM_STAT_TX_FRAG_COUNT = 6,
+	ETHTOOL_A_MM_STAT_HOLD_COUNT = 7,
+	__ETHTOOL_A_MM_STAT_CNT = 8,
+	ETHTOOL_A_MM_STAT_MAX = 7,
+};
+
+struct mm_reply_data {
+	struct ethnl_reply_data base;
+	struct ethtool_mm_state state;
+	long: 32;
+	struct ethtool_mm_stats stats;
+};
+
+enum ethtool_reset_flags {
+	ETH_RESET_MGMT = 1,
+	ETH_RESET_IRQ = 2,
+	ETH_RESET_DMA = 4,
+	ETH_RESET_FILTER = 8,
+	ETH_RESET_OFFLOAD = 16,
+	ETH_RESET_MAC = 32,
+	ETH_RESET_PHY = 64,
+	ETH_RESET_RAM = 128,
+	ETH_RESET_AP = 256,
+	ETH_RESET_DEDICATED = 65535,
+	ETH_RESET_ALL = 4294967295,
+};
+
+struct cmis_fw_update_fw_mng_features {
+	u8 start_cmd_payload_size;
+	u16 max_duration_start;
+	u16 max_duration_write;
+	u16 max_duration_complete;
+};
+
+struct cmis_cdb_fw_mng_features_rpl {
+	u8 resv1;
+	u8 resv2;
+	u8 start_cmd_payload_size;
+	u8 resv3;
+	u8 read_write_len_ext;
+	u8 write_mechanism;
+	u8 resv4;
+	u8 resv5;
+	__be16 max_duration_start;
+	__be16 resv6;
+	__be16 max_duration_write;
+	__be16 max_duration_complete;
+	__be16 resv7;
+};
+
+enum cmis_cdb_fw_write_mechanism {
+	CMIS_CDB_FW_WRITE_MECHANISM_LPL = 1,
+	CMIS_CDB_FW_WRITE_MECHANISM_BOTH = 17,
+};
+
+struct cmis_cdb_start_fw_download_pl_h {
+	__be32 image_size;
+	__be32 resv1;
+};
+
+struct cmis_cdb_start_fw_download_pl {
+	union {
+		struct {
+			__be32 image_size;
+			__be32 resv1;
+		};
+		struct cmis_cdb_start_fw_download_pl_h head;
+	};
+	u8 vendor_data[112];
+};
+
+struct cmis_cdb_write_fw_block_lpl_pl {
+	__be32 block_address;
+	u8 fw_block[116];
+};
+
+enum {
+	CMIS_MODULE_LOW_PWR = 1,
+	CMIS_MODULE_READY = 3,
+};
+
+struct cmis_cdb_run_fw_image_pl {
+	u8 resv1;
+	u8 image_to_run;
+	u16 delay_to_reset;
+};
+
+struct plca_reply_data {
+	struct ethnl_reply_data base;
+	struct phy_plca_cfg plca_cfg;
+	struct phy_plca_status plca_st;
+};
+
+struct nf_hook_entries_rcu_head {
+	struct callback_head head;
+	void *allocation;
+};
+
+enum nf_nat_manip_type;
+
+struct nf_nat_hook {
+	int (*parse_nat_setup)(struct nf_conn *, enum nf_nat_manip_type, const struct nlattr *);
+	void (*decode_session)(struct sk_buff *, struct flowi *);
+	void (*remove_nat_bysrc)(struct nf_conn *);
+};
+
+struct nf_ct_hook {
+	int (*update)(struct net *, struct sk_buff *);
+	void (*destroy)(struct nf_conntrack *);
+	bool (*get_tuple_skb)(struct nf_conntrack_tuple *, const struct sk_buff *);
+	void (*attach)(struct sk_buff *, const struct sk_buff *);
+	void (*set_closing)(struct nf_conntrack *);
+	int (*confirm)(struct sk_buff *);
+};
+
+struct nfnl_ct_hook {
+	size_t (*build_size)(const struct nf_conn *);
+	int (*build)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, u_int16_t, u_int16_t);
+	int (*parse)(const struct nlattr *, struct nf_conn *);
+	int (*attach_expect)(const struct nlattr *, struct nf_conn *, u32, u32);
+	void (*seq_adjust)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, s32);
+};
+
+struct rt_cache_stat {
+	unsigned int in_slow_tot;
+	unsigned int in_slow_mc;
+	unsigned int in_no_route;
+	unsigned int in_brd;
+	unsigned int in_martian_dst;
+	unsigned int in_martian_src;
+	unsigned int out_slow_tot;
+	unsigned int out_slow_mc;
+};
+
+struct ip_fraglist_iter {
+	struct sk_buff *frag;
+	struct iphdr *iph;
+	int offset;
+	unsigned int hlen;
+};
+
+struct ip_frag_state {
+	bool DF;
+	unsigned int hlen;
+	unsigned int ll_rs;
+	unsigned int mtu;
+	unsigned int left;
+	int offset;
+	int ptr;
+	__be16 not_last_frag;
+};
+
+struct ip_reply_arg {
+	struct kvec iov[1];
+	int flags;
+	__wsum csum;
+	int csumoffset;
+	int bound_dev_if;
+	u8 tos;
+	kuid_t uid;
+};
+
+struct dmabuf_cmsg {
+	__u64 frag_offset;
+	__u32 frag_size;
+	__u32 frag_token;
+	__u32 dmabuf_id;
+	__u32 flags;
+};
+
+enum {
+	BPF_TCP_ESTABLISHED = 1,
+	BPF_TCP_SYN_SENT = 2,
+	BPF_TCP_SYN_RECV = 3,
+	BPF_TCP_FIN_WAIT1 = 4,
+	BPF_TCP_FIN_WAIT2 = 5,
+	BPF_TCP_TIME_WAIT = 6,
+	BPF_TCP_CLOSE = 7,
+	BPF_TCP_CLOSE_WAIT = 8,
+	BPF_TCP_LAST_ACK = 9,
+	BPF_TCP_LISTEN = 10,
+	BPF_TCP_CLOSING = 11,
+	BPF_TCP_NEW_SYN_RECV = 12,
+	BPF_TCP_BOUND_INACTIVE = 13,
+	BPF_TCP_MAX_STATES = 14,
+};
+
+struct tcp_repair_opt {
+	__u32 opt_code;
+	__u32 opt_val;
+};
+
+struct tcp_repair_window {
+	__u32 snd_wl1;
+	__u32 snd_wnd;
+	__u32 max_window;
+	__u32 rcv_wnd;
+	__u32 rcv_wup;
+};
+
+enum {
+	TCP_NLA_PAD = 0,
+	TCP_NLA_BUSY = 1,
+	TCP_NLA_RWND_LIMITED = 2,
+	TCP_NLA_SNDBUF_LIMITED = 3,
+	TCP_NLA_DATA_SEGS_OUT = 4,
+	TCP_NLA_TOTAL_RETRANS = 5,
+	TCP_NLA_PACING_RATE = 6,
+	TCP_NLA_DELIVERY_RATE = 7,
+	TCP_NLA_SND_CWND = 8,
+	TCP_NLA_REORDERING = 9,
+	TCP_NLA_MIN_RTT = 10,
+	TCP_NLA_RECUR_RETRANS = 11,
+	TCP_NLA_DELIVERY_RATE_APP_LMT = 12,
+	TCP_NLA_SNDQ_SIZE = 13,
+	TCP_NLA_CA_STATE = 14,
+	TCP_NLA_SND_SSTHRESH = 15,
+	TCP_NLA_DELIVERED = 16,
+	TCP_NLA_DELIVERED_CE = 17,
+	TCP_NLA_BYTES_SENT = 18,
+	TCP_NLA_BYTES_RETRANS = 19,
+	TCP_NLA_DSACK_DUPS = 20,
+	TCP_NLA_REORD_SEEN = 21,
+	TCP_NLA_SRTT = 22,
+	TCP_NLA_TIMEOUT_REHASH = 23,
+	TCP_NLA_BYTES_NOTSENT = 24,
+	TCP_NLA_EDT = 25,
+	TCP_NLA_TTL = 26,
+	TCP_NLA_REHASH = 27,
+};
+
+struct tcp_zerocopy_receive {
+	__u64 address;
+	__u32 length;
+	__u32 recv_skip_hint;
+	__u32 inq;
+	__s32 err;
+	__u64 copybuf_address;
+	__s32 copybuf_len;
+	__u32 flags;
+	__u64 msg_control;
+	__u64 msg_controllen;
+	__u32 msg_flags;
+	__u32 reserved;
+};
+
+struct tcp_ao_hdr {
+	u8 kind;
+	u8 length;
+	u8 keyid;
+	u8 rnext_keyid;
+};
+
+enum {
+	TCP_CMSG_INQ = 1,
+	TCP_CMSG_TS = 2,
+};
+
+struct tcp_splice_state {
+	struct pipe_inode_info *pipe;
+	size_t len;
+	unsigned int flags;
+};
+
+struct tcp_xa_pool {
+	u8 max;
+	u8 idx;
+	__u32 tokens[17];
+	netmem_ref netmems[17];
+};
+
+struct sock_bh_locked {
+	struct sock *sock;
+	local_lock_t bh_lock;
+};
+
+enum tcp_seq_states {
+	TCP_SEQ_STATE_LISTENING = 0,
+	TCP_SEQ_STATE_ESTABLISHED = 1,
+};
+
+struct tcp_seq_afinfo {
+	sa_family_t family;
+};
+
+struct tcp_iter_state {
+	struct seq_net_private p;
+	enum tcp_seq_states state;
+	struct sock *syn_wait_sk;
+	int bucket;
+	int offset;
+	int sbucket;
+	int num;
+	long: 32;
+	loff_t last_pos;
+};
+
+struct bpf_tcp_iter_state {
+	struct tcp_iter_state state;
+	unsigned int cur_sk;
+	unsigned int end_sk;
+	unsigned int max_sk;
+	struct sock **batch;
+	bool st_bucket_done;
+	long: 32;
+};
+
+struct bpf_iter__tcp {
+	union {
+		struct bpf_iter_meta *meta;
+	};
+	union {
+		struct sock_common *sk_common;
+	};
+	uid_t uid;
+	long: 32;
+};
+
+typedef struct sk_buff * (*gro_receive_sk_t)(struct sock *, struct list_head *, struct sk_buff *);
+
+enum {
+	IFLA_INET_UNSPEC = 0,
+	IFLA_INET_CONF = 1,
+	__IFLA_INET_MAX = 2,
+};
+
+struct in_validator_info {
+	__be32 ivi_addr;
+	struct in_device *ivi_dev;
+	struct netlink_ext_ack *extack;
+};
+
+struct inet_fill_args {
+	u32 portid;
+	u32 seq;
+	int event;
+	unsigned int flags;
+	int netnsid;
+	int ifindex;
+};
+
+struct devinet_sysctl_table {
+	struct ctl_table_header *sysctl_header;
+	struct ctl_table devinet_vars[33];
+};
+
+struct fib_nh_notifier_info {
+	struct fib_notifier_info info;
+	struct fib_nh *fib_nh;
+};
+
+struct ping_table {
+	struct hlist_head hash[64];
+	spinlock_t lock;
+};
+
+struct fib4_rule {
+	struct fib_rule common;
+	u8 dst_len;
+	u8 src_len;
+	dscp_t dscp;
+	u8 dscp_full: 1;
+	__be32 src;
+	__be32 srcmask;
+	__be32 dst;
+	__be32 dstmask;
+	u32 tclassid;
+};
+
+enum {
+	UDP_BPF_IPV4 = 0,
+	UDP_BPF_IPV6 = 1,
+	UDP_BPF_NUM_PROTS = 2,
+};
+
+struct xfrm_if_decode_session_result {
+	struct net *net;
+	u32 if_id;
+};
+
+struct xfrm_if_cb {
+	bool (*decode_session)(struct sk_buff *, short unsigned int, struct xfrm_if_decode_session_result *);
+};
+
+struct xfrm_policy_walk {
+	struct xfrm_policy_walk_entry walk;
+	u8 type;
+	u32 seq;
+};
+
+struct xfrmk_spdinfo {
+	u32 incnt;
+	u32 outcnt;
+	u32 fwdcnt;
+	u32 inscnt;
+	u32 outscnt;
+	u32 fwdscnt;
+	u32 spdhcnt;
+	u32 spdhmcnt;
+};
+
+struct xfrm_flo {
+	struct dst_entry *dst_orig;
+	u8 flags;
+};
+
+struct xfrm_pol_inexact_node {
+	struct rb_node node;
+	union {
+		xfrm_address_t addr;
+		struct callback_head rcu;
+	};
+	u8 prefixlen;
+	struct rb_root root;
+	struct hlist_head hhead;
+};
+
+struct xfrm_pol_inexact_key {
+	possible_net_t net;
+	u32 if_id;
+	u16 family;
+	u8 dir;
+	u8 type;
+};
+
+struct xfrm_pol_inexact_bin {
+	struct xfrm_pol_inexact_key k;
+	struct rhash_head head;
+	struct hlist_head hhead;
+	seqcount_spinlock_t count;
+	struct rb_root root_d;
+	struct rb_root root_s;
+	struct list_head inexact_bins;
+	struct callback_head rcu;
+};
+
+enum xfrm_pol_inexact_candidate_type {
+	XFRM_POL_CAND_BOTH = 0,
+	XFRM_POL_CAND_SADDR = 1,
+	XFRM_POL_CAND_DADDR = 2,
+	XFRM_POL_CAND_ANY = 3,
+	XFRM_POL_CAND_MAX = 4,
+};
+
+struct xfrm_pol_inexact_candidates {
+	struct hlist_head *res[4];
+};
+
+struct xfrm_flow_keys {
+	struct flow_dissector_key_basic basic;
+	struct flow_dissector_key_control control;
+	union {
+		struct flow_dissector_key_ipv4_addrs ipv4;
+		struct flow_dissector_key_ipv6_addrs ipv6;
+	} addrs;
+	struct flow_dissector_key_ip ip;
+	struct flow_dissector_key_icmp icmp;
+	struct flow_dissector_key_ports ports;
+	struct flow_dissector_key_keyid gre;
+};
+
+enum unix_vertex_index {
+	UNIX_VERTEX_INDEX_MARK1 = 0,
+	UNIX_VERTEX_INDEX_MARK2 = 1,
+	UNIX_VERTEX_INDEX_START = 2,
+};
+
+enum flowlabel_reflect {
+	FLOWLABEL_REFLECT_ESTABLISHED = 1,
+	FLOWLABEL_REFLECT_TCP_RESET = 2,
+	FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES = 4,
+};
+
+struct ifaddrlblmsg {
+	__u8 ifal_family;
+	__u8 __ifal_reserved;
+	__u8 ifal_prefixlen;
+	__u8 ifal_flags;
+	__u32 ifal_index;
+	__u32 ifal_seq;
+};
+
+enum {
+	IFAL_ADDRESS = 1,
+	IFAL_LABEL = 2,
+	__IFAL_MAX = 3,
+};
+
+struct ip6addrlbl_entry {
+	struct in6_addr prefix;
+	int prefixlen;
+	int ifindex;
+	int addrtype;
+	u32 label;
+	struct hlist_node list;
+	struct callback_head rcu;
+};
+
+struct ip6addrlbl_init_table {
+	const struct in6_addr *prefix;
+	int prefixlen;
+	u32 label;
+};
+
+struct ipv6_mreq {
+	struct in6_addr ipv6mr_multiaddr;
+	int ipv6mr_ifindex;
+};
+
+typedef void ip6_icmp_send_t(struct sk_buff *, u8, u8, __u32, const struct in6_addr *, const struct inet6_skb_parm *);
+
+struct icmpv6_msg {
+	struct sk_buff *skb;
+	int offset;
+	uint8_t type;
+};
+
+struct icmp6_err {
+	int err;
+	int fatal;
+};
+
+struct xfrm6_protocol {
+	int (*handler)(struct sk_buff *);
+	int (*input_handler)(struct sk_buff *, int, __be32, int);
+	int (*cb_handler)(struct sk_buff *, int);
+	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
+	struct xfrm6_protocol *next;
+	int priority;
+};
+
+struct nf_br_ops {
+	int (*br_dev_xmit_hook)(struct sk_buff *);
+};
+
+struct br_frame_type {
+	__be16 type;
+	int (*frame_handler)(struct net_bridge_port *, struct sk_buff *);
+	struct hlist_node list;
+};
+
+struct pimhdr {
+	__u8 type;
+	__u8 reserved;
+	__be16 csum;
+};
+
+enum {
+	BRIDGE_QUERIER_UNSPEC = 0,
+	BRIDGE_QUERIER_IP_ADDRESS = 1,
+	BRIDGE_QUERIER_IP_PORT = 2,
+	BRIDGE_QUERIER_IP_OTHER_TIMER = 3,
+	BRIDGE_QUERIER_PAD = 4,
+	BRIDGE_QUERIER_IPV6_ADDRESS = 5,
+	BRIDGE_QUERIER_IPV6_PORT = 6,
+	BRIDGE_QUERIER_IPV6_OTHER_TIMER = 7,
+	__BRIDGE_QUERIER_MAX = 8,
+};
+
+struct br_ip_list {
+	struct list_head list;
+	struct br_ip addr;
+};
+
+enum {
+	IFLA_BRIDGE_MST_UNSPEC = 0,
+	IFLA_BRIDGE_MST_ENTRY = 1,
+	__IFLA_BRIDGE_MST_MAX = 2,
+};
+
+enum {
+	IFLA_BRIDGE_MST_ENTRY_UNSPEC = 0,
+	IFLA_BRIDGE_MST_ENTRY_MSTI = 1,
+	IFLA_BRIDGE_MST_ENTRY_STATE = 2,
+	__IFLA_BRIDGE_MST_ENTRY_MAX = 3,
+};
+
+enum devlink_port_fn_attr_cap {
+	DEVLINK_PORT_FN_ATTR_CAP_ROCE_BIT = 0,
+	DEVLINK_PORT_FN_ATTR_CAP_MIGRATABLE_BIT = 1,
+	DEVLINK_PORT_FN_ATTR_CAP_IPSEC_CRYPTO_BIT = 2,
+	DEVLINK_PORT_FN_ATTR_CAP_IPSEC_PACKET_BIT = 3,
+	__DEVLINK_PORT_FN_ATTR_CAPS_MAX = 4,
+};
+
+enum devlink_param_type {
+	DEVLINK_PARAM_TYPE_U8 = 0,
+	DEVLINK_PARAM_TYPE_U16 = 1,
+	DEVLINK_PARAM_TYPE_U32 = 2,
+	DEVLINK_PARAM_TYPE_STRING = 3,
+	DEVLINK_PARAM_TYPE_BOOL = 4,
+};
+
+struct devlink_param {
+	u32 id;
+	const char *name;
+	bool generic;
+	enum devlink_param_type type;
+	long unsigned int supported_cmodes;
+	int (*get)(struct devlink *, u32, struct devlink_param_gset_ctx *);
+	int (*set)(struct devlink *, u32, struct devlink_param_gset_ctx *, struct netlink_ext_ack *);
+	int (*validate)(struct devlink *, u32, union devlink_param_value, struct netlink_ext_ack *);
+};
+
+struct devlink_param_item {
+	struct list_head list;
+	const struct devlink_param *param;
+	union devlink_param_value driverinit_value;
+	bool driverinit_value_valid;
+	union devlink_param_value driverinit_value_new;
+	bool driverinit_value_new_valid;
+};
+
+enum devlink_param_generic_id {
+	DEVLINK_PARAM_GENERIC_ID_INT_ERR_RESET = 0,
+	DEVLINK_PARAM_GENERIC_ID_MAX_MACS = 1,
+	DEVLINK_PARAM_GENERIC_ID_ENABLE_SRIOV = 2,
+	DEVLINK_PARAM_GENERIC_ID_REGION_SNAPSHOT = 3,
+	DEVLINK_PARAM_GENERIC_ID_IGNORE_ARI = 4,
+	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MAX = 5,
+	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MIN = 6,
+	DEVLINK_PARAM_GENERIC_ID_FW_LOAD_POLICY = 7,
+	DEVLINK_PARAM_GENERIC_ID_RESET_DEV_ON_DRV_PROBE = 8,
+	DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE = 9,
+	DEVLINK_PARAM_GENERIC_ID_ENABLE_REMOTE_DEV_RESET = 10,
+	DEVLINK_PARAM_GENERIC_ID_ENABLE_ETH = 11,
+	DEVLINK_PARAM_GENERIC_ID_ENABLE_RDMA = 12,
+	DEVLINK_PARAM_GENERIC_ID_ENABLE_VNET = 13,
+	DEVLINK_PARAM_GENERIC_ID_ENABLE_IWARP = 14,
+	DEVLINK_PARAM_GENERIC_ID_IO_EQ_SIZE = 15,
+	DEVLINK_PARAM_GENERIC_ID_EVENT_EQ_SIZE = 16,
+	__DEVLINK_PARAM_GENERIC_ID_MAX = 17,
+	DEVLINK_PARAM_GENERIC_ID_MAX = 16,
+};
+
+struct dsa_devlink_priv {
+	struct dsa_switch *ds;
+};
+
+struct dsa_8021q_context {
+	struct dsa_switch *ds;
+	struct list_head vlans;
+	__be16 proto;
+};
+
+struct dsa_tag_8021q_vlan {
+	struct list_head list;
+	int port;
+	u16 vid;
+	refcount_t refcount;
+};
+
+struct vlan_vid_info {
+	struct list_head list;
+	__be16 proto;
+	u16 vid;
+	int refcount;
+};
+
+enum {
+	IFLA_VLAN_UNSPEC = 0,
+	IFLA_VLAN_ID = 1,
+	IFLA_VLAN_FLAGS = 2,
+	IFLA_VLAN_EGRESS_QOS = 3,
+	IFLA_VLAN_INGRESS_QOS = 4,
+	IFLA_VLAN_PROTOCOL = 5,
+	__IFLA_VLAN_MAX = 6,
+};
+
+struct ifla_vlan_flags {
+	__u32 flags;
+	__u32 mask;
+};
+
+enum {
+	IFLA_VLAN_QOS_UNSPEC = 0,
+	IFLA_VLAN_QOS_MAPPING = 1,
+	__IFLA_VLAN_QOS_MAX = 2,
+};
+
+struct ifla_vlan_qos_mapping {
+	__u32 from;
+	__u32 to;
+};
+
+typedef int (*lookup_by_table_id_t)(struct net *, u32);
+
+struct l3mdev_handler {
+	lookup_by_table_id_t dev_lookup;
+};
+
+struct xsk_dma_map {
+	dma_addr_t *dma_pages;
+	struct device *dev;
+	struct net_device *netdev;
+	refcount_t users;
+	struct list_head list;
+	u32 dma_pages_cnt;
+};
+
+struct xsk_cb_desc {
+	void *src;
+	u8 off;
+	u8 bytes;
+};
+
+struct token_bucket {
+	spinlock_t lock;
+	int chain_len;
+	struct hlist_nulls_head req_chain;
+	struct hlist_nulls_head msk_chain;
+};
+
+struct id_bitmap {
+	long unsigned int map[8];
+};
+
+enum {
+	HANDSHAKE_NLGRP_NONE = 0,
+	HANDSHAKE_NLGRP_TLSHD = 1,
+};
+
+enum {
+	TLS_NO_KEYRING = 0,
+	TLS_NO_PEERID = 0,
+	TLS_NO_CERT = 0,
+	TLS_NO_PRIVKEY = 0,
+};
+
+typedef void (*tls_done_func_t)(void *, int, key_serial_t);
+
+struct tls_handshake_args {
+	struct socket *ta_sock;
+	tls_done_func_t ta_done;
+	void *ta_data;
+	const char *ta_peername;
+	unsigned int ta_timeout_ms;
+	key_serial_t ta_keyring;
+	key_serial_t ta_my_cert;
+	key_serial_t ta_my_privkey;
+	unsigned int ta_num_peerids;
+	key_serial_t ta_my_peerids[5];
+};
+
+enum handshake_msg_type {
+	HANDSHAKE_MSG_TYPE_UNSPEC = 0,
+	HANDSHAKE_MSG_TYPE_CLIENTHELLO = 1,
+	HANDSHAKE_MSG_TYPE_SERVERHELLO = 2,
+};
+
+enum handshake_auth {
+	HANDSHAKE_AUTH_UNSPEC = 0,
+	HANDSHAKE_AUTH_UNAUTH = 1,
+	HANDSHAKE_AUTH_PSK = 2,
+	HANDSHAKE_AUTH_X509 = 3,
+};
+
+enum {
+	HANDSHAKE_A_X509_CERT = 1,
+	HANDSHAKE_A_X509_PRIVKEY = 2,
+	__HANDSHAKE_A_X509_MAX = 3,
+	HANDSHAKE_A_X509_MAX = 2,
+};
+
+struct tls_handshake_req {
+	void (*th_consumer_done)(void *, int, key_serial_t);
+	void *th_consumer_data;
+	int th_type;
+	unsigned int th_timeout_ms;
+	int th_auth_mode;
+	const char *th_peername;
+	key_serial_t th_keyring;
+	key_serial_t th_certificate;
+	key_serial_t th_privkey;
+	unsigned int th_num_peerids;
+	key_serial_t th_peerid[5];
+};
+
+struct compress_format {
+	unsigned char magic[2];
+	const char *name;
+	decompress_fn decompressor;
+};
+
+typedef struct {
+	long unsigned int key[2];
+} hsiphash_key_t;
+
+enum format_type {
+	FORMAT_TYPE_NONE = 0,
+	FORMAT_TYPE_WIDTH = 1,
+	FORMAT_TYPE_PRECISION = 2,
+	FORMAT_TYPE_CHAR = 3,
+	FORMAT_TYPE_STR = 4,
+	FORMAT_TYPE_PTR = 5,
+	FORMAT_TYPE_PERCENT_CHAR = 6,
+	FORMAT_TYPE_INVALID = 7,
+	FORMAT_TYPE_LONG_LONG = 8,
+	FORMAT_TYPE_ULONG = 9,
+	FORMAT_TYPE_LONG = 10,
+	FORMAT_TYPE_UBYTE = 11,
+	FORMAT_TYPE_BYTE = 12,
+	FORMAT_TYPE_USHORT = 13,
+	FORMAT_TYPE_SHORT = 14,
+	FORMAT_TYPE_UINT = 15,
+	FORMAT_TYPE_INT = 16,
+	FORMAT_TYPE_SIZE_T = 17,
+	FORMAT_TYPE_PTRDIFF = 18,
+};
+
+struct printf_spec {
+	unsigned int type: 8;
+	int field_width: 24;
+	unsigned int flags: 8;
+	unsigned int base: 8;
+	int precision: 16;
+};
+
+struct page_flags_fields {
+	int width;
+	int shift;
+	int mask;
+	const struct printf_spec *spec;
+	const char *name;
+};
+
+#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
+#pragma clang attribute pop
+#endif
+
+#endif /* __VMLINUX_H__ */
--- a/dae-core/trace/kern/headers/vmlinux.h
+++ b/dae-core/trace/kern/headers/vmlinux.h
@@ -1,5 +1,7 @@
 #if defined(__TARGET_ARCH_x86)
 #include "vmlinux-x86.h"
+#elif defined(__TARGET_ARCH_arm)
+#include "vmlinux-arm.h"
 #elif defined(__TARGET_ARCH_arm64)
 #include "vmlinux-arm64.h"
 #else
